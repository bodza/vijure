(ns vijure.core
    (:refer-clojure :exclude [boolean byte short int long])
    (:require [org.baznex.imports :refer [import-static]])
    (:import [java.util Arrays Comparator])
    (:gen-class))

(org.baznex.imports/rename {vijure.VimA$Bytes 'Bytes, vijure.VimB$timeval_C 'timeval_C, vijure.VimS$context_sha256_C 'context_sha256_C})

(import-static vijure.VimA u8)
(import-static vijure.VimB SIGHUP SIGQUIT SIGILL SIGTRAP SIGABRT SIGFPE SIGBUS SIGSEGV SIGSYS SIGALRM SIGTERM SIGVTALRM SIGPROF SIGXCPU SIGXFSZ SIGUSR1 SIGUSR2 SIGINT SIGWINCH SIGTSTP SIGPIPE)

(defmacro § [& _])

(defmacro def- [symbol & init] (list* 'def (vary-meta symbol assoc :private true) init))

(def- null nil)

(def- & bit-and)
(def- | bit-or)
(def- << bit-shift-left)

(defn- boolean? [b] (instance? Boolean b))

(def- byte! unchecked-byte)
(def- int! unchecked-int)

(defn- boolean ([] (boolean nil)) ([b] (cond (nil? b) false (boolean? b) b :else (throw (IllegalArgumentException. (str "fuzzy boolean " b))))))
(defn- byte    ([] (byte nil))    ([n] (clojure.core/byte (if (nil? n) 0 n))))
(defn- short   ([] (short nil))   ([n] (clojure.core/short (if (nil? n) 0 n))))
(defn- int     ([] (int nil))     ([n] (clojure.core/int (if (nil? n) 0 n))))
(defn- long    ([] (long nil))    ([n] (clojure.core/long (if (nil? n) 0 n))))
(defn- object  ([] (object nil))  ([o] o))

(def- maybean int)

(defmacro def'type* [& types] (cons 'do
    (map (fn [t] (let [t* (symbol (str t \*))]
        `(defn- ~t* [v#] (cond (sequential? v#) (mapv ~t v#) (number? v#) (recur (repeat v# nil)) :else (assert (nil? v#) (str "fuzzy " '~t* " " v#))))
    )) types)))
(def'type* boolean byte byte* short int int* long object object*)

(def- frag_C* object*)

(def- C (map #(symbol (str % "_C")) '(barray block_hdr buffblock buffer buffheader clipboard cmdline_info cmdmod except file fmark fragnode frame lpos mapblock match matchitem memfile memline mf_hashitem mf_hashtab msgchunk msg_hist msglist nfa_pim nfa_state oparg pos posmatch reg_extmatch regmatch regmmatch regprog regsave regsub regsubs save_se soffset tabpage termios timeval typebuf u_entry u_header u_link visualinfo window wininfo winopt yankreg)))

(def- C* (map #(symbol (str % "_C*")) '(attrentry backpos btcap charstab chunksize cmdmods cmdname decomp digr file frag frame hl_group infoptr key_name linepos llpos lpos mf_hashitem modmasktable mousetable msglist multipos nfa_state nfa_thread nv_cmd pos ptr_entry save_se signalinfo spat tasave tcname termcode typebuf vimoption wline xfmark yankreg)))

(def- C** (map #(symbol (str % "_C**")) '(histentry mapblock)))

(def- F (map #(symbol (str % "_F")) '(ex_func getline nv_func)))

(let [I '(byte byte! byte* byte** short short* int int! int* long maybean) O (concat '(Bytes Object) C) O* (concat '(Bytes* Bytes*') C*)
      T (merge (zipmap I I) (zipmap O (repeat 'object)) (zipmap O* (repeat 'object*)))]
    (letfn [(f [t s] (if s (cons `(def- ~(first s) (~t ~(second s))) (f t (nnext s))) '(nil)))]
        (defmacro final [t & s] (let [t' (T t)] (assert t' (str "unexpected type: " t)) (when s (cons 'do (f t' s)))))))

(let [I '(boolean boolean* short short* int int* int** long long* maybean) O (cons 'Bytes C) O* (concat '(Bytes* Object*) C*) O** C**
      T (merge (zipmap I I) (zipmap O (repeat 'object)) (zipmap O* (repeat 'object*)) (zipmap O** (repeat 'object**)))]
    (letfn [(f [t s] (if s (cons `(def- ~(first s) (atom (~t ~(second s)))) (f t (nnext s))) '(nil)))]
        (defmacro atom! [t & s] (let [t' (T t)] (assert t' (str "unexpected type: " t)) (when s (cons 'do (f t' s)))))))

(let [I '#{boolean byte short int long} A '(byte* short* int*) O (concat '(Bytes Object) C F) O* (concat '(Bytes* Object*) C*) O** C**
      T (merge (zipmap I I) (zipmap A A) (zipmap O (repeat 'object)) (zipmap O* (repeat 'object*)) (zipmap O** (repeat 'object**)))]
    (letfn [(f' [[f t n & [v]]] (let [t' (T t)] (assert t' (str "unexpected type: " t))
            (case f atom' `[~n (atom (~t' ~v))]
                    field `[~(if (I t) (vary-meta n assoc :tag t) n) (~t' ~v)])))]
        (defmacro class! [c [& fs] & _] (let [fs' (map f' fs)]
            `(do (defrecord ~c ~(mapv first fs') ~@_)
                 (defn- ~(symbol (str "§_" c)) [] (new ~c ~@(map second fs'))) nil)))))

;;; ============================================================================================== VimA

(final maybean FALSE 0, TRUE 1, MAYBE 2)

(final Bytes VIMVERSION (u8 "VIM - Vi IMproved 7.4.692"))

;;; ============================================================================================== VimC

(final int MAXNAMLEN 255)	;; %% VimB/MAXNAMLEN

(final int BASENAMELEN (- MAXNAMLEN 5))

(final int MAXPATHL 4096)

(final int NUMBUFLEN 30)        ;; length of a buffer to store a number in ASCII

;; ----------------------------------------------------------------------- ;;

(defn- #_int charOrd [#_int x]
    (§
;       return (x < 'a') ? x - 'A' : x - 'a';
    ))

(defn- #_int charOrdLow [#_int x]
    (§
;       return x - 'a';
    ))

(defn- #_int charOrdUp [#_int x]
    (§
;       return x - 'A';
    ))

(defn- #_int rot13 [#_int c, #_int a]
    (§
;       return (((c - a) + 13) % 26) + a;
    ))

;; Definitions of various common control characters.

(final byte NUL     000)    ;; %% VimA/NUL
(final byte BELL    007)
(final byte BS      010)
(final byte TAB     011)
(final byte NL      012)
(final byte FF      014)
(final byte CAR     015)    ;; CR is used by Mac OS X
(final byte ESC     033)
(final byte DEL    0x7f)

(final byte! CSI   0x9b)    ;; Control Sequence Introducer
(final byte! DCS   0x90)    ;; Device Control String
(final byte! STERM 0x9c)    ;; String Terminator

(final byte! POUND 0xa3)

(final Bytes
    NL_STR   (u8 "\012")
    ESC_STR  (u8 "\033")
    DEL_STR  (u8 "\177")
    CSI_STR  (u8 "\233"))

(defn- #_int ctrl_key [#_byte c]
    (§
;       if (c < NUL)
;           return char_u(c);

;       return asc_toupper(c) ^ 0x40;       ;; '?' -> DEL, '@' -> ^@, etc.
    ))

(final Bytes
    CTRL_F_STR (u8 "\006")
    CTRL_H_STR (u8 "\010")
    CTRL_V_STR (u8 "\026"))

(final byte
    Ctrl_AT   0,        ;; @
    Ctrl_A    1,
    Ctrl_B    2,
    Ctrl_C    3,
    Ctrl_D    4,
    Ctrl_E    5,
    Ctrl_F    6,
    Ctrl_G    7,
    Ctrl_H    8,
    Ctrl_I    9,
    Ctrl_J   10,
    Ctrl_K   11,
    Ctrl_L   12,
    Ctrl_M   13,
    Ctrl_N   14,
    Ctrl_O   15,
    Ctrl_P   16,
    Ctrl_Q   17,
    Ctrl_R   18,
    Ctrl_S   19,
    Ctrl_T   20,
    Ctrl_U   21,
    Ctrl_V   22,
    Ctrl_W   23,
    Ctrl_X   24,
    Ctrl_Y   25,
    Ctrl_Z   26,
                        ;; CTRL- [ Left Square Bracket == ESC
    Ctrl_BSL 28,        ;; \ BackSLash
    Ctrl_RSB 29,        ;; ] Right Square Bracket
    Ctrl_HAT 30,        ;; ^
    Ctrl__   31)

;; ----------------------------------------------------------------------- ;;

;; Keycode definitions for special keys.
;;
;; Any special key code sequences are replaced by these codes.

;; KB_SPECIAL is the first byte of a special key code and is always followed by two bytes.
;; The second byte can have any value.  ASCII is used for normal termcap entries,
;; 0x80 and higher for special keys, see below.
;; The third byte is guaranteed to be between 0x02 and 0x7f.

(final byte! KB_SPECIAL         0x80)

;; Positive characters are "normal" characters.
;; Negative characters are special key codes.  Only characters below -0x200 are used,
;; so that the absolute value can't be mistaken for a single-byte character.

(defn- #_boolean is_special [#_int c]
    (§
;       return (c < 0);
    ))

;; Characters 0x0100 - 0x01ff have a special meaning for abbreviations.
;; Multi-byte characters also have ABBR_OFF added, thus are above 0x0200.

(final int ABBR_OFF           0x100)

;; NUL cannot be in the input string, therefore it is replaced by
;;      KB_SPECIAL  KS_ZERO     KE_FILLER

(final byte! KS_ZERO            255)

;; KB_SPECIAL cannot be in the input string, therefore it is replaced by
;;      KB_SPECIAL  KS_SPECIAL  KE_FILLER

(final byte! KS_SPECIAL         254)

;; KS_EXTRA is used for keys that have no termcap name
;;      KB_SPECIAL  KS_EXTRA    KE_xxx

(final byte! KS_EXTRA           253)

;; KS_MODIFIER is used when a modifier is given for a (special) key
;;      KB_SPECIAL  KS_MODIFIER bitmask

(final byte! KS_MODIFIER        252)

;; These are used for the GUI
;;      KB_SPECIAL  KS_xxx      KE_FILLER

(final byte! KS_MOUSE           251)
(final byte! KS_VER_SCROLLBAR   249)
(final byte! KS_HOR_SCROLLBAR   248)

;; Used for switching Select mode back on after a mapping or menu.

(final byte! KS_SELECT          245)
(final Bytes K_SELECT_STRING    (u8 "\200\365X"))

;; Used a termcap entry that produces a normal character.

(final byte! KS_KEY             242)

;; Filler used after KS_SPECIAL and others.

(final byte KE_FILLER            \X)

;; Translation of three byte code "KB_SPECIAL a b" into int "K_xxx" and back.

(defn- #_int TERMCAP2KEY [#_byte a, #_byte b]
    (§
;       return (int)(-(int_u(a) + (int_u(b) << 8)));
    ))

(defn- #_byte KEY2TERMCAP0 [#_int x]
    (§
;       return (byte)((-(x)) & 0xff);
    ))

(defn- #_byte KEY2TERMCAP1 [#_int x]
    (§
;       return (byte)((int_u(-(x)) >>> 8) & 0xff);
    ))

;; Get second or third byte when translating special key code into three bytes.

(defn- #_byte KB_SECOND [#_int c]
    (§
;       return (c == char_u(KB_SPECIAL)) ? KS_SPECIAL : (c == NUL) ? KS_ZERO : KEY2TERMCAP0(c);
    ))

(defn- #_byte KB_THIRD [#_int c]
    (§
;       return (c == char_u(KB_SPECIAL) || c == NUL) ? KE_FILLER : KEY2TERMCAP1(c);
    ))

;; Codes for keys that do not have a termcap name.
;;
;; KB_SPECIAL KS_EXTRA KE_xxx

(final byte
    KE_NAME 3,        ;; name of this terminal entry

    KE_S_UP 4,            ;; shift-up
    KE_S_DOWN 5,          ;; shift-down

    KE_S_F1 6,            ;; shifted function keys
    KE_S_F2 7,
    KE_S_F3 8,
    KE_S_F4 9,
    KE_S_F5 10,
    KE_S_F6 11,
    KE_S_F7 12,
    KE_S_F8 13,
    KE_S_F9 14,
    KE_S_F10 15,

    KE_S_F11 16,
    KE_S_F12 17,
    KE_S_F13 18,
    KE_S_F14 19,
    KE_S_F15 20,
    KE_S_F16 21,
    KE_S_F17 22,
    KE_S_F18 23,
    KE_S_F19 24,
    KE_S_F20 25,

    KE_S_F21 26,
    KE_S_F22 27,
    KE_S_F23 28,
    KE_S_F24 29,
    KE_S_F25 30,
    KE_S_F26 31,
    KE_S_F27 32,
    KE_S_F28 33,
    KE_S_F29 34,
    KE_S_F30 35,

    KE_S_F31 36,
    KE_S_F32 37,
    KE_S_F33 38,
    KE_S_F34 39,
    KE_S_F35 40,
    KE_S_F36 41,
    KE_S_F37 42,

    KE_MOUSE 43,          ;; mouse event start

;; Symbols for pseudo keys which are translated from the real key symbols above.

    KE_LEFTMOUSE 44,      ;; left mouse button click
    KE_LEFTDRAG 45,       ;; drag with left mouse button down
    KE_LEFTRELEASE 46,    ;; left mouse button release
    KE_MIDDLEMOUSE 47,    ;; middle mouse button click
    KE_MIDDLEDRAG 48,     ;; drag with middle mouse button down
    KE_MIDDLERELEASE 49,  ;; middle mouse button release
    KE_RIGHTMOUSE 50,     ;; right mouse button click
    KE_RIGHTDRAG 51,      ;; drag with right mouse button down
    KE_RIGHTRELEASE 52,   ;; right mouse button release

    KE_IGNORE 53,         ;; ignored mouse drag/release

    KE_TAB 54,            ;; unshifted TAB key
    KE_S_TAB_OLD 55,      ;; shifted TAB key (no longer used)

    KE_XF1 56,            ;; extra vt100 function keys for xterm
    KE_XF2 57,
    KE_XF3 58,
    KE_XF4 59,
    KE_XEND 60,           ;; extra (vt100) end key for xterm
    KE_ZEND 61,           ;; extra (vt100) end key for xterm
    KE_XHOME 62,          ;; extra (vt100) home key for xterm
    KE_ZHOME 63,          ;; extra (vt100) home key for xterm
    KE_XUP 64,            ;; extra vt100 cursor keys for xterm
    KE_XDOWN 65,
    KE_XLEFT 66,
    KE_XRIGHT 67,

    KE_LEFTMOUSE_NM 68,   ;; non-mappable left mouse button click
    KE_LEFTRELEASE_NM 69, ;; non-mappable left mouse button release

    KE_S_XF1 70,          ;; extra vt100 shifted function keys for xterm
    KE_S_XF2 71,
    KE_S_XF3 72,
    KE_S_XF4 73,

        ;; NOTE: The scroll wheel events are inverted: i.e. UP is the same as moving the
        ;; actual scroll wheel down, LEFT is the same as moving the scroll wheel right.

    KE_MOUSEDOWN 74,      ;; scroll wheel pseudo-button Down
    KE_MOUSEUP 75,        ;; scroll wheel pseudo-button Up
    KE_MOUSELEFT 76,      ;; scroll wheel pseudo-button Left
    KE_MOUSERIGHT 77,     ;; scroll wheel pseudo-button Right

    KE_KINS 78,           ;; keypad Insert key
    KE_KDEL 79,           ;; keypad Delete key

    KE_CSI 80,            ;; CSI typed directly
    KE_SNR 81,            ;; <SNR>
    KE_PLUG 82,           ;; <Plug>
    KE_CMDWIN 83,         ;; open command-line window from Command-line Mode

    KE_C_LEFT 84,         ;; control-left
    KE_C_RIGHT 85,        ;; control-right
    KE_C_HOME 86,         ;; control-home
    KE_C_END 87,          ;; control-end

    KE_X1MOUSE 88,        ;; X1/X2 mouse-buttons
    KE_X1DRAG 89,
    KE_X1RELEASE 90,
    KE_X2MOUSE 91,
    KE_X2DRAG 92,
    KE_X2RELEASE 93,

    KE_DROP 94,           ;; DnD data is available
    KE_CURSORHOLD 95,     ;; CursorHold event
    KE_FOCUSGAINED 96,    ;; focus gained
    KE_FOCUSLOST 97,      ;; focus lost

    KE_NOP 98)            ;; doesn't do anything

;; the three byte codes are replaced with the following int when using vgetc()

(final int
    K_ZERO          -22527,   ;; TERMCAP2KEY(KS_ZERO, KE_FILLER),

    K_UP            -30059,   ;; TERMCAP2KEY((byte)'k', (byte)'u'),
    K_DOWN          -25707,   ;; TERMCAP2KEY((byte)'k', (byte)'d'),
    K_LEFT          -27755,   ;; TERMCAP2KEY((byte)'k', (byte)'l'),
    K_RIGHT         -29291,   ;; TERMCAP2KEY((byte)'k', (byte)'r'),
    K_S_UP          -1021,    ;; TERMCAP2KEY(KS_EXTRA, KE_S_UP),
    K_S_DOWN        -1277,    ;; TERMCAP2KEY(KS_EXTRA, KE_S_DOWN),
    K_S_LEFT        -13347,   ;; TERMCAP2KEY((byte)'#', (byte)'4'),
    K_C_LEFT        -21501,   ;; TERMCAP2KEY(KS_EXTRA, KE_C_LEFT),
    K_S_RIGHT       -26917,   ;; TERMCAP2KEY((byte)'%', (byte)'i'),
    K_C_RIGHT       -21757,   ;; TERMCAP2KEY(KS_EXTRA, KE_C_RIGHT),
    K_S_HOME        -12835,   ;; TERMCAP2KEY((byte)'#', (byte)'2'),
    K_C_HOME        -22013,   ;; TERMCAP2KEY(KS_EXTRA, KE_C_HOME),
    K_S_END         -14122,   ;; TERMCAP2KEY((byte)'*', (byte)'7'),
    K_C_END         -22269,   ;; TERMCAP2KEY(KS_EXTRA, KE_C_END),
    K_TAB           -13821,   ;; TERMCAP2KEY(KS_EXTRA, KE_TAB),
    K_S_TAB         -17003,   ;; TERMCAP2KEY((byte)'k', (byte)'B'),

;; extra set of function keys F1-F4, for vt100 compatible xterm
    K_XF1           -14333,   ;; TERMCAP2KEY(KS_EXTRA, KE_XF1),
    K_XF2           -14589,   ;; TERMCAP2KEY(KS_EXTRA, KE_XF2),
    K_XF3           -14845,   ;; TERMCAP2KEY(KS_EXTRA, KE_XF3),
    K_XF4           -15101,   ;; TERMCAP2KEY(KS_EXTRA, KE_XF4),

;; extra set of cursor keys for vt100 compatible xterm
    K_XUP           -16381,   ;; TERMCAP2KEY(KS_EXTRA, KE_XUP),
    K_XDOWN         -16637,   ;; TERMCAP2KEY(KS_EXTRA, KE_XDOWN),
    K_XLEFT         -16893,   ;; TERMCAP2KEY(KS_EXTRA, KE_XLEFT),
    K_XRIGHT        -17149,   ;; TERMCAP2KEY(KS_EXTRA, KE_XRIGHT),

    K_F0            -12395,   ;; TERMCAP2KEY((byte)'k', (byte)'0'),

    K_F1            -12651,   ;; TERMCAP2KEY((byte)'k', (byte)'1'),   ;; function keys
    K_F2            -12907,   ;; TERMCAP2KEY((byte)'k', (byte)'2'),
    K_F3            -13163,   ;; TERMCAP2KEY((byte)'k', (byte)'3'),
    K_F4            -13419,   ;; TERMCAP2KEY((byte)'k', (byte)'4'),
    K_F5            -13675,   ;; TERMCAP2KEY((byte)'k', (byte)'5'),
    K_F6            -13931,   ;; TERMCAP2KEY((byte)'k', (byte)'6'),
    K_F7            -14187,   ;; TERMCAP2KEY((byte)'k', (byte)'7'),
    K_F8            -14443,   ;; TERMCAP2KEY((byte)'k', (byte)'8'),
    K_F9            -14699,   ;; TERMCAP2KEY((byte)'k', (byte)'9'),
    K_F10           -15211,   ;; TERMCAP2KEY((byte)'k', (byte)';'),

    K_F11           -12614,   ;; TERMCAP2KEY((byte)'F', (byte)'1'),
    K_F12           -12870,   ;; TERMCAP2KEY((byte)'F', (byte)'2'),
    K_F13           -13126,   ;; TERMCAP2KEY((byte)'F', (byte)'3'),
    K_F14           -13382,   ;; TERMCAP2KEY((byte)'F', (byte)'4'),
    K_F15           -13638,   ;; TERMCAP2KEY((byte)'F', (byte)'5'),
    K_F16           -13894,   ;; TERMCAP2KEY((byte)'F', (byte)'6'),
    K_F17           -14150,   ;; TERMCAP2KEY((byte)'F', (byte)'7'),
    K_F18           -14406,   ;; TERMCAP2KEY((byte)'F', (byte)'8'),
    K_F19           -14662,   ;; TERMCAP2KEY((byte)'F', (byte)'9'),
    K_F20           -16710,   ;; TERMCAP2KEY((byte)'F', (byte)'A'),

    K_F21           -16966,   ;; TERMCAP2KEY((byte)'F', (byte)'B'),
    K_F22           -17222,   ;; TERMCAP2KEY((byte)'F', (byte)'C'),
    K_F23           -17478,   ;; TERMCAP2KEY((byte)'F', (byte)'D'),
    K_F24           -17734,   ;; TERMCAP2KEY((byte)'F', (byte)'E'),
    K_F25           -17990,   ;; TERMCAP2KEY((byte)'F', (byte)'F'),
    K_F26           -18246,   ;; TERMCAP2KEY((byte)'F', (byte)'G'),
    K_F27           -18502,   ;; TERMCAP2KEY((byte)'F', (byte)'H'),
    K_F28           -18758,   ;; TERMCAP2KEY((byte)'F', (byte)'I'),
    K_F29           -19014,   ;; TERMCAP2KEY((byte)'F', (byte)'J'),
    K_F30           -19270,   ;; TERMCAP2KEY((byte)'F', (byte)'K'),

    K_F31           -19526,   ;; TERMCAP2KEY((byte)'F', (byte)'L'),
    K_F32           -19782,   ;; TERMCAP2KEY((byte)'F', (byte)'M'),
    K_F33           -20038,   ;; TERMCAP2KEY((byte)'F', (byte)'N'),
    K_F34           -20294,   ;; TERMCAP2KEY((byte)'F', (byte)'O'),
    K_F35           -20550,   ;; TERMCAP2KEY((byte)'F', (byte)'P'),
    K_F36           -20806,   ;; TERMCAP2KEY((byte)'F', (byte)'Q'),
    K_F37           -21062,   ;; TERMCAP2KEY((byte)'F', (byte)'R'),

;; extra set of shifted function keys F1-F4, for vt100 compatible xterm
    K_S_XF1         -17917,   ;; TERMCAP2KEY(KS_EXTRA, KE_S_XF1),
    K_S_XF2         -18173,   ;; TERMCAP2KEY(KS_EXTRA, KE_S_XF2),
    K_S_XF3         -18429,   ;; TERMCAP2KEY(KS_EXTRA, KE_S_XF3),
    K_S_XF4         -18685,   ;; TERMCAP2KEY(KS_EXTRA, KE_S_XF4),

    K_S_F1          -1533,    ;; TERMCAP2KEY(KS_EXTRA, KE_S_F1),  ;; shifted func. keys
    K_S_F2          -1789,    ;; TERMCAP2KEY(KS_EXTRA, KE_S_F2),
    K_S_F3          -2045,    ;; TERMCAP2KEY(KS_EXTRA, KE_S_F3),
    K_S_F4          -2301,    ;; TERMCAP2KEY(KS_EXTRA, KE_S_F4),
    K_S_F5          -2557,    ;; TERMCAP2KEY(KS_EXTRA, KE_S_F5),
    K_S_F6          -2813,    ;; TERMCAP2KEY(KS_EXTRA, KE_S_F6),
    K_S_F7          -3069,    ;; TERMCAP2KEY(KS_EXTRA, KE_S_F7),
    K_S_F8          -3325,    ;; TERMCAP2KEY(KS_EXTRA, KE_S_F8),
    K_S_F9          -3581,    ;; TERMCAP2KEY(KS_EXTRA, KE_S_F9),
    K_S_F10         -3837,    ;; TERMCAP2KEY(KS_EXTRA, KE_S_F10),

    K_S_F11         -4093,    ;; TERMCAP2KEY(KS_EXTRA, KE_S_F11),
    K_S_F12         -4349,    ;; TERMCAP2KEY(KS_EXTRA, KE_S_F12),
;; K_S_F13 to K_S_F37 are currently not used

    K_HELP          -12581,   ;; TERMCAP2KEY((byte)'%', (byte)'1'),
    K_UNDO          -14374,   ;; TERMCAP2KEY((byte)'&', (byte)'8'),

    K_BS            -25195,   ;; TERMCAP2KEY((byte)'k', (byte)'b'),

    K_INS           -18795,   ;; TERMCAP2KEY((byte)'k', (byte)'I'),
    K_KINS          -19965,   ;; TERMCAP2KEY(KS_EXTRA, KE_KINS),
    K_DEL           -17515,   ;; TERMCAP2KEY((byte)'k', (byte)'D'),
    K_KDEL          -20221,   ;; TERMCAP2KEY(KS_EXTRA, KE_KDEL),
    K_HOME          -26731,   ;; TERMCAP2KEY((byte)'k', (byte)'h'),
    K_KHOME         -12619,   ;; TERMCAP2KEY((byte)'K', (byte)'1'),   ;; keypad home (upper left)
    K_XHOME         -15869,   ;; TERMCAP2KEY(KS_EXTRA, KE_XHOME),
    K_ZHOME         -16125,   ;; TERMCAP2KEY(KS_EXTRA, KE_ZHOME),
    K_END           -14144,   ;; TERMCAP2KEY((byte)'@', (byte)'7'),
    K_KEND          -13387,   ;; TERMCAP2KEY((byte)'K', (byte)'4'),   ;; keypad end (lower left)
    K_XEND          -15357,   ;; TERMCAP2KEY(KS_EXTRA, KE_XEND),
    K_ZEND          -15613,   ;; TERMCAP2KEY(KS_EXTRA, KE_ZEND),
    K_PAGEUP        -20587,   ;; TERMCAP2KEY((byte)'k', (byte)'P'),
    K_PAGEDOWN      -20075,   ;; TERMCAP2KEY((byte)'k', (byte)'N'),
    K_KPAGEUP       -13131,   ;; TERMCAP2KEY((byte)'K', (byte)'3'),   ;; keypad pageup (upper R.)
    K_KPAGEDOWN     -13643,   ;; TERMCAP2KEY((byte)'K', (byte)'5'),   ;; keypad pagedown (lower R.)

    K_KPLUS         -13899,   ;; TERMCAP2KEY((byte)'K', (byte)'6'),   ;; keypad plus
    K_KMINUS        -14155,   ;; TERMCAP2KEY((byte)'K', (byte)'7'),   ;; keypad minus
    K_KDIVIDE       -14411,   ;; TERMCAP2KEY((byte)'K', (byte)'8'),   ;; keypad /
    K_KMULTIPLY     -14667,   ;; TERMCAP2KEY((byte)'K', (byte)'9'),   ;; keypad *
    K_KENTER        -16715,   ;; TERMCAP2KEY((byte)'K', (byte)'A'),   ;; keypad Enter
    K_KPOINT        -16971,   ;; TERMCAP2KEY((byte)'K', (byte)'B'),   ;; keypad . or ,

    K_K0            -17227,   ;; TERMCAP2KEY((byte)'K', (byte)'C'),   ;; keypad 0
    K_K1            -17483,   ;; TERMCAP2KEY((byte)'K', (byte)'D'),   ;; keypad 1
    K_K2            -17739,   ;; TERMCAP2KEY((byte)'K', (byte)'E'),   ;; keypad 2
    K_K3            -17995,   ;; TERMCAP2KEY((byte)'K', (byte)'F'),   ;; keypad 3
    K_K4            -18251,   ;; TERMCAP2KEY((byte)'K', (byte)'G'),   ;; keypad 4
    K_K5            -18507,   ;; TERMCAP2KEY((byte)'K', (byte)'H'),   ;; keypad 5
    K_K6            -18763,   ;; TERMCAP2KEY((byte)'K', (byte)'I'),   ;; keypad 6
    K_K7            -19019,   ;; TERMCAP2KEY((byte)'K', (byte)'J'),   ;; keypad 7
    K_K8            -19275,   ;; TERMCAP2KEY((byte)'K', (byte)'K'),   ;; keypad 8
    K_K9            -19531,   ;; TERMCAP2KEY((byte)'K', (byte)'L'),   ;; keypad 9

    K_MOUSE         -22523,   ;; TERMCAP2KEY(KS_MOUSE, KE_FILLER),
    K_VER_SCROLLBAR -22521,   ;; TERMCAP2KEY(KS_VER_SCROLLBAR, KE_FILLER),
    K_HOR_SCROLLBAR -22520,   ;; TERMCAP2KEY(KS_HOR_SCROLLBAR, KE_FILLER),

    K_SELECT        -22517,   ;; TERMCAP2KEY(KS_SELECT, KE_FILLER),

;; Symbols for pseudo keys which are translated from the real key symbols above.

    K_LEFTMOUSE     -11261,   ;; TERMCAP2KEY(KS_EXTRA, KE_LEFTMOUSE),
    K_LEFTMOUSE_NM  -17405,   ;; TERMCAP2KEY(KS_EXTRA, KE_LEFTMOUSE_NM),
    K_LEFTDRAG      -11517,   ;; TERMCAP2KEY(KS_EXTRA, KE_LEFTDRAG),
    K_LEFTRELEASE   -11773,   ;; TERMCAP2KEY(KS_EXTRA, KE_LEFTRELEASE),
    K_LEFTRELEASE_NM -17661,  ;; TERMCAP2KEY(KS_EXTRA, KE_LEFTRELEASE_NM),
    K_MIDDLEMOUSE   -12029,   ;; TERMCAP2KEY(KS_EXTRA, KE_MIDDLEMOUSE),
    K_MIDDLEDRAG    -12285,   ;; TERMCAP2KEY(KS_EXTRA, KE_MIDDLEDRAG),
    K_MIDDLERELEASE -12541,   ;; TERMCAP2KEY(KS_EXTRA, KE_MIDDLERELEASE),
    K_RIGHTMOUSE    -12797,   ;; TERMCAP2KEY(KS_EXTRA, KE_RIGHTMOUSE),
    K_RIGHTDRAG     -13053,   ;; TERMCAP2KEY(KS_EXTRA, KE_RIGHTDRAG),
    K_RIGHTRELEASE  -13309,   ;; TERMCAP2KEY(KS_EXTRA, KE_RIGHTRELEASE),
    K_X1MOUSE       -22525,   ;; TERMCAP2KEY(KS_EXTRA, KE_X1MOUSE),
    K_X1DRAG        -22781,   ;; TERMCAP2KEY(KS_EXTRA, KE_X1DRAG),
    K_X1RELEASE     -23037,   ;; TERMCAP2KEY(KS_EXTRA, KE_X1RELEASE),
    K_X2MOUSE       -23293,   ;; TERMCAP2KEY(KS_EXTRA, KE_X2MOUSE),
    K_X2DRAG        -23549,   ;; TERMCAP2KEY(KS_EXTRA, KE_X2DRAG),
    K_X2RELEASE     -23805,   ;; TERMCAP2KEY(KS_EXTRA, KE_X2RELEASE),

    K_IGNORE        -13565,   ;; TERMCAP2KEY(KS_EXTRA, KE_IGNORE),
    K_NOP           -25085,   ;; TERMCAP2KEY(KS_EXTRA, KE_NOP),

    K_MOUSEDOWN     -18941,   ;; TERMCAP2KEY(KS_EXTRA, KE_MOUSEDOWN),
    K_MOUSEUP       -19197,   ;; TERMCAP2KEY(KS_EXTRA, KE_MOUSEUP),
    K_MOUSELEFT     -19453,   ;; TERMCAP2KEY(KS_EXTRA, KE_MOUSELEFT),
    K_MOUSERIGHT    -19709,   ;; TERMCAP2KEY(KS_EXTRA, KE_MOUSERIGHT),

    K_CSI           -20477,   ;; TERMCAP2KEY(KS_EXTRA, KE_CSI),
    K_SNR           -20733,   ;; TERMCAP2KEY(KS_EXTRA, KE_SNR),
    K_PLUG          -20989,   ;; TERMCAP2KEY(KS_EXTRA, KE_PLUG),
    K_CMDWIN        -21245,   ;; TERMCAP2KEY(KS_EXTRA, KE_CMDWIN),

    K_DROP          -24061,   ;; TERMCAP2KEY(KS_EXTRA, KE_DROP),
    K_FOCUSGAINED   -24573,   ;; TERMCAP2KEY(KS_EXTRA, KE_FOCUSGAINED),
    K_FOCUSLOST     -24829,   ;; TERMCAP2KEY(KS_EXTRA, KE_FOCUSLOST),

    K_CURSORHOLD    -24317)   ;; TERMCAP2KEY(KS_EXTRA, KE_CURSORHOLD);

;; Bits for modifier mask.
;; 0x01 cannot be used, because the modifier must be 0x02 or higher
(final int MOD_MASK_SHIFT      0x02)
(final int MOD_MASK_CTRL       0x04)
(final int MOD_MASK_ALT        0x08)        ;; aka META
(final int MOD_MASK_META       0x10)        ;; META when it's different from ALT
(final int MOD_MASK_2CLICK     0x20)        ;; use MOD_MASK_MULTI_CLICK
(final int MOD_MASK_3CLICK     0x40)        ;; use MOD_MASK_MULTI_CLICK
(final int MOD_MASK_4CLICK     0x60)        ;; use MOD_MASK_MULTI_CLICK

(final int MOD_MASK_MULTI_CLICK (| MOD_MASK_2CLICK MOD_MASK_3CLICK MOD_MASK_4CLICK))

;; The length of the longest special key name, including modifiers.
;; Current longest is <M-C-S-T-4-MiddleRelease> (length includes '<' and '>').

(final int MAX_KEY_NAME_LEN    25)

;; Maximum length of a special key event as tokens.  This includes modifiers.
;; The longest event is something like <M-C-S-T-4-LeftDrag> which would be the
;; following string of tokens:
;;
;; <KB_SPECIAL> <KS_MODIFIER> bitmask <KB_SPECIAL> <KS_EXTRA> <KE_LEFTDRAG>.
;;
;; This is a total of 6 tokens, and is currently the longest one possible.

(final int MAX_KEY_CODE_LEN    6)

;; Get single int code from second byte after KB_SPECIAL.

(defn- #_int toSpecial [#_byte a, #_byte b]
    (§
;       return (a == KS_SPECIAL) ? char_u(KB_SPECIAL) : (a == KS_ZERO) ? K_ZERO : TERMCAP2KEY(a, b);
    ))

;; ----------------------------------------------------------------------- ;;

;; This file contains the defines for the machine dependent escape sequences
;; that the editor needs to perform various operations.  All of the sequences
;; here are optional, except "cm" (cursor motion).

;; Index of the termcap codes in the 'term_strings' array.

(final int
    KS_NAME  0,     ;; name of this terminal entry
    KS_CE    1,     ;; clear to end of line
    KS_AL    2,     ;; add new blank line
    KS_CAL   3,     ;; add number of blank lines
    KS_DL    4,     ;; delete line
    KS_CDL   5,     ;; delete number of lines
    KS_CS    6,     ;; scroll region
    KS_CL    7,     ;; clear screen
    KS_CD    8,     ;; clear to end of display
    KS_UT    9,     ;; clearing uses current background color
    KS_DA   10,     ;; text may be scrolled down from up
    KS_DB   11,     ;; text may be scrolled up from down
    KS_VI   12,     ;; cursor invisible
    KS_VE   13,     ;; cursor visible
    KS_VS   14,     ;; cursor very visible
    KS_ME   15,     ;; normal mode
    KS_MR   16,     ;; reverse mode
    KS_MD   17,     ;; bold mode
    KS_SE   18,     ;; normal mode
    KS_SO   19,     ;; standout mode
    KS_CZH  20,     ;; italic mode start
    KS_CZR  21,     ;; italic mode end
    KS_UE   22,     ;; exit underscore (underline) mode
    KS_US   23,     ;; underscore (underline) mode
    KS_UCE  24,     ;; exit undercurl mode
    KS_UCS  25,     ;; undercurl mode
    KS_MS   26,     ;; save to move cur in reverse mode
    KS_CM   27,     ;; cursor motion
    KS_SR   28,     ;; scroll reverse (backward)
    KS_CRI  29,     ;; cursor number of chars right
    KS_VB   30,     ;; visual bell
    KS_KS   31,     ;; put term in "keypad transmit" mode
    KS_KE   32,     ;; out of "keypad transmit" mode
    KS_TI   33,     ;; put terminal in termcap mode
    KS_TE   34,     ;; out of termcap mode
    KS_BC   35,     ;; backspace character (cursor left)
    KS_CCS  36,     ;; cur is relative to scroll region
    KS_CCO  37,     ;; number of colors
    KS_CSF  38,     ;; set foreground color
    KS_CSB  39,     ;; set background color
    KS_XS   40,     ;; standout not erased by overwriting (hpterm)
    KS_XN   41,     ;; newline glitch
    KS_MB   42,     ;; blink mode
    KS_CAF  43,     ;; set foreground color (ANSI)
    KS_CAB  44,     ;; set background color (ANSI)
    KS_LE   45,     ;; cursor left (mostly backspace)
    KS_ND   46,     ;; cursor right
    KS_CIS  47,     ;; set icon text start
    KS_CIE  48,     ;; set icon text end
    KS_TS   49,     ;; set window title start (to status line)
    KS_FS   50,     ;; set window title end (from status line)
    KS_CWP  51,     ;; set window position in pixels
    KS_CWS  52,     ;; set window size in characters
    KS_CRV  53,     ;; request version string
    KS_CSI  54,     ;; start insert mode (bar cursor)
    KS_CEI  55,     ;; end insert mode (block cursor)
    KS_CSR  56,     ;; start replace mode (underline cursor)
    KS_CSV  57,     ;; scroll region vertical
    KS_OP   58,     ;; original color pair
    KS_U7   59)     ;; request cursor position

;; The terminal capabilities are stored in this array.
;; IMPORTANT: When making changes, note the following:
;; - there should be an entry for each code in the builtin termcaps
;; - there should be an option for each code in option.c
;; - there should be code in term.c to obtain the value from the termcap

;; strings used for terminal

(atom! Bytes
    T_NAME  nil,    ;; terminal name
    T_CE    nil,    ;; clear to end of line
    T_AL    nil,    ;; add new blank line
    T_CAL   nil,    ;; add number of blank lines
    T_DL    nil,    ;; delete line
    T_CDL   nil,    ;; delete number of lines
    T_CS    nil,    ;; scroll region
    T_CL    nil,    ;; clear screen
    T_CD    nil,    ;; clear to end of display
    T_UT    nil,    ;; clearing uses background color
    T_DA    nil,    ;; text may be scrolled down from up
    T_DB    nil,    ;; text may be scrolled up from down
    T_VI    nil,    ;; cursor invisible
    T_VE    nil,    ;; cursor visible
    T_VS    nil,    ;; cursor very visible
    T_ME    nil,    ;; normal mode
    T_MR    nil,    ;; reverse mode
    T_MD    nil,    ;; bold mode
    T_SE    nil,    ;; normal mode
    T_SO    nil,    ;; standout mode
    T_CZH   nil,    ;; italic mode start
    T_CZR   nil,    ;; italic mode end
    T_UE    nil,    ;; exit underscore (underline) mode
    T_US    nil,    ;; underscore (underline) mode
    T_UCE   nil,    ;; exit undercurl mode
    T_UCS   nil,    ;; undercurl mode
    T_MS    nil,    ;; save to move cur in reverse mode
    T_CM    nil,    ;; cursor motion
    T_SR    nil,    ;; scroll reverse (backward)
    T_CRI   nil,    ;; cursor number of chars right
    T_VB    nil,    ;; visual bell
    T_KS    nil,    ;; put term in "keypad transmit" mode
    T_KE    nil,    ;; out of "keypad transmit" mode
    T_TI    nil,    ;; put terminal in termcap mode
    T_TE    nil,    ;; out of termcap mode
    T_BC    nil,    ;; backspace character
    T_CCS   nil,    ;; cur is relative to scroll region
    T_CCO   nil,    ;; number of colors
    T_CSF   nil,    ;; set foreground color
    T_CSB   nil,    ;; set background color
    T_XS    nil,    ;; standout not erased by overwriting
    T_XN    nil,    ;; newline glitch
    T_MB    nil,    ;; blink mode
    T_CAF   nil,    ;; set foreground color (ANSI)
    T_CAB   nil,    ;; set background color (ANSI)
    T_LE    nil,    ;; cursor left
    T_ND    nil,    ;; cursor right
    T_CIS   nil,    ;; set icon text start
    T_CIE   nil,    ;; set icon text end
    T_TS    nil,    ;; set window title start
    T_FS    nil,    ;; set window title end
    T_CWP   nil,    ;; window position
    T_CWS   nil,    ;; window size
    T_CRV   nil,    ;; request version string
    T_CSI   nil,    ;; start insert mode
    T_CEI   nil,    ;; end insert mode
    T_CSR   nil,    ;; start replace mode
    T_CSV   nil,    ;; scroll region vertical
    T_OP    nil,    ;; original color pair
    T_U7    nil)    ;; request cursor position

;; 'term_strings' contains currently used terminal output strings.
;; It is initialized with the default values by parse_builtin_tcap().
;; The values can be changed by setting the option with the same name.

(final Bytes*' term_strings [ T_NAME T_CE  T_AL  T_CAL T_DL  T_CDL T_CS  T_CL  T_CD  T_UT
                              T_DA   T_DB  T_VI  T_VE  T_VS  T_ME  T_MR  T_MD  T_SE  T_SO
                              T_CZH  T_CZR T_UE  T_US  T_UCE T_UCS T_MS  T_CM  T_SR  T_CRI
                              T_VB   T_KS  T_KE  T_TI  T_TE  T_BC  T_CCS T_CCO T_CSF T_CSB
                              T_XS   T_XN  T_MB  T_CAF T_CAB T_LE  T_ND  T_CIS T_CIE T_TS
                              T_FS   T_CWP T_CWS T_CRV T_CSI T_CEI T_CSR T_CSV T_OP  T_U7 ])

(final int TMODE_COOK  0)   ;; terminal mode for external cmds and Ex mode
(final int TMODE_SLEEP 1)   ;; terminal mode for sleeping (cooked but no echo)
(final int TMODE_RAW   2)   ;; terminal mode for Normal and Insert mode

;; ----------------------------------------------------------------------- ;;

;; flags for update_screen()
;; The higher the value, the higher the priority

(final int VALID        10) ;; buffer not changed, or changes marked with b_mod_*
(final int INVERTED     20) ;; redisplay inverted part that changed
(final int INVERTED_ALL 25) ;; redisplay whole inverted part
(final int REDRAW_TOP   30) ;; display first w_upd_rows screen lines
(final int SOME_VALID   35) ;; like NOT_VALID but may scroll
(final int NOT_VALID    40) ;; buffer needs complete redraw
(final int CLEAR        50) ;; screen messed up, clear it

;; Flags for w_valid.
;; These are set when something in a window structure becomes invalid, except when the cursor is moved.
;; Call check_cursor_moved() before testing one of the flags.
;; These are reset when that thing has been updated and is valid again.
;;
;; Every function that invalidates one of these must call one of the invalidate_* functions.
;;
;; w_valid is supposed to be encapsulated: use the functions that set or reset the flags, instead.
;;
;; VALID_BOTLINE    VALID_BOTLINE_AP
;;     on               on              w_botline valid
;;     off              on              w_botline approximated
;;     off              off             w_botline not valid
;;     on               off             not possible

(final int VALID_WROW         0x01)     ;; w_wrow (window row) is valid
(final int VALID_WCOL         0x02)     ;; w_wcol (window col) is valid
(final int VALID_VIRTCOL      0x04)     ;; w_virtcol (file col) is valid
(final int VALID_CHEIGHT      0x08)     ;; w_cline_height and w_cline_folded valid
(final int VALID_CROW         0x10)     ;; w_cline_row is valid
(final int VALID_BOTLINE      0x20)     ;; w_botine and w_empty_rows are valid
(final int VALID_BOTLINE_AP   0x40)     ;; w_botine is approximated
(final int VALID_TOPLINE      0x80)     ;; w_topline is valid (for cursor position)

;; Terminal highlighting attribute bits.
;; Attributes above HL_ALL are used for syntax highlighting.

(final int HL_NORMAL          0x00)
(final int HL_INVERSE         0x01)
(final int HL_BOLD            0x02)
(final int HL_ITALIC          0x04)
(final int HL_UNDERLINE       0x08)
(final int HL_UNDERCURL       0x10)
(final int HL_STANDOUT        0x20)
(final int HL_ALL             0x3f)

;; special attribute addition: put message in history
(final int MSG_HIST           0x1000)

;; values for State
;;
;; The lower bits up to 0x20 are used to distinguish normal/visual/op_pending
;; and cmdline/insert+replace mode.  This is used for mapping.
;; If none of these bits are set, no mapping is done.
;; The upper bits are used to distinguish between other states.

(final int
    NORMAL          0x01,             ;; normal mode, command expected
    VISUAL          0x02,             ;; visual mode - use get_real_state()
    OP_PENDING      0x04,             ;; normal mode, operator is pending - use get_real_state()
    CMDLINE         0x08,             ;; editing command line
    INSERT          0x10,             ;; insert mode

    REPLACE_FLAG    0x40,             ;; replace mode flag
    REPLACE         (+ REPLACE_FLAG INSERT),
    VREPLACE_FLAG   0x80,             ;; virtual-replace mode flag
    VREPLACE        (+ REPLACE_FLAG VREPLACE_FLAG INSERT),

    NORMAL_BUSY     (+ 0x100 NORMAL), ;; normal mode, busy with a command
    HITRETURN       (+ 0x200 NORMAL), ;; waiting for return or command
    ASKMORE         0x300,            ;; asking if you want --more--
    SETWSIZE        0x400,            ;; window size has changed
    ABBREV          0x500,            ;; abbreviation instead of mapping
    SHOWMATCH       (+ 0x700 INSERT), ;; show matching paren
    CONFIRM         0x800,            ;; ":confirm" prompt
    SELECTMODE      0x1000)           ;; select mode, only for mappings

(final int MAP_ALL_MODES (| 0x3f SELECTMODE)) ;; all mode bits used for mapping

;; directions
(final int FORWARD        1)
(final int BACKWARD       -1)
(final int FORWARD_FILE   3)
(final int BACKWARD_FILE  -3)

;; flags for b_flags
(final int BF_RECOVERED   0x01)     ;; buffer has been recovered
(final int BF_CHECK_RO    0x02)     ;; need to check readonly when loading file into buffer (set by ":e", may be reset by ":buf")
(final int BF_NEVERLOADED 0x04)     ;; file has never been loaded into buffer, many variables still need to be set
(final int BF_NOTEDITED   0x08)     ;; set when file name is changed after starting to edit, reset when file is written out
(final int BF_NEW         0x10)     ;; file didn't exist when editing started
(final int BF_NEW_W       0x20)     ;; warned for BF_NEW and file created
(final int BF_READERR     0x40)     ;; got errors while reading the file
(final int BF_DUMMY       0x80)     ;; dummy buffer, only used internally

;; Mask to check for flags that prevent normal writing.
(final int BF_WRITE_MASK  (+ BF_NOTEDITED BF_NEW BF_READERR))

;; Values for exmode_active (0 is no exmode).
(final int EXMODE_NORMAL      1)
(final int EXMODE_VIM         2)

(final int HL_CONTAINED    0x01)    ;; not used on toplevel
(final int HL_TRANSP       0x02)    ;; has no highlighting
(final int HL_ONELINE      0x04)    ;; match within one line only
(final int HL_HAS_EOL      0x08)    ;; end pattern that matches with $
(final int HL_SYNC_HERE    0x10)    ;; sync point after this item (syncing only)
(final int HL_SYNC_THERE   0x20)    ;; sync point at current line (syncing only)
(final int HL_MATCH        0x40)    ;; use match ID instead of item ID
(final int HL_SKIPNL       0x80)    ;; nextgroup can skip newlines
(final int HL_SKIPWHITE    0x100)   ;; nextgroup can skip white space
(final int HL_SKIPEMPTY    0x200)   ;; nextgroup can skip empty lines
(final int HL_KEEPEND      0x400)   ;; end match always kept
(final int HL_EXCLUDENL    0x800)   ;; exclude NL from match
(final int HL_DISPLAY      0x1000)  ;; only used for displaying, not syncing
(final int HL_FOLD         0x2000)  ;; define fold
(final int HL_EXTEND       0x4000)  ;; ignore a keepend
(final int HL_MATCHCONT    0x8000)  ;; match continued from previous line
(final int HL_TRANS_CONT   0x10000) ;; transparent item without contains arg
(final int HL_CONCEAL      0x20000) ;; can be concealed
(final int HL_CONCEALENDS  0x40000) ;; can be concealed

;; Values for 'options' argument in do_search() and searchit().
(final int SEARCH_REV      0x01)    ;; go in reverse of previous dir.
(final int SEARCH_ECHO     0x02)    ;; echo the search command and handle options
(final int SEARCH_MSG      0x0c)    ;; give messages (yes, it's not 0x04)
(final int SEARCH_NFMSG    0x08)    ;; give all messages except not found
(final int SEARCH_OPT      0x10)    ;; interpret optional flags
(final int SEARCH_HIS      0x20)    ;; put search pattern in history
(final int SEARCH_END      0x40)    ;; put cursor at end of match
(final int SEARCH_NOOF     0x80)    ;; don't add offset to position
(final int SEARCH_START    0x100)   ;; start search without col offset
(final int SEARCH_MARK     0x200)   ;; set previous context mark
(final int SEARCH_KEEP     0x400)   ;; keep previous search pattern
(final int SEARCH_PEEK     0x800)   ;; peek for typed char, cancel search

;; Values for find_ident_under_cursor().
(final int FIND_IDENT      1)       ;; find identifier (word)
(final int FIND_STRING     2)       ;; find any string (WORD)
(final int FIND_EVAL       4)       ;; include "->", "[]" and "."

;; Values for buflist_getfile().
(final int GETF_SETMARK    0x01)    ;; set pcmark before jumping
(final int GETF_ALT        0x02)    ;; jumping to alternate file (not buf num)
(final int GETF_SWITCH     0x04)    ;; respect 'switchbuf' settings when jumping

;; Values for in_cinkeys().
(final int KEY_OPEN_FORW   0x101)
(final int KEY_OPEN_BACK   0x102)
(final int KEY_COMPLETE    0x103)   ;; end of completion

;; Values for "noremap" argument of ins_typebuf().
;; Also used for map.m_noremap and menu.noremap[].

(final int REMAP_YES       0)       ;; allow remapping
(final int REMAP_NONE      -1)      ;; no remapping
(final int REMAP_SCRIPT    -2)      ;; remap script-local mappings only
(final int REMAP_SKIP      -3)      ;; no remapping for first char

;; Values for mch_call_shell() second argument.
(final int SHELL_FILTER    1)       ;; filtering text
(final int SHELL_COOKED    4)       ;; set term to cooked mode
(final int SHELL_DOOUT     8)       ;; redirecting output
(final int SHELL_READ      32)      ;; read lines and insert into buffer
(final int SHELL_WRITE     64)      ;; write lines from buffer

;; Values returned by mch_nodetype().
(final int NODE_NORMAL     0)       ;; file or directory, check with mch_isdir()
(final int NODE_WRITABLE   1)       ;; something we can write to (character device, fifo, socket, ..)
(final int NODE_OTHER      2)       ;; non-writable thing (e.g., block device)

;; Values for readfile() flags.
(final int READ_NEW        0x01)    ;; read a file into a new buffer
(final int READ_FILTER     0x02)    ;; read filter output
(final int READ_STDIN      0x04)    ;; read from stdin

;; Values for change_indent().
(final int INDENT_SET      1)       ;; set indent
(final int INDENT_INC      2)       ;; increase indent
(final int INDENT_DEC      3)       ;; decrease indent

;; Values for flags argument for findmatchlimit().
(final int FM_BACKWARD     0x01)    ;; search backwards
(final int FM_FORWARD      0x02)    ;; search forwards
(final int FM_BLOCKSTOP    0x04)    ;; stop at start/end of block
(final int FM_SKIPCOMM     0x08)    ;; skip comments

;; Values for action argument for do_buffer().
(final int DOBUF_GOTO      0)       ;; go to specified buffer
(final int DOBUF_SPLIT     1)       ;; split window and go to specified buffer
(final int DOBUF_UNLOAD    2)       ;; unload specified buffer(s)
(final int DOBUF_DEL       3)       ;; delete specified buffer(s) from buflist
(final int DOBUF_WIPE      4)       ;; delete specified buffer(s) really

;; Values for start argument for do_buffer().
(final int DOBUF_CURRENT   0)       ;; "count" buffer from current buffer
(final int DOBUF_FIRST     1)       ;; "count" buffer from first buffer
(final int DOBUF_LAST      2)       ;; "count" buffer from last buffer
(final int DOBUF_MOD       3)       ;; "count" mod. buffer from current buffer

;; Values for sub_cmd and which_pat argument for search_regcomp().
;; Also used for which_pat argument for searchit().
(final int RE_SEARCH       0)       ;; save/use pat in/from search_pattern
(final int RE_SUBST        1)       ;; save/use pat in/from subst_pattern
(final int RE_BOTH         2)       ;; save pat in both patterns
(final int RE_LAST         2)       ;; use last used pattern if "pat" is null

;; Second argument for vim_regcomp().
(final int RE_MAGIC        1)       ;; 'magic' option
(final int RE_STRING       2)       ;; match in string instead of buffer text
(final int RE_STRICT       4)       ;; don't allow [abc] without ]
(final int RE_AUTO         8)       ;; automatic engine selection

;; values for reg_do_extmatch
(final int REX_SET         1)       ;; to allow \z\(...\),
(final int REX_USE         2)       ;; to allow \z\1 et al.

;; flags for do_ecmd()
(final int ECMD_HIDE       0x01)    ;; don't free the current buffer
(final int ECMD_FORCEIT    0x08)    ;; ! used in Ex command

;; for lnum argument in do_ecmd()
(final int ECMD_LASTL      0)       ;; use last position in loaded file
(final int ECMD_LAST       -1)      ;; use last position in all files
(final int ECMD_ONE        1)       ;; use first line

;; flags for do_cmdline()
(final int DOCMD_VERBOSE   0x01)    ;; included command in error message
(final int DOCMD_NOWAIT    0x02)    ;; don't call wait_return() and friends
(final int DOCMD_REPEAT    0x04)    ;; repeat exec. until getline() returns null
(final int DOCMD_KEYTYPED  0x08)    ;; don't reset keyTyped
(final int DOCMD_KEEPLINE  0x20)    ;; keep typed line for repeating with "."

;; flags for beginline()
(final int BL_WHITE        1)       ;; cursor on first non-white in the line
(final int BL_SOL          2)       ;; use 'sol' option
(final int BL_FIX          4)       ;; don't leave cursor on a NUL

;; flags for buf_copy_options()
(final int BCO_ENTER       1)       ;; going to enter the buffer
(final int BCO_ALWAYS      2)       ;; always copy the options

;; flags for do_put()
(final int PUT_FIXINDENT   1)       ;; make indent look nice
(final int PUT_CURSEND     2)       ;; leave cursor after end of new text
(final int PUT_CURSLINE    4)       ;; leave cursor on last line of new text
(final int PUT_LINE        8)       ;; put register as lines
(final int PUT_LINE_SPLIT  16)      ;; split line for linewise register
(final int PUT_LINE_FORWARD 32)     ;; put linewise register below Visual sel.

;; flags for set_indent()
(final int SIN_CHANGED     1)       ;; call changed_bytes() when line changed
(final int SIN_INSERT      2)       ;; insert indent before existing text
(final int SIN_UNDO        4)       ;; save line for undo before changing it

;; flags for insertchar()
(final int INSCHAR_FORMAT  1)       ;; force formatting
(final int INSCHAR_DO_COM  2)       ;; format comments
(final int INSCHAR_CTRLV   4)       ;; char typed just after CTRL-V
(final int INSCHAR_NO_FEX  8)       ;; don't use 'formatexpr'
(final int INSCHAR_COM_LIST 16)     ;; format comments with list/2nd line indent

;; flags for open_line()
(final int OPENLINE_DELSPACES  1)   ;; delete spaces after cursor
(final int OPENLINE_DO_COM     2)   ;; format comments
(final int OPENLINE_KEEPTRAIL  4)   ;; keep trailing spaces
(final int OPENLINE_MARKFIX    8)   ;; fix mark positions
(final int OPENLINE_COM_LIST  16)   ;; format comments with list/2nd line indent

;; There are four history tables:

(final int HIST_CMD        0)       ;; colon commands
(final int HIST_SEARCH     1)       ;; search commands
(final int HIST_EXPR       2)       ;; expressions (from entering = register)
(final int HIST_INPUT      3)       ;; input() lines
(final int HIST_COUNT      4)       ;; number of history tables

;; Flags for chartab[].

(final int CT_CELL_MASK    0x07)    ;; mask: nr of display cells (1, 2 or 4)
(final int CT_PRINT_CHAR   0x10)    ;; flag: set for printable chars
(final int CT_ID_CHAR      0x20)    ;; flag: set for ID chars
(final int CT_FNAME_CHAR   0x40)    ;; flag: set for file name chars

;; Return values for functions like gui_yesnocancel()

(final int VIM_YES         2)
(final int VIM_NO          3)
(final int VIM_CANCEL      4)
(final int VIM_ALL         5)
(final int VIM_DISCARDALL  6)

;; arguments for win_split()

(final int WSP_ROOM        1)       ;; require enough room
(final int WSP_VERT        2)       ;; split vertically
(final int WSP_TOP         4)       ;; window at top-left of shell
(final int WSP_BOT         8)       ;; window at bottom-right of shell
(final int WSP_BELOW       32)      ;; put new window below/right
(final int WSP_ABOVE       64)      ;; put new window above/left
(final int WSP_NEWLOC      128)     ;; don't copy location list

;; flags for check_changed()

(final int CCGD_MULTWIN    2)       ;; check also when several wins for the buf
(final int CCGD_FORCEIT    4)       ;; ! used
(final int CCGD_ALLBUF     8)       ;; may write all buffers
(final int CCGD_EXCMD      16)      ;; may suggest using !

;; "flags" values for option-setting functions.
;; When OPT_GLOBAL and OPT_LOCAL are both missing, set both local and global
;; values, get local value.

(final int OPT_FREE        1)       ;; free old value if it was allocated
(final int OPT_GLOBAL      2)       ;; use global value
(final int OPT_LOCAL       4)       ;; use local value
(final int OPT_MODELINE    8)       ;; option in modeline
(final int OPT_WINONLY     16)      ;; only set window-local options
(final int OPT_NOWIN       32)      ;; don't set window-local options

;; Magic chars used in confirm dialog strings.
(final byte DLG_BUTTON_SEP  \newline)
(final byte DLG_HOTKEY_CHAR \&)

;; Values for "starting".
(final int NO_SCREEN       2)       ;; no screen updating yet
(final int NO_BUFFERS      1)       ;; not all buffers loaded yet
;;                         0           not starting anymore

;; Values for index in highlight_attr[].
;; When making changes, also update HL_FLAGS below!
;; And update the default value of 'highlight' in option.c.

(final int
    HLF_8 0,        ;; Meta & special keys listed with ":map", text that is displayed different from what it is
    HLF_AT 1,       ;; @ and ~ characters at end of screen, characters that don't really exist in the text
    HLF_D 2,        ;; directories in CTRL-D listing
    HLF_E 3,        ;; error messages
    HLF_H 4,        ;; obsolete, ignored
    HLF_I 5,        ;; incremental search
    HLF_L 6,        ;; last search string
    HLF_M 7,        ;; "--More--" message
    HLF_CM 8,       ;; Mode (e.g., "-- INSERT --")
    HLF_N 9,        ;; line number for ":number" and ":#" commands
    HLF_CLN 10,     ;; current line number
    HLF_R 11,       ;; return to continue message and yes/no questions
    HLF_S 12,       ;; status lines
    HLF_SNC 13,     ;; status lines of not-current windows
    HLF_C 14,       ;; column to separate vertically split windows
    HLF_T 15,       ;; Titles for output from ":set all", ":autocmd" etc.
    HLF_V 16,       ;; Visual mode
    HLF_VNC 17,     ;; Visual mode, autoselecting and not clipboard owner
    HLF_W 18,       ;; warning messages
    HLF_WM 19,      ;; Wildmenu highlight
    HLF_FL 20,      ;; Folded line
    HLF_FC 21,      ;; Fold column
    HLF_ADD 22,     ;; Added diff line
    HLF_CHD 23,     ;; Changed diff line
    HLF_DED 24,     ;; Deleted diff line
    HLF_TXD 25,     ;; Text Changed in diff line
    HLF_CONCEAL 26, ;; Concealed text
    HLF_SC 27,      ;; Sign column
    HLF_SPB 28,     ;; SpellBad
    HLF_SPC 29,     ;; SpellCap
    HLF_SPR 30,     ;; SpellRare
    HLF_SPL 31,     ;; SpellLocal
    HLF_PNI 32,     ;; popup menu normal item
    HLF_PSI 33,     ;; popup menu selected item
    HLF_PSB 34,     ;; popup menu scrollbar
    HLF_PST 35,     ;; popup menu scrollbar thumb
    HLF_TP 36,      ;; tabpage line
    HLF_TPS 37,     ;; tabpage line selected
    HLF_TPF 38,     ;; tabpage line filler
    HLF_CUC 39,     ;; 'cursorcolumn'
    HLF_CUL 40,     ;; 'cursorline'
    HLF_MC 41,      ;; 'colorcolumn'
    HLF_COUNT 42)   ;; MUST be the last one

;; Operator IDs; The order must correspond to opchars[] in ops.c!

(final int
    OP_NOP       0,       ;; no pending operation
    OP_DELETE    1,       ;; "d"  delete operator
    OP_YANK      2,       ;; "y"  yank operator
    OP_CHANGE    3,       ;; "c"  change operator
    OP_LSHIFT    4,       ;; "<"  left shift operator
    OP_RSHIFT    5,       ;; ">"  right shift operator
    OP_FILTER    6,       ;; "!"  filter operator
    OP_TILDE     7,       ;; "g~" switch case operator
    OP_INDENT    8,       ;; "="  indent operator
    OP_FORMAT    9,       ;; "gq" format operator
    OP_COLON    10,       ;; ":"  colon operator
    OP_UPPER    11,       ;; "gU" make upper case operator
    OP_LOWER    12,       ;; "gu" make lower case operator
    OP_JOIN     13,       ;; "J"  join operator, only for Visual mode
    OP_JOIN_NS  14,       ;; "gJ"  join operator, only for Visual mode
    OP_ROT13    15,       ;; "g?" rot-13 encoding
    OP_REPLACE  16,       ;; "r"  replace chars, only for Visual mode
    OP_INSERT   17,       ;; "I"  Insert column, only for Visual mode
    OP_APPEND   18,       ;; "A"  Append column, only for Visual mode
    OP_FORMAT2  19,       ;; "gw" format operator, keeps cursor pos
    OP_FUNCTION 20)       ;; "g@" call 'operatorfunc'

;; Motion types, used for operators and for yank/delete registers.

(final byte!
    MCHAR   0,            ;; character-wise movement/register
    MLINE   1,            ;; line-wise movement/register
    MBLOCK  2,            ;; block-wise register
    MAUTO   0xff)         ;; decide between MLINE/MCHAR

;; Minimum screen size.

(final int MIN_COLUMNS     12)          ;; minimal columns for screen
(final int MIN_LINES       2)           ;; minimal lines for screen
(final int STATUS_HEIGHT   1)           ;; height of a status line under a window

(final int IOSIZE          (inc 1024))  ;; file i/o and sprintf buffer size

(final int DIALOG_MSG_SIZE 1000)        ;; buffer size for dialog_msg()

(final int
    MSG_BUF_LEN     480,                ;; length of buffer for small messages
    MSG_BUF_CLEN    (/ MSG_BUF_LEN 6))  ;; cell length (worst case: utf-8 takes 6 bytes for one cell)

;; Maximum length of key sequence to be mapped.
;; Must be able to hold an Amiga resize report.

(final int MAXMAPLEN 50)

;; Size in bytes of the hash used in the undo file.
(final int UNDO_HASH_SIZE 32)

(final long MAXLNUM 0x7fffffff#_L)      ;; maximum (invalid) line number

;; Well, you won't believe it, but some S/390 machines ("host", now also known
;; as zServer) use 31 bit pointers.  There are also some newer machines, that
;; use 64 bit pointers.  I don't know how to distinguish between 31 and 64 bit
;; machines, so the best way is to assume 31 bits whenever we detect OS/390 Unix.
;; With this we restrict the maximum line length to 1073741823.  I guess this is
;; not a real problem.  BTW:  Longer lines are split.

(final int MAXCOL 0x7fffffff)           ;; maximum column number, 31 bits

(final int SHOWCMD_COLS 10)             ;; columns needed by shown command
(final int STL_MAX_ITEM 80)             ;; max nr of %<flag> in statusline

;; vim_iswhite() is used for "^" and the like.  It differs from isspace()
;; because it doesn't include <CR> and <LF> and the like.

(defn- #_boolean vim_iswhite [#_int x]
    (§
;       return (x == ' ' || x == '\t');
    ))

(final int MAX_MCO        6)        ;; maximum value for 'maxcombine'

;; Maximum number of bytes in a multi-byte character.  It can be one 32-bit
;; character of up to 6 bytes, or one 16-bit character of up to three bytes
;; plus six following composing characters of three bytes each.

(final int MB_MAXBYTES    21)

;;; ============================================================================================== VimD

;; option.h: definition of global variables for settable options

;; Formatting options for "p_fo" 'formatoptions'.
(final byte
    FO_WRAP         \t,
    FO_WRAP_COMS    \c,
    FO_RET_COMS     \r,
    FO_OPEN_COMS    \o,
    FO_Q_COMS       \q,
    FO_Q_NUMBER     \n,
    FO_Q_SECOND     \2,
    FO_INS_VI       \v,
    FO_INS_LONG     \l,
    FO_INS_BLANK    \b,
    FO_MBYTE_BREAK  \m,  ;; break before/after multi-byte char
    FO_MBYTE_JOIN   \M,  ;; no space before/after multi-byte char
    FO_MBYTE_JOIN2  \B,  ;; no space between multi-byte chars
    FO_ONE_LETTER   \1,
    FO_WHITE_PAR    \w,  ;; trailing white space continues paragr.
    FO_AUTO         \a,  ;; automatic formatting
    FO_REMOVE_COMS  \j)  ;; remove comment leaders when joining lines

(final Bytes DFLT_FO_VIM  (u8 "tcq"))
(final Bytes FO_ALL       (u8 "tcroq2vlb1mMBn,awj"))    ;; for do_set()

;; characters for the "p_cpo" option:
(final byte
    CPO_ALTREAD     \a,  ;; ":read" sets alternate file name
    CPO_ALTWRITE    \A,  ;; ":write" sets alternate file name
    CPO_BAR         \b,  ;; "\|" ends a mapping
    CPO_BSLASH      \B,  ;; backslash in mapping is not special
    CPO_SEARCH      \c,
    CPO_CONCAT      \C,  ;; don't concatenate sourced lines
    CPO_DOTTAG      \d,  ;; "./tags" in 'tags' is in current dir
    CPO_DIGRAPH     \D,  ;; no digraph after "r", "f", etc.
    CPO_EXECBUF     \e,
    CPO_EMPTYREGION \E,  ;; operating on empty region is an error
    CPO_FNAMER      \f,  ;; set file name for ":r file"
    CPO_FNAMEW      \F,  ;; set file name for ":w file"
    CPO_GOTO1       \g,  ;; goto line 1 for ":edit"
    CPO_INSEND      \H,  ;; "I" inserts before last blank in line
    CPO_INTMOD      \i,  ;; interrupt a read makes buffer modified
    CPO_INDENT      \I,  ;; remove auto-indent more often
    CPO_JOINSP      \j,  ;; only use two spaces for join after '.'
    CPO_ENDOFSENT   \J,  ;; need two spaces to detect end of sentence
    CPO_KEYCODE     \k,  ;; don't recognize raw key code in mappings
    CPO_KOFFSET     \K,  ;; don't wait for key code in mappings
    CPO_LITERAL     \l,  ;; take char after backslash in [] literal
    CPO_LISTWM      \L,  ;; 'list' changes wrapmargin
    CPO_SHOWMATCH   \m,
    CPO_MATCHBSL    \M,  ;; "%" ignores use of backslashes
    CPO_NUMCOL      \n,  ;; 'number' column also used for text
    CPO_LINEOFF     \o,
    CPO_OVERNEW     \O,  ;; silently overwrite new file
    CPO_LISP        \p,  ;; 'lisp' indenting
    CPO_FNAMEAPP    \P,  ;; set file name for ":w >>file"
    CPO_JOINCOL     \q,  ;; with "3J" use column after first join
    CPO_REDO        \r,
    CPO_REMMARK     \R,  ;; remove marks when filtering
    CPO_BUFOPT      \s,
    CPO_BUFOPTGLOB  \S,
    CPO_TAGPAT      \t,
    CPO_UNDO        \u,  ;; "u" undoes itself
    CPO_BACKSPACE   \v,  ;; "v" keep deleted text
    CPO_CW          \w,  ;; "cw" only changes one blank
    CPO_FWRITE      \W,  ;; "w!" doesn't overwrite readonly files
    CPO_ESC         \x,
    CPO_REPLCNT     \X,  ;; "R" with a count only deletes chars once
    CPO_YANK        \y,
    CPO_KEEPRO      \Z,  ;; don't reset 'readonly' on ":w!"
    CPO_DOLLAR      \$,
    CPO_FILTER      \!,
    CPO_MATCH       \%,
    CPO_STAR        \*,  ;; ":*" means ":@"
    CPO_PLUS        \+,  ;; ":write file" resets 'modified'
    CPO_MINUS       \-,  ;; "9-" fails at and before line 9
    CPO_SPECI       \<,  ;; don't recognize <> in mappings
    CPO_REGAPPEND   \>,  ;; insert NL when appending to a register

;; POSIX flags
    CPO_HASH        \#,  ;; "D", "o" and "O" do not use a count
    CPO_PARA        \{,  ;; "{" is also a paragraph boundary
    CPO_TSIZE       \|,  ;; $LINES and $COLUMNS overrule term size
    CPO_PRESERVE    \&,  ;; keep swap file after :preserve
    CPO_SUBPERCENT  \/,  ;; % in :s string uses previous one
    CPO_BACKSL      \\,  ;; \ is not special in []
    CPO_CHDIR       \.,  ;; don't chdir if buffer is modified
    CPO_SCOLON      \;)  ;; using "," and ";" will skip over char if cursor would not move

;; default values for Vim, Vi and POSIX
(final Bytes CPO_VIM  (u8 "aABceFs"))
(final Bytes CPO_ALL  (u8 "aAbBcCdDeEfFgHiIjJkKlLmMnoOpPqrRsStuvwWxXyZ$!%*-+<>#{|&/\\.;"))

;; characters for "p_ww" option:
(final Bytes WW_ALL   (u8 "bshl<>[],~"))

;; characters for "p_mouse" option:
(final byte MOUSE_NORMAL  \n)              ;; use mouse in Normal mode
(final byte MOUSE_VISUAL  \v)              ;; use mouse in Visual/Select mode
(final byte MOUSE_INSERT  \i)              ;; use mouse in Insert mode
(final byte MOUSE_COMMAND \c)              ;; use mouse in Command-line mode
(final byte MOUSE_HELP    \h)              ;; use mouse in help buffers
(final byte MOUSE_RETURN  \r)              ;; use mouse for hit-return message
(final Bytes MOUSE_A      (u8 "nvich"))    ;; used for 'a' flag
(final Bytes MOUSE_ALL    (u8 "anvichr"))  ;; all possible characters
(final byte MOUSE_NONE    \space)          ;; don't use Visual selection
(final byte MOUSE_NONEF   \x)              ;; forced modeless selection

(final Bytes COCU_ALL     (u8 "nvic"))     ;; flags for 'concealcursor'

;; characters for "p_shm" option:
(final byte SHM_RO        \r)              ;; readonly
(final byte SHM_MOD       \m)              ;; modified
(final byte SHM_FILE      \f)              ;; (file 1 of 2)
(final byte SHM_LAST      \i)              ;; last line incomplete
(final byte SHM_TEXT      \x)              ;; tx instead of textmode
(final byte SHM_LINES     \l)              ;; "L" instead of "lines"
(final byte SHM_NEW       \n)              ;; "[New]" instead of "[New file]"
(final byte SHM_WRI       \w)              ;; "[w]" instead of "written"
(final Bytes SHM_A        (u8 "rmfixlnw")) ;; represented by 'a' flag
(final byte SHM_WRITE     \W)              ;; don't use "written" at all
(final byte SHM_TRUNC     \t)              ;; trunctate file messages
(final byte SHM_TRUNCALL  \T)              ;; trunctate all messages
(final byte SHM_OVER      \o)              ;; overwrite file messages
(final byte SHM_OVERALL   \O)              ;; overwrite more messages
(final byte SHM_SEARCH    \s)              ;; no search hit bottom messages
(final byte SHM_ATTENTION \A)              ;; no ATTENTION messages
(final byte SHM_INTRO     \I)              ;; intro messages
(final byte SHM_COMPLETIONMENU \c)         ;; completion menu messages
(final Bytes SHM_ALL      (u8 "rmfixlnwaWtToOsAIc")) ;; all possible flags for 'shm'

;; characters for p_go:
(final byte GO_ASEL       \a)              ;; autoselect
(final byte GO_ASELML     \A)              ;; autoselect modeless selection
(final byte GO_BOT        \b)              ;; use bottom scrollbar
(final byte GO_CONDIALOG  \c)              ;; use console dialog
(final byte GO_TABLINE    \e)              ;; may show tabline
(final byte GO_FORG       \f)              ;; start GUI in foreground
(final byte GO_GREY       \g)              ;; use grey menu items
(final byte GO_HORSCROLL  \h)              ;; flexible horizontal scrolling
(final byte GO_ICON       \i)              ;; use Vim icon
(final byte GO_LEFT       \l)              ;; use left scrollbar
(final byte GO_VLEFT      \L)              ;; left scrollbar with vert split
(final byte GO_MENUS      \m)              ;; use menu bar
(final byte GO_NOSYSMENU  \M)              ;; don't source system menu
(final byte GO_POINTER    \p)              ;; pointer enter/leave callbacks
(final byte GO_ASELPLUS   \P)              ;; autoselectPlus
(final byte GO_RIGHT      \r)              ;; use right scrollbar
(final byte GO_VRIGHT     \R)              ;; right scrollbar with vert split
(final byte GO_TEAROFF    \t)              ;; add tear-off menu items
(final byte GO_TOOLBAR    \T)              ;; add toolbar
(final byte GO_FOOTER     \F)              ;; add footer
(final byte GO_VERTICAL   \v)              ;; arrange dialog buttons vertically
(final Bytes GO_ALL       (u8 "aAbcefFghilmMprtTv")) ;; all possible flags for 'go'

;; flags for 'comments' option
(final byte COM_NEST      \n)              ;; comments strings nest
(final byte COM_BLANK     \b)              ;; needs blank after string
(final byte COM_START     \s)              ;; start of comment
(final byte COM_MIDDLE    \m)              ;; middle of comment
(final byte COM_END       \e)              ;; end of comment
(final byte COM_AUTO_END  \x)              ;; last char of end closes comment
(final byte COM_FIRST     \f)              ;; first line comment only
(final byte COM_LEFT      \l)              ;; left adjusted
(final byte COM_RIGHT     \r)              ;; right adjusted
(final byte COM_NOBACK    \O)              ;; don't use for "O" command
(final Bytes COM_ALL      (u8 "nbsmexflrO")) ;; all flags for 'comments' option
(final int COM_MAX_LEN    50)              ;; maximum length of a part

;; flags for 'statusline' option
(final byte
    STL_FILEPATH        \f,      ;; path of file in buffer
    STL_FULLPATH        \F,      ;; full path of file in buffer
    STL_FILENAME        \t,      ;; last part (tail) of file path
    STL_COLUMN          \c,      ;; column og cursor
    STL_VIRTCOL         \v,      ;; virtual column
    STL_VIRTCOL_ALT     \V,      ;; - with 'if different' display
    STL_LINE            \l,      ;; line number of cursor
    STL_NUMLINES        \L,      ;; number of lines in buffer
    STL_BUFNO           \n,      ;; current buffer number
    STL_KEYMAP          \k,      ;; 'keymap' when active
    STL_OFFSET          \o,      ;; offset of character under cursor
    STL_OFFSET_X        \O,      ;; - in hexadecimal
    STL_BYTEVAL         \b,      ;; byte value of character
    STL_BYTEVAL_X       \B,      ;; - in hexadecimal
    STL_ROFLAG          \r,      ;; readonly flag
    STL_ROFLAG_ALT      \R,      ;; - other display
    STL_HELPFLAG        \h,      ;; window is showing a help file
    STL_HELPFLAG_ALT    \H,      ;; - other display
    STL_FILETYPE        \y,      ;; 'filetype'
    STL_FILETYPE_ALT    \Y,      ;; - other display
    STL_PREVIEWFLAG     \w,      ;; window is showing the preview buf
    STL_PREVIEWFLAG_ALT \W,      ;; - other display
    STL_MODIFIED        \m,      ;; modified flag
    STL_MODIFIED_ALT    \M,      ;; - other display
    STL_QUICKFIX        \q,      ;; quickfix window description
    STL_PERCENTAGE      \p,      ;; percentage through file
    STL_ALTPERCENT      \P,      ;; percentage as TOP BOT ALL or NN%
    STL_ARGLISTSTAT     \a,      ;; argument list status as (x of y)
    STL_PAGENUM         \N,      ;; page number (when printing)
    STL_VIM_EXPR        \{,      ;; start of expression to substitute
    STL_MIDDLEMARK      \=,      ;; separation between left and right
    STL_TRUNCMARK       \<,      ;; truncation mark if line is too long
    STL_USER_HL         \*,      ;; highlight from (User)1..9 or 0
    STL_HIGHLIGHT       \#,      ;; highlight name
    STL_TABPAGENR       \T,      ;; tab page label nr
    STL_TABCLOSENR      \X)      ;; tab page close nr
(final Bytes STL_ALL (u8 "fFtcvVlLknoObBrRhHmYyWwMqpPaN{#"))

;; arguments for can_bs()
(final byte BS_INDENT     \i)      ;; "Indent"
(final byte BS_EOL        \o)      ;; "eOl"
(final byte BS_START      \s)      ;; "Start"

(final Bytes LISPWORD_VALUE (u8 "defun,define,defmacro,set!,lambda,if,case,let,flet,let*,letrec,do,do*,define-syntax,let-syntax,letrec-syntax,destructuring-bind,defpackage,defparameter,defstruct,deftype,defvar,do-all-symbols,do-external-symbols,do-symbols,dolist,dotimes,ecase,etypecase,eval-when,labels,macrolet,multiple-value-bind,multiple-value-call,multiple-value-prog1,multiple-value-setq,prog1,progv,typecase,unless,unwind-protect,when,with-input-from-string,with-open-file,with-open-stream,with-output-to-string,with-package-iterator,define-condition,handler-bind,handler-case,restart-bind,restart-case,with-simple-restart,store-value,use-value,muffle-warning,abort,continue,with-slots,with-slots*,with-accessors,with-accessors*,defclass,defmethod,print-unreadable-object"))

;; The following are actual variables for the options:

(atom! Bytes   p_ambw)      ;; 'ambiwidth'
(atom! Bytes   p_bs)        ;; 'backspace'
(atom! Bytes   p_bg)        ;; 'background'
(atom! Bytes   p_breakat)   ;; 'breakat'
(atom! Bytes   p_cedit)     ;; 'cedit'
(atom! long    p_cwh)       ;; 'cmdwinheight'
(atom! Bytes   p_cb)        ;; 'clipboard'
(atom! long    p_ch)        ;; 'cmdheight'
(atom! Bytes   p_cpo)       ;; 'cpoptions'
(atom! boolean p_deco)      ;; 'delcombine'
(atom! boolean p_dg)        ;; 'digraph'
(atom! Bytes   p_dy)        ;; 'display'

(final int
    DY_LASTLINE 0x001,
    DY_UHEX     0x002)
(atom! int    dy_flags)
(final Bytes* p_dy_values [ (u8 "lastline"), (u8 "uhex"), null ])

(atom! Bytes   p_ead)       ;; 'eadirection'
(atom! boolean p_ea)        ;; 'equalalways'
(atom! boolean p_eb)        ;; 'errorbells'
(atom! boolean p_ek)        ;; 'esckeys'
(atom! boolean p_fs)        ;; 'fsync'
(atom! boolean p_gd)        ;; 'gdefault'
(atom! boolean p_prompt)    ;; 'prompt'
(atom! Bytes   p_hl)        ;; 'highlight'
(atom! boolean p_hls)       ;; 'hlsearch'
(atom! long    p_hi)        ;; 'history'
(atom! boolean p_ic)        ;; 'ignorecase'
(atom! boolean p_is)        ;; 'incsearch'
(atom! boolean p_im)        ;; 'insertmode'
(atom! Bytes   p_isf)       ;; 'isfname'
(atom! Bytes   p_isi)       ;; 'isident'
(atom! Bytes   p_isp)       ;; 'isprint'
(atom! boolean p_js)        ;; 'joinspaces'
(atom! Bytes   p_kp)        ;; 'keywordprg'
(atom! Bytes   p_km)        ;; 'keymodel'
(atom! Bytes   p_lispwords) ;; 'lispwords'
(atom! long    p_ls)        ;; 'laststatus'
(atom! Bytes   p_lcs)       ;; 'listchars'
(atom! boolean p_lz)        ;; 'lazyredraw'
(atom! boolean p_magic)     ;; 'magic'
(atom! long    p_mat)       ;; 'matchtime'
(atom! long    p_mco)       ;; 'maxcombine'
(atom! long    p_mmd)       ;; 'maxmapdepth'
(atom! long    p_mmp)       ;; 'maxmempattern'
(atom! Bytes   p_mouse)     ;; 'mouse'
(atom! Bytes   p_mousem)    ;; 'mousemodel'
(atom! long    p_mouset)    ;; 'mousetime'
(atom! boolean p_more)      ;; 'more'
(atom! Bytes   p_opfunc)    ;; 'operatorfunc'
(atom! Bytes   p_para)      ;; 'paragraphs'
(atom! boolean p_paste)     ;; 'paste'
(atom! Bytes   p_pt)        ;; 'pastetoggle'
(atom! long    p_rdt)       ;; 'redrawtime'
(atom! boolean p_remap)     ;; 'remap'
(atom! long    p_re)        ;; 'regexpengine'
(atom! long    p_report)    ;; 'report'
(atom! boolean p_ari)       ;; 'allowrevins'
(atom! boolean p_ri)        ;; 'revins'
(atom! boolean p_ru)        ;; 'ruler'
(atom! long    p_sj)        ;; 'scrolljump'
(atom! long    p_so)        ;; 'scrolloff'
(atom! Bytes   p_sbo)       ;; 'scrollopt'
(atom! Bytes   p_sections)  ;; 'sections'
(atom! Bytes   p_sel)       ;; 'selection'
(atom! Bytes   p_slm)       ;; 'selectmode'
(atom! boolean p_sr)        ;; 'shiftround'
(atom! Bytes   p_shm)       ;; 'shortmess'
(atom! Bytes   p_sbr)       ;; 'showbreak'
(atom! boolean p_sc)        ;; 'showcmd'
(atom! boolean p_sm)        ;; 'showmatch'
(atom! boolean p_smd)       ;; 'showmode'
(atom! long    p_ss)        ;; 'sidescroll'
(atom! long    p_siso)      ;; 'sidescrolloff'
(atom! boolean p_scs)       ;; 'smartcase'
(atom! boolean p_sta)       ;; 'smarttab'
(atom! boolean p_sb)        ;; 'splitbelow'
(atom! Bytes   p_tal)       ;; 'tabline'
(atom! boolean p_spr)       ;; 'splitright'
(atom! boolean p_sol)       ;; 'startofline'
(atom! boolean p_terse)     ;; 'terse'
(atom! boolean p_to)        ;; 'tildeop'
(atom! boolean p_timeout)   ;; 'timeout'
(atom! long    p_tm)        ;; 'timeoutlen'
(atom! boolean p_ttimeout)  ;; 'ttimeout'
(atom! long    p_ttm)       ;; 'ttimeoutlen'
(atom! boolean p_tf)        ;; 'ttyfast'
(atom! long    p_ttyscroll) ;; 'ttyscroll'
(atom! Bytes   p_ttym)      ;; 'ttymouse'

(final int
    TTYM_XTERM  0x01,
    TTYM_XTERM2 0x02)
(atom! int    ttym_flags)
(final Bytes* p_ttym_values [ (u8 "xterm"), (u8 "xterm2"), null ])

(atom! long    p_ul)        ;; 'undolevels'
(atom! long    p_ut)        ;; 'updatetime'
(atom! Bytes   p_fcs)       ;; 'fillchar'
(atom! boolean p_vb)        ;; 'visualbell'
(atom! Bytes   p_ve)        ;; 'virtualedit'

(final int
    VE_BLOCK   5,       ;; includes "all"
    VE_INSERT  6,       ;; includes "all"
    VE_ALL     4,
    VE_ONEMORE 8)
(atom! int    ve_flags)
(final Bytes* p_ve_values [ (u8 "block"), (u8 "insert"), (u8 "all"), (u8 "onemore"), null ])

(atom! long    p_verbose)   ;; 'verbose'
(atom! long    p_window)    ;; 'window'
(atom! Bytes   p_ww)        ;; 'whichwrap'
(atom! long    p_wc)        ;; 'wildchar'
(atom! long    p_wh)        ;; 'winheight'
(atom! long    p_wmh)       ;; 'winminheight'
(atom! long    p_wmw)       ;; 'winminwidth'
(atom! long    p_wiw)       ;; 'winwidth'
(atom! boolean p_ws)        ;; 'wrapscan'
(atom! long    p_wd)        ;; 'writedelay'

;; "indir" values for buffer-local opions.

(final int
    BV_AI     0,
    BV_BIN    2,
    BV_CI     5,
    BV_CIN    6,
    BV_CINK   7,
    BV_CINO   8,
    BV_CINW   9,
    BV_CM    10,
    BV_COM   11,
    BV_ET    14,
    BV_FLP   18,
    BV_FO    19,
    BV_INF   25,
    BV_ISK   26,
    BV_KP    27,
    BV_LISP  28,
    BV_LW    29,
    BV_MA    30,
    BV_MOD   31,
    BV_MPS   32,
    BV_NF    33,
    BV_PI    34,
    BV_QE    35,
    BV_RO    36,
    BV_SI    37,
    BV_STS   40,
    BV_SW    41,
    BV_TS    42,
    BV_TW    43,
    BV_UL    46,
    BV_WM    47)

;; "indir" values for window-local options.

(final int
    WV_LIST    0,
    WV_COCU    1,
    WV_COLE    2,
    WV_CRBIND  3,
    WV_BRI     4,
    WV_BRIOPT  5,
    WV_LBR     6,
    WV_NU      7,
    WV_RNU     8,
    WV_NUW     9,
    WV_RL     10,
    WV_RLC    11,
    WV_SCBIND 12,
    WV_SCROLL 13,
    WV_CUC    14,
    WV_CUL    15,
    WV_CC     16,
    WV_WFH    18,
    WV_WFW    19,
    WV_WRAP   20)

;; Value for "b_p_ul" indicating the global value must be used.
(final int NO_LOCAL_UNDOLEVEL -123456)

;; ----------------------------------------------------------------------- ;;

;; position in file or buffer

(class! #_final pos_C
    [
        (field long     lnum)       ;; line number
        (field int      col)        ;; column number
        (field int      coladd)
    ])

(final pos_C NOPOS (§_pos_C))

(defn- #_pos_C new_pos [#_long lnum, #_int col, #_int coladd]
    (§
;       pos_C p = §_pos_C();
;       p.lnum = lnum;
;       p.col = col;
;       p.coladd = coladd;
;       return p;
    ))

(defn- #_void COPY_pos [#_pos_C p1, #_pos_C p0]
    (§
;       p1.lnum = p0.lnum;
;       p1.col = p0.col;
;       p1.coladd = p0.coladd;
    ))

(defn- #_pos_C* ARRAY_pos [#_int n]
    (vec (repeatedly n §_pos_C)))

;; Same, but without coladd.

(class! #_final lpos_C
    [
        (field long     lnum)       ;; line number
        (field int      col)        ;; column number
    ])

(defn- #_void MIN1_lpos [#_lpos_C lp]
    (§
;       lp.lnum = -1;
;       lp.col = -1;
    ))

(defn- #_void COPY_lpos [#_lpos_C lp1, #_lpos_C lp0]
    (§
;       lp1.lnum = lp0.lnum;
;       lp1.col = lp0.col;
    ))

(defn- #_lpos_C* ARRAY_lpos [#_int n]
    (vec (repeatedly n §_lpos_C)))

(defn- #_void COPY__lpos [#_lpos_C* a1, #_lpos_C* a0, #_int n]
    (§
;       for (int i = 0; i < n; i++)
;           COPY_lpos(a1[i], a0[i]);
    ))

;; ----------------------------------------------------------------------- ;;

;; The number of sub-matches is limited to 10.
;; The first one (index 0) is the whole match, referenced with "\0".
;; The second one (index 1) is the first sub-match, referenced with "\1".
;; This goes up to the tenth (index 9), referenced with "\9".

(final int NSUBEXP  10)

;; In the NFA engine: how many braces are allowed.

(final int NFA_MAX_BRACES 20)

;; In the NFA engine: how many states are allowed.

(final int NFA_MAX_STATES 100000)
(final int NFA_TOO_EXPENSIVE -1)

;; Which regexp engine to use? Needed for vim_regcomp().
;; Must match with 'regexpengine'.

(final int AUTOMATIC_ENGINE    0)
(final int BACKTRACKING_ENGINE 1)
(final int NFA_ENGINE          2)

;; Structure returned by vim_regcomp() to pass on to vim_regexec().
;; This is the general structure.  For the actual matcher, two specific
;; structures are used.  See code below.

(§
;   static abstract class regprog_C
    (§
;       regengine_C         engine;
;       int                 regflags;
;       int                 re_engine;      ;; automatic, backtracking or nfa engine
;       int                 re_flags;       ;; second argument for vim_regcomp()

;       protected regprog_C()
;       {
;       }
    ))

;; Structure used by the back track matcher.
;; These fields are only to be used in regexp.c!
;; See regexp.c for an explanation.

(§
;   static final class bt_regprog_C extends regprog_C
    (§
;       int                 reganch;
;       int                 regstart;
;       Bytes               regmust;
;       int                 regmlen;
;       int                 reghasz;
;       Bytes               program;
    ))

;; Structure representing a NFA state.
;; A NFA state may have no outgoing edge, when it is a NFA_MATCH state.

(declare §_fragnode_C)

(class! #_final nfa_state_C
    [
        (field int          c)
        (field fragnode_C   out0        (§_fragnode_C))
        (field fragnode_C   out1        (§_fragnode_C))
        (field int          id)
        (field int*         lastlist    2)  ;; 0: normal, 1: recursive
        (field int          val)

;       #_private void out0(nfa_state_C out0)
;       {
;           this.out0.fn_next = out0;
;       }

;       #_private void out1(nfa_state_C out1)
;       {
;           this.out1.fn_next = out1;
;       }

;       #_private nfa_state_C out0()
;       {
;           return (nfa_state_C)out0.fn_next;
;       }

;       #_private nfa_state_C out1()
;       {
;           return (nfa_state_C)out1.fn_next;
;       }
    ])

;; Structure used by the NFA matcher.

(§
;   static final class nfa_regprog_C extends regprog_C
    (§
;       nfa_state_C         start;          ;; points into state[]

;       int                 reganch;        ;; pattern starts with ^
;       int                 regstart;       ;; char at start of pattern
;       Bytes               match_text;     ;; plain text to match with

;       boolean             has_zend;       ;; pattern contains \ze
;       boolean             has_backref;    ;; pattern contains \1 .. \9
;       int                 reghasz;
;       Bytes               pattern;
;       int                 nsubexp;        ;; number of ()

;       int                 nstate;         ;; states.length
;       nfa_state_C[]       states;
;       int                 istate;         ;; index in states == number of states allocated
    ))

;; Structure to be used for single-line matching.
;; Sub-match "no" starts at "startp[no]" and ends just before "endp[no]".
;; When there is no match, the pointer is null.

(class! #_final regmatch_C
    [
        (field regprog_C    regprog)
        (field Bytes*       startp      NSUBEXP)
        (field Bytes*       endp        NSUBEXP)
        (field boolean      rm_ic)
    ])

;; Structure to be used for multi-line matching.
;; Sub-match "no" starts in line "startpos[no].lnum" column "startpos[no].col"
;; and ends in line "endpos[no].lnum" just before column "endpos[no].col".
;; The line numbers are relative to the first line, thus startpos[0].lnum is always 0.
;; When there is no match, the line number is -1.

(class! #_final regmmatch_C
    [
        (field regprog_C    regprog)
        (field lpos_C*      startpos    (ARRAY_lpos NSUBEXP))
        (field lpos_C*      endpos      (ARRAY_lpos NSUBEXP))
        (field boolean      rmm_ic)
        (field int          rmm_maxcol)     ;; when not zero: maximum column
    ])

(defn- #_void COPY_regmmatch [#_regmmatch_C rmm1, #_regmmatch_C rmm0]
    (§
;       rmm1.regprog = rmm0.regprog;
;       COPY__lpos(rmm1.startpos, rmm0.startpos, NSUBEXP);
;       COPY__lpos(rmm1.endpos, rmm0.endpos, NSUBEXP);
;       rmm1.rmm_ic = rmm0.rmm_ic;
;       rmm1.rmm_maxcol = rmm0.rmm_maxcol;
    ))

;; Structure used to store external references: "\z\(\)" to "\z\1".
;; Use a reference count to avoid the need to copy this around.
;; When it goes from 1 to zero the matches need to be freed.

(class! #_final reg_extmatch_C
    [
        (field short        refcnt)
        (field Bytes*       matches     NSUBEXP)
    ])

(§
;   static abstract class regengine_C
    (§
;       Bytes expr = u8("");

;       protected regengine_C()
;       {
;       }

;       public abstract regprog_C regcomp(Bytes expr, int re_flags);
;       public abstract long regexec_nl(regmatch_C rmp, Bytes line, int col, boolean line_lbr);
;       public abstract long regexec_multi(regmmatch_C rmp, window_C win, buffer_C buf, long lnum, int col, timeval_C tm);
    ))

;; ----------------------------------------------------------------------- ;;

;; marks: positions in a file
;; (a normal mark is a lnum/col pair, the same as a file position)

(final int NMARKS (inc (- (int \z) (int \a))))  ;; max. # of named marks
(final int JUMPLISTSIZE 100)        ;; max. # of marks in jump list

(class! #_final fmark_C
    [
        (field pos_C    mark    (§_pos_C))      ;; cursor position
        (field int      fnum)                   ;; file number
    ])

(defn- #_void COPY_fmark [#_fmark_C fm1, #_fmark_C fm0]
    (§
;       COPY_pos(fm1.mark, fm0.mark);
;       fm1.fnum = fm0.fnum;
    ))

;; Xtended file mark: also has a file name.
(class! #_final xfmark_C
    [
        (field fmark_C  fmark   (§_fmark_C))
        (field Bytes    fname)                  ;; file name, used when fnum == 0
    ])

(defn- #_void COPY_xfmark [#_xfmark_C xfm1, #_xfmark_C xfm0]
    (§
;       COPY_fmark(xfm1.fmark, xfm0.fmark);
;       xfm1.fname = xfm0.fname;
    ))

(defn- #_xfmark_C* ARRAY_xfmark [#_int n]
    (vec (repeatedly n §_xfmark_C)))

;; Structure that contains all options that are local to a window.
;; Used twice in a window: for the current buffer and for all buffers.
;; Also used in wininfo_C.

(class! #_final winopt_C
    [
        (atom' boolean wo_bri)      ;; 'breakindent'
        (atom' Bytes   wo_briopt)   ;; 'breakindentopt'
        (atom' boolean wo_lbr)      ;; 'linebreak'
        (atom' boolean wo_list)     ;; 'list'
        (atom' boolean wo_nu)       ;; 'number'
        (atom' boolean wo_rnu)      ;; 'relativenumber'
        (atom' long    wo_nuw)      ;; 'numberwidth'
        (atom' boolean wo_wfh)      ;; 'winfixheight'
        (atom' boolean wo_wfw)      ;; 'winfixwidth'
        (atom' boolean wo_rl)       ;; 'rightleft'
        (atom' Bytes   wo_rlc)      ;; 'rightleftcmd'
        (atom' long    wo_scr)      ;; 'scroll'
        (atom' boolean wo_cuc)      ;; 'cursorcolumn'
        (atom' boolean wo_cul)      ;; 'cursorline'
        (atom' Bytes   wo_cc)       ;; 'colorcolumn'
        (atom' boolean wo_scb)      ;; 'scrollbind'
        (atom' boolean wo_wrap)     ;; 'wrap'
        (atom' Bytes   wo_cocu)     ;; 'concealcursor'
        (atom' long    wo_cole)     ;; 'conceallevel'
        (atom' boolean wo_crb)      ;; 'cursorbind'
    ])

;; Window info stored with a buffer.
;;
;; Two types of info are kept for a buffer which are associated with a specific window:
;; 1. Each window can have a different line number associated with a buffer.
;; 2. The window-local options for a buffer work in a similar way.
;; The window-info is kept in a list at b_wininfo.  It is kept in most-recently-used order.

(class! #_final wininfo_C
    [
        (field wininfo_C    wi_next)                    ;; next entry or null for last entry
        (field wininfo_C    wi_prev)                    ;; previous entry or null for first entry
        (field window_C     wi_win)                     ;; pointer to window that did set wi_fpos
        (field pos_C        wi_fpos     (§_pos_C))      ;; last cursor position in the file
        (field boolean      wi_optset)                  ;; true when wi_opt has useful values
        (field winopt_C     wi_opt      (§_winopt_C))   ;; local window options
    ])

;; Structure to store info about the Visual area.
(class! #_final visualinfo_C
    [
        (field pos_C        vi_start    (§_pos_C))      ;; start pos of last VIsual
        (field pos_C        vi_end      (§_pos_C))      ;; end position of last VIsual
        (field int          vi_mode)                    ;; VIsual_mode of last VIsual
        (field int          vi_curswant)                ;; MAXCOL from w_curswant
    ])

(defn- #_void COPY_visualinfo [#_visualinfo_C vi1, #_visualinfo_C vi0]
    (§
;       COPY_pos(vi1.vi_start, vi0.vi_start);
;       COPY_pos(vi1.vi_end, vi0.vi_end);
;       vi1.vi_mode = vi0.vi_mode;
;       vi1.vi_curswant = vi0.vi_curswant;
    ))

;; structures used for undo

(class! #_final u_entry_C
    [
        (field u_entry_C    ue_next)        ;; pointer to next entry in list
        (field long         ue_top)         ;; number of line above undo block
        (field long         ue_bot)         ;; number of line below undo block
        (field long         ue_lcount)      ;; linecount when u_save() called
        (field Bytes*       ue_array)       ;; array of lines in undo block
        (field long         ue_size)        ;; number of lines in "ue_array"
    ])

(class! #_final u_link_C
    [
        (field u_header_C   ptr)
        (field long         seq)
    ])

(class! #_final u_header_C
    [
        ;; The following have a pointer and a number.
        ;; The number is used when reading the undo file in u_read_undo().
        (field u_link_C     uh_next         (§_u_link_C))       ;; next undo header in list
        (field u_link_C     uh_prev         (§_u_link_C))       ;; previous header in list
        (field u_link_C     uh_alt_next     (§_u_link_C))       ;; next header for alt. redo
        (field u_link_C     uh_alt_prev     (§_u_link_C))       ;; previous header for alt. redo
        (field long         uh_seq)                             ;; sequence number, higher == newer undo
        (field int          uh_walk)                            ;; used by undo_time()
        (field u_entry_C    uh_entry)                           ;; pointer to first entry
        (field u_entry_C    uh_getbot_entry)                    ;; pointer to where ue_bot must be set
        (field pos_C        uh_cursor       (§_pos_C))          ;; cursor position before saving
        (field long         uh_cursor_vcol)
        (field int          uh_flags)                           ;; see below
        (field pos_C*       uh_namedm       (ARRAY_pos NMARKS)) ;; marks before undo/after redo
        (field visualinfo_C uh_visual       (§_visualinfo_C))   ;; Visual areas before undo/after redo
        (field long         uh_time)                            ;; timestamp when the change was made
        (field long         uh_save_nr)                         ;; set when the file was saved after changes in this block
    ])

;; values for uh_flags
(final int UH_CHANGED  0x01)            ;; "b_changed" flag before undo/after redo
(final int UH_EMPTYBUF 0x02)            ;; buffer was empty

;; mf_hashtab_C is a chained hashtable with blocknr_C key and arbitrary
;; structures as items.  This is an intrusive data structure: we require
;; that items begin with mf_hashitem_C which contains the key and linked
;; list pointers.  List of items in each bucket is doubly-linked.

(class! #_final mf_hashitem_C
    [
        (field mf_hashitem_C    mhi_next)
        (field mf_hashitem_C    mhi_prev)
        (field long             mhi_key)
        (field Object           mhi_data)
    ])

(defn- #_mf_hashitem_C* ARRAY_mf_hashitem [#_int n]
    (vec (repeatedly n §_mf_hashitem_C)))

(final int MHT_INIT_SIZE 64)

(class! #_final mf_hashtab_C
    [
        (field int              mht_mask)       ;; mask used for hash value (nr of items in array is "mht_mask" + 1)
        (field int              mht_count)      ;; number of items inserted into hashtable
        (field mf_hashitem_C*   mht_buckets)
    ])

(defn- #_void ZER0_mf_hashtab [#_mf_hashtab_C mht]
    (§
;       mht.mht_mask = 0;
;       mht.mht_count = 0;
;       mht.mht_buckets = null;
    ))

;; For each (previously) used block in the memfile there is one block header.
;;
;; The block may be linked in the used list OR in the free list.
;; The used blocks are also kept in hash lists.
;;
;; The used list is a doubly linked list, most recently used block first.
;;      The blocks in the used list have a block of memory allocated.
;; The hash lists are used to quickly find a block in the used list.
;; The free list is a single linked list, not sorted.
;;      The blocks in the free list have no block of memory allocated and
;;      the contents of the block in the file (if any) is irrelevant.

;; 'bh_flags':
(final byte
    BH_DIRTY    1,
    BH_LOCKED   2)

(class! #_final block_hdr_C
    [
        (field mf_hashitem_C bh_hashitem    (§_mf_hashitem_C))  ;; header for hash table and key

        (field block_hdr_C  bh_next)            ;; next block_hdr in free or used list
        (field block_hdr_C  bh_prev)            ;; previous block_hdr in used list
        (field Object       bh_data)            ;; pointer to memory (for used block)
        (field int          bh_page_count)      ;; number of pages in this block

        (field byte         bh_flags)           ;; BH_DIRTY or BH_LOCKED

;       #_private block_hdr_C()
;       {
;           bh_hashitem.mhi_data = this;
;       }

;       long bh_bnum()
;       {
;           return bh_hashitem.mhi_key; ;; block number, part of bh_hashitem
;       }

;       void bh_bnum(long bnum)
;       {
;           bh_hashitem.mhi_key = bnum;
;       }
    ])

;; When a block with a negative number is flushed to the file, it gets a positive number.
;; Because the reference to the block is still the negative number,
;; we remember the translation to the new positive number in the double linked trans lists.
;; The structure is the same as the hash lists.

(class! #_final nr_trans_C
    [
        (field mf_hashitem_C nt_hashitem    (§_mf_hashitem_C))  ;; header for hash table and key

        (field long         nt_new_bnum)    ;; new (positive) number

;       #_private nr_trans_C()
;       {
;           nt_hashitem.mhi_data = this;
;       }

;       void nt_old_bnum(long bnum)
;       {
;           nt_hashitem.mhi_key = bnum;     ;; old (negative) number
;       }
    ])

;; structure used to store one block of the stuff/redo/recording buffers

(class! #_final buffblock_C
    [
        (field buffblock_C  bb_next)        ;; pointer to next buffblock
        (field Bytes        bb_str)         ;; contents
    ])

(defn- #_void COPY_buffblock [#_buffblock_C bb1, #_buffblock_C bb0]
    (§
;       bb1.bb_next = bb0.bb_next;
;       bb1.bb_str = bb0.bb_str;
    ))

;; header used for the stuff buffer and the redo buffer

(class! #_final buffheader_C
    [
        (field buffblock_C  bh_first    (§_buffblock_C))    ;; first (dummy) block of list
        (field buffblock_C  bh_curr)        ;; buffblock for appending
        (field int          bh_index)       ;; index for reading
        (field int          bh_space)       ;; space in bh_curr for appending
    ])

(defn- #_void COPY_buffheader [#_buffheader_C bh1, #_buffheader_C bh0]
    (§
;       COPY_buffblock(bh1.bh_first, bh0.bh_first);
;       bh1.bh_curr = bh0.bh_curr;
;       bh1.bh_index = bh0.bh_index;
;       bh1.bh_space = bh0.bh_space;
    ))

;; Command modifiers ":vertical" and ":hide" set a flag.
;; This needs to be saved for recursive commands, put them in a structure for easy manipulation.

(class! #_final cmdmod_C
    [
        (field boolean      hide)               ;; true when ":hide" was used
        (field int          split)              ;; flags for win_split()
        (field boolean      keepalt)            ;; true when ":keepalt" was used
        (field boolean      keepmarks)          ;; true when ":keepmarks" was used
        (field boolean      keepjumps)          ;; true when ":keepjumps" was used
        (field boolean      lockmarks)          ;; true when ":lockmarks" was used
        (field boolean      keeppatterns)       ;; true when ":keeppatterns" was used
    ])

(defn- #_void ZER0_cmdmod [#_cmdmod_C cm]
    (§
;       cm.hide = false;
;       cm.split = 0;
;       cm.keepalt = false;
;       cm.keepmarks = false;
;       cm.keepjumps = false;
;       cm.lockmarks = false;
;       cm.keeppatterns = false;
    ))

(defn- #_void COPY_cmdmod [#_cmdmod_C cm1, #_cmdmod_C cm0]
    (§
;       cm1.hide = cm0.hide;
;       cm1.split = cm0.split;
;       cm1.keepalt = cm0.keepalt;
;       cm1.keepmarks = cm0.keepmarks;
;       cm1.keepjumps = cm0.keepjumps;
;       cm1.lockmarks = cm0.lockmarks;
;       cm1.keeppatterns = cm0.keeppatterns;
    ))

(class! #_final memfile_C
    [
        (field block_hdr_C  mf_used_first)      ;; mru block_hdr in used list
        (field block_hdr_C  mf_used_last)       ;; lru block_hdr in used list
        (field mf_hashtab_C mf_hash         (§_mf_hashtab_C))   ;; hash lists
        (field mf_hashtab_C mf_trans        (§_mf_hashtab_C))   ;; trans lists
        (field long         mf_blocknr_max)     ;; highest positive block number + 1
        (field long         mf_blocknr_min)     ;; lowest negative block number - 1
        (field long         mf_neg_count)       ;; number of negative blocks numbers
    ])

;; things used in memline.c

;; When searching for a specific line, we remember what blocks in the tree
;; are the branches leading to that block.  This is stored in ml_stack.  Each
;; entry is a pointer to info in a block (may be data block or pointer block)

(class! #_final infoptr_C
    [
        (field long         ip_bnum)            ;; block number
        (field long         ip_low)             ;; lowest lnum in this block
        (field long         ip_high)            ;; highest lnum in this block
        (field int          ip_index)           ;; index for block with current lnum
    ])

(defn- #_void COPY_infoptr [#_infoptr_C ip1, #_infoptr_C ip0]
    (§
;       ip1.ip_bnum = ip0.ip_bnum;
;       ip1.ip_low = ip0.ip_low;
;       ip1.ip_high = ip0.ip_high;
;       ip1.ip_index = ip0.ip_index;
    ))

(defn- #_infoptr_C* ARRAY_infoptr [#_int n]
    (vec (repeatedly n §_infoptr_C)))

(class! #_final chunksize_C
    [
        (field int      mlcs_numlines)
        (field long     mlcs_totalsize)
    ])

(defn- #_void COPY_chunksize [#_chunksize_C cs1, #_chunksize_C cs0]
    (§
;       cs1.mlcs_numlines = cs0.mlcs_numlines;
;       cs1.mlcs_totalsize = cs0.mlcs_totalsize;
    ))

(defn- #_chunksize_C* ARRAY_chunksize [#_int n]
    (vec (repeatedly n §_chunksize_C)))

;; Flags when calling ml_updatechunk().
(final int ML_CHNK_ADDLINE 1)
(final int ML_CHNK_DELLINE 2)
(final int ML_CHNK_UPDLINE 3)

;; 'ml_flags':
(final int ML_EMPTY        1)   ;; empty buffer
(final int ML_LINE_DIRTY   2)   ;; cached line was changed and allocated
(final int ML_LOCKED_DIRTY 4)   ;; ml_locked was changed
(final int ML_LOCKED_POS   8)   ;; ml_locked needs positive block number

;; The memline structure holds all the information about a memline.

(class! #_final memline_C
    [
        (field long         ml_line_count)      ;; number of lines in the buffer

        (field memfile_C    ml_mfp)             ;; pointer to associated memfile

        (field int          ml_flags)

        (field infoptr_C*   ml_stack)           ;; stack of pointer blocks (array of IPTRs)
        (field int          ml_stack_top)       ;; current top in ml_stack
        (field int          ml_stack_size)      ;; total number of entries in ml_stack

        (field long         ml_line_lnum)       ;; line number of cached line, 0 if not valid
        (field Bytes        ml_line_ptr)        ;; pointer to cached line

        (field block_hdr_C  ml_locked)          ;; block used by last ml_get()
        (field long         ml_locked_low)      ;; first line in ml_locked
        (field long         ml_locked_high)     ;; last line in ml_locked
        (field int          ml_locked_lineadd)  ;; number of lines inserted in ml_locked

        (field chunksize_C* ml_chunksize)
        (field int          ml_numchunks)
        (field int          ml_usedchunks)
    ])

;; What's pending for being reactivated at the ":endtry" of this try conditional:

(final byte
    CSTP_NONE       0,    ;; nothing pending in ":finally" clause
    CSTP_ERROR      1,    ;; an error is pending
    CSTP_INTERRUPT  2,    ;; an interrupt is pending
    CSTP_THROW      4)    ;; a throw is pending

;; A list of error messages that can be converted to an exception.  "throw_msg"
;; is only set in the first element of the list.  Usually, it points to the
;; original message stored in that element, but sometimes it points to a later
;; message in the list.  See cause_errthrow() below.

(class! #_final msglist_C
    [
        (field Bytes        msg)            ;; original message
        (field Bytes        throw_msg)      ;; "msg" to throw: usually original one
        (field msglist_C    next)           ;; next of several messages in a row
    ])

;; Structure describing an exception.
;; (don't use "struct exception", it's used by the math library).

(class! #_final except_C
    [
        (field int          type)           ;; exception type
        (field Bytes        value)          ;; exception value
        (field msglist_C    messages)       ;; message(s) causing error exception
        (field except_C     caught)         ;; next exception on the caught stack
    ])

;; The exception types.

(final int
    ET_USER      0,       ;; exception caused by ":throw" command
    ET_ERROR     1,       ;; error exception
    ET_INTERRUPT 2)       ;; interrupt exception triggered by Ctrl-C

;; Structure to save the error/interrupt/exception state between calls to
;; enter_cleanup() and leave_cleanup().  Must be allocated as an automatic
;; variable by the (common) caller of these functions.

(class! #_final cleanup_C
    [
        (field int          pending)        ;; error/interrupt/exception state
        (field except_C     exception)      ;; exception value
    ])

;; Structure shared between syntax.c and screen.c.

(class! #_final attrentry_C
    [
        (field int          ae_attr)            ;; HL_BOLD, etc.
        (field Bytes        ae_esc_start)       ;; start escape sequence
        (field Bytes        ae_esc_stop)        ;; stop escape sequence
    ;; These colors need to be > 8 bits to hold 256.
        (field int          ae_fg_color)        ;; foreground color number
        (field int          ae_bg_color)        ;; background color number
    ])

(defn- #_void ZER0_attrentry [#_attrentry_C ae]
    (§
;       ae.ae_attr = 0;
;       ae.ae_esc_start = null;
;       ae.ae_esc_stop = null;
;       ae.ae_fg_color = 0;
;       ae.ae_bg_color = 0;
    ))

(defn- #_void COPY_attrentry [#_attrentry_C ae1, #_attrentry_C ae0]
    (§
;       ae1.ae_attr = ae0.ae_attr;
;       ae1.ae_esc_start = ae0.ae_esc_start;
;       ae1.ae_esc_stop = ae0.ae_esc_stop;
;       ae1.ae_fg_color = ae0.ae_fg_color;
;       ae1.ae_bg_color = ae0.ae_bg_color;
    ))

;; Used for the typeahead buffer: typebuf.

(class! #_final typebuf_C
    [
        (field Bytes        tb_buf)             ;; buffer for typed characters
        (field Bytes        tb_noremap)         ;; mapping flags for characters in "tb_buf"
        (field int          tb_buflen)          ;; size of "tb_buf"
        (field int          tb_off)             ;; current position in "tb_buf"
        (field int          tb_len)             ;; number of valid bytes in "tb_buf"
        (field int          tb_maplen)          ;; nr of mapped bytes in "tb_buf"
        (field int          tb_silent)          ;; nr of silently mapped bytes in "tb_buf"
        (field int          tb_no_abbr_cnt)     ;; nr of bytes without abbrev. in "tb_buf"
        (field int          tb_change_cnt)      ;; nr of time "tb_buf" was changed; never zero
    ])

(defn- #_void COPY_typebuf [#_typebuf_C tb1, #_typebuf_C tb0]
    (§
;       tb1.tb_buf = tb0.tb_buf;
;       tb1.tb_noremap = tb0.tb_noremap;
;       tb1.tb_buflen = tb0.tb_buflen;
;       tb1.tb_off = tb0.tb_off;
;       tb1.tb_len = tb0.tb_len;
;       tb1.tb_maplen = tb0.tb_maplen;
;       tb1.tb_silent = tb0.tb_silent;
;       tb1.tb_no_abbr_cnt = tb0.tb_no_abbr_cnt;
;       tb1.tb_change_cnt = tb0.tb_change_cnt;
    ))

(defn- #_typebuf_C* ARRAY_typebuf [#_int n]
    (vec (repeatedly n §_typebuf_C)))

;; Struct to hold the saved typeahead for save_typeahead().
(class! #_final tasave_C
    [
        (field int          old_char)
        (field int          old_mod_mask)
        (field buffheader_C save_readbuf1)
        (field buffheader_C save_readbuf2)
        (field Bytes        save_inputbuf)
        (field int          save_inputlen)
    ])

(defn- #_tasave_C new_tasave []
    (§
;       tasave_C tasp = §_tasave_C();
;       tasp.save_readbuf1 = §_buffheader_C();
;       tasp.save_readbuf2 = §_buffheader_C();
;       return tasp;
    ))

;; Structure used for mappings and abbreviations.

(class! #_final mapblock_C
    [
        (field mapblock_C   m_next)         ;; next mapblock in list
        (field Bytes        m_keys)         ;; mapped from, lhs
        (field Bytes        m_str)          ;; mapped to, rhs
        (field Bytes        m_orig_str)     ;; rhs as entered by the user
        (field int          m_keylen)       ;; STRLEN(m_keys)
        (field int          m_mode)         ;; valid mode
        (field int          m_noremap)      ;; if non-zero no re-mapping for "m_str"
        (field boolean      m_silent)       ;; <silent> used, don't echo commands
        (field boolean      m_nowait)       ;; <nowait> used
        (field boolean      m_expr)         ;; <expr> used, "m_str" is an expression
    ])

;; Used for highlighting in the status line.

(class! #_final stl_hlrec_C
    [
        (field Bytes        start)
        (field int          userhl)         ;; 0: no HL, 1-9: User HL, < 0 for syn ID
    ])

(defn- #_stl_hlrec_C* ARRAY_stl_hlrec [#_int n]
    (vec (repeatedly n §_stl_hlrec_C)))

;; buffer: structure that holds information about one file
;;
;; Several windows can share a single Buffer.
;; A buffer is unallocated if there is no memfile for it.
;; A buffer is new if the associated file has never been loaded yet.

(class! #_final buffer_C
    [
        (field memline_C    b_ml)               ;; associated memline (also contains line count)

        (field buffer_C     b_next)             ;; links in list of buffers
        (field buffer_C     b_prev)

        (field int          b_nwindows)         ;; nr of windows open on this buffer

        (field int          b_flags)            ;; various BF_ flags
        (field boolean      b_closing)          ;; buffer is being closed, don't let autocommands close it too

        (field int          b_fnum)             ;; buffer number for this file.

        (atom' boolean      b_changed)          ;; 'modified': Set to true if something in the
                                                ;; file has been changed and not written out.
        (field int          b_changedtick)      ;; incremented for each change, also for undo

        (field boolean      b_saving)           ;; Set to true if we are in the middle of saving the buffer.

        ;; Changes to a buffer require updating of the display.
        ;; To minimize the work, remember changes made and update everything at once.

        (field boolean      b_mod_set)          ;; true when there are changes since the
                                                ;; last time the display was updated
        (field long         b_mod_top)          ;; topmost lnum that was changed
        (field long         b_mod_bot)          ;; lnum below last changed line, AFTER the change
        (field long         b_mod_xlines)       ;; number of extra buffer lines inserted;
                                                ;; negative when lines were deleted

        (field wininfo_C    b_wininfo)          ;; list of last used info for each window

        (field long         b_mtime)            ;; last change time of original file
        (field long         b_mtime_read)       ;; last change time when reading
        (field long         b_orig_size)        ;; size of original file in bytes
        (field int          b_orig_mode)        ;; mode of original file

        (field pos_C*       b_namedm)           ;; current named marks (mark.c)

        ;; These variables are set when VIsual_active becomes false.
        (field visualinfo_C b_visual)
        (field int          b_visual_mode_eval) ;; b_visual.vi_mode for visualmode()

        (field pos_C        b_last_cursor)      ;; cursor position when last unloading this buffer
        (field pos_C        b_last_insert)      ;; where Insert mode was left
        (field pos_C        b_last_change)      ;; position of last change: '. mark

        ;; the changelist contains old change positions

        (field pos_C*       b_changelist)
        (field int          b_changelistlen)    ;; number of active entries
        (field boolean      b_new_change)       ;; set by u_savecommon()

        ;; Character table, only used in charset.c for 'iskeyword'.
        ;; 8 bytes of 32 bits: 1 bit per character 0-255.

        (field int*         b_chartab)

        ;; Table used for mappings local to a buffer.
        (field mapblock_C** b_maphash)

        ;; First abbreviation local to a buffer.
        (atom' mapblock_C   b_first_abbr)

        ;; start and end of an operator, also used for '[ and ']

        (field pos_C        b_op_start)
        (field pos_C        b_op_start_orig)    ;; used for insStart_orig
        (field pos_C        b_op_end)

        ;; The following only used in undo.c.

        (field u_header_C   b_u_oldhead)        ;; pointer to oldest header
        (field u_header_C   b_u_newhead)        ;; pointer to newest header; may not be valid
                                                ;; if b_u_curhead is not null
        (field u_header_C   b_u_curhead)        ;; pointer to current header
        (field int          b_u_numhead)        ;; current number of headers
        (field boolean      b_u_synced)         ;; entry lists are synced
        (field long         b_u_seq_last)       ;; last used undo sequence number
        (field long         b_u_save_nr_last)   ;; counter for last file write
        (field long         b_u_seq_cur)        ;; hu_seq of header below which we are now
        (field long         b_u_time_cur)       ;; uh_time of header below which we are now
        (field long         b_u_save_nr_cur)    ;; file write nr after which we are now

        ;; variables for "U" command in undo.c

        (field Bytes        b_u_line_ptr)       ;; saved line for "U" command
        (field long         b_u_line_lnum)      ;; line number of line in u_line
        (field int          b_u_line_colnr)     ;; optional column number

        ;; Options local to a buffer.
        ;; They are here because their value depends on the type of file
        ;; or contents of the file being edited.

        (field boolean      b_p_initialized)    ;; set when options initialized

        (atom' boolean      b_p_ai)             ;; 'autoindent'
        (field boolean      b_p_ai_nopaste)     ;; "b_p_ai" saved for paste mode
        (atom' boolean      b_p_ci)             ;; 'copyindent'
        (atom' boolean      b_p_bin)            ;; 'binary'
        (atom' boolean      b_p_cin)            ;; 'cindent'
        (atom' Bytes        b_p_cino)           ;; 'cinoptions'
        (atom' Bytes        b_p_cink)           ;; 'cinkeys'
        (atom' Bytes        b_p_cinw)           ;; 'cinwords'
        (atom' Bytes        b_p_com)            ;; 'comments'
        (atom' boolean      b_p_et)             ;; 'expandtab'
        (field boolean      b_p_et_nobin)       ;; "b_p_et" saved for binary mode
        (atom' Bytes        b_p_fo)             ;; 'formatoptions'
        (atom' Bytes        b_p_flp)            ;; 'formatlistpat'
        (atom' boolean      b_p_inf)            ;; 'infercase'
        (atom' Bytes        b_p_isk)            ;; 'iskeyword'
        (atom' Bytes        b_p_kp)             ;; 'keywordprg'
        (atom' boolean      b_p_lisp)           ;; 'lisp'
        (atom' Bytes        b_p_mps)            ;; 'matchpairs'
        (atom' boolean      b_p_ma)             ;; 'modifiable'
        (atom' Bytes        b_p_nf)             ;; 'nrformats'
        (atom' boolean      b_p_pi)             ;; 'preserveindent'
        (atom' Bytes        b_p_qe)             ;; 'quoteescape'
        (atom' boolean      b_p_ro)             ;; 'readonly'
        (atom' long         b_p_sw)             ;; 'shiftwidth'
        (atom' boolean      b_p_si)             ;; 'smartindent'
        (atom' long         b_p_sts)            ;; 'softtabstop'
        (field long         b_p_sts_nopaste)    ;; "b_p_sts" saved for paste mode
        (atom' long         b_p_ts)             ;; 'tabstop'
        (atom' long         b_p_tw)             ;; 'textwidth'
        (field long         b_p_tw_nobin)       ;; "b_p_tw" saved for binary mode
        (field long         b_p_tw_nopaste)     ;; "b_p_tw" saved for paste mode
        (atom' long         b_p_wm)             ;; 'wrapmargin'
        (field long         b_p_wm_nobin)       ;; "b_p_wm" saved for binary mode
        (field long         b_p_wm_nopaste)     ;; "b_p_wm" saved for paste mode

        ;; local values for options which are normally global
        (atom' long         b_p_ul)             ;; 'undolevels' local value
        (atom' Bytes        b_p_lw)             ;; 'lispwords' local value

        ;; end of buffer options

        ;; values set from "b_p_cino"
; %%    (field int          b_ind_level)
; %%    (field int          b_ind_open_imag)
; %%    (field int          b_ind_no_brace)
; %%    (field int          b_ind_first_open)
; %%    (field int          b_ind_open_extra)
; %%    (field int          b_ind_close_extra)
; %%    (field int          b_ind_open_left_imag)
; %%    (field int          b_ind_jump_label)
; %%    (field int          b_ind_case)
; %%    (field int          b_ind_case_code)
; %%    (field int          b_ind_case_break)
; %%    (field int          b_ind_param)
; %%    (field int          b_ind_func_type)
; %%    (field int          b_ind_comment)
; %%    (field int          b_ind_in_comment)
; %%    (field int          b_ind_in_comment2)
; %%    (field int          b_ind_cpp_baseclass)
; %%    (field int          b_ind_continuation)
; %%    (field int          b_ind_unclosed)
; %%    (field int          b_ind_unclosed2)
; %%    (field int          b_ind_unclosed_noignore)
; %%    (field int          b_ind_unclosed_wrapped)
; %%    (field int          b_ind_unclosed_whiteok)
; %%    (field int          b_ind_matching_paren)
; %%    (field int          b_ind_paren_prev)
; %%    (field int          b_ind_maxparen)
; %%    (field int          b_ind_maxcomment)
; %%    (field int          b_ind_scopedecl)
; %%    (field int          b_ind_scopedecl_code)
; %%    (field int          b_ind_java)
; %%    (field int          b_ind_js)
; %%    (field int          b_ind_keep_case_label)
; %%    (field int          b_ind_hash_comment)
; %%    (field int          b_ind_cpp_namespace)
; %%    (field int          b_ind_if_for_while)

; %%    (field long         b_no_eol_lnum)      ;; non-zero lnum when last line of next binary write should not have an end-of-line

; %%    (field int          b_bad_char)         ;; "++bad=" argument when edit started or 0

; %%    (field boolean      b_did_warn)         ;; set to true if user has been warned on first change of a read-only file

; %%    (field int          b_mapped_ctrl_c)    ;; modes where CTRL-C is mapped
    ])

;; Tab pages point to the top frame of each tab page.
;; Note: Most values are NOT valid for the current tab page!  Use "curwin",
;; "firstwin", etc. for that.  "tp_topframe" is always valid and can be
;; compared against "topframe" to find the current tab page.

(class! #_final tabpage_C
    [
        (field tabpage_C    tp_next)            ;; next tabpage or null
        (field frame_C      tp_topframe)        ;; topframe for the windows
        (field window_C     tp_curwin)          ;; current window in this Tab page
        (field window_C     tp_prevwin)         ;; previous window in this Tab page
        (field window_C     tp_firstwin)        ;; first window in this Tab page
        (field window_C     tp_lastwin)         ;; last window in this Tab page
        (field long         tp_old_Rows)        ;; Rows when Tab page was left
        (field long         tp_old_Columns)     ;; Columns when Tab page was left
        (field long         tp_ch_used)         ;; value of 'cmdheight' when frame size was set
    ])

;; Structure to cache info for displayed lines in w_lines[].
;; Each logical line has one entry.
;; The entry tells how the logical line is currently displayed in the window.
;; This is updated when displaying the window.
;; When the display is changed (e.g., when clearing the screen) w_lines_valid
;; is changed to exclude invalid entries.
;; When making changes to the buffer, wl_valid is reset to indicate wl_size
;; may not reflect what is actually in the buffer.  When wl_valid is false,
;; the entries can only be used to count the number of displayed lines used.
;; wl_lnum and wl_lastlnum are invalid too.

(class! #_final wline_C
    [
        (field long         wl_lnum)        ;; buffer line number for logical line
        (field int          wl_size)        ;; height in screen lines
        (field boolean      wl_valid)       ;; true values are valid for text in buffer
    ])

(defn- #_void COPY_wline [#_wline_C wl1, #_wline_C wl0]
    (§
;       wl1.wl_lnum = wl0.wl_lnum;
;       wl1.wl_size = wl0.wl_size;
;       wl1.wl_valid = wl0.wl_valid;
    ))

(defn- #_wline_C* ARRAY_wline [#_int n]
    (vec (repeatedly n §_wline_C)))

;; Windows are kept in a tree of frames.  Each frame has a column (FR_COL)
;; or row (FR_ROW) layout or is a leaf, which has a window.

(class! #_final frame_C
    [
        (field byte         fr_layout)      ;; FR_LEAF, FR_COL or FR_ROW
        (field int          fr_width)
        (field int          fr_newwidth)    ;; new width used in win_equal_rec()
        (field int          fr_height)
        (field int          fr_newheight)   ;; new height used in win_equal_rec()
        (field frame_C      fr_parent)      ;; containing frame or null
        (field frame_C      fr_next)        ;; frame right or below in same parent, null for first
        (field frame_C      fr_prev)        ;; frame left or above in same parent, null for last
                                            ;; fr_child and fr_win are mutually exclusive
        (field frame_C      fr_child)       ;; first contained frame
        (field window_C     fr_win)         ;; window that fills this frame
    ])

(defn- #_void COPY_frame [#_frame_C fr1, #_frame_C fr0]
    (§
;       fr1.fr_layout = fr0.fr_layout;
;       fr1.fr_width = fr0.fr_width;
;       fr1.fr_newwidth = fr0.fr_newwidth;
;       fr1.fr_height = fr0.fr_height;
;       fr1.fr_newheight = fr0.fr_newheight;
;       fr1.fr_parent = fr0.fr_parent;
;       fr1.fr_next = fr0.fr_next;
;       fr1.fr_prev = fr0.fr_prev;
;       fr1.fr_child = fr0.fr_child;
;       fr1.fr_win = fr0.fr_win;
    ))

(final byte
    FR_LEAF 0,            ;; frame is a leaf
    FR_ROW  1,            ;; frame with a row of windows
    FR_COL  2)            ;; frame with a column of windows

;; Struct used for highlighting 'hlsearch' matches, matches defined by ":match" and
;; matches defined by match functions.  For 'hlsearch' there is one pattern for all windows.
;; For ":match" and the match functions there is a different pattern for each window.

(class! #_final match_C
    [
        (field regmmatch_C  rmm     (§_regmmatch_C))    ;; points to the regexp program; contains last found match (may continue in next line)
        (field buffer_C     buf)                        ;; the buffer to search for a match
        (field long         lnum)                       ;; the line to search for a match
        (field int          attr)                       ;; attributes to be used for a match
        (field int          attr_cur)                   ;; attributes currently active in win_line()
        (field long         first_lnum)                 ;; first lnum to search for multi-line pat
        (field int          startcol)                   ;; in win_line() points to char where HL starts
        (field int          endcol)                     ;; in win_line() points to char where HL ends
        (field timeval_C    tm      (timeval_C.))       ;; for a time limit
    ])

;; number of positions supported by matchaddpos()
(final int MAXPOSMATCH 8)

;; Same as lpos_C, but with additional field len.

(class! #_final llpos_C
    [
        (field long     lnum)       ;; line number
        (field int      col)        ;; column number
        (field int      len)        ;; length: 0 - to the end of line
    ])

(defn- #_void COPY_llpos [#_llpos_C llp1, #_llpos_C llp0]
    (§
;       llp1.lnum = llp0.lnum;
;       llp1.col = llp0.col;
;       llp1.len = llp0.len;
    ))

(defn- #_llpos_C* ARRAY_llpos [#_int n]
    (vec (repeatedly n §_llpos_C)))

;; posmatch_C provides an array for storing match items for matchaddpos() function.

(class! #_final posmatch_C
    [
        (field llpos_C* pm_pos  (ARRAY_llpos MAXPOSMATCH))  ;; array of positions
        (field int      cur)        ;; internal position counter
        (field long     toplnum)    ;; top buffer line
        (field long     botlnum)    ;; bottom buffer line
    ])

(defn- #_posmatch_C* ARRAY_posmatch [#_int n]
    (vec (repeatedly n §_posmatch_C)))

;; matchitem_C provides a linked list for storing match items for ":match" and the match functions.

(class! #_final matchitem_C
    [
        (field matchitem_C  next)
        (field int          id)             ;; match ID
        (field int          priority)       ;; match priority
        (field Bytes        pattern)        ;; pattern to highlight
        (field int          hlg_id)         ;; highlight group ID
        (field regmmatch_C  mi_match    (§_regmmatch_C))    ;; regexp program for "pattern"
        (field posmatch_C   mi_pos      (§_posmatch_C))     ;; position matches
        (field match_C      mi_hl       (§_match_C))        ;; struct for doing the actual highlighting
    ])

;; Structure which contains all information that belongs to a window
;;
;; All row numbers are relative to the start of the window, except w_winrow.

(class! #_final window_C
    [
        (field buffer_C     w_buffer)           ;; buffer we are a window into (used often, keep it the first item!)

        (field window_C     w_prev)             ;; link to previous window
        (field window_C     w_next)             ;; link to next window
        (field boolean      w_closing)          ;; window is being closed, don't let autocommands close it too

        (field frame_C      w_frame)            ;; frame containing this window

        (field pos_C        w_cursor            (§_pos_C))  ;; cursor position in buffer
        (field int          w_curswant)         ;; column we'd like to be at: used to try to stay in the same column for up/down cursor motions
        (field boolean      w_set_curswant)     ;; if set, update w_curswant the next time through cursupdate() to the current virtual column

        ;; the next six are used to update the visual part

        (field int          w_old_visual_mode)  ;; last known VIsual_mode
        (field long         w_old_cursor_lnum)  ;; last known end of visual part
        (field int          w_old_cursor_fcol)  ;; first column for block visual part
        (field int          w_old_cursor_lcol)  ;; last column for block visual part
        (field long         w_old_visual_lnum)  ;; last known start of visual part
        (field int          w_old_visual_col)   ;; last known start of visual part
        (field int          w_old_curswant)     ;; last known value of curswant

        ;; "w_topline", "w_leftcol" and "w_skipcol" specify the offsets for displaying the buffer.

        (field long         w_topline)          ;; buffer line number of the line at the top of the window
        (field boolean      w_topline_was_set)  ;; flag set to true when topline is set, e.g. by winrestview()
        (field int          w_leftcol)          ;; window column of the leftmost character in the window; used when 'wrap' is off
        (field int          w_skipcol)          ;; starting column when a single line doesn't fit in the window

        ;; Layout of the window in the screen.
        ;; May need to add "msg_scrolled" to "w_winrow" in rare situations.

        (field int          w_winrow)           ;; first row of window in screen
        (field int          w_height)           ;; number of rows in window, excluding status/command line(s)
        (field int          w_status_height)    ;; number of status lines (0 or 1)
        (field int          w_wincol)           ;; leftmost column of window in screen
        (field int          w_width)            ;; width of window, excluding separation
        (field int          w_vsep_width)       ;; number of separator columns (0 or 1)

        ;; === start of cached values ====

        ;; Recomputing is minimized by storing the result of computations.
        ;; Use functions in screen.c to check if they are valid and to update.
        ;; w_valid is a bitfield of flags, which indicate if specific values are
        ;; valid or need to be recomputed.  See screen.c for values.

        (field int          w_valid)
        (field pos_C        w_valid_cursor      (§_pos_C))  ;; last known position of w_cursor, used to adjust w_valid
        (field int          w_valid_leftcol)    ;; last known w_leftcol

        ;; w_cline_height is the number of physical lines taken by the buffer line
        ;; that the cursor is on.  We use this to avoid extra calls to plines().

        (field int          w_cline_height)     ;; current size of cursor line

        (field int          w_cline_row)        ;; starting row of the cursor line

        (field int          w_virtcol)          ;; Column number of the cursor in the buffer line,
                                                ;; as opposed to the column number we're at on the screen.
                                                ;; This makes a difference on lines which span more than
                                                ;; one screen line or when w_leftcol is non-zero.

        ;; w_wrow and w_wcol specify the cursor position in the window.
        ;; This is related to positions in the window, not in the display
        ;; or buffer, thus w_wrow is relative to w_winrow.

        (field int          w_wrow)
        (field int          w_wcol)

        (field long         w_botline)          ;; number of the line below the bottom of the screen
        (field int          w_empty_rows)       ;; number of ~ rows in window

        ;; Info about the lines currently in the window is remembered to avoid
        ;; recomputing it every time.  The allocated size of w_lines[] is Rows.
        ;; Only the w_lines_valid entries are actually valid.
        ;; When the display is up-to-date w_lines[0].wl_lnum is equal to w_topline
        ;; and w_lines[w_lines_valid - 1].wl_lnum is equal to w_botline.
        ;; Between changing text and updating the display w_lines[] represents
        ;; what is currently displayed.  wl_valid is reset to indicated this.
        ;; This is used for efficient redrawing.

        (field int          w_lines_valid)      ;; number of valid entries
        (field wline_C*     w_lines)
        (field int          w_lines_len)

        (field int          w_nrwidth)          ;; width of 'number' and 'relativenumber' column being used

        ;; === end of cached values ===

        (field int          w_redr_type)        ;; type of redraw to be performed on win
        (field int          w_upd_rows)         ;; number of window lines to update when w_redr_type is REDRAW_TOP
        (field long         w_redraw_top)       ;; when != 0: first line needing redraw
        (field long         w_redraw_bot)       ;; when != 0: last line needing redraw
        (field boolean      w_redr_status)      ;; if true status line must be redrawn

        ;; remember what is shown in the ruler for this window (if 'ruler' set)
        (field pos_C        w_ru_cursor         (§_pos_C))  ;; cursor position shown in ruler
        (field int          w_ru_virtcol)       ;; virtcol shown in ruler
        (field long         w_ru_topline)       ;; topline shown in ruler
        (field long         w_ru_line_count)    ;; line count used for ruler
        (field boolean      w_ru_empty)         ;; true if ruler shows 0-1 (empty line)

        (field int          w_alt_fnum)         ;; alternate file (for # and CTRL-^)

        ;; Options local to a window.
        ;; They are local because they influence the layout of the window or depend on the window layout.
        ;; There are two values:
        ;; "w_onebuf_opt" is local to the buffer currently in this window,
        ;; "w_allbuf_opt" is for all buffers in this window.

        (field winopt_C     w_onebuf_opt    (§_winopt_C))
        (field winopt_C     w_allbuf_opt    (§_winopt_C))

        ;; A few options have local flags for P_INSECURE.
        (field int*         w_p_cc_cols)        ;; array of columns to highlight or null
        (field int          w_p_brimin)         ;; minimum width for breakindent
        (field int          w_p_brishift)       ;; additional shift for breakindent
        (field boolean      w_p_brisbr)         ;; sbr in 'briopt'

        (field long         w_scbind_pos)

        ;; w_prev_pcmark is used to check whether we really did jump to a new line after setting w_pcmark.
        ;; If not, we revert to using the previous w_pcmark.

        (field pos_C        w_pcmark            (§_pos_C))  ;; previous context mark
        (field pos_C        w_prev_pcmark       (§_pos_C))  ;; previous w_pcmark

        ;; the jumplist contains old cursor positions

        (field xfmark_C*    w_jumplist  (ARRAY_xfmark JUMPLISTSIZE))
        (field int          w_jumplistlen)      ;; number of active entries
        (field int          w_jumplistidx)      ;; current position

        (field int          w_changelistidx)    ;; current position in b_changelist

        (field matchitem_C  w_match_head)       ;; head of match list
        (field int          w_next_match_id)    ;; next match ID

        ;; w_fraction is the fractional row of the cursor within the window,
        ;; from 0 at the top row to FRACTION_MULT at the last row.
        ;; w_prev_fraction_row was the actual cursor row when w_fraction was last calculated.

        (field int          w_fraction)
        (field int          w_prev_fraction_row)

        (field long         w_nrwidth_line_count)   ;; line count when ml_nrwidth_width was computed
        (field long         w_nuw_cached)           ;; 'numberwidth' option cached
        (field int          w_nrwidth_width)        ;; nr of chars to print line count
    ])

;; Arguments for operators.

(class! #_final oparg_C
    [
        (field int          op_type)            ;; current pending operator type
        (field int          regname)            ;; register to use for the operator
        (field byte         motion_type)        ;; type of the current cursor motion
        (field int          motion_force)       ;; force motion type: 'v', 'V' or CTRL-V
        (field boolean      use_reg_one)        ;; true if delete uses reg 1 even when not linewise
        (field boolean      inclusive)          ;; true if char motion is inclusive (only valid when motion_type is MCHAR)
        (field boolean      end_adjusted)       ;; backuped b_op_end one char (only used by do_format())
        (field pos_C        op_start        (§_pos_C))  ;; start of the operator
        (field pos_C        op_end          (§_pos_C))  ;; end of the operator
        (field pos_C        cursor_start    (§_pos_C))  ;; cursor position before motion for "gw"
        (field long         line_count)         ;; number of lines from op_start to op_end (inclusive)
        (field boolean      empty)              ;; op_start and op_end the same (only used by do_change())
        (field boolean      is_VIsual)          ;; operator on Visual area
        (field boolean      block_mode)         ;; current operator is Visual block mode
        (field int          start_vcol)         ;; start col for block mode operator
        (field int          end_vcol)           ;; end col for block mode operator
        (field long         prev_opcount)       ;; ca.opcount saved for K_CURSORHOLD
        (field long         prev_count0)        ;; ca.count0 saved for K_CURSORHOLD
    ])

;; Arguments for Normal mode commands.

(class! #_final cmdarg_C
    [
        (field oparg_C      oap)                ;; operator arguments
        (field int          prechar)            ;; prefix character (optional, always 'g')
        (field int          cmdchar)            ;; command character
        (atom' int          nchar)              ;; next command character (optional)
        (field int          ncharC1)            ;; first composing character (optional)
        (field int          ncharC2)            ;; second composing character (optional)
        (atom' int          extra_char)         ;; yet another character (optional)
        (field long         opcount)            ;; count before an operator
        (field long         count0)             ;; count before command, default 0
        (field long         count1)             ;; count before command, default 1
        (field int          arg)                ;; extra argument from nv_cmds[]
        (field int          retval)             ;; return: CA_* values
        (field Bytes        searchbuf)          ;; return: pointer to search pattern or null
    ])

;; values for retval:
(final int CA_COMMAND_BUSY  1)  ;; skip restarting edit() once
(final int CA_NO_ADJ_OP_END 2)  ;; don't adjust operator end

;; ----------------------------------------------------------------------- ;;

;; Codes for mouse button events in lower three bits:
(final int MOUSE_LEFT     0x00)
(final int MOUSE_MIDDLE   0x01)
(final int MOUSE_RIGHT    0x02)
(final int MOUSE_RELEASE  0x03)

;; bit masks for modifiers:
(final int MOUSE_SHIFT    0x04)
(final int MOUSE_ALT      0x08)
(final int MOUSE_CTRL     0x10)

;; mouse buttons that are handled like a key press (GUI only)

;; Note that the scroll wheel keys are inverted: MOUSE_5 scrolls lines up but
;; the result of this is that the window moves down, similarly MOUSE_6 scrolls
;; columns left but the window moves right.

(final int MOUSE_4    0x100)    ;; scroll wheel down
(final int MOUSE_5    0x200)    ;; scroll wheel up

(final int MOUSE_X1   0x300)    ;; Mouse-button X1 (6th)
(final int MOUSE_X2   0x400)    ;; Mouse-button X2

(final int MOUSE_6    0x500)    ;; scroll wheel left
(final int MOUSE_7    0x600)    ;; scroll wheel right

;; 0x20 is reserved by xterm
(final int MOUSE_DRAG_XTERM 0x40)

(final int MOUSE_DRAG (| 0x40 MOUSE_RELEASE))

;; Lowest button code for using the mouse wheel (xterm only).
(final int MOUSEWHEEL_LOW     0x60)

(final int MOUSE_CLICK_MASK   0x03)

;; jump_to_mouse() returns one of first four these values, possibly with
;; some of the other three added.

(final int IN_UNKNOWN         0)
(final int IN_BUFFER          1)
(final int IN_STATUS_LINE     2)        ;; on status or command line
(final int IN_SEP_LINE        4)        ;; on vertical separator line
(final int IN_OTHER_WIN       8)        ;; in other window but can't go there
(final int CURSOR_MOVED       0x100)

;; flags for jump_to_mouse()
(final int MOUSE_FOCUS        0x01)     ;; need to stay in this window
(final int MOUSE_MAY_VIS      0x02)     ;; may start Visual mode
(final int MOUSE_DID_MOVE     0x04)     ;; only act when mouse has moved
(final int MOUSE_SETPOS       0x08)     ;; only set current mouse position
(final int MOUSE_MAY_STOP_VIS 0x10)     ;; may stop Visual mode
(final int MOUSE_RELEASED     0x20)     ;; button was released

;; Selection states for modeless selection.
(final int SELECT_CLEARED     0)
(final int SELECT_IN_PROGRESS 1)
(final int SELECT_DONE        2)

(final int SELECT_MODE_CHAR   0)
(final int SELECT_MODE_WORD   1)
(final int SELECT_MODE_LINE   2)

;; Info about selected text.
(class! #_final clipboard_C
    [
        (field boolean      available)          ;; Is clipboard available?
        (field boolean      owned)              ;; Flag: do we own the selection?
        (field pos_C        cbd_start       (§_pos_C))  ;; start of selected area
        (field pos_C        cbd_end         (§_pos_C))  ;; end of selected area
        (field int          vmode)              ;; visual mode character

        ;; Fields for selection that doesn't use Visual mode.
        (field int          origin_row)
        (field int          origin_start_col)
        (field int          origin_end_col)
        (field int          word_start_col)
        (field int          word_end_col)

        (field pos_C        cbd_prev        (§_pos_C))  ;; previous position
        (field short        state)              ;; current selection state
        (field short        mode)               ;; select by char, word, or line
    ])

;;; ============================================================================================== VimE

;; ex_cmds.h --------------------------------------------------------------------------------------

(final int
    RANGE           0x001,   ;; allow a linespecs
    BANG            0x002,   ;; allow a ! after the command name
    EXTRA           0x004,   ;; allow extra args after command name
    XFILE           0x008,   ;; expand wildcards in extra part
    NOSPC           0x010,   ;; no spaces allowed in the extra part
    DFLALL          0x020,   ;; default file range is 1,$
    NEEDARG         0x080,   ;; argument required
    REGSTR          0x200,   ;; allow "x for register designation
    COUNT           0x400,   ;; allow count in argument, after command
    NOTRLCOM        0x800,   ;; no trailing comment allowed
    ZEROR          0x1000,   ;; zero line number allowed
    USECTRLV       0x2000,   ;; do not remove CTRL-V from argument
    NOTADR         0x4000,   ;; number before command is not an address
    EDITCMD        0x8000,   ;; allow "+command" argument
    BUFNAME       0x10000,   ;; accepts buffer name
    BUFUNL        0x20000,   ;; accepts unlisted buffer too
    ARGOPT        0x40000,   ;; allow "++opt=val" argument
    SBOXOK        0x80000,   ;; allowed in the sandbox
    CMDWIN       0x100000,   ;; allowed in cmdline window
    MODIFY       0x200000,   ;; forbidden in non-'modifiable' buffer
    EXFLAGS      0x400000,   ;; allow flags after count in argument

    FILES (| XFILE EXTRA),   ;; multiple extra files allowed
    WORD1 (| EXTRA NOSPC),   ;; one extra word allowed
    FILE1 (| FILES NOSPC))   ;; 1 file allowed, defaults to current file

;; values for cmd_addr_type
(final byte
    ADDR_LINES          0,
    ADDR_WINDOWS        1,
    ADDR_LOADED_BUFFERS 3,
    ADDR_BUFFERS        4)

(final int
    CMD_append 0,
    CMD_abbreviate 1,
    CMD_abclear 2,
    CMD_aboveleft 3,
    CMD_ascii 4,
    CMD_buffer 5,
    CMD_bNext 6,
    CMD_ball 7,
    CMD_bdelete 8,
    CMD_belowright 9,
    CMD_bfirst 10,
    CMD_blast 11,
    CMD_bmodified 12,
    CMD_bnext 13,
    CMD_botright 14,
    CMD_bprevious 15,
    CMD_brewind 16,
    CMD_buffers 17,
    CMD_bunload 18,
    CMD_bwipeout 19,
    CMD_change 20,
    CMD_cabbrev 21,
    CMD_cabclear 22,
    CMD_center 23,
    CMD_changes 24,
    CMD_close 25,
    CMD_cmap 26,
    CMD_cmapclear 27,
    CMD_cnoremap 28,
    CMD_cnoreabbrev 29,
    CMD_copy 30,
    CMD_cunmap 31,
    CMD_cunabbrev 32,
    CMD_delete 33,
    CMD_delmarks 34,
    CMD_display 35,
    CMD_digraphs 36,
    CMD_edit 37,
    CMD_earlier 38,
    CMD_enew 39,
    CMD_ex 40,
    CMD_fixdel 41,
    CMD_global 42,
    CMD_goto 43,
    CMD_hide 44,
    CMD_history 45,
    CMD_insert 46,
    CMD_iabbrev 47,
    CMD_iabclear 48,
    CMD_imap 49,
    CMD_imapclear 50,
    CMD_inoremap 51,
    CMD_inoreabbrev 52,
    CMD_iunmap 53,
    CMD_iunabbrev 54,
    CMD_join 55,
    CMD_jumps 56,
    CMD_k 57,
    CMD_keepmarks 58,
    CMD_keepjumps 59,
    CMD_keeppatterns 60,
    CMD_keepalt 61,
    CMD_list 62,
    CMD_later 63,
    CMD_left 64,
    CMD_leftabove 65,
    CMD_lockmarks 66,
    CMD_move 67,
    CMD_mark 68,
    CMD_map 69,
    CMD_mapclear 70,
    CMD_marks 71,
    CMD_messages 72,
    CMD_mode 73,
    CMD_new 74,
    CMD_nmap 75,
    CMD_nmapclear 76,
    CMD_nnoremap 77,
    CMD_noremap 78,
    CMD_nohlsearch 79,
    CMD_noreabbrev 80,
    CMD_normal 81,
    CMD_number 82,
    CMD_nunmap 83,
    CMD_omap 84,
    CMD_omapclear 85,
    CMD_only 86,
    CMD_onoremap 87,
    CMD_ounmap 88,
    CMD_print 89,
    CMD_put 90,
    CMD_quit 91,
    CMD_quitall 92,
    CMD_qall 93,
    CMD_redo 94,
    CMD_redraw 95,
    CMD_redrawstatus 96,
    CMD_registers 97,
    CMD_resize 98,
    CMD_retab 99,
    CMD_right 100,
    CMD_rightbelow 101,
    CMD_substitute 102,
    CMD_sandbox 103,
    CMD_sbuffer 104,
    CMD_sbNext 105,
    CMD_sball 106,
    CMD_sbfirst 107,
    CMD_sblast 108,
    CMD_sbmodified 109,
    CMD_sbnext 110,
    CMD_sbprevious 111,
    CMD_sbrewind 112,
    CMD_set 113,
    CMD_setglobal 114,
    CMD_setlocal 115,
    CMD_silent 116,
    CMD_smagic 117,
    CMD_smap 118,
    CMD_smapclear 119,
    CMD_snomagic 120,
    CMD_snoremap 121,
    CMD_split 122,
    CMD_stop 123,
    CMD_startinsert 124,
    CMD_startgreplace 125,
    CMD_startreplace 126,
    CMD_stopinsert 127,
    CMD_sunhide 128,
    CMD_sunmap 129,
    CMD_suspend 130,
    CMD_sview 131,
    CMD_syncbind 132,
    CMD_t 133,
    CMD_topleft 134,
    CMD_undo 135,
    CMD_undojoin 136,
    CMD_undolist 137,
    CMD_unabbreviate 138,
    CMD_unhide 139,
    CMD_unmap 140,
    CMD_unsilent 141,
    CMD_vglobal 142,
    CMD_verbose 143,
    CMD_vertical 144,
    CMD_visual 145,
    CMD_view 146,
    CMD_vmap 147,
    CMD_vmapclear 148,
    CMD_vnoremap 149,
    CMD_vnew 150,
    CMD_vsplit 151,
    CMD_vunmap 152,
    CMD_wincmd 153,
    CMD_xmap 154,
    CMD_xmapclear 155,
    CMD_xnoremap 156,
    CMD_xunmap 157,
    CMD_yank 158,
    CMD_z 159,

;; commands that don't start with a lowercase letter

    CMD_pound 160,
    CMD_and 161,
    CMD_lshift 162,
    CMD_equal 163,
    CMD_rshift 164,
    CMD_tilde 165,

    CMD_SIZE 166)     ;; MUST be after all real commands!

;; Arguments used for Ex commands.

(class! #_final exarg_C
    [
        (field Bytes        arg)            ;; argument of the command
        (field Bytes        nextcmd)        ;; next command (null if none)
        (field Bytes        cmd)            ;; the name of the command (except for :make)
        (field Bytes*       cmdlinep)       ;; pointer to pointer of allocated cmdline
        (field int          cmdidx)         ;; the index for the command
        (field long         argt)           ;; flags for the command
        (field boolean      skip)           ;; don't execute the command, only parse it
        (field boolean      forceit)        ;; true if ! present
        (field int          addr_count)     ;; the number of addresses given
        (field long         line1)          ;; the first line number
        (field long         line2)          ;; the second line number or count
        (field int          addr_type)      ;; type of the count/range
        (field int          flags)          ;; extra flags after count: EXFLAG_
        (field Bytes        do_ecmd_cmd)    ;; +command arg to be used in edited file
        (field long         do_ecmd_lnum)   ;; the line number in an edited file
        (field int          amount)         ;; number of '>' or '<' for shift command
        (field int          regname)        ;; register name (NUL if none)
        (field int          force_bin)      ;; 0, FORCE_BIN or FORCE_NOBIN
        (field boolean      read_edit)      ;; ++edit argument
        (field int          bad_char)       ;; BAD_KEEP, BAD_DROP or replacement byte
        (field int          useridx)        ;; user command index
        (field Bytes        errmsg)         ;; returned error message
        (field getline_F    getline)
        (field Object       cookie)         ;; argument for getline()
    ])

(final int FORCE_BIN 1)         ;; ":edit ++bin file"
(final int FORCE_NOBIN 2)       ;; ":edit ++nobin file"

;; Values for "flags".
(final int EXFLAG_LIST  0x01)   ;; 'l': list
(final int EXFLAG_NR    0x02)   ;; '#': number
(final int EXFLAG_PRINT 0x04)   ;; 'p': print

;; ----------------------------------------------------------------------- ;;

(defn- #_boolean asc_islower [#_int c]
    (§
;       return ('a' <= c && c <= 'z');
    ))

(defn- #_boolean asc_isupper [#_int c]
    (§
;       return ('A' <= c && c <= 'Z');
    ))

(defn- #_boolean asc_isalpha [#_int c]
    (§
;       return (asc_isupper(c) || asc_islower(c));
    ))

(defn- #_boolean asc_isalnum [#_int c]
    (§
;       return (asc_isalpha(c) || asc_isdigit(c));
    ))

(defn- #_boolean asc_iscntrl [#_int c]
    (§
;       return (0x00 <= c && c <= 0x1f)
;           || (c == 0x7f);
    ))

(defn- #_boolean asc_isgraph [#_int c]
    (§
;       return (0x21 <= c && c <= 0x7e);
    ))

(defn- #_boolean asc_isprint [#_int c]
    (§
;       return (0x20 <= c && c <= 0x7e);
    ))

(defn- #_boolean asc_ispunct [#_int c]
    (§
;       return (0x21 <= c && c <= 0x2f)
;           || (0x3a <= c && c <= 0x40)
;           || (0x5b <= c && c <= 0x60)
;           || (0x7b <= c && c <= 0x7e);
    ))

;;; ============================================================================================== VimF

;; #include "globals.h"             ;; global variables and messages

;; Number of Rows and Columns in the screen.
;; Must be long to be able to use them as options in option.c.
;; Note: Use screenRows and screenColumns to access items in screenLines[].
;; They may have different values when the screen wasn't (re)allocated yet
;; after setting Rows or Columns (e.g., when starting up).

(atom! long   Rows 24#_L)     ;; nr of rows in the screen
(atom! long   Columns 80#_L)  ;; nr of columns in the screen

;; The characters that are currently on the screen are kept in screenLines[].
;; It is a single block of characters, the size of the screen plus one line.
;; The attributes for those characters are kept in screenAttrs[].
;;
;; "lineOffset[n]" is the offset from screenLines[] for the start of line 'n'.
;; The same value is used for screenLinesUC[] and screenAttrs[].
;;
;; Note: before the screen is initialized and when out of memory these can be null.

(atom! Bytes    screenLines)
(atom! int*     screenAttrs)
(atom! int*     lineOffset)
(atom! boolean* lineWraps)         ;; line wraps to next line

;; When using Unicode characters (in UTF-8 encoding) the character in
;; screenLinesUC[] contains the Unicode for the character at this position,
;; or NUL when the character in screenLines[] is to be used (ASCII char).
;; The composing characters are to be drawn on top of the original character.
;; screenLinesC[0][off] is only to be used when screenLinesUC[off] != 0.

(atom! int*     screenLinesUC)      ;; decoded UTF-8 characters
(atom! int**    screenLinesC    MAX_MCO)    ;; composing characters
(atom! int      screen_mco)         ;; value of "p_mco" used when allocating screenLinesC[]

;; Indexes for tab page line:
;;      N > 0 for label of tab page N
;;      N == 0 for no label
;;      N < 0 for closing tab page -N
;;      N == -999 for closing current tab page

(atom! short*   tabPageIdxs)

(atom! int      screenRows)         ;; actual size of screenLines[]
(atom! int      screenColumns)      ;; actual size of screenLines[]

;; When vgetc() is called, it sets mod_mask to the set of modifiers that are
;; held down based on the MOD_MASK_* symbols that are read first.

(atom! int      mod_mask)           ;; current key modifiers

;; Cmdline_row is the row where the command line starts, just below the last window.
;; When the cmdline gets longer than the available space the screen gets scrolled up.
;; After a CTRL-D (show matches), after hitting ':' after "hit return",
;; and for the :global command, the command line is temporarily moved.
;; The old position is restored with the next call to update_screen().

(atom! int      cmdline_row)

(atom! boolean  redraw_cmdline)     ;; cmdline must be redrawn
(atom! boolean  clear_cmdline)      ;; cmdline must be cleared
(atom! boolean  mode_displayed)     ;; mode is being displayed
(atom! int      cmdline_star)       ;; cmdline is crypted

(atom! boolean  exec_from_reg)      ;; executing register

(atom! maybean  screen_cleared FALSE)     ;; screen has been cleared

;; When '$' is included in 'cpoptions' option set:
;; When a change command is given that deletes only part of a line, a dollar
;; is put at the end of the changed text. dollar_vcol is set to the virtual
;; column of this '$'.  -1 is used to indicate no $ is being displayed.

(atom! int      dollar_vcol -1)

;; Functions for putting characters in the command line,
;; while keeping screenLines[] updated.

(atom! boolean  cmdmsg_rl)          ;; cmdline is drawn right to left
(atom! int      msg_col)
(atom! int      msg_row)
(atom! int      msg_scrolled)       ;; number of screen lines that windows have scrolled because of printing messages
(atom! boolean  msg_scrolled_ign)   ;; when true don't set need_wait_return in msg_puts_attr() when msg_scrolled is non-zero

(atom! Bytes    keep_msg)           ;; msg to be shown after redraw
(atom! int      keep_msg_attr)      ;; highlight attr for "keep_msg"
(atom! boolean  keep_msg_more)      ;; "keep_msg" was set by msgmore()
(atom! boolean  need_fileinfo)      ;; do fileinfo() after redraw
(atom! boolean  msg_scroll)         ;; msg_start() will scroll
(atom! boolean  msg_didout)         ;; msg_outstr() was used in line
(atom! boolean  msg_didany)         ;; msg_outstr() was used at all
(atom! boolean  msg_nowait)         ;; don't wait for this msg
(atom! int      emsg_off)           ;; don't display errors for now
(atom! boolean  info_message)       ;; printing informative message
(atom! boolean  msg_hist_off)       ;; don't add messages to history
(atom! boolean  need_clr_eos)       ;; need to clear text before displaying a message
(atom! int      emsg_skip)          ;; don't display errors for expression that is skipped
(atom! boolean  emsg_severe)        ;; use message of next of several emsg() calls for throw
(atom! boolean  did_emsg)           ;; set by emsg() when the message is displayed or thrown
(atom! boolean  did_emsg_syntax)    ;; did_emsg set because of a syntax error
(atom! boolean  called_emsg)        ;; always set by emsg()
(atom! int      ex_exitval)         ;; exit value for ex mode
(atom! boolean  emsg_on_display)    ;; there is an error message
(atom! boolean  rc_did_emsg)        ;; vim_regcomp() called emsg()

(atom! int      no_wait_return)     ;; don't wait for return for now
(atom! boolean  need_wait_return)   ;; need to wait for return later
(atom! boolean  did_wait_return)    ;; wait_return() was used and nothing written since then

(atom! boolean  quit_more)          ;; 'q' hit at "--more--" msg
(atom! boolean  newline_on_exit)    ;; did msg in altern. screen
(atom! int      intr_char)          ;; extra interrupt character
(atom! boolean  ex_keep_indent)     ;; getexmodeline(): keep indent
(atom! int      vgetc_busy)         ;; when inside vgetc() then > 0

;; Lines left before a "more" message.
;; Ex mode needs to be able to reset this after you type something.

(atom! int      lines_left      -1)     ;; lines left for listing
(atom! boolean  msg_no_more)            ;; don't use more prompt, truncate messages

;; The exception currently being thrown.  Used to pass an exception to
;; a different cstack.  Also used for discarding an exception before it is
;; caught or made pending.  Only valid when did_throw is true.

(atom! except_C current_exception)

;; did_throw: An exception is being thrown.  Reset when the exception is caught
;; or as long as it is pending in a finally clause.

(atom! boolean did_throw)

;; need_rethrow: set to true when a throw that cannot be handled in do_cmdline()
;; must be propagated to the cstack of the previously called do_cmdline().

(atom! boolean need_rethrow)

;; When "force_abort" is true, always skip commands after an error message,
;; even after the outermost ":endif", ":endwhile" or ":endfor" or for a
;; function without the "abort" flag.  It is set to true when "trylevel" is
;; non-zero (and ":silent!" was not used) or an exception is being thrown at
;; the time an error is detected.  It is set to false when "trylevel" gets
;; zero again and there was no error or interrupt or throw.

(atom! boolean force_abort)

;; "msg_list" points to a variable in the stack of do_cmdline() which keeps
;; the list of arguments of several emsg() calls, one of which is to be
;; converted to an error exception immediately after the failing command
;; returns.  The message to be used for the exception value is pointed to by
;; the "throw_msg" field of the first element in the list.  It is usually the
;; same as the "msg" field of that element, but can be identical to the "msg"
;; field of a later list element, when the "emsg_severe" flag was set when the
;; emsg() call was made.

(atom! msglist_C* msg_list)

;; suppress_errthrow: When true, don't convert an error to an exception.  Used
;; when displaying the interrupt message or reporting an exception that is still
;; uncaught at the top level (which has already been discarded then).  Also used
;; for the error message when no exception can be thrown.

(atom! boolean suppress_errthrow)

;; The stack of all caught and not finished exceptions.  The exception on the
;; top of the stack is the one got by evaluation of v:exception.  The complete
;; stack of all caught and pending exceptions is embedded in the various
;; cstacks; the pending exceptions, however, are not on the caught stack.

(atom! except_C caught_stack)

(atom! boolean  scroll_region)                  ;; term supports scroll region
(atom! int      t_colors)                       ;; int value of T_CCO

;; When highlight_match is true, highlight a match, starting at the cursor position.
;; Search_match_lines is the number of lines after the match (0 for a match within one line),
;; search_match_endcol the column number of the character just after the match in the last line.

(atom! boolean  highlight_match)                ;; show search match pos
(atom! long     search_match_lines)             ;; lines of of matched string
(atom! int      search_match_endcol)            ;; col nr of match end

(atom! boolean  no_smartcase)                   ;; don't use 'smartcase' once

(atom! boolean  need_check_timestamps)          ;; need to check file timestamps asap
(atom! boolean  did_check_timestamps)           ;; did check timestamps recently
(atom! int      no_check_timestamps)            ;; don't check timestamps

(atom! int*     highlight_attr HLF_COUNT)       ;; highl. attr. for each context
(atom! int*     highlight_user 9)               ;; user[1-9] attributes
(atom! int*     highlight_stlnc 9)              ;; on top of user
(atom! int      cterm_normal_fg_color)
(atom! int      cterm_normal_fg_bold)
(atom! int      cterm_normal_bg_color)

(defn- #_int hl_attr [#_int n]
    (§
;       return @highlight_attr[n];
    ))

(atom! boolean  modified_was_set)       ;; did ":set modified"

;; Mouse coordinates, set by check_termcode()

(atom! int      mouse_row)
(atom! int      mouse_col)
(atom! boolean  mouse_past_bottom)      ;; mouse below last line
(atom! boolean  mouse_past_eol)         ;; mouse right of line
(atom! int      mouse_dragging)         ;; extending Visual area with mouse dragging

;; While redrawing the screen this flag is set.
;; It means the screen size ('lines' and 'rows') must not be changed.

(atom! boolean  updating_screen)

(atom! clipboard_C clip_star (§_clipboard_C))
(atom! clipboard_C clip_plus (§_clipboard_C))

(final int
    CLIP_UNNAMED      1,
    CLIP_UNNAMED_PLUS 2)
(atom! int      clip_unnamed)           ;; above two values or'ed
(atom! int      clip_unnamed_saved)

(atom! boolean  clip_autoselect_star)
(atom! boolean  clip_autoselect_plus)
(atom! boolean  clip_autoselectml)
(atom! boolean  clip_html)
(atom! regprog_C clip_exclude_prog)
(atom! boolean  clip_did_set_selection true)

;; All windows are linked in a list.  "firstwin" points to the first entry,
;; "lastwin" to the last entry (can be the same as "firstwin") and "curwin"
;; to the currently active window.

(atom! window_C firstwin)               ;; first window
(atom! window_C lastwin)                ;; last window
(atom! window_C prevwin)                ;; previous window
(atom! window_C curwin)                 ;; currently active window

(atom! window_C aucmd_win)              ;; window used in aucmd_prepbuf()

;; The window layout is kept in a tree of frames.  "topframe" points to the top of the tree.

(atom! frame_C  topframe)               ;; top of the window frame tree

;; Tab pages are alternative topframes.  "first_tabpage" points to the first
;; one in the list, "curtab" is the current one.

(atom! tabpage_C    first_tabpage)
(atom! tabpage_C    curtab)
(atom! boolean      redraw_tabline)     ;; need to redraw tabline

;; All buffers are linked in a list.  'firstbuf' points to the first entry,
;; 'lastbuf' to the last entry and 'curbuf' to the currently active buffer.

(atom! buffer_C firstbuf)               ;; first buffer
(atom! buffer_C lastbuf)                ;; last buffer
(atom! buffer_C curbuf)                 ;; currently active buffer

(atom! int      ru_col)                 ;; column for ruler
(atom! int      ru_wid)                 ;; 'rulerfmt' width of ruler when non-zero
(atom! int      sc_col)                 ;; column for shown command

;; When starting or exiting some things are done differently (e.g. screen updating).

(atom! int      starting NO_SCREEN)     ;; first NO_SCREEN, then NO_BUFFERS and then set to 0 when starting up finished
(atom! boolean  exiting)                ;; true when planning to exit Vim.  Might still keep on running if there is a changed buffer.

;; volatile because it is used in signal handler deathtrap().
(atom! #_"/*volatile*/transient" boolean full_screen)   ;; true when doing full-screen output
                                                        ;; otherwise only writing some messages

(atom! boolean  restricted)             ;; true when started as "rvim"
(atom! int      secure)                 ;; non-zero when only "safe" commands are allowed,
                                        ;; e.g. when sourcing .exrc or .vimrc in current directory

(atom! int      textlock)               ;; non-zero when changing text and jumping to another window or buffer is not allowed

(atom! int      curbuf_lock)            ;; non-zero when the current buffer can't be changed.
                                        ;; Used for FileChangedRO.
(atom! int      allbuf_lock)            ;; non-zero when no buffer name can be changed,
                                        ;; no buffer can be deleted and current directory can't be changed.
(atom! int      sandbox)                ;; Non-zero when evaluating an expression in a "sandbox".
                                        ;; Several things are not allowed then.

(atom! boolean  silent_mode)            ;; set to true when "-s" commandline argument used for ex

(atom! pos_C    VIsual      (§_pos_C))  ;; start position of active Visual selection
(atom! boolean  VIsual_active)          ;; whether Visual mode is active
(atom! boolean  VIsual_select)          ;; whether Select mode is active
(atom! boolean  VIsual_reselect)        ;; whether to restart the selection after a Select mode mapping or menu

(atom! int      VIsual_mode \v)         ;; type of Visual mode

(atom! boolean  redo_VIsual_busy)       ;; true when redoing Visual

;; When pasting text with the middle mouse button in visual mode with
;; restart_edit set, remember where it started so we can set insStart.

(atom! pos_C    where_paste_started     (§_pos_C))

;; This flag is used to make auto-indent work right on lines where only a
;; <RETURN> or <ESC> is typed.  It is set when an auto-indent is done, and
;; reset when any other editing is done on the line.  If an <ESC> or <RETURN>
;; is received, and did_ai is true, the line is truncated.

(atom! boolean  did_ai)

;; Column of first char after autoindent.  0 when no autoindent done.
;; Used when 'backspace' is 0, to avoid backspacing over autoindent.

(atom! int      ai_col)

;; This is a character which will end a start-middle-end comment when typed as
;; the first character on a new line.  It is taken from the last character of
;; the "end" comment leader when the COM_AUTO_END flag is given for that
;; comment end in 'comments'.  It is only valid when did_ai is true.

(atom! int      end_comment_pending     NUL)

;; This flag is set after a ":syncbind" to let the check_scrollbind() function
;; know that it should not attempt to perform scrollbinding due to the scroll
;; that was a result of the ":syncbind." (Otherwise, check_scrollbind() will
;; undo some of the work done by ":syncbind.")  -ralston

(atom! boolean  did_syncbind)

;; This flag is set when a smart indent has been performed.
;; When the next typed character is a '{' the inserted tab will be deleted again.

(atom! boolean  did_si)

;; This flag is set after an auto indent.
;; If the next typed character is a '}' one indent will be removed.

(atom! boolean  can_si)

;; This flag is set after an "O" command.
;; If the next typed character is a '{' one indent will be removed.

(atom! boolean  can_si_back)

(atom! pos_C    saved_cursor    (§_pos_C)) ;; w_cursor before formatting text.

;; Stuff for insert mode.
;; This is where the latest insert/append mode started.

(atom! pos_C    insStart        (§_pos_C))

;; This is where the latest insert/append mode started.  In contrast to
;; insStart, this won't be reset by certain keys and is needed for
;; op_insert(), to detect correctly where inserting by the user started.

(atom! pos_C    insStart_orig   (§_pos_C))

;; Stuff for VREPLACE mode.

(atom! long     orig_line_count)    ;; Line count when "gR" started
(atom! int      vr_lines_changed)   ;; #Lines changed by "gR" so far

;; "State" is the main state of Vim.
;; There are other variables that modify the state:
;; "Visual_mode"    When State is NORMAL or INSERT.
;; "finish_op"      When State is NORMAL, after typing the operator and before typing the motion command.

(atom! int      State NORMAL)       ;; This is the current state of the command interpreter.

(atom! boolean  finish_op)          ;; true while an operator is pending
(atom! long     opcount)            ;; count for pending operator

;; ex mode (Q) state

(atom! int      exmode_active)      ;; zero, EXMODE_NORMAL or EXMODE_VIM
(atom! boolean  ex_no_reprint)      ;; no need to print after z or p

(atom! boolean  Recording)          ;; true when recording into a reg.
(atom! boolean  execReg)            ;; true when executing a register

(atom! int      no_mapping)         ;; currently no mapping allowed
(atom! int      no_zero_mapping)    ;; mapping zero not allowed
(atom! int      allow_keys)         ;; allow key codes when no_mapping is set
(atom! int      no_u_sync)          ;; Don't call u_sync()
(atom! int      u_sync_once)        ;; Call u_sync() once when evaluating an expression.

(atom! int      restart_edit)       ;; call edit when next cmd finished
(atom! boolean  arrow_used)         ;; Normally false, set to true after hitting cursor key in insert mode.
                                    ;; Used by vgetorpeek() to decide when to call u_sync()
(atom! boolean  ins_at_eol)         ;; put cursor after eol when restarting edit after CTRL-O

(atom! boolean  no_abbr     true)   ;; true when no abbreviations loaded

(atom! int      mapped_ctrl_c)              ;; modes where CTRL-C is mapped
(atom! boolean  ctrl_c_interrupts true)     ;; CTRL-C sets got_int

(atom! cmdmod_C cmdmod      (§_cmdmod_C))   ;; Ex command modifiers

(atom! int      msg_silent)                 ;; don't print messages
(atom! int      emsg_silent)                ;; don't print error messages
(atom! boolean  cmd_silent)                 ;; don't echo the command line

(atom! Bytes    ioBuff)                             ;; sprintf's are done in this buffer, size is IOSIZE
(atom! Bytes    nameBuff)                           ;; file names are expanded in this buffer, size is MAXPATHL
(final Bytes    msg_buf     (Bytes. MSG_BUF_LEN))   ;; small buffer for messages

(atom! int      redrawingDisabled)          ;; When non-zero, postpone redrawing.

(atom! boolean  readonlymode)               ;; set to true for "view"

(atom! typebuf_C typebuf    (§_typebuf_C))  ;; typeahead buffer
(atom! int      ex_normal_busy)             ;; recursiveness of ex_normal()
(atom! int      ex_normal_lock)             ;; forbid use of ex_normal()
(atom! boolean  ignore_script)              ;; ignore script input
(atom! boolean  stop_insert_mode)           ;; for ":stopinsert" and 'insertmode'

(atom! boolean  keyTyped)                   ;; true if user typed current char
(atom! boolean  keyStuffed)                 ;; true if current char from stuffbuf
(atom! int      maptick)                    ;; tick for each non-mapped char

(final byte*    chartab     256)            ;; table used in charset.c; see init_chartab()

(atom! int      must_redraw)                ;; type of redraw necessary
(atom! boolean  skip_redraw)                ;; skip redraw once
(atom! boolean  do_redraw)                  ;; extra redraw once

(atom! boolean  need_highlight_changed true)

(atom! int      read_cmd_fd)                ;; fd to read commands from

;; volatile because it is used in signal handler catch_sigint().
(atom! #_"/*volatile*/transient" boolean got_int) ;; set to true when interrupt signal occurred

(atom! boolean  termcap_active)             ;; set by starttermcap()
(atom! int      cur_tmode       TMODE_COOK) ;; input terminal mode
(atom! boolean  bangredo)                   ;; set to true with ! command
(atom! int      searchcmdlen)               ;; length of previous search cmd
(atom! int      reg_do_extmatch)            ;; Used when compiling regexp:
                                                        ;; REX_SET to allow \z\(...\),
                                                        ;; REX_USE to allow \z\1 et al.
(atom! reg_extmatch_C re_extmatch_in)       ;; Used by vim_regexec():
                                                        ;; strings for \z\1...\z\9
(atom! reg_extmatch_C re_extmatch_out)      ;; Set by vim_regexec()
                                                        ;; to store \z\(...\) matches

(atom! boolean  undo_off)                   ;; undo switched off for now
(atom! int      global_busy)                ;; set when :global is executing
(atom! boolean  listcmd_busy)               ;; set when :argdo, :windo or :bufdo is executing
(atom! boolean  need_start_insertmode)      ;; start insert mode soon
(atom! Bytes    last_cmdline)               ;; last command line (for ":)
(atom! Bytes    repeat_cmdline)             ;; command line for "."
(atom! Bytes    new_last_cmdline)           ;; new value for "last_cmdline"
(atom! boolean  did_cursorhold)             ;; set when CursorHold t'gerd
(atom! pos_C    last_cursormoved    (§_pos_C)) ;; for CursorMoved event
(atom! int      last_changedtick)           ;; for TextChanged event
(atom! buffer_C last_changedtick_buf)

(atom! int      postponed_split)            ;; for CTRL-W CTRL-] command
(atom! int      postponed_split_flags)      ;; args for win_split()
(atom! int      replace_offset)             ;; offset for replace_push()

(final Bytes    escape_chars (u8 " \t\\\"|")) ;; need backslash in cmd line

;; When a string option is null (which only happens in out-of-memory situations),
;; it is set to EMPTY_OPTION to avoid having to check for null everywhere.

(final Bytes EMPTY_OPTION (u8 ""))

(atom! boolean* breakat_flags 256) ;; which characters are in 'breakat'

;; Characters from 'fillchars' option.
(atom! int
    fill_stl    \space,
    fill_stlnc  \space,
    fill_vert   \space,
    fill_fold   \-,
    fill_diff   \-)

;; Characters from 'listchars' option.
(atom! int
    lcs_eol     \$,
    lcs_ext     NUL,
    lcs_prec    NUL,
    lcs_nbsp    NUL,
    lcs_tab1    NUL,
    lcs_tab2    NUL,
    lcs_trail   NUL,
    lcs_conceal \space)

;; Whether 'keymodel' contains "stopsel" and "startsel".
(atom! boolean  km_stopsel)
(atom! boolean  km_startsel)

(atom! int      cedit_key -1)         ;; key value of 'cedit' option
(atom! int      cmdwin_type)            ;; type of cmdline window or 0
(atom! int      cmdwin_result)          ;; result of cmdline window or 0

(final Bytes    no_lines_msg (u8 "--No lines in buffer--"))

;; When ":global" is used to number of substitutions and changed lines is
;; accumulated until it's finished.

(atom! long     sub_nsubs)              ;; total number of substitutions
(atom! long     sub_nlines)             ;; total number of lines changed

;; don't use 'hlsearch' temporarily
(atom! boolean  no_hlsearch)

(atom! boolean  typebuf_was_filled)     ;; received text from client or from feedkeys()

(atom! boolean  term_is_xterm)          ;; xterm-like 'term'

;; Set to TRUE when an operator is being executed with virtual editing,
;; MAYBE when no operator is being executed, FALSE otherwise.

(atom! maybean  virtual_op  MAYBE)

;; Display tick, incremented for each call to update_screen().
(atom! short    display_tick)

;; Set when the cursor line needs to be redrawn.
(atom! boolean  need_cursor_line_redraw)

;; The error messages that can be shared are included here.
;; Excluded are errors that are only used once.

(final Bytes
    e_abort           (u8 "E470: Command aborted"),
    e_argreq          (u8 "E471: Argument required"),
    e_backslash       (u8 "E10: \\ should be followed by /, ? or &"),
    e_cmdwin          (u8 "E11: Invalid in command-line window; <CR> executes, CTRL-C quits"),
    e_curdir          (u8 "E12: Command not allowed from exrc/vimrc in current dir"),
    e_internal        (u8 "E473: Internal error"),
    e_interr          (u8 "Interrupted"),
    e_invaddr         (u8 "E14: Invalid address"),
    e_invarg          (u8 "E474: Invalid argument"),
    e_invarg2         (u8 "E475: Invalid argument: %s"),
    e_invrange        (u8 "E16: Invalid range"),
    e_invcmd          (u8 "E476: Invalid command"),
    e_markinval       (u8 "E19: Mark has invalid line number"),
    e_marknotset      (u8 "E20: Mark not set"),
    e_modifiable      (u8 "E21: Cannot make changes, 'modifiable' is off"),
    e_noabbr          (u8 "E24: No such abbreviation"),
    e_nobang          (u8 "E477: No ! allowed"),
    e_noinstext       (u8 "E29: No inserted text yet"),
    e_nolastcmd       (u8 "E30: No previous command line"),
    e_nomap           (u8 "E31: No such mapping"),
    e_nopresub        (u8 "E33: No previous substitute regular expression"),
    e_noprevre        (u8 "E35: No previous regular expression"),
    e_norange         (u8 "E481: No range allowed"),
    e_noroom          (u8 "E36: Not enough room"),
    e_nowrtmsg        (u8 "E37: No write since last change (add ! to override)"),
    e_nowrtmsg_nobang (u8 "E37: No write since last change"),
    e_null            (u8 "E38: Null argument"),
    e_number_exp      (u8 "E39: Number expected"),
    e_patnotf2        (u8 "E486: Pattern not found: %s"),
    e_positive        (u8 "E487: Argument must be positive"),
    e_prev_dir        (u8 "E459: Cannot go back to previous directory"),
    e_re_damg         (u8 "E43: Damaged match string"),
    e_re_corr         (u8 "E44: Corrupted regexp program"),
    e_sandbox         (u8 "E48: Not allowed in sandbox"),
    e_secure          (u8 "E523: Not allowed here"),
    e_screenmode      (u8 "E359: Screen mode setting not supported"),
    e_scroll          (u8 "E49: Invalid scroll size"),
    e_toocompl        (u8 "E74: Command too complex"),
    e_toomsbra        (u8 "E76: Too many ["),
    e_trailing        (u8 "E488: Trailing characters"),
    e_umark           (u8 "E78: Unknown mark"),
    e_winheight       (u8 "E591: 'winheight' cannot be smaller than 'winminheight'"),
    e_winwidth        (u8 "E592: 'winwidth' cannot be smaller than 'winminwidth'"),
    e_zerocount       (u8 "Zero count"),
    e_intern2         (u8 "E685: Internal error: %s"),
    e_maxmempat       (u8 "E363: pattern uses more memory than 'maxmempattern'"),
    e_emptybuf        (u8 "E749: empty buffer"),
    e_nobufnr         (u8 "E86: Buffer %ld does not exist"))

;; For undo we need to know the lowest time possible.
(atom! long starttime)

;; ----------------------------------------------------------------------- ;;

;; values for vim_handle_signal() that are not a signal
(final int SIGNAL_BLOCK    -1)
(final int SIGNAL_UNBLOCK  -2)

;; behavior for bad character, "++bad=" argument
(final byte BAD_REPLACE    \?)      ;; replace it with '?' (default)
(final int BAD_KEEP        -1)      ;; leave it
(final int BAD_DROP        -2)      ;; erase it

;; flags for buf_freeall()
(final int BFA_DEL         1)       ;; buffer is going to be deleted
(final int BFA_WIPE        2)       ;; buffer is going to be wiped out
(final int BFA_KEEP_UNDO   4)       ;; do not free undo information

;; direction for nv_mousescroll() and ins_mousescroll()
(final int MSCR_DOWN       0)       ;; DOWN must be false
(final int MSCR_UP         1)
(final int MSCR_LEFT       -1)
(final int MSCR_RIGHT      -2)

(final int KEYLEN_PART_KEY -1)      ;; keylen value for incomplete key-code
(final int KEYLEN_PART_MAP -2)      ;; keylen value for incomplete mapping
(final int KEYLEN_REMOVED  9999)    ;; keylen value for removed sequence

;; Option types for various functions in option.c.
(final int SREQ_GLOBAL     0)       ;; Request global option
(final int SREQ_WIN        1)       ;; Request window-local option
(final int SREQ_BUF        2)       ;; Request buffer-local option

;; Flags for get_reg_contents().
(final int GREG_NO_EXPR    1)       ;; Do not allow expression register
(final int GREG_EXPR_SRC   2)       ;; Return expression itself for "=" register

;; Character used as separated in autoload function/variable names.
(final byte AUTOLOAD_CHAR \#)

;; Position comparisons

(defn- #_boolean ltpos [#_pos_C a, #_pos_C b]
    (§
;       return (a.lnum != b.lnum) ? (a.lnum < b.lnum) : (a.col != b.col) ? (a.col < b.col) : (a.coladd < b.coladd);
    ))

(defn- #_boolean eqpos [#_pos_C a, #_pos_C b]
    (§
;       return (a.lnum == b.lnum) && (a.col == b.col) && (a.coladd == b.coladd);
    ))

(defn- #_boolean ltoreq [#_pos_C a, #_pos_C b]
    (§
;       return ltpos(a, b) || eqpos(a, b);
    ))

(defn- #_void clearpos [#_pos_C a]
    (§
;       a.lnum = 0;
;       a.col = 0;
;       a.coladd = 0;
    ))

;; lineempty() - return true if the line is empty

(defn- #_boolean lineempty [#_long lnum]
    (§
;       return (ml_get(lnum).at(0) == NUL);
    ))

;; bufempty() - return true if the current buffer is empty

(defn- #_boolean bufempty []
    (§
;       return (@curbuf.b_ml.ml_line_count == 1 && ml_get(1).at(0) == NUL);
    ))

;;; ============================================================================================== VimG

;; Struct for various parameters passed between main() and other functions.
(class! #_final mparm_C
    [
        (field int      argc)
        (field Bytes*   argv)

        (field int      edit_type)              ;; type of editing to do

        (field boolean  stdout_isatty)          ;; is stdout a terminal?
        (field Bytes    term)                   ;; specified terminal name
    ])

;; Values for edit_type.

(final int EDIT_NONE   0)       ;; no edit type yet
(final int EDIT_FILE   1)       ;; file name argument[s] given, use argument list
(final int EDIT_STDIN  2)       ;; read file from stdin

;; Different types of error messages.

(final int ME_UNKNOWN_OPTION       0)
(final int ME_TOO_MANY_ARGS        1)
(final int ME_ARG_MISSING          2)
(final int ME_GARBAGE              3)

(final Bytes* main_errors
    [
        (u8 "Unknown option argument"),
        (u8 "Too many edit arguments"),
        (u8 "Argument missing after"),
        (u8 "Garbage after option argument"),
    ])

(defn #_int _main [#_int argc, #_Bytes* argv]
    (§
;       @starttime = libC._time();

;       mparm_C params = §_mparm_C();
        ;; Many variables are in "params" so that we can pass them to invoked
        ;; functions without a lot of arguments.  "argc" and "argv" are also
        ;; copied, so that they can be changed.
;       params.argc = argc;
;       params.argv = argv;

        ;; Init the table of Normal mode commands.
;       init_normal_cmds();

        ;; Allocate space for the generic buffers (needed for set_init_1() and emsg2()).

;       @ioBuff = new Bytes(IOSIZE);
;       @nameBuff = new Bytes(MAXPATHL);

;       clip_init(false);                       ;; initialise clipboard stuff

        ;; Check if we have an interactive window.

;       params.stdout_isatty = mch_output_isatty();

        ;; Allocate the first window and buffer.
        ;; Can't do anything without it, exit when it fails.

;       win_alloc_first();

;       init_yank();                            ;; init yank buffers

        ;; Set the default values for the options.

;       set_init_1();

        ;; Figure out the way to work from the command name argv[0].
        ;; "vimdiff" starts diff mode, "rvim" sets "restricted", etc.

;       parse_command_name(params);

        ;; Process the command line arguments.
;       command_line_scan(params);

        ;; Don't redraw until much later.
;       @redrawingDisabled++;

        ;; mch_init() sets up the terminal (window) for use.
        ;; This must be done after resetting full_screen, otherwise it may move the cursor (MSDOS).
        ;; Note that we may use mch_exit() before mch_init()!

;       mch_init();

        ;; Print a warning if stdout is not a terminal.

;       check_tty(params);

;       if (!@silent_mode)
;       {
;           termcapinit(params.term);           ;; set terminal name and get terminal
                                                ;; capabilities (will set full_screen)
;           screen_start();                     ;; don't know where cursor is now
;       }

        ;; Set the default values for the options that use Rows and Columns.

;       ui_get_shellsize();                     ;; inits Rows and Columns
;       win_init_size();

;       @cmdline_row = (int)(@Rows - @p_ch);
;       @msg_row = @cmdline_row;
;       screenalloc(false);                     ;; allocate screen buffers
;       set_init_2();

;       @msg_scroll = true;
;       @no_wait_return = TRUE;

;       init_mappings();                        ;; set up initial mappings

;       init_highlight(true, false);            ;; set the default highlight groups

        ;; Start putting things on the screen.
        ;; Scroll screen down before drawing over it.
        ;; Clear screen now, so file message will not be cleared.

;       @starting = NO_BUFFERS;
;       @no_wait_return = FALSE;
;       if (@exmode_active == 0)
;           @msg_scroll = false;

        ;; If "-" argument given: Read file from stdin.
        ;; Do this before starting Raw mode, because it may change things that the
        ;; writing end of the pipe doesn't like, e.g., in case stdin and stderr
        ;; are the same terminal: "cat | vim -".
        ;; Using autocommands here may cause trouble...

;       if (params.edit_type == EDIT_STDIN)
;           read_stdin();

        ;; When switching screens and something caused a message from a vimrc script,
        ;; need to output an extra newline on exit.
;       if ((@did_emsg || @msg_didout) && @T_TI.at(0) != NUL)
;           @newline_on_exit = true;

        ;; When done something that is not allowed or error message call wait_return.
        ;; This must be done before starttermcap(), because it may switch to another screen.
        ;; It must be done after settmode(TMODE_RAW), because we want to react on a single key stroke.
        ;; Call settmode and starttermcap here, so the T_KS and T_TI may be defined
        ;; by termcapinit and redefined in .exrc.

;       settmode(TMODE_RAW);

;       if (@need_wait_return || @msg_didany)
;           wait_return(TRUE);

;       starttermcap();                         ;; start termcap if not done by wait_return()
;       may_req_ambiguous_char_width();

;       setmouse();                             ;; may start using the mouse
;       if (@scroll_region)
;           scroll_region_reset();              ;; in case Rows changed
;       scroll_start();                         ;; may scroll the screen to the right position

        ;; Don't clear the screen when starting in Ex mode, unless using the GUI.

;       if (@exmode_active != 0)
;           @must_redraw = CLEAR;
;       else
;           screenclear();                      ;; clear screen

;       @no_wait_return = TRUE;

        ;; Create the requested number of windows and edit buffers in them.

;       create_windows(params);

        ;; Ex starts at last line of the file.
;       if (@exmode_active != 0)
;           @curwin.w_cursor.lnum = @curbuf.b_ml.ml_line_count;

;       setpcmark();

        ;; If opened more than one window, start editing files in the other windows.

;       edit_buffers(params);

;       @redrawingDisabled = 0;
;       redraw_all_later(NOT_VALID);
;       @no_wait_return = FALSE;
;       @starting = 0;

        ;; Requesting the termresponse is postponed until here, so that a "-c q"
        ;; argument doesn't make it appear in the shell Vim was started from.
;       may_req_termresponse();

        ;; start in insert mode
;       if (@p_im)
;           @need_start_insertmode = true;

        ;; If ":startinsert" command used, stuff a dummy command to be
        ;; able to call normal_cmd(), which will then start Insert mode.
;       if (@restart_edit != 0)
;           stuffcharReadbuff(K_NOP);

        ;; Call the main command loop.  This never returns.

;       main_loop(false, false);

;       return 0;
    ))

;; Main loop: Execute Normal mode commands until exiting Vim.
;; Also used to handle commands in the command-line window, until the window is closed.
;; Also used to handle ":visual" command after ":global": execute Normal mode commands,
;; return when entering Ex mode.  "noexmode" is true then.

(defn- #_void main_loop [#_boolean cmdwin, #_boolean noexmode]
    ;; cmdwin: true when working in the command-line window
    ;; noexmode: true when return on entering Ex mode
    (§
;       /*volatile*//*transient */boolean previous_got_int = false;     ;; "got_int" was true

;       long conceal_old_cursor_line = 0;
;       long conceal_new_cursor_line = 0;
;       boolean conceal_update_lines = false;

;       oparg_C oa = §_oparg_C();                     ;; operator arguments

;       while (!cmdwin || @cmdwin_result == 0)
;       {
;           if (stuff_empty())
;           {
;               @did_check_timestamps = false;
;               if (@need_check_timestamps)
;                   check_timestamps(false);
;               if (@need_wait_return)                   ;; if wait_return still needed ...
;                   wait_return(FALSE);                 ;; ... call it now
;               if (@need_start_insertmode && goto_im() && !@VIsual_active)
;               {
;                   @need_start_insertmode = false;
;                   stuffReadbuff(u8("i"));                 ;; start insert mode next
                    ;; skip the fileinfo message now,
                    ;; because it would be shown after insert mode finishes!
;                   @need_fileinfo = false;
;               }
;           }

            ;; Reset "got_int" now that we got back to the main loop.  Except when inside
            ;; a ":g/pat/cmd" command, then the "got_int" needs to abort the ":g" command.
            ;; For ":g/pat/vi" we reset "got_int" when used once.  When used
            ;; a second time we go back to Ex mode and abort the ":g" command.
;           if (@got_int)
;           {
;               if (noexmode && @global_busy != 0 && @exmode_active == 0 && previous_got_int)
;               {
                    ;; Typed two CTRL-C in a row: go back to ex mode as if "Q" was used
                    ;; and keep "got_int" set, so that it aborts ":g".
;                   @exmode_active = EXMODE_NORMAL;
;                   @State = NORMAL;
;               }
;               else if (@global_busy == 0 || @exmode_active == 0)
;               {
;                   if (!@quit_more)
;                       vgetc();                ;; flush all buffers
;                   @got_int = false;
;               }
;               previous_got_int = true;
;           }
;           else
;               previous_got_int = false;

;           if (@exmode_active == 0)
;               @msg_scroll = false;
;           @quit_more = false;

            ;; If skip redraw is set (for ":" in wait_return()), don't redraw now.
            ;; If there is nothing in the stuff_buffer or do_redraw is true, update cursor and redraw.

;           if (@skip_redraw || @exmode_active != 0)
;               @skip_redraw = false;
;           else if (@do_redraw || stuff_empty())
;           {
                ;; Trigger CursorMoved if the cursor moved.
;               if (!@finish_op && 0 < @curwin.w_onebuf_opt.@wo_cole && !eqpos(@last_cursormoved, @curwin.w_cursor))
;               {
;                   conceal_old_cursor_line = @last_cursormoved.lnum;
;                   conceal_new_cursor_line = @curwin.w_cursor.lnum;
;                   conceal_update_lines = true;

;                   COPY_pos(@last_cursormoved, @curwin.w_cursor);
;               }

                ;; Before redrawing, make sure w_topline is correct,
                ;; and w_leftcol if lines don't wrap, and w_skipcol if lines wrap.

;               update_topline();
;               validate_cursor();

;               if (@VIsual_active)
;                   update_curbuf(INVERTED);    ;; update inverted part
;               else if (@must_redraw != 0)
;                   update_screen(0);
;               else if (@redraw_cmdline || @clear_cmdline)
;                   showmode();
;               redraw_statuslines();
                ;; display message after redraw
;               if (@keep_msg != null)
;               {
                    ;; msg_attr_keep() will set "keep_msg" to null, must free the string here.
                    ;; Don't reset "keep_msg", msg_attr_keep() uses it to check for duplicates.
;                   msg_attr(@keep_msg, @keep_msg_attr);
;               }
;               if (@need_fileinfo)          ;; show file info after redraw
;               {
;                   fileinfo(0, false);
;                   @need_fileinfo = false;
;               }

;               @emsg_on_display = false;    ;; can delete error message now
;               @did_emsg = false;
;               @msg_didany = false;         ;; reset lines_left in msg_start()
;               may_clear_sb_text();        ;; clear scroll-back text on next msg
;               showruler(false);

;               if (conceal_update_lines
;                   && (conceal_old_cursor_line != conceal_new_cursor_line || conceal_cursor_line(@curwin) || @need_cursor_line_redraw))
;               {
;                   if (conceal_old_cursor_line != conceal_new_cursor_line && conceal_old_cursor_line <= @curbuf.b_ml.ml_line_count)
;                       update_single_line(@curwin, conceal_old_cursor_line);
;                   update_single_line(@curwin, conceal_new_cursor_line);
;                   @curwin.w_valid &= ~VALID_CROW;
;               }
;               setcursor();
;               cursor_on();

;               @do_redraw = false;
;           }

            ;; Update w_curswant if w_set_curswant has been set.
            ;; Postponed until here to avoid computing w_virtcol too often.

;           update_curswant();

            ;; If we're invoked as ex, do a round of ex commands.
            ;; Otherwise, get and execute a normal mode command.

;           if (@exmode_active != 0)
;           {
;               if (noexmode)   ;; End of ":global/path/visual" commands
;                   return;
;               do_exmode(@exmode_active == EXMODE_VIM);
;           }
;           else
;               normal_cmd(oa, true);
;       }
    ))

;; Exit properly.
(defn- #_void getout [#_int exitval]
    (§
;       @exiting = true;

        ;; When running in Ex mode an error causes us to exit with a non-zero exit code.
        ;; POSIX requires this, although it's not 100% clear from the standard.
;       if (@exmode_active != 0)
;           exitval += @ex_exitval;

        ;; Position the cursor on the last screen line, below all the text.
;       windgoto((int)@Rows - 1, 0);

;       if (@did_emsg)
;       {
            ;; give the user a chance to read the (error) message
;           @no_wait_return = FALSE;
;           wait_return(FALSE);
;       }

        ;; Position the cursor again, the autocommands may have moved it.
;       windgoto((int)@Rows - 1, 0);

;       mch_exit(exitval);
    ))

;; Get a (optional) count for a Vim argument.

(defn- #_int get_number_arg [#_Bytes p, #_int* idx, #_int def]
    ;; p: pointer to argument
    ;; idx: index in argument, is incremented
    ;; def: default value
    (§
;       if (asc_isdigit(p.at(idx[0])))
;       {
;           def = libC.atoi(p.plus(idx[0]));
;           while (asc_isdigit(p.at(idx[0])))
;               idx[0] += 1;
;       }
;       return def;
    ))

;; Check for: [r][e][vi|vim|view][ex[im]]
;; If the executable name starts with "r" we disable shell commands.
;; If the next character is "e" we run in Easy mode.
;; If the next characters are "view" we start in readonly mode.
;; If the next characters are "ex" we start in Ex mode.  If it's followed
;; by "im" use improved Ex mode.

(defn- #_void parse_command_name [#_mparm_C parmp]
    (§
;       Bytes s = gettail(parmp.argv[0]);

;       if (asc_tolower(s.at(0)) == 'r')
;       {
;           @restricted = true;
;           s = s.plus(1);
;       }

;       if (STRNCASECMP(s, u8("view"), 4) == 0)
;       {
;           @readonlymode = true;
;           @curbuf.@b_p_ro = true;
;           s = s.plus(4);
;       }
;       else if (STRNCASECMP(s, u8("vim"), 3) == 0)
;           s = s.plus(3);

;       if (STRNCASECMP(s, u8("ex"), 2) == 0)
;       {
;           if (STRNCASECMP(s.plus(2), u8("im"), 2) == 0)
;               @exmode_active = EXMODE_VIM;
;           else
;               @exmode_active = EXMODE_NORMAL;
;       }
    ))

;; Scan the command line arguments.

(defn- #_void command_line_scan [#_mparm_C parmp]
    (§
;       int argc = parmp.argc;
;       Bytes[] argv = parmp.argv;
;       --argc;
;       int i = 1;

;       boolean had_minmin = false;     ;; found "--" argument
;       int[] ai = { 1 };               ;; active option letter is argv[i].at(ai[0])

;       while (0 < argc)
;       {
            ;; "+" or "+{number}" or "+/{pat}" or "+{command}" argument.

;           if (argv[i].at(0) == (byte)'+' && !had_minmin)
;           {
;               ai[0] = -1;                         ;; skip to next argument
;           }

            ;; Optional argument.

;           else if (argv[i].at(0) == (byte)'-' && !had_minmin)
;           {
;               boolean want_argument = false;
;               int c = argv[i].at(ai[0]++);
;               switch (c)
;               {
;                   case NUL:
;                   {
;                       if (@exmode_active != 0)     ;; "ex -" silent mode
;                           @silent_mode = true;
;                       else                        ;; "vim -" read from stdin
;                       {
;                           if (parmp.edit_type != EDIT_NONE)
;                               mainerr(ME_TOO_MANY_ARGS, argv[i]);
;                           parmp.edit_type = EDIT_STDIN;
;                           @read_cmd_fd = 2;        ;; read from stderr instead of stdin
;                       }
;                       ai[0] = -1;                 ;; skip to next argument
;                       break;
;                   }

;                   case '-':
;                   {
                        ;; "--" don't take any more option arguments
                        ;; "--help" give help message
;                       if (STRCASECMP(argv[i].plus(ai[0]), u8("help")) == 0)
;                           usage();
;                       else
;                       {
;                           if (argv[i].at(ai[0]) != NUL)
;                               mainerr(ME_UNKNOWN_OPTION, argv[i]);
;                           had_minmin = true;
;                       }
;                       if (!want_argument)
;                           ai[0] = -1;             ;; skip to next argument
;                       break;
;                   }

;                   case 'b':                       ;; "-b" binary mode
;                   {
                        ;; Needs to be effective before expanding file names,
                        ;; because for Win32 this makes us edit a shortcut file itself,
                        ;; instead of the file it links to.
;                       set_options_bin(@curbuf.@b_p_bin, true, 0);
;                       @curbuf.@b_p_bin = true;   ;; binary file I/O
;                       break;
;                   }

;                   case 'e':                       ;; "-e" Ex mode
;                       @exmode_active = EXMODE_NORMAL;
;                       break;

;                   case 'E':                       ;; "-E" Improved Ex mode
;                       @exmode_active = EXMODE_VIM;
;                       break;

;                   case 'h':                       ;; "-h" give help message
;                       usage();
;                       break;

;                   case 'l':                       ;; "-l" lisp mode, 'lisp' and 'showmatch' on
;                       set_option_value(u8("lisp"), 1L, null, 0);
;                       @p_sm = true;
;                       break;

;                   case 'M':                       ;; "-M" no changes or writing of files
;                       reset_modifiable();
                        ;; FALLTHROUGH
;                   case 'm':                       ;; "-m" no writing of files
;                       @p_write = false;
;                       break;

;                   case 'R':                       ;; "-R" readonly mode
;                       @readonlymode = true;
;                       @curbuf.@b_p_ro = true;
;                       break;

;                   case 'v':                       ;; "-v" Vi-mode (as if called "vi")
;                       @exmode_active = 0;
;                       break;

;                   case 'Z':                       ;; "-Z" restricted mode
;                       @restricted = true;
;                       break;

;                   case 'T':                       ;; "-T {terminal}" terminal name
;                       want_argument = true;
;                       break;

;                   default:
;                       mainerr(ME_UNKNOWN_OPTION, argv[i]);
;                       break;
;               }

                ;; Handle option arguments with argument.

;               if (want_argument)
;               {
                    ;; Check for garbage immediately after the option letter.

;                   if (argv[i].at(ai[0]) != NUL)
;                       mainerr(ME_GARBAGE, argv[i]);

;                   --argc;
;                   if (argc < 1)
;                       mainerr_arg_missing(argv[i]);
;                   i++;
;                   ai[0] = -1;

;                   switch (c)
;                   {
;                       case 'T':                   ;; "-T {terminal}" terminal name

                            ;; The -T term argument is always available and when
                            ;; HAVE_TERMLIB is supported it overrides the environment variable TERM.

;                           parmp.term = argv[i];
;                           break;
;                   }
;               }
;           }

            ;; File name argument.

;           else
;           {
;               ai[0] = -1;                      ;; skip to next argument

                ;; Check for only one type of editing.
;               if (parmp.edit_type != EDIT_NONE && parmp.edit_type != EDIT_FILE)
;                   mainerr(ME_TOO_MANY_ARGS, argv[i]);
;               parmp.edit_type = EDIT_FILE;

                ;; Add the file to the global argument list.
                
;           }

            ;; If there are no more letters after the current "-", go to next argument.
            ;; "ai" is set to -1 when the current argument is to be skipped.

;           if (ai[0] <= 0 || argv[i].at(ai[0]) == NUL)
;           {
;               --argc;
;               i++;
;               ai[0] = 1;
;           }
;       }
    ))

;; Print a warning if stdout is not a terminal.
;; When starting in Ex mode and commands come from a file, set Silent mode.

(defn- #_void check_tty [#_mparm_C parmp]
    (§
;       boolean input_isatty = mch_input_isatty();  ;; is active input a terminal?

;       if (@exmode_active != 0)
;       {
;           if (!input_isatty)
;               @silent_mode = true;
;       }
;       else if (!parmp.stdout_isatty || !input_isatty)
;       {
;           if (!parmp.stdout_isatty)
;               libC.fprintf(stderr, u8("Vim: Warning: Output is not to a terminal\n"));
;           if (!input_isatty)
;               libC.fprintf(stderr, u8("Vim: Warning: Input is not from a terminal\n"));
;           out_flush();
;           ui_delay(2000L, true);
;       }
    ))

;; Create the requested number of windows and edit buffers in them.

(defn- #_void create_windows [#_mparm_C parmp]
    (§
;       int done = 0;

        ;; Open a buffer for windows that don't have one yet.
        ;; Commands in the .vimrc might have loaded a file or split the window.
        ;; Watch out for autocommands that delete a window.

        ;; Don't execute Win/Buf Enter/Leave autocommands here

;       boolean dorewind = true;
;       while (done++ < 1000)
;       {
;           if (dorewind)
;           {
;               @curwin = @firstwin;
;           }
;           else
;           {
;               if (@curwin.w_next == null)
;                   break;
;               @curwin = @curwin.w_next;
;           }
;           dorewind = false;
;           @curbuf = @curwin.w_buffer;
;           if (@curbuf.b_ml.ml_mfp == null)
;           {
                ;; create memfile, read file
;               open_buffer(false, null, 0);

;               dorewind = true;                ;; start again
;           }
;           ui_breakcheck();
;           if (@got_int)
;           {
;               vgetc();    ;; only break the file loading, not the rest
;               break;
;           }
;       }
;       @curwin = @firstwin;
;       @curbuf = @curwin.w_buffer;
    ))

;; If opened more than one window, start editing files in the other windows.
;; make_windows() has already opened the windows.

(defn- #_void edit_buffers [#_mparm_C parmp]
    (§
        ;; make the first window the current window
;       window_C win = @firstwin;
;       win_enter(win, false);
    ))

;; Give an error message main_errors[n] and exit.

(defn- #_void mainerr [#_int n, #_Bytes str]
    ;; n: one of the ME_ defines
    ;; str: extra argument or null
    (§
;       reset_signals();            ;; kill us with CTRL-C here, if you like

;       libC.fprintf(stderr, u8("%s\n"), VIMVERSION);
;       libC.fprintf(stderr, u8("%s"), main_errors[n]);
;       if (str != null)
;           libC.fprintf(stderr, u8(": \"%s\""), str);
;       libC.fprintf(stderr, u8("\nMore info with: \"vim -h\"\n"));

;       mch_exit(1);
    ))

(defn- #_void mainerr_arg_missing [#_Bytes str]
    (§
;       mainerr(ME_ARG_MISSING, str);
    ))

;; print a message with three spaces prepended and '\n' appended.

(defn- #_void main_msg [#_Bytes s]
    (§
;       libC.fprintf(stdout, u8("   %s\n"), s);
    ))

(final Bytes* __usage
    [
        (u8 "[file ..]       edit specified file(s)"),
        (u8 "-               read text from stdin"),
    ])

;; Print messages for "vim -h" or "vim --help" and exit.

(defn- #_void usage []
    (§
;       reset_signals();            ;; kill us with CTRL-C here, if you like

;       libC.fprintf(stdout, u8("%s\n\nusage:"), VIMVERSION);
;       for (int i = 0; ; i++)
;       {
;           libC.fprintf(stdout, u8(" vim [arguments] %s"), __usage[i]);
;           if (i == __usage.length - 1)
;               break;
;           libC.fprintf(stdout, u8("\n   or:"));
;       }

;       libC.fprintf(stdout, u8("\n\nArguments:\n"));
;       main_msg(u8("--\t\t\tOnly file names after this"));
;       main_msg(u8("-v\t\t\tVi mode (like \"vi\")"));
;       main_msg(u8("-e\t\t\tEx mode (like \"ex\")"));
;       main_msg(u8("-E\t\t\tImproved Ex mode"));
;       main_msg(u8("-R\t\t\tReadonly mode (like \"view\")"));
;       main_msg(u8("-Z\t\t\tRestricted mode (like \"rvim\")"));
;       main_msg(u8("-m\t\t\tModifications (writing files) not allowed"));
;       main_msg(u8("-M\t\t\tModifications in text not allowed"));
;       main_msg(u8("-b\t\t\tBinary mode"));
;       main_msg(u8("-l\t\t\tLisp mode"));
;       main_msg(u8("-T <terminal>\tSet terminal type to <terminal>"));
;       main_msg(u8("+\t\t\tStart at end of file"));
;       main_msg(u8("+<lnum>\t\tStart at line <lnum>"));
;       main_msg(u8("-h  or  --help\tPrint Help (this message) and exit"));

;       mch_exit(0);
    ))

;;; ============================================================================================== VimH

;; os_unix.c --------------------------------------------------------------------------------------

;; volatile because it is used in signal handler sig_winch().
(atom! #_"/*volatile*/transient" boolean do_resize)
;; volatile because it is used in signal handler deathtrap().
(atom! #_"/*volatile*/transient" int deadly_signal)                     ;; the signal we caught
;; volatile because it is used in signal handler deathtrap().
(atom! #_"/*volatile*/transient" boolean in_mch_delay)                  ;; sleeping in mch_delay()

(atom! int curr_tmode TMODE_COOK)                 ;; contains current terminal mode

(class! #_final signalinfo_C
    [
        (field int      sig)        ;; Signal number, e.g. SIGSEGV etc.
        (field Bytes    name)       ;; Signal name.
        (field boolean  deadly)     ;; Catch as a deadly signal?
    ])

(final signalinfo_C* signal_info
    [
        (->signalinfo_C SIGHUP,    (u8 "HUP"),      true ),
        (->signalinfo_C SIGQUIT,   (u8 "QUIT"),     true ),
        (->signalinfo_C SIGILL,    (u8 "ILL"),      true ),
        (->signalinfo_C SIGTRAP,   (u8 "TRAP"),     true ),
        (->signalinfo_C SIGABRT,   (u8 "ABRT"),     true ),
        (->signalinfo_C SIGFPE,    (u8 "FPE"),      true ),
        (->signalinfo_C SIGBUS,    (u8 "BUS"),      true ),
        (->signalinfo_C SIGSEGV,   (u8 "SEGV"),     true ),
        (->signalinfo_C SIGSYS,    (u8 "SYS"),      true ),
        (->signalinfo_C SIGALRM,   (u8 "ALRM"),     false),
        (->signalinfo_C SIGTERM,   (u8 "TERM"),     true ),
        (->signalinfo_C SIGVTALRM, (u8 "VTALRM"),   true ),
        (->signalinfo_C SIGPROF,   (u8 "PROF"),     true ),
        (->signalinfo_C SIGXCPU,   (u8 "XCPU"),     true ),
        (->signalinfo_C SIGXFSZ,   (u8 "XFSZ"),     true ),
        (->signalinfo_C SIGUSR1,   (u8 "USR1"),     true ),
        (->signalinfo_C SIGUSR2,   (u8 "USR2"),     true ),
        (->signalinfo_C SIGINT,    (u8 "INT"),      false),
        (->signalinfo_C SIGWINCH,  (u8 "WINCH"),    false),
        (->signalinfo_C SIGTSTP,   (u8 "TSTP"),     false),
        (->signalinfo_C SIGPIPE,   (u8 "PIPE"),     false),

        (->signalinfo_C -1,        (u8 "Unknown!"), false)
    ])

(defn- #_int mch_chdir [#_Bytes path]
    (§
;       return libC.chdir(path);
    ))

;; Write s[len] to the screen.

(defn- #_void mch_write [#_Bytes s, #_int len]
    (§
;       libC.write(1, s, len);
;       if (@p_wd != 0)           ;; Unix is too fast, slow down a bit more
;           realWaitForChar(@read_cmd_fd, @p_wd);
    ))

;; mch_inchar(): low level input function.
;; Get a characters from the keyboard.
;; Return the number of characters that are available.
;; If wtime == 0 do not wait for characters.
;; If wtime == n wait a short time for characters.
;; If wtime == -1 wait forever for characters.

(defn- #_int mch_inchar [#_Bytes buf, #_int maxlen, #_long wtime, #_int tb_change_cnt]
    ;; wtime: don't use "time", MIPS cannot handle it
    (§
        ;; Check if window changed size while we were busy, perhaps the ":set columns=99" command was used.
;       while (@do_resize)
;           handle_resize();

;       if (0 <= wtime)
;       {
;           while (waitForChar(wtime) == false)         ;; no character available
;           {
;               if (!@do_resize)                     ;; return if not interrupted by resize
;                   return 0;
;               handle_resize();
;           }
;       }
;       else        ;; wtime == -1
;       {
            ;; If there is no character available within 'updatetime' seconds
            ;; flush all the swap files to disk.
            ;; Also done when interrupted by SIGWINCH.

;           if (waitForChar(@p_ut) == false)
;           {
;               if (trigger_cursorhold() && 3 <= maxlen && !typebuf_changed(tb_change_cnt))
;               {
;                   buf.be(0, KB_SPECIAL);
;                   buf.be(1, KS_EXTRA);
;                   buf.be(2, KE_CURSORHOLD);
;                   return 3;
;               }
;               before_blocking();
;           }
;       }

;       for ( ; ; )                                 ;; repeat until we got a character
;       {
;           while (@do_resize)                       ;; window changed size
;               handle_resize();

            ;; We want to be interrupted by the winch signal
            ;; or by an event on the monitored file descriptors.

;           if (waitForChar(-1L) == false)
;           {
;               if (@do_resize)                      ;; interrupted by SIGWINCH signal
;                   handle_resize();
;               return 0;
;           }

            ;; If input was put directly in typeahead buffer bail out here.
;           if (typebuf_changed(tb_change_cnt))
;               return 0;

            ;; For some terminals we only get one character at a time.
            ;; We want the get all available characters, so we could keep on trying until none is available
            ;; For some other terminals this is quite slow, that's why we don't do it.

;           int len = read_from_input_buf(buf, maxlen);
;           if (0 < len)
;               return len;
;       }
    ))

(defn- #_void handle_resize []
    (§
;       @do_resize = false;
;       shell_resized();
    ))

(defn- #_void mch_delay [#_long msec, #_boolean ignoreinput]
    (§
;       if (ignoreinput)
;       {
            ;; Go to cooked mode without echo, to allow SIGINT interrupting us here.
            ;; But we don't want QUIT to kill us (CTRL-\ used in a shell may produce SIGQUIT).
;           @in_mch_delay = true;
;           int old_tmode = @curr_tmode;
;           if (@curr_tmode == TMODE_RAW)
;               settmode(TMODE_SLEEP);

            ;; Everybody sleeps in a different way...
            ;; Prefer nanosleep(), some versions of usleep() can only sleep up to one second.

;           {
;               timespec_C ts = new timespec_C();

;               ts.tv_sec(msec / 1000);
;               ts.tv_nsec((msec % 1000) * 1000000);
;               libc.nanosleep(ts, null);
;           }

;           settmode(old_tmode);
;           @in_mch_delay = false;
;       }
;       else
;           waitForChar(msec);
    ))

;; We need correct prototypes for a signal function, otherwise mean compilers
;; will barf when the second argument to sigset() is ``wrong''.

(defn- #_void sig_winch [#_int _sigarg]
    (§
        ;; this is not required on all systems, but it doesn't hurt anybody
;       libC.sigset(SIGWINCH, /*(void (*)())sig_winch*/null);
;       @do_resize = true;
    ))

(defn- #_void catch_sigint [#_int _sigarg]
    (§
        ;; this is not required on all systems, but it doesn't hurt anybody
;       libC.sigset(SIGINT, /*(void (*)())catch_sigint*/null);
;       @got_int = true;
    ))

(defn- #_void catch_sigpwr [#_int _sigarg]
    (§
        ;; this is not required on all systems, but it doesn't hurt anybody
;       libC.sigset(SIGPWR, /*(void (*)())catch_sigpwr*/null);
    ))

(atom! int trap__entered)       ;; Count the number of times we got here.
                                            ;; Note: when memory has been corrupted
                                            ;; this may get an arbitrary value!

(defn- #_void may_core_dump []
    (§
;       if (@deadly_signal != 0)
;       {
;           libC.sigset(@deadly_signal, /*SIG_DFL*/null);
;           libc.kill(libc.getpid(), @deadly_signal);        ;; Die using the signal we caught
;       }
    ))

;; This function handles deadly signals.
;; It tries to preserve any swap files and exit properly.
;; NOTE: Avoid unsafe functions, such as allocating memory, they can result in a deadlock.

(defn- #_void deathtrap [#_int sigarg]
    (§
        ;; While in mch_delay() we go to cooked mode to allow a CTRL-C to interrupt us.
        ;; But in cooked mode we may also get SIGQUIT, e.g., when pressing CTRL-\,
        ;; but we don't want Vim to exit then.
;       if (@in_mch_delay && sigarg == SIGQUIT)
;           return;

        ;; When SIGHUP, SIGQUIT, etc. are blocked: postpone the effect and return here.
        ;; This avoids that a non-reentrant function is interrupted, e.g. free().
        ;; Calling free() again may then cause a crash.
;       if (@trap__entered == 0
;               && (sigarg == SIGHUP
;                || sigarg == SIGQUIT
;                || sigarg == SIGTERM
;                || sigarg == SIGPWR
;                || sigarg == SIGUSR1
;                || sigarg == SIGUSR2)
;               && !vim_handle_signal(sigarg))
;           return;

        ;; Remember how often we have been called.
;       @trap__entered++;

;       int i;

        ;; try to find the name of this signal
;       for (i = 0; signal_info[i].sig != -1; i++)
;           if (sigarg == signal_info[i].sig)
;               break;
;       @deadly_signal = sigarg;

;       @full_screen = false;    ;; don't write message to the GUI, it might be part of the problem...

        ;; If something goes wrong after entering here, we may get here again.
        ;; When this happens, give a message and try to exit nicely (resetting the terminal mode, etc.)
        ;; When this happens twice, just exit, don't even try to give a message,
        ;; stack may be corrupt or something weird.
        ;; When this still happens again (or memory was corrupted in such a way
        ;; that "trap__entered" was clobbered) use _exit(), don't try freeing resources.

;       if (3 <= @trap__entered)
;       {
;           reset_signals();        ;; don't catch any signals anymore
;           may_core_dump();
;           if (4 <= @trap__entered)
;               libc._exit(8);
;           libc.exit(7);
;       }
;       if (@trap__entered == 2)
;       {
;           out_str(u8("Vim: Double signal, exiting\n"));
;           out_flush();
;           getout(1);
;       }

;       libC.sprintf(@ioBuff, u8("Vim: Caught deadly signal %s\n"), signal_info[i].name);

        ;; Preserve files and exit.
;       preserve_exit();
    ))

;; If the machine has job control, use it to suspend the program,
;; otherwise fake it by starting a new shell.

(defn- #_void mch_suspend []
    (§
;       out_flush();                        ;; needed to make cursor visible on some systems
;       settmode(TMODE_COOK);
;       out_flush();                        ;; needed to disable mouse on some systems

;       libc.kill(0, SIGTSTP);              ;; send ourselves a STOP signal

;       settmode(TMODE_RAW);
;       @need_check_timestamps = true;
;       @did_check_timestamps = false;
    ))

(defn- #_void mch_init []
    (§
;       @Columns = 80;
;       @Rows = 24;

;       out_flush();
;       set_signals();
    ))

(defn- #_void set_signals []
    (§
        ;; WINDOW CHANGE signal is handled with sig_winch().

;       libC.sigset(SIGWINCH, /*(void (*)())sig_winch*/null);

        ;; We want the STOP signal to work, to make mch_suspend() work.
        ;; For "rvim" the STOP signal is ignored.

;       libC.sigset(SIGTSTP, /*@restricted ? SIG_IGN : SIG_DFL*/null);

        ;; We want to ignore breaking of PIPEs.

;       libC.sigset(SIGPIPE, /*SIG_IGN*/null);

;       catch_int_signal();

        ;; Ignore alarm signals (Perl's alarm() generates it).

;       libC.sigset(SIGALRM, /*SIG_IGN*/null);

        ;; Catch SIGPWR (power failure?) to preserve the swap files, so that no work will be lost.

;       libC.sigset(SIGPWR, /*(void (*)())catch_sigpwr*/null);

        ;; Arrange for other signals to gracefully shutdown Vim.

;       catch_signals(/*deathtrap*//*null*/0, SIG_ERR);
    ))

;; Catch CTRL-C (only works while in Cooked mode).

(defn- #_void catch_int_signal []
    (§
;       libC.sigset(SIGINT, /*(void (*)())catch_sigint*/null);
    ))

(defn- #_void reset_signals []
    (§
;       catch_signals(SIG_DFL, SIG_DFL);
    ))

(defn- #_void catch_signals #_"/*(void (*func_deadly)(), void (*func_other)())*/" [#_@sighandler_t #_long func_deadly, #_@sighandler_t #_long func_other]
    (§
;       for (int i = 0; signal_info[i].sig != -1; i++)
;       {
;           if (signal_info[i].deadly)
;           {
;            // sigaction_C sa = new sigaction_C();

                ;; Setup to use the alternate stack for the signal function.
;            // sa.sa_handler(func_deadly);
;               libC.sigemptyset(/*&sa.sa_mask*/null);
;            // sa.sa_flags(SA_ONSTACK);
;               libC.sigaction(signal_info[i].sig, /*sa*/null, null);
;           }
;           else if (func_other != SIG_ERR)
;               libC.sigset(signal_info[i].sig, /*func_other*/null);
;       }
    ))

(atom! int got_signal)
(atom! boolean __blocked true)

;; Handling of SIGHUP, SIGQUIT and SIGTERM:
;; "when" == a signal:       when busy, postpone and return false, otherwise return true
;; "when" == SIGNAL_BLOCK:   Going to be busy, block signals
;; "when" == SIGNAL_UNBLOCK: Going to wait, unblock signals, use postponed signal
;; Returns true when Vim should exit.

(defn- #_boolean vim_handle_signal [#_int sig]
    (§
;       switch (sig)
;       {
;           case SIGNAL_BLOCK:
;           {
;               @__blocked = true;
;               break;
;           }
;           case SIGNAL_UNBLOCK:
;           {
;               @__blocked = false;
;               if (@got_signal != 0)
;               {
;                   libc.kill(libc.getpid(), @got_signal);
;                   @got_signal = 0;
;               }
;               break;
;           }
;           default:
;           {
;               if (!@__blocked)
;                   return true;            ;; exit!
;               @got_signal = sig;
;               if (sig != SIGPWR)
;                   @got_int = true;         ;; break any loops
;               break;
;           }
;       }
;       return false;
    ))

;; Check_win checks whether we have an interactive stdout.

(defn- #_boolean mch_output_isatty []
    (§
;       return (libc.isatty(1) != 0);
    ))

;; Return true if the input comes from a terminal, false otherwise.

(defn- #_boolean mch_input_isatty []
    (§
;       return (libc.isatty(@read_cmd_fd) != 0);
    ))

;; Return true if "name" looks like some xterm name.

(defn- #_boolean vim_is_xterm [#_Bytes name]
    (§
;       if (name == null)
;           return false;

;       return (STRNCASECMP(name, u8("xterm"), 5) == 0
;            || STRNCASECMP(name, u8("rxvt"), 4) == 0
;            || STRCMP(name, u8("builtin_xterm")) == 0);
    ))

;; Return true if "name" appears to be that of a terminal
;; known to support the xterm-style mouse protocol.
;; Relies on term_is_xterm having been set to its correct value.

(defn- #_boolean use_xterm_like_mouse [#_Bytes name]
    (§
;       return (name != null && (@term_is_xterm || STRNCASECMP(name, u8("screen"), 6) == 0));
    ))

;; Return non-zero when using an xterm mouse, according to 'ttymouse'.
;; Return 1 for "xterm".
;; Return 2 for "xterm2".

(defn- #_int use_xterm_mouse []
    (§
;       if (@ttym_flags == TTYM_XTERM2)
;           return 2;
;       if (@ttym_flags == TTYM_XTERM)
;           return 1;

;       return 0;
    ))

(defn- #_boolean vim_is_vt300 [#_Bytes name]
    (§
;       if (name == null)
;           return false;           ;; actually all ANSI comp. terminals should be here

        ;; catch VT100 - VT5xx
;       return ((STRNCASECMP(name, u8("vt"), 2) == 0 && vim_strbyte(u8("12345"), name.at(2)) != null)
;           || STRCMP(name, u8("builtin_vt320")) == 0);
    ))

;; Return true if "name" is a terminal for which 'ttyfast' should be set.
;; This should include all windowed terminal emulators.

(defn- #_boolean vim_is_fastterm [#_Bytes name]
    (§
;       if (name == null)
;           return false;
;       if (vim_is_xterm(name) || vim_is_vt300(name))
;           return true;

;       return (STRNCASECMP(name, u8("screen"), 6) == 0);
    ))

;; Get name of current directory into buffer 'buf' of length 'len' bytes.
;; Return true for success, false for failure.

(defn- #_boolean mch_dirname [#_Bytes buf, #_int len]
    (§
;       if (!libC._getcwd(buf, len))
;       {
;           STRCPY(buf, libC.strerror(libC.errno()));
;           return false;
;       }
;       return true;
    ))

(atom! boolean dont_fchdir)     ;; true when fchdir() doesn't work

;; Get absolute file name into "buf[len]".
;;
;; return false for failure, true for success

(defn- #_boolean mch_fullName [#_Bytes fname, #_Bytes buf, #_int len, #_boolean force]
    ;; force: also expand when already absolute path
    (§
;       boolean retval = true;

        ;; expand it if forced or not an absolute path
;       if (force || !mch_isFullName(fname))
;       {
;           int fd = -1;
;           Bytes olddir = new Bytes(MAXPATHL);

            ;; If the file name has a path, change to that directory for a moment,
            ;; and then do the getwd() (and get back to where we were).
            ;; This will get the correct path name with "../" things.

;           Bytes p = vim_strrchr(fname, (byte)'/');
;           if (p != null)
;           {
                ;; Use fchdir() if possible, it's said to be faster and more reliable.
                ;; But on SunOS 4 it might not work.  Check this by doing a fchdir() right now.

;               if (!@dont_fchdir)
;               {
;                   fd = libC.open(u8("."), O_RDONLY, 0);
;                   if (0 <= fd && libc.fchdir(fd) < 0)
;                   {
;                       libc.close(fd);
;                       fd = -1;
;                       @dont_fchdir = true;     ;; don't try again
;                   }
;               }

                ;; Only change directory when we are sure we can return to where we are now.
                ;; After doing "su" chdir(".") might not work.
;               if (fd < 0 && (mch_dirname(olddir, MAXPATHL) == false || mch_chdir(olddir) != 0))
;               {
;                   p = null;       ;; can't get current dir: don't chdir
;                   retval = false;
;               }
;               else
;               {
                    ;; The directory is copied into buf[], to be able to remove the file name
                    ;; without changing it (could be a string in read-only memory)
;                   if (len <= BDIFF(p, fname))
;                       retval = false;
;                   else
;                   {
;                       vim_strncpy(buf, fname, BDIFF(p, fname));
;                       if (mch_chdir(buf) != 0)
;                           retval = false;
;                       else
;                           fname = p.plus(1);
;                       buf.be(0, NUL);
;                   }
;               }
;           }
;           if (mch_dirname(buf, len) == false)
;           {
;               retval = false;
;               buf.be(0, NUL);
;           }
;           if (p != null)
;           {
;               int l;
;               if (0 <= fd)
;               {
;                   l = libc.fchdir(fd);
;                   libc.close(fd);
;               }
;               else
;                   l = mch_chdir(olddir);
;               if (l != 0)
;                   emsg(e_prev_dir);
;           }

;           int l = STRLEN(buf);
;           if (len - 1 <= l)
;               retval = false; ;; no space for trailing "/"
;           else if (0 < l && buf.at(l - 1) != (byte)'/' && fname.at(0) != NUL && STRCMP(fname, u8(".")) != 0)
;               STRCAT(buf, u8("/"));
;       }

        ;; Catch file names which are too long.
;       if (retval == false || len <= STRLEN(buf) + STRLEN(fname))
;           return false;

        ;; Do not append ".", "/dir/." is equal to "/dir".
;       if (STRCMP(fname, u8(".")) != 0)
;           STRCAT(buf, fname);

;       return true;
    ))

;; Return true if "fname" does not depend on the current directory.

(defn- #_boolean mch_isFullName [#_Bytes fname]
    (§
;       return (fname.at(0) == (byte)'/' || fname.at(0) == (byte)'~');
    ))

;; Get file permissions for 'name'.
;; Returns -1 when it doesn't exist.

(defn- #_int mch_getperm [#_Bytes name]
    (§
;       stat_C st = new stat_C();

;       if (libC.stat(name, st) != 0)
;           return -1;

;       return st.st_mode();
    ))

;; set file permission for 'name' to 'perm'
;;
;; return false for failure, true otherwise

(defn- #_boolean mch_setperm [#_Bytes name, #_int perm]
    (§
;       return (libC.chmod(name, perm) == 0);
    ))

;; return true if "name" is a directory
;; return false if "name" is not a directory
;; return false for error

(defn- #_boolean mch_isdir [#_Bytes name]
    (§
;       if (name.at(0) == NUL)       ;; Some stat()s don't flag "" as an error.
;           return false;

;       stat_C st = new stat_C();
;       if (libC.stat(name, st) != 0)
;           return false;

;       return S_ISDIR(st.st_mode());
    ))

;; Check what "name" is:
;; NODE_NORMAL: file or directory (or doesn't exist)
;; NODE_WRITABLE: writable device, socket, fifo, etc.
;; NODE_OTHER: non-writable things

(defn- #_int mch_nodetype [#_Bytes name]
    (§
;       stat_C st = new stat_C();

;       if (libC.stat(name, st) != 0)
;           return NODE_NORMAL;
;       if (S_ISREG(st.st_mode()) || S_ISDIR(st.st_mode()))
;           return NODE_NORMAL;
;       if (S_ISBLK(st.st_mode()))  ;; block device isn't writable
;           return NODE_OTHER;
        ;; Everything else is writable?
;       return NODE_WRITABLE;
    ))

;; Output a newline when exiting.
;; Make sure the newline goes to the same stream as the text.

(defn- #_void exit_scroll []
    (§
;       if (@silent_mode)
;           return;
;       if (@newline_on_exit || @msg_didout)
;       {
;           if (msg_use_printf())
;           {
;               if (@info_message)
;                   libC.fprintf(stdout, u8("\n"));
;               else
;                   libC.fprintf(stderr, u8("\r\n"));
;           }
;           else
;               out_char((byte)'\n');
;       }
;       else
;       {
;           restore_cterm_colors();         ;; get original colors back
;           msg_clr_eos_force();            ;; clear the rest of the display
;           windgoto((int)@Rows - 1, 0);     ;; may have moved the cursor
;       }
    ))

(defn- #_void mch_exit [#_int r]
    (§
;       @exiting = true;

;       settmode(TMODE_COOK);

        ;; When t_ti is not empty, but it doesn't cause swapping terminal pages,
        ;; need to output a newline when msg_didout is set.
        ;; But when t_ti does swap pages, it should not go to the shell page.
        ;; Do this before stoptermcap().

;       if (swapping_screen() && !@newline_on_exit)
;           exit_scroll();

        ;; Stop termcap: may need to check for T_CRV response,
        ;; which requires RAW mode.
;       stoptermcap();

        ;; A newline is only required after a message in the alternate screen.
        ;; This is set to true by wait_return().
;       if (!swapping_screen() || @newline_on_exit)
;           exit_scroll();

        ;; Cursor may have been switched off without calling starttermcap()
        ;; when doing "vim -u vimrc" and vimrc contains ":q".
;       if (@full_screen)
;           cursor_on();

;       out_flush();
;       ml_close_all();
;       may_core_dump();

;       libc.exit(r);
    ))

;; for "new" tty systems

(atom! termios_C stm__told)

(defn- #_void mch_settmode [#_int tmode]
    (§
;       if (@stm__told == null)
;       {
;           @stm__told = new termios_C();
;           libc.tcgetattr(@read_cmd_fd, @stm__told);
;       }

;       termios_C tnew = new termios_C();
;       COPY_termios(tnew, @stm__told);

;       if (tmode == TMODE_RAW)
;       {
            ;; ~ICRNL enables typing ^V^M

;           tnew.c_iflag(tnew.c_iflag() & ~(ICRNL));
;           tnew.c_lflag(tnew.c_lflag() & ~(ICANON | ECHO | ISIG | ECHOE | IEXTEN));
;           tnew.c_oflag(tnew.c_oflag() & ~(ONLCR));
;           tnew.c_vmin((short)1);      ;; return after 1 char
;           tnew.c_vtime((short)0);     ;; don't wait
;       }
;       else if (tmode == TMODE_SLEEP)
;           tnew.c_lflag(tnew.c_lflag() & ~(ECHO));

        ;; A signal may cause tcsetattr() to fail (e.g., SIGCONT).  Retry a few times.
;       for (int n = 10; libc.tcsetattr(@read_cmd_fd, TCSANOW, tnew) == -1 && libC.errno() == EINTR && 0 < n; )
;           --n;

;       @curr_tmode = tmode;
    ))

;; Try to get the code for "t_kb" from the stty setting
;;
;; Even if termcap claims a backspace key, the user's setting *should*
;; prevail.  stty knows more about reality than termcap does, and if
;; somebody's usual erase key is DEL (which, for most BSD users, it will
;; be), they're going to get really annoyed if their erase key starts
;; doing forward deletes for no reason.

(defn- #_void get_stty []
    (§
        ;; for "new" tty systems
;       termios_C keys = new termios_C();

;       if (libc.tcgetattr(@read_cmd_fd, keys) != -1)
;       {
;           Bytes buf = new Bytes(2);

;           buf.be(0, keys.c_verase());
;           @intr_char = keys.c_vintr();
;           buf.be(1, NUL);
;           add_termcode(u8("kb"), buf, FALSE);

            ;; If <BS> and <DEL> are now the same, redefine <DEL>.

;           Bytes p = find_termcode(u8("kD"));
;           if (p != null && p.at(0) == buf.at(0) && p.at(1) == buf.at(1))
;               ex_fixdel(null);
;       }
    ))

(atom! boolean sm__ison)

;; Set mouse clicks on or off.

(defn- #_void mch_setmouse [#_boolean on]
    (§
;       if (on == @sm__ison)     ;; return quickly if nothing to do
;           return;

;       int xterm_mouse_vers = use_xterm_mouse();

;       if (0 < xterm_mouse_vers)
;       {
;           if (on) ;; enable mouse events, use mouse tracking if available
;               out_str_nf((1 < xterm_mouse_vers) ? u8("\033[?1002h") : u8("\033[?1000h"));
;           else    ;; disable mouse events, could probably always send the same
;               out_str_nf((1 < xterm_mouse_vers) ? u8("\033[?1002l") : u8("\033[?1000l"));
;           @sm__ison = on;
;       }
    ))

;; Set the mouse termcode, depending on the 'term' and 'ttymouse' options.

(defn- #_void check_mouse_termcode []
    (§
;       if (use_xterm_mouse() != 0)
;       {
;           set_mouse_termcode(KS_MOUSE, term_is_8bit(@T_NAME) ? u8("\233M") : u8("\033[M"));
;           if (@p_mouse.at(0) != NUL)
;           {
                ;; Force mouse off and maybe on to send possibly new mouse
                ;; activation sequence to the xterm, with(out) drag tracing.
;               mch_setmouse(false);
;               setmouse();
;           }
;       }
;       else
;           del_mouse_termcode(KS_MOUSE);
    ))

;; set screen mode, always fails.

(defn- #_boolean mch_screenmode [#_Bytes _arg]
    (§
;       emsg(e_screenmode);
;       return false;
    ))

;; Try to get the current window size:
;; 1. with an ioctl(), most accurate method
;; 2. from the environment variables LINES and COLUMNS
;; 3. from the termcap
;; 4. keep using the old values
;; Return true when size could be determined, false otherwise.

(defn- #_boolean mch_get_shellsize []
    (§
;       long rows = 0;
;       long columns = 0;

        ;; 1. try using an ioctl.  It is the most accurate method.
        ;;
        ;; Try using TIOCGWINSZ first, some systems that have it also define
        ;; TIOCGSIZE but don't have a struct ttysize.

;       {
;           winsize_C ws = new winsize_C();
;           int fd = 1;

            ;; When stdout is not a tty, use stdin for the ioctl().
;           if (libc.isatty(fd) == 0 && libc.isatty(@read_cmd_fd) != 0)
;               fd = @read_cmd_fd;
;           if (libc.ioctl(fd, TIOCGWINSZ, ws) == 0)
;           {
;               rows = ws.ws_row();
;               columns = ws.ws_col();
;           }
;       }

        ;; 2. get size from environment
        ;;    When being POSIX compliant ('|' flag in 'cpoptions') this overrules
        ;;    the ioctl() values!

;       if (columns == 0 || rows == 0 || vim_strbyte(@p_cpo, CPO_TSIZE) != null)
;       {
;           Bytes p;
;           if ((p = libC.getenv(u8("LINES"))) != null)
;               rows = libC.atoi(p);
;           if ((p = libC.getenv(u8("COLUMNS"))) != null)
;               columns = libC.atoi(p);
;       }

        ;; 4. If everything fails, use the old values

;       if (columns <= 0 || rows <= 0)
;           return false;

;       @Rows = rows;
;       @Columns = columns;
;       limit_screen_size();
;       return true;
    ))

;; Try to set the window size to Rows and Columns.

(defn- #_void mch_set_shellsize []
    (§
;       if (@T_CWS.at(0) != NUL)
;       {
            ;; NOTE: if you get an error here that term_set_winsize() is undefined,
            ;; check the output of configure.  It could probably not find a ncurses,
            ;; termcap or termlib library.

;           term_set_winsize((int)@Rows, (int)@Columns);
;           out_flush();
;           screen_start();                 ;; don't know where cursor is now
;       }
    ))

;; Rows and/or Columns has changed.

(defn- #_void mch_new_shellsize []
    (§
        ;; Nothing to do.
    ))

;; Check for CTRL-C typed by reading all available characters.
;; In cooked mode we should get SIGINT, no need to check.

(defn- #_void mch_breakcheck []
    (§
;       if (@curr_tmode == TMODE_RAW && realWaitForChar(@read_cmd_fd, 0L))
;           fill_input_buf(false);
    ))

;; Wait "msec" msec until a character is available from the keyboard or from inbuf[].
;; "msec" == -1 will block forever.

(defn- #_boolean waitForChar [#_long msec]
    (§
;       if (input_available())          ;; something in inbuf[]
;           return true;

;       return realWaitForChar(@read_cmd_fd, msec);
    ))

;; Wait "msec" msec until a character is available from file descriptor "fd".
;; "msec" == 0 will check for characters once.
;; "msec" == -1 will block until a character is available.

(defn- #_boolean realWaitForChar [#_int fd, #_long msec]
    (§
;       timeval_C tv = new timeval_C();
;       if (0 <= msec)
;       {
;           tv.tv_sec(msec / 1000);
;           tv.tv_usec((msec % 1000) * 1000);
;       }

        ;; Select on ready for reading and exceptional condition (end of file).

;       for (long[] rfds = new long[FD_SET_LENGTH], efds = new long[FD_SET_LENGTH]; ; )
;       {
;           FD_ZERO(rfds);
;           FD_ZERO(efds);
;           FD_SET(fd, rfds);
;           FD_SET(fd, efds);

;           int ret = libc.select(fd + 1, rfds, null, efds, (msec < 0) ? null : tv);

;           if (ret == -1 && libC.errno() == EINTR)
;           {
                ;; Check whether window has been resized, EINTR may be caused by SIGWINCH.
;               if (@do_resize)
;                   handle_resize();

                ;; Interrupted by a signal, need to try again.  We ignore msec
                ;; here, because we do want to check even after a timeout if
                ;; characters are available.  Needed for reading output of an
                ;; external command after the process has finished.
;               continue;
;           }

;           return (0 < ret);
;       }

        ;; NOTREACHED
    ))

;; message.c: functions for displaying messages on the command line -------------------------------

(atom! int      confirm_msg_used)       ;; displaying "confirm_msg"
(atom! Bytes    confirm_msg)            ;; ":confirm" message
(atom! Bytes    confirm_msg_tail)       ;; tail of "confirm_msg"

(class! #_final msg_hist_C
    [
        (field msg_hist_C   next)
        (field Bytes        msg)
        (field int          attr)
    ])

(atom! msg_hist_C first_msg_hist)
(atom! msg_hist_C last_msg_hist)
(atom! int msg_hist_len)

;; When writing messages to the screen, there are many different situations.
;; A number of variables is used to remember the current state:
;; msg_didany       true when messages were written since the last time the user reacted to a prompt.
;;                  Reset: After hitting a key for the hit-return prompt,
;;                  hitting <CR> for the command line or input().
;;                  Set: When any message is written to the screen.
;; msg_didout       true when something was written to the current line.
;;                  Reset: When advancing to the next line, when the current text can be overwritten.
;;                  Set: When any message is written to the screen.
;; msg_nowait       No extra delay for the last drawn message.
;;                  Used in normal_cmd() before the mode message is drawn.
;; emsg_on_display  There was an error message recently.
;;                  Indicates that there should be a delay before redrawing.
;; msg_scroll       The next message should not overwrite the current one.
;; msg_scrolled     How many lines the screen has been scrolled (because of messages).
;;                  Used in update_screen() to scroll the screen back.
;;                  Incremented each time the screen scrolls a line.
;; msg_scrolled_ign true when msg_scrolled is non-zero and msg_puts_attr() writes something
;;                  without scrolling should not make need_wait_return to be set.
;;                  This is a hack to make ":ts" work without an extra prompt.
;; lines_left       Number of lines available for messages before the more-prompt is to be given.
;;                  -1 when not set.
;; need_wait_return true when the hit-return prompt is needed.
;;                  Reset: After giving the hit-return prompt, when the user has answered some other prompt.
;;                  Set: When the ruler or typeahead display is overwritten,
;;                  scrolling the screen for some message.
;; keep_msg         Message to be displayed after redrawing the screen, in main_loop().
;;                  This is an allocated string or null when not used.

;; msg(s) - displays the string 's' on the status line.
;; Return true if wait_return not called.

(defn- #_boolean msg [#_Bytes s]
    (§
;       return msg_attr_keep(s, 0, false);
    ))

(defn- #_boolean msg_attr [#_Bytes s, #_int attr]
    (§
;       return msg_attr_keep(s, attr, false);
    ))

(atom! int msg__entered)

(defn- #_boolean msg_attr_keep [#_Bytes s, #_int attr, #_boolean keep]
    ;; keep: true: set "keep_msg" if it doesn't scroll
    (§
        ;; It is possible that displaying a messages causes a problem
        ;; (e.g. when redrawing the window), which causes another message, etc.
        ;; To break this loop, limit the recursiveness to 3 levels.

;       if (3 <= @msg__entered)
;           return true;
;       @msg__entered++;

        ;; Add message to history (unless it's a repeated kept message or a truncated message)
;       if (BNE(s, @keep_msg)
;               || (s.at(0) != (byte)'<'
;                   && @last_msg_hist != null
;                   && @last_msg_hist.msg != null
;                   && STRCMP(s, @last_msg_hist.msg) != 0))
;           add_msg_hist(s, -1, attr);

        ;; When displaying "keep_msg", don't let msg_start() free it, caller must do that.
;       if (BEQ(s, @keep_msg))
;           @keep_msg = null;

        ;; Truncate the message if needed.
;       msg_start();

;       Bytes buf = msg_strtrunc(s, false);
;       if (buf != null)
;           s = buf;

;       msg_outtrans_attr(s, attr);
;       msg_clr_eos();

;       boolean retval = msg_end();

;       if (keep && retval && mb_string2cells(s, -1) < (int)(@Rows - @cmdline_row - 1) * (int)@Columns + @sc_col)
;           set_keep_msg(s, 0);

;       --@msg__entered;
;       return retval;
    ))

;; Truncate a string such that it can be printed without causing a scroll.
;; Returns an allocated string or null when no truncating is done.

(defn- #_Bytes msg_strtrunc [#_Bytes s, #_boolean force]
    ;; force: always truncate
    (§
;       Bytes buf = null;
;       int len;
;       int room;

        ;; May truncate message to avoid a hit-return prompt.
;       if ((!@msg_scroll && !@need_wait_return && shortmess(SHM_TRUNCALL)
;                                  && @exmode_active == 0 && @msg_silent == 0) || force)
;       {
;           len = mb_string2cells(s, -1);
;           if (@msg_scrolled != 0)
                ;; Use all the columns.
;               room = (int)(@Rows - @msg_row) * (int)@Columns - 1;
;           else
                ;; Use up to 'showcmd' column.
;               room = (int)(@Rows - @msg_row - 1) * (int)@Columns + @sc_col - 1;
;           if (room < len && 0 < room)
;           {
                ;; may have up to 18 bytes per cell (6 per char, up to two composing chars)
;               len = (room + 2) * 18;
;               buf = new Bytes(len);
;               trunc_string(s, buf, room, len);
;           }
;       }
;       return buf;
    ))

;; Truncate a string "s" to "buf" with cell width "room".
;; "s" and "buf" may be equal.

(defn- #_void trunc_string [#_Bytes s, #_Bytes buf, #_int room, #_int buflen]
    (§
;       room -= 3;

;       int half = room / 2;
;       int len = 0;

;       int e;

        ;; First part: Start of the string.
;       for (e = 0; len < half && e < buflen; e++)
;       {
;           if (s.at(e) == NUL)
;           {
                ;; text fits without truncating!
;               buf.be(e, NUL);
;               return;
;           }

;           int n = mb_ptr2cells(s.plus(e));
;           if (half <= len + n)
;               break;
;           len += n;
;           buf.be(e, s.at(e));

;           for (n = us_ptr2len_cc(s.plus(e)); 0 < --n; )
;           {
;               if (++e == buflen)
;                   break;
;               buf.be(e, s.at(e));
;           }
;       }

        ;; Last part: End of the string.
;       int i = e;

        ;; For UTF-8 we can go backwards easily.
;       half = i = STRLEN(s);
;       for ( ; ; )
;       {
;           do
;           {
;               half = half - us_head_off(s, s.plus(half - 1)) - 1;
;           } while (utf_iscomposing(us_ptr2char(s.plus(half))) && 0 < half);
;           int n = mb_ptr2cells(s.plus(half));
;           if (room < len + n)
;               break;
;           len += n;
;           i = half;
;       }

        ;; Set the middle and copy the last part.
;       if (e + 3 < buflen)
;       {
;           BCOPY(buf, e, u8("..."), 0, 3);
;           len = STRLEN(s, i) + 1;
;           if (buflen - e - 3 <= len)
;               len = buflen - e - 3 - 1;
;           BCOPY(buf, e + 3, s, i, len);
;           buf.be(e + 3 + len - 1, NUL);
;       }
;       else
;       {
;           buf.be(e - 1, NUL);     ;; make sure it is truncated
;       }
    ))

(defn- #_final #_boolean smsg [#_Bytes s, #_Object... args]
    (§
;       return smsg_attr(0, s, args);
    ))

(defn- #_boolean smsg_attr [#_int attr, #_Bytes s, #_Object... args]
    (§
;       vim_snprintf(@ioBuff, IOSIZE, s, args);

;       return msg_attr(@ioBuff, attr);
    ))

;; Return true if not giving error messages right now:
;; If "emsg_off" is set: no error messages at the moment.
;; If "emsg_skip" is set: never do error messages.

(defn- #_boolean emsg_not_now []
    (§
;       return (0 < @emsg_off || 0 < @emsg_skip);
    ))

;; emsg() - display an error message.
;;
;; Rings the bell, if appropriate, and calls message() to do the real work.
;;
;; Return true if wait_return not called.

(defn- #_boolean emsg [#_Bytes s]
    (§
;       boolean[] ignore = { false };

        ;; Skip this if not giving error messages at the moment.
;       if (emsg_not_now())
;           return true;

;       @called_emsg = true;
;       @ex_exitval = 1;

        ;; If "emsg_severe" is true: When an error exception is to be thrown,
        ;; prefer this message over previous messages for the same command.

;       boolean severe = @emsg_severe;
;       @emsg_severe = false;

;       if (@emsg_off == 0)
;       {
            ;; Cause a throw of an error exception if appropriate.
            ;; Don't display the error message in this case.
            ;; (If no matching catch clause will be found, the message will be displayed later on.)
            ;; "ignore" is set when the message should be ignored completely
            ;; (used for the interrupt message).

;           if (cause_errthrow(s, severe, ignore) == true)
;           {
;               if (!ignore[0])
;                   @did_emsg = true;
;               return true;
;           }

            ;; When using ":silent! cmd" ignore error messages.
            ;; But do write it to the redirection file.

;           if (@emsg_silent != 0)
;           {
;               msg_start();
;               redir_write(s, -1);
;               return true;
;           }

            ;; Reset msg_silent, an error causes messages to be switched back on.
;           @msg_silent = 0;
;           @cmd_silent = false;

;           if (@global_busy != 0)           ;; break :global command
;               @global_busy++;

;           if (@p_eb)
;               beep_flush();               ;; also includes flush_buffers()
;           else
;               flush_buffers(false);       ;; flush internal buffers
;           @did_emsg = true;                ;; flag for DoOneCmd()
;       }

;       @emsg_on_display = true;             ;; remember there is an error message
;       @msg_scroll = true;                  ;; don't overwrite a previous message
;       int attr = hl_attr(HLF_E);          ;; set highlight mode for error messages
;       if (@msg_scrolled != 0)
;           @need_wait_return = true;        ;; needed in case emsg() is called after
                                            ;; wait_return has reset need_wait_return
                                            ;; and a redraw is expected because
                                            ;; msg_scrolled is non-zero

        ;; Display the error message itself.

;       @msg_nowait = false;                 ;; wait for this msg
;       return msg_attr(s, attr);
    ))

;; Print an error message with one "%s" and one string argument.

(defn- #_boolean emsg2 [#_Bytes s, #_Bytes a1]
    (§
;       return emsg3(s, a1, null);
    ))

;; emsg3() and emsgn() are in misc.c to avoid warnings for the prototypes.

(defn- #_void emsg_invreg [#_int name]
    (§
;       emsg2(u8("E354: Invalid register name: '%s'"), transchar(name));
    ))

;; Like msg(), but truncate to a single line if "p_shm" contains 't', or when "force" is true.
;; This truncates in another way as for normal messages.
;; Careful: The string may be changed by msg_may_trunc()!
;; Returns a pointer to the printed message, if wait_return() not called.

(defn- #_Bytes msg_trunc_attr [#_Bytes s, #_boolean force, #_int attr]
    (§
        ;; Add message to history before truncating.
;       add_msg_hist(s, -1, attr);

;       s = msg_may_trunc(force, s);

;       @msg_hist_off = true;
;       boolean b = msg_attr(s, attr);
;       @msg_hist_off = false;

;       return (b) ? s : null;
    ))

;; Check if message "s" should be truncated at the start (for filenames).
;; Return a pointer to where the truncated message starts.
;; Note: May change the message by replacing a character with '<'.

(defn- #_Bytes msg_may_trunc [#_boolean force, #_Bytes s]
    (§
;       int room = (int)(@Rows - @cmdline_row - 1) * (int)@Columns + @sc_col - 1;

;       if ((force || (shortmess(SHM_TRUNC) && @exmode_active == 0)) && 0 < STRLEN(s) - room)
;       {
;           int cells = mb_string2cells(s, -1);

            ;; There may be room anyway when there are multibyte chars.
;           if (cells <= room)
;               return s;

;           int n;
;           for (n = 0; room <= cells; n += us_ptr2len_cc(s.plus(n)))
;               cells -= us_ptr2cells(s.plus(n));
;           --n;

;           s = s.plus(n);
;           s.be(0, (byte)'<');
;       }

;       return s;
    ))

(defn- #_void add_msg_hist [#_Bytes s, #_int len, #_int attr]
    ;; len: -1 for undetermined length
    (§
;       final int MAX_MSG_HIST_LEN = 200;

;       if (@msg_hist_off || @msg_silent != 0)
;           return;

        ;; don't let the message history get too big
;       while (MAX_MSG_HIST_LEN < @msg_hist_len)
;           delete_first_msg();

        ;; allocate an entry and add the message at the end of the history
;       msg_hist_C p = §_msg_hist_C();

;       if (len < 0)
;           len = STRLEN(s);
        ;; remove leading and trailing newlines
;       while (0 < len && s.at(0) == (byte)'\n')
;       {
;           s = s.plus(1);
;           --len;
;       }
;       while (0 < len && s.at(len - 1) == (byte)'\n')
;           --len;
;       p.msg = STRNDUP(s, len);
;       p.next = null;
;       p.attr = attr;
;       if (@last_msg_hist != null)
;           @last_msg_hist.next = p;
;       @last_msg_hist = p;
;       if (@first_msg_hist == null)
;           @first_msg_hist = @last_msg_hist;
;       @msg_hist_len++;
    ))

;; Delete the first (oldest) message from the history.
;; Returns false if there are no messages.

(defn- #_boolean delete_first_msg []
    (§
;       if (@msg_hist_len <= 0)
;           return false;

;       msg_hist_C p = @first_msg_hist;
;       @first_msg_hist = p.next;
;       if (@first_msg_hist == null)
;           @last_msg_hist = null;       ;; history is empty

;       --@msg_hist_len;
;       return true;
    ))

;; ":messages" command.

(defn- #_void ex_messages [#_exarg_C _eap]
    (§
;       @msg_hist_off = true;

;       for (msg_hist_C p = @first_msg_hist; p != null && !@got_int; p = p.next)
;           if (p.msg != null)
;               msg_attr(p.msg, p.attr);

;       @msg_hist_off = false;
    ))

;; Call this after prompting the user.  This will avoid a hit-return message and a delay.

(defn- #_void msg_end_prompt []
    (§
;       @need_wait_return = false;
;       @emsg_on_display = false;
;       @cmdline_row = @msg_row;
;       @msg_col = 0;
;       msg_clr_eos();
;       @lines_left = -1;
    ))

;; wait for the user to hit a key (normally a return)
;; if 'redraw' is true, clear and redraw the screen
;; if 'redraw' is false, just redraw the screen
;; if 'redraw' is -1, don't redraw at all

(defn- #_void wait_return [#_int redraw]
    (§
;       if (redraw == TRUE)
;           @must_redraw = CLEAR;

        ;; If using ":silent cmd", don't wait for a return.
        ;; Also don't set need_wait_return to do it later.
;       if (@msg_silent != 0)
;           return;

        ;; When inside vgetc(), we can't wait for a typed character at all.
        ;; With the global command (and some others) we only need one return at
        ;; the end.  Adjust cmdline_row to avoid the next message overwriting the last one.

;       if (0 < @vgetc_busy)
;           return;
;       @need_wait_return = true;
;       if (@no_wait_return != 0)
;       {
;           if (@exmode_active == 0)
;               @cmdline_row = @msg_row;
;           return;
;       }

;       int c;

;       int oldState = @State;
;       if (@quit_more)
;       {
;           c = CAR;                    ;; just pretend CR was hit
;           @quit_more = false;
;           @got_int = false;
;       }
;       else if (@exmode_active != 0)
;       {
;           msg_puts(u8(" "));              ;; make sure the cursor is on the right line
;           c = CAR;                    ;; no need for a return in ex mode
;           @got_int = false;
;       }
;       else
;       {
            ;; Make sure the hit-return prompt is on screen when 'guioptions' was just changed.
;           screenalloc(false);

;           @State = HITRETURN;
;           setmouse();
            ;; Avoid the sequence that the user types ":" at the hit-return prompt
            ;; to start an Ex command, but the file-changed dialog gets in the way.
;           if (@need_check_timestamps)
;               check_timestamps(false);

;           hit_return_msg();

;           boolean had_got_int;
;           do
;           {
                ;; Remember "got_int", if it is set vgetc() probably returns a CTRL-C,
                ;; but we need to loop then.
;               had_got_int = @got_int;

                ;; Don't do mappings here, we put the character back in the typeahead buffer.
;               @no_mapping++;
;               @allow_keys++;

                ;; Temporarily disable Recording.
                ;; If Recording is active, the character will be recorded later,
                ;; since it will be added to the typebuf after the loop.
;               boolean save_Recording = @Recording;
;               @Recording = false;
;               c = safe_vgetc();
;               if (had_got_int && @global_busy == 0)
;                   @got_int = false;
;               --@no_mapping;
;               --@allow_keys;
;               @Recording = save_Recording;

                ;; Strange way to allow copying (yanking) a modeless selection at
                ;; the hit-enter prompt.  Use CTRL-Y, because the same is used in
                ;; Cmdline-mode and it's harmless when there is no selection.
;               if (c == Ctrl_Y && @clip_star.state == SELECT_DONE)
;               {
;                   clip_copy_modeless_selection(true);
;                   c = K_IGNORE;
;               }

                ;; Allow scrolling back in the messages.
                ;; Also accept scroll-down commands when messages fill the screen,
                ;; to avoid that typing one 'j' too many makes the messages disappear.

;               if (@p_more)
;               {
;                   if (c == 'b' || c == 'k' || c == 'u' || c == 'g' || c == K_UP || c == K_PAGEUP)
;                   {
;                       if (@Rows < @msg_scrolled)
                            ;; scroll back to show older messages
;                           do_more_prompt(c);
;                       else
;                       {
;                           @msg_didout = false;
;                           c = K_IGNORE;
;                           @msg_col = @cmdmsg_rl ? (int)@Columns - 1 : 0;
;                       }
;                       if (@quit_more)
;                       {
;                           c = CAR;                ;; just pretend CR was hit
;                           @quit_more = false;
;                           @got_int = false;
;                       }
;                       else if (c != K_IGNORE)
;                       {
;                           c = K_IGNORE;
;                           hit_return_msg();
;                       }
;                   }
;                   else if (@Rows - 2 < @msg_scrolled
;                            && (c == 'j' || c == 'd' || c == 'f' || c == K_DOWN || c == K_PAGEDOWN))
;                       c = K_IGNORE;
;               }
;           } while ((had_got_int && c == Ctrl_C)
;                                 || c == K_IGNORE
;                                 || c == K_LEFTDRAG   || c == K_LEFTRELEASE
;                                 || c == K_MIDDLEDRAG || c == K_MIDDLERELEASE
;                                 || c == K_RIGHTDRAG  || c == K_RIGHTRELEASE
;                                 || c == K_MOUSELEFT  || c == K_MOUSERIGHT
;                                 || c == K_MOUSEDOWN  || c == K_MOUSEUP
;                                 || (!mouse_has(MOUSE_RETURN)
;                                     && @mouse_row < @msg_row
;                                     && (c == K_LEFTMOUSE
;                                      || c == K_MIDDLEMOUSE
;                                      || c == K_RIGHTMOUSE
;                                      || c == K_X1MOUSE
;                                      || c == K_X2MOUSE)));
;           ui_breakcheck();

            ;; Avoid that the mouse-up event causes visual mode to start.

;           if (c == K_LEFTMOUSE || c == K_MIDDLEMOUSE || c == K_RIGHTMOUSE || c == K_X1MOUSE || c == K_X2MOUSE)
;               jump_to_mouse(MOUSE_SETPOS, null, 0);
;           else if (vim_strchr(u8("\r\n "), c) == null && c != Ctrl_C)
;           {
                ;; Put the character back in the typeahead buffer.
                ;; Don't use the stuff buffer, because lmaps wouldn't work.
;               ins_char_typebuf(c);
;               @do_redraw = true;       ;; need a redraw even though there is typeahead
;           }
;       }

        ;; If the user hits ':', '?' or '/' we get a command line from the next line.

;       if (c == ':' || c == '?' || c == '/')
;       {
;           if (@exmode_active == 0)
;               @cmdline_row = @msg_row;
;           @skip_redraw = true;         ;; skip redraw once
;           @do_redraw = false;
;       }

        ;; If the window size changed set_shellsize() will redraw the screen.
        ;; Otherwise the screen is only redrawn if 'redraw' is set and no ':' typed.

;       int tmpState = @State;
;       @State = oldState;               ;; restore State before set_shellsize
;       setmouse();
;       msg_check();

        ;; When switching screens, we need to output an extra newline on exit.

;       if (swapping_screen() && !@termcap_active)
;           @newline_on_exit = true;

;       @need_wait_return = false;
;       @did_wait_return = true;
;       @emsg_on_display = false;    ;; can delete error message now
;       @lines_left = -1;            ;; reset lines_left at next msg_start()

;       if (@keep_msg != null && (int)(@Rows - @cmdline_row - 1) * (int)@Columns + @sc_col <= mb_string2cells(@keep_msg, -1))
;       {
;           @keep_msg = null;            ;; don't redisplay message, it's too long
;       }

;       if (tmpState == SETWSIZE)       ;; got resize event while in vgetc()
;       {
;           starttermcap();             ;; start termcap before redrawing
;           shell_resized();
;       }
;       else if (!@skip_redraw && (redraw == TRUE || (@msg_scrolled != 0 && redraw != -1)))
;       {
;           starttermcap();             ;; start termcap before redrawing
;           redraw_later(VALID);
;       }
    ))

;; Write the hit-return prompt.

(defn- #_void hit_return_msg []
    (§
;       boolean save_p_more = @p_more;

;       @p_more = false;             ;; don't want see this message when scrolling back
;       if (@msg_didout)             ;; start on a new line
;           msg_putchar('\n');
;       if (@got_int)
;           msg_puts(u8("Interrupt: "));

;       msg_puts_attr(u8("Press ENTER or type command to continue"), hl_attr(HLF_R));
;       if (!msg_use_printf())
;           msg_clr_eos();
;       @p_more = save_p_more;
    ))

;; Set "keep_msg" to "s".  Free the old value and check for null pointer.

(defn- #_void set_keep_msg [#_Bytes s, #_int attr]
    (§
;       if (s != null && @msg_silent == 0)
;           @keep_msg = STRDUP(s);
;       else
;           @keep_msg = null;
;       @keep_msg_more = false;
;       @keep_msg_attr = attr;
    ))

;; If there currently is a message being displayed, set "keep_msg" to it, so
;; that it will be displayed again after redraw.

(defn- #_void set_keep_msg_from_hist []
    (§
;       if (@keep_msg == null && @last_msg_hist != null && @msg_scrolled == 0 && (@State & NORMAL) != 0)
;           set_keep_msg(@last_msg_hist.msg, @last_msg_hist.attr);
    ))

;; Prepare for outputting characters in the command line.

(defn- #_void msg_start []
    (§
;       boolean did_return = false;

;       if (@msg_silent == 0)
;       {
;           @keep_msg = null;                    ;; don't display old message now
;       }

;       if (@need_clr_eos)
;       {
            ;; Halfway an ":echo" command and getting an (error) message:
            ;; clear any text from the command.
;           @need_clr_eos = false;
;           msg_clr_eos();
;       }

;       if (!@msg_scroll && @full_screen)         ;; overwrite last message
;       {
;           @msg_row = @cmdline_row;
;           @msg_col = @cmdmsg_rl ? (int)@Columns - 1 : 0;
;       }
;       else if (@msg_didout)                    ;; start message on next line
;       {
;           msg_putchar('\n');
;           did_return = true;
;           if (@exmode_active != EXMODE_NORMAL)
;               @cmdline_row = @msg_row;
;       }
;       if (!@msg_didany || @lines_left < 0)
;           msg_starthere();
;       if (@msg_silent == 0)
;       {
;           @msg_didout = false;                 ;; no output on current line yet
;           cursor_off();
;       }
    ))

;; Note that the current msg position is where messages start.

(defn- #_void msg_starthere []
    (§
;       @lines_left = @cmdline_row;
;       @msg_didany = false;
    ))

(defn- #_void msg_putchar [#_int c]
    (§
;       msg_putchar_attr(c, 0);
    ))

(defn- #_void msg_putchar_attr [#_int c, #_int attr]
    (§
;       Bytes buf = new Bytes(MB_MAXBYTES + 1);

;       if (is_special(c))
;       {
;           buf.be(0, KB_SPECIAL);
;           buf.be(1, KB_SECOND(c));
;           buf.be(2, KB_THIRD(c));
;           buf.be(3, NUL);
;       }
;       else
;       {
;           buf.be(utf_char2bytes(c, buf), NUL);
;       }
;       msg_puts_attr(buf, attr);
    ))

(defn- #_void msg_outnum [#_long n]
    (§
;       Bytes buf = new Bytes(20);

;       libC.sprintf(buf, u8("%ld"), n);
;       msg_puts(buf);
    ))

;; Output 'len' characters in 'p' (including NULs) with translation
;; if 'len' is -1, output upto a NUL character.
;; Use attributes 'attr'.
;; Return the number of characters it takes on the screen.

(defn- #_int msg_outtrans [#_Bytes p]
    (§
;       return msg_outtrans_attr(p, 0);
    ))

(defn- #_int msg_outtrans_attr [#_Bytes p, #_int attr]
    (§
;       return msg_outtrans_len_attr(p, STRLEN(p), attr);
    ))

(defn- #_int msg_outtrans_len [#_Bytes p, #_int len]
    (§
;       return msg_outtrans_len_attr(p, len, 0);
    ))

(defn- #_int msg_outtrans_len_attr [#_Bytes p, #_int len, #_int attr]
    (§
;       int cells = 0;

        ;; if MSG_HIST flag set, add message to history
;       if ((attr & MSG_HIST) != 0)
;       {
;           add_msg_hist(p, len, attr);
;           attr &= ~MSG_HIST;
;       }

        ;; If the string starts with a composing character,
        ;; first draw a space on which the composing char can be drawn.
;       if (utf_iscomposing(us_ptr2char(p)))
;           msg_puts_attr(u8(" "), attr);

;       Bytes q = p;

        ;; Go over the string.  Special characters are translated and printed.
        ;; Normal characters are printed several at a time.

;       while (0 <= --len)
;       {
            ;; Don't include composing chars after the end.
;           int l = us_ptr2len_cc_len(p, len + 1);
;           if (1 < l)
;           {
;               int c = us_ptr2char(p);
;               if (vim_isprintc(c))
                    ;; printable multi-byte char: count the cells.
;                   cells += us_ptr2cells(p);
;               else
;               {
                    ;; unprintable multi-byte char: print the printable chars
                    ;; so far and the translation of the unprintable char
;                   if (BLT(q, p))
;                       msg_puts_attr_len(q, BDIFF(p, q), attr);
;                   q = p.plus(l);
;                   msg_puts_attr(transchar(c), (attr == 0) ? hl_attr(HLF_8) : attr);
;                   cells += mb_char2cells(c);
;               }
;               len -= l - 1;
;               p = p.plus(l);
;           }
;           else
;           {
;               Bytes s = transchar_byte(p.at(0));
;               if (s.at(1) != NUL)
;               {
                    ;; unprintable char: print the printable chars so far
                    ;; and the translation of the unprintable char
;                   if (BLT(q, p))
;                       msg_puts_attr_len(q, BDIFF(p, q), attr);
;                   q = p.plus(1);
;                   msg_puts_attr(s, (attr == 0) ? hl_attr(HLF_8) : attr);
;                   cells += STRLEN(s);
;               }
;               else
;                   cells++;
;               p = p.plus(1);
;           }
;       }

;       if (BLT(q, p))
            ;; print the printable chars at the end
;           msg_puts_attr_len(q, BDIFF(p, q), attr);

;       return cells;
    ))

;; Output the string 's' upto a NUL character.
;; Return the number of characters it takes on the screen.
;;
;; If KB_SPECIAL is encountered, then it is taken in conjunction with the following character
;; and shown as <F1>, <S-Up> etc.  Any other character which is not printable shown in <> form.
;; If 'from' is true (lhs of a mapping), a space is shown as <Space>.
;; If a character is displayed in one of these special ways, is also highlighted
;; (its highlight name is '8' in the "p_hl" variable).  Otherwise characters are not highlighted.
;; This function is used to show mappings, where we want to see how to type the character/string.

(defn- #_int msg_outtrans_special [#_Bytes _p, #_boolean is_lhs]
    ;; is_lhs: true for lhs of a mapping
    (§
;       Bytes[] p = { _p };
;       int cells = 0;

;       int attr = hl_attr(HLF_8);
;       for (Bytes q = p[0]; p[0].at(0) != NUL; )
;       {
;           Bytes s;

            ;; Leading and trailing spaces need to be displayed in <> form.
;           if ((BEQ(p[0], q) || p[0].at(1) == NUL) && p[0].at(0) == (byte)' ')
;           {
;               s = u8("<Space>");
;               p[0] = p[0].plus(1);
;           }
;           else
;               s = str2special(p, is_lhs);

;           int len = mb_string2cells(s, -1);
            ;; Highlight special keys.
;           msg_puts_attr(s, (1 < len && us_ptr2len_cc(s) <= 1) ? attr : 0);
;           cells += len;
;       }

;       return cells;
    ))

;; Return the lhs or rhs of a mapping, with the key codes
;; turned into printable strings, in an allocated string.

(defn- #_Bytes str2special_save [#_Bytes _s, #_boolean is_lhs]
    ;; is_lhs: true for lhs, false for rhs
    (§
;       Bytes[] s = { _s };
;       barray_C ba = new barray_C(40);

;       while (s[0].at(0) != NUL)
;           ba_concat(ba, str2special(s, is_lhs));
;       ba_append(ba, NUL);

;       return new Bytes(ba.ba_data);
    ))

(final Bytes buf7   (Bytes. 7))

;; Return the printable string for the key codes at "*sp".
;; Used for translating the lhs or rhs of a mapping to printable chars.
;; Advances "*sp" to the next code.

(defn- #_Bytes str2special [#_Bytes* sp, #_boolean is_lhs]
    ;; is_lhs: true for lhs of mapping
    (§
;       Bytes s = sp[0];
;       int modifiers = 0;
;       boolean special = false;

        ;; Try to un-escape a multi-byte character.
        ;; Return the un-escaped string if it is a multi-byte character.
;       Bytes p = mb_unescape(sp);
;       if (p != null)
;           return p;

;       int c = char_u(s.at(0));
;       if (c == char_u(KB_SPECIAL) && s.at(1) != NUL && s.at(2) != NUL)
;       {
;           if (s.at(1) == KS_MODIFIER)
;           {
;               modifiers = char_u(s.at(2));
;               s = s.plus(3);
;               c = char_u(s.at(0));
;           }
;           if (c == char_u(KB_SPECIAL) && s.at(1) != NUL && s.at(2) != NUL)
;           {
;               c = toSpecial(s.at(1), s.at(2));
;               s = s.plus(2);
;               if (c == char_u(KS_ZERO))   ;; display <Nul> as ^@ or <Nul>
;                   c = NUL;
;           }
;           if (is_special(c) || modifiers != 0)    ;; special key
;               special = true;
;       }

;       if (!is_special(c))
;       {
;           int len = us_ptr2len_cc(s);

            ;; For multi-byte characters check for an illegal byte.
;           if (len < us_byte2len(s.at(0), false))
;           {
;               transchar_nonprint(buf7, c);
;               sp[0] = s.plus(1);
;               return buf7;
;           }
            ;; Since 'special' is true, the multi-byte character 'c'
            ;; will be processed by get_special_key_name().
;           c = us_ptr2char(s);
;           sp[0] = s.plus(len);
;       }
;       else
;           sp[0] = s.plus(1);

        ;; Make unprintable characters in <> form, also <M-Space> and <Tab>.
        ;; Use <Space> only for lhs of a mapping.
;       if (special || 1 < mb_char2cells(c) || (is_lhs && c == ' '))
;           return get_special_key_name(c, modifiers);

;       buf7.be(0, c);
;       buf7.be(1, NUL);
;       return buf7;
    ))

;; Translate a key sequence into special key names.

(defn- #_void str2specialbuf [#_Bytes _sp, #_Bytes buf, #_int len]
    (§
;       Bytes[] sp = { _sp };
;       buf.be(0, NUL);
;       while (sp[0].at(0) != NUL)
;       {
;           Bytes s = str2special(sp, false);
;           if (STRLEN(s) + STRLEN(buf) < len)
;               STRCAT(buf, s);
;       }
    ))

;; print line for :print or :list command

(defn- #_void msg_prt_line [#_Bytes s, #_boolean list]
    (§
;       if (@curwin.w_onebuf_opt.@wo_list)
;           list = true;

        ;; find start of trailing whitespace
;       Bytes trail = null;
;       if (list && @lcs_trail != NUL)
;       {
;           trail = s.plus(STRLEN(s));
;           while (BLT(s, trail) && vim_iswhite(trail.at(-1)))
;               trail = trail.minus(1);
;       }

        ;; output a space for an empty line, otherwise the line will be overwritten
;       if (s.at(0) == NUL && !(list && @lcs_eol != NUL))
;           msg_putchar(' ');

;       int col = 0;
;       int n_extra = 0;
;       int c_extra = 0;
;       Bytes p_extra = null;
;       int attr = 0;

;       for (int c; !@got_int; )
;       {
;           int len;

;           if (0 < n_extra)
;           {
;               --n_extra;
;               if (c_extra != 0)
;                   c = c_extra;
;               else
;                   c = char_u((p_extra = p_extra.plus(1)).at(-1));
;           }
;           else if (1 < (len = us_ptr2len_cc(s)))
;           {
;               Bytes buf = new Bytes(MB_MAXBYTES + 1);

;               col += us_ptr2cells(s);
;               if (@lcs_nbsp != NUL && list && us_ptr2char(s) == 0xa0)
;               {
;                   utf_char2bytes(@lcs_nbsp, buf);
;                   buf.be(us_ptr2len_cc(buf), NUL);
;               }
;               else
;               {
;                   BCOPY(buf, s, len);
;                   buf.be(len, NUL);
;               }
;               msg_puts(buf);
;               s = s.plus(len);
;               continue;
;           }
;           else
;           {
;               int n;

;               attr = 0;
;               c = char_u((s = s.plus(1)).at(-1));
;               if (c == TAB && (!list || lcs_tab1[0] != NUL))
;               {
                    ;; tab amount depends on current column
;                   n_extra = (int)@curbuf.@b_p_ts - col % (int)@curbuf.@b_p_ts - 1;
;                   if (!list)
;                   {
;                       c = ' ';
;                       c_extra = ' ';
;                   }
;                   else
;                   {
;                       c = lcs_tab1[0];
;                       c_extra = lcs_tab2[0];
;                       attr = hl_attr(HLF_8);
;                   }
;               }
;               else if (c == 0xa0 && list && @lcs_nbsp != NUL)
;               {
;                   c = @lcs_nbsp;
;                   attr = hl_attr(HLF_8);
;               }
;               else if (c == NUL && list && @lcs_eol != NUL)
;               {
;                   p_extra = u8("");
;                   c_extra = NUL;
;                   n_extra = 1;
;                   c = @lcs_eol;
;                   attr = hl_attr(HLF_AT);
;                   s = s.minus(1);
;               }
;               else if (c != NUL && 1 < (n = mb_byte2cells((byte)c)))
;               {
;                   n_extra = n - 1;
;                   p_extra = transchar_byte((byte)c);
;                   c_extra = NUL;
;                   c = char_u((p_extra = p_extra.plus(1)).at(-1));
                    ;; Use special coloring to be able to distinguish <hex> from the same in plain text.
;                   attr = hl_attr(HLF_8);
;               }
;               else if (c == ' ' && trail != null && BLT(trail, s))
;               {
;                   c = @lcs_trail;
;                   attr = hl_attr(HLF_8);
;               }
;           }

;           if (c == NUL)
;               break;

;           msg_putchar_attr(c, attr);
;           col++;
;       }

;       msg_clr_eos();
    ))

;; Use screen_puts() to output one multi-byte character.
;; Return the pointer "s" advanced to the next character.

(defn- #_Bytes screen_puts_mbyte [#_Bytes s, #_int len, #_int attr]
    (§
;       @msg_didout = true;          ;; remember that line is not empty

;       int cells = us_ptr2cells(s);
;       if (1 < cells && (@cmdmsg_rl ? @msg_col <= 1 : @msg_col == (int)@Columns - 1))
;       {
            ;; Doesn't fit, print a highlighted '>' to fill it up.
;           msg_screen_putchar('>', hl_attr(HLF_AT));
;           return s;
;       }

;       screen_puts_len(s, len, @msg_row, @msg_col, attr);
;       if (@cmdmsg_rl)
;       {
;           @msg_col -= cells;
;           if (@msg_col == 0)
;           {
;               @msg_col = (int)@Columns;
;               @msg_row++;
;           }
;       }
;       else
;       {
;           @msg_col += cells;
;           if ((int)@Columns <= @msg_col)
;           {
;               @msg_col = 0;
;               @msg_row++;
;           }
;       }
;       return s.plus(len);
    ))

;; Output a string to the screen at position msg_row, msg_col.
;; Update msg_row and msg_col for the next message.

(defn- #_void msg_puts [#_Bytes s]
    (§
;       msg_puts_attr(s, 0);
    ))

(defn- #_void msg_puts_title [#_Bytes s]
    (§
;       msg_puts_attr(s, hl_attr(HLF_T));
    ))

;; Basic function for writing a message with highlight attributes.

(defn- #_void msg_puts_attr [#_Bytes s, #_int attr]
    (§
;       msg_puts_attr_len(s, -1, attr);
    ))

;; Like msg_puts_attr(), but with a maximum length "maxlen" (in bytes).
;; When "maxlen" is -1 there is no maximum length.
;; When "maxlen" is >= 0 the message is not put in the history.

(defn- #_void msg_puts_attr_len [#_Bytes str, #_int maxlen, #_int attr]
    (§
        ;; Don't print anything when using ":silent cmd".

;       if (@msg_silent != 0)
;           return;

        ;; if MSG_HIST flag set, add message to history
;       if ((attr & MSG_HIST) != 0 && maxlen < 0)
;       {
;           add_msg_hist(str, -1, attr);
;           attr &= ~MSG_HIST;
;       }

        ;; When writing something to the screen after it has scrolled, requires
        ;; a wait-return prompt later.  Needed when scrolling, resetting need_wait_return
        ;; after some prompt, and then outputting something without scrolling

;       if (@msg_scrolled != 0 && !@msg_scrolled_ign)
;           @need_wait_return = true;
;       @msg_didany = true;          ;; remember that something was outputted

        ;; If there is no valid screen, use fprintf so we can see error messages.
        ;; If termcap is not active, we may be writing in an alternate console window,
        ;; cursor positioning may not work correctly (window size may be different,
        ;; e.g. for Win32 console) or we just don't know where the cursor is.

;       if (msg_use_printf())
;           msg_puts_printf(str, maxlen);
;       else
;           msg_puts_display(str, maxlen, attr, false);
    ))

;; The display part of msg_puts_attr_len().
;; May be called recursively to display scroll-back text.

(defn- #_void msg_puts_display [#_Bytes str, #_int maxlen, #_int attr, #_boolean recurse]
    (§
;       Bytes s = str;
;       Bytes t_s = str;       ;; string from "t_s" to "s" is still todo
;       int t_col = 0;          ;; screen cells todo, 0 when "t_s" not used
;       Bytes[] sb_str = { str };
;       int[] sb_col = { @msg_col };

;       @did_wait_return = false;
;       while ((maxlen < 0 || BDIFF(s, str) < maxlen) && s.at(0) != NUL)
;       {
            ;; We are at the end of the screen line when:
            ;; - When outputting a newline.
            ;; - When outputting a character in the last column.

;           if (!recurse && @Rows - 1 <= @msg_row && (s.at(0) == (byte)'\n' || (
;                       @cmdmsg_rl
;                       ? (@msg_col <= 1
;                           || (s.at(0) == TAB && @msg_col <= 7)
;                           || (1 < us_ptr2cells(s) && @msg_col <= 2))
;                       : ((int)@Columns - 1 <= @msg_col + t_col
;                           || (s.at(0) == TAB && (((int)@Columns - 1) & ~7) <= @msg_col + t_col)
;                           || (1 < us_ptr2cells(s) && (int)@Columns - 2 <= @msg_col + t_col)))))
;           {
                ;; The screen is scrolled up when at the last row (some terminals scroll
                ;; automatically, some don't.  To avoid problems we scroll ourselves).

;               if (0 < t_col)
                    ;; output postponed text
;                   t_col = t_puts(t_col, t_s, s, attr);

                ;; When no more prompt and no more room, truncate here.
;               if (@msg_no_more && @lines_left == 0)
;                   break;

                ;; Scroll the screen up one line.
;               msg_scroll_up();

;               @msg_row = (int)@Rows - 2;
;               if ((int)@Columns <= @msg_col)     ;; can happen after screen resize
;                   @msg_col = (int)@Columns - 1;

;               boolean did_last_char;

                ;; Display char in last column before showing more-prompt.
;               if (' ' <= s.at(0) && !@cmdmsg_rl)
;               {
;                   int len;
;                   if (0 <= maxlen)
                        ;; avoid including composing chars after the end
;                       len = us_ptr2len_cc_len(s, BDIFF(str.plus(maxlen), s));
;                   else
;                       len = us_ptr2len_cc(s);
;                   s = screen_puts_mbyte(s, len, attr);

;                   did_last_char = true;
;               }
;               else
;                   did_last_char = false;

;               if (@p_more)
                    ;; store text for scrolling back
;                   store_sb_text(sb_str, s, attr, sb_col, true);

;               inc_msg_scrolled();
;               @need_wait_return = true;    ;; may need wait_return in main()
;               if (@must_redraw < VALID)
;                   @must_redraw = VALID;
;               @redraw_cmdline = true;
;               if (0 < @cmdline_row && @exmode_active == 0)
;                   --@cmdline_row;

                ;; If screen is completely filled and 'more' is set then wait for a character.

;               if (0 < @lines_left)
;                   --@lines_left;
;               if (@p_more && @lines_left == 0 && @State != HITRETURN && !@msg_no_more && @exmode_active == 0)
;               {
;                   if (do_more_prompt(NUL))
;                       s = @confirm_msg_tail;
;                   if (@quit_more)
;                       return;
;               }

                ;; When we displayed a char in last column need to check if there is still more.
;               if (did_last_char)
;                   continue;
;           }

;           boolean wrap = (s.at(0) == (byte)'\n')
;                       || (int)@Columns <= @msg_col + t_col
;                       || (1 < us_ptr2cells(s) && (int)@Columns - 1 <= @msg_col + t_col);
;           if (0 < t_col && (wrap || s.at(0) == (byte)'\r' || s.at(0) == (byte)'\b' || s.at(0) == (byte)'\t' || s.at(0) == BELL))
                ;; output any postponed text
;               t_col = t_puts(t_col, t_s, s, attr);

;           if (wrap && @p_more && !recurse)
                ;; store text for scrolling back
;               store_sb_text(sb_str, s, attr, sb_col, true);

;           if (s.at(0) == (byte)'\n')                 ;; go to next line
;           {
;               @msg_didout = false;         ;; remember that line is empty
;               if (@cmdmsg_rl)
;                   @msg_col = (int)@Columns - 1;
;               else
;                   @msg_col = 0;
;               if (@Rows <= ++@msg_row)      ;; safety check
;                   @msg_row = (int)@Rows - 1;
;           }
;           else if (s.at(0) == (byte)'\r')            ;; go to column 0
;           {
;               @msg_col = 0;
;           }
;           else if (s.at(0) == (byte)'\b')            ;; go to previous char
;           {
;               if (0 < @msg_col)
;                   --@msg_col;
;           }
;           else if (s.at(0) == TAB)                    ;; translate Tab into spaces
;           {
;               do
;               {
;                   msg_screen_putchar(' ', attr);
;               } while ((@msg_col & 7) != 0);
;           }
;           else if (s.at(0) == BELL)                   ;; beep (from ":sh")
;               vim_beep();
;           else
;           {
;               int cells = us_ptr2cells(s);

;               int len;
;               if (0 <= maxlen)
                    ;; avoid including composing chars after the end
;                   len = us_ptr2len_cc_len(s, BDIFF(str.plus(maxlen), s));
;               else
;                   len = us_ptr2len_cc(s);

                ;; When drawing from right to left or when a double-wide character
                ;; doesn't fit, draw a single character here.  Otherwise collect
                ;; characters and draw them all at once later.
;               if (@cmdmsg_rl || (1 < cells && (int)@Columns - 1 <= @msg_col + t_col))
;               {
;                   if (1 < len)
;                       s = screen_puts_mbyte(s, len, attr).minus(1);
;                   else
;                       msg_screen_putchar(s.at(0), attr);
;               }
;               else
;               {
                    ;; postpone this character until later
;                   if (t_col == 0)
;                       t_s = s;
;                   t_col += cells;
;                   s = s.plus(len - 1);
;               }
;           }
;           s = s.plus(1);
;       }

        ;; output any postponed text
;       if (0 < t_col)
;           t_col = t_puts(t_col, t_s, s, attr);
;       if (@p_more && !recurse)
;           store_sb_text(sb_str, s, attr, sb_col, false);

;       msg_check();
    ))

;; Scroll the screen up one line for displaying the next message line.

(defn- #_void msg_scroll_up []
    (§
        ;; scrolling up always works
;       screen_del_lines(0, 0, 1, (int)@Rows, true, null);

;       if (!can_clear(u8(" ")))
;       {
            ;; Scrolling up doesn't result in the right background.
            ;; Set the background here.  It's not efficient,
            ;; but avoids that we have to do it all over the code.
;           screen_fill((int)@Rows - 1, (int)@Rows, 0, (int)@Columns, ' ', ' ', 0);

            ;; Also clear the last char of the last but one line
            ;; if it was not cleared before to avoid a scroll-up.
;           if (@screenAttrs[@lineOffset[(int)@Rows - 2] + (int)@Columns - 1] == -1)
;               screen_fill((int)@Rows - 2, (int)@Rows - 1, (int)@Columns - 1, (int)@Columns, ' ', ' ', 0);
;       }
    ))

;; Increment "msg_scrolled".

(defn- #_void inc_msg_scrolled []
    (§
;       @msg_scrolled++;
    ))

;; To be able to scroll back at the "more" and "hit-enter" prompts we need to
;; store the displayed text and remember where screen lines start.

(class! #_final msgchunk_C
    [
        (field msgchunk_C   sb_next)
        (field msgchunk_C   sb_prev)
        (field boolean      sb_eol)         ;; true when line ends after this text
        (field int          sb_msg_col)     ;; column in which text starts
        (field int          sb_attr)        ;; text attributes
        (field Bytes        sb_text)        ;; text to be displayed, actually longer
    ])

(atom! msgchunk_C last_msgchunk)    ;; last displayed text

(atom! boolean do_clear_sb_text)    ;; clear text on next msg

;; Store part of a printed message for displaying when scrolling back.

(defn- #_void store_sb_text [#_Bytes* sb_str, #_Bytes s, #_int attr, #_int* sb_col, #_boolean finish]
    ;; sb_str: start of string
    ;; s: just after string
    ;; finish: line ends
    (§
;       if (@do_clear_sb_text)
;       {
;           clear_sb_text();
;           @do_clear_sb_text = false;
;       }

;       if (BLT(sb_str[0], s))
;       {
;           msgchunk_C mp = §_msgchunk_C();

;           mp.sb_eol = finish;
;           mp.sb_msg_col = sb_col[0];
;           mp.sb_attr = attr;
;           mp.sb_text = STRNDUP(sb_str[0], BDIFF(s, sb_str[0]));

;           if (@last_msgchunk == null)
;           {
;               @last_msgchunk = mp;
;               mp.sb_prev = null;
;           }
;           else
;           {
;               mp.sb_prev = @last_msgchunk;
;               @last_msgchunk.sb_next = mp;
;               @last_msgchunk = mp;
;           }
;           mp.sb_next = null;
;       }
;       else if (finish && @last_msgchunk != null)
;           @last_msgchunk.sb_eol = true;

;       sb_str[0] = s;
;       sb_col[0] = 0;
    ))

;; Finished showing messages, clear the scroll-back text on the next message.

(defn- #_void may_clear_sb_text []
    (§
;       @do_clear_sb_text = true;
    ))

;; Clear any text remembered for scrolling back.
;; Called when redrawing the screen.

(defn- #_void clear_sb_text []
    (§
;       @last_msgchunk = null;
    ))

;; "g<" command.

(defn- #_void show_sb_text []
    (§
        ;; Only show something if there is more than one line, otherwise it looks weird,
        ;; typing a command without output results in one line.
;       msgchunk_C mp = msg_sb_start(@last_msgchunk);
;       if (mp == null || mp.sb_prev == null)
;           vim_beep();
;       else
;       {
;           do_more_prompt('G');
;           wait_return(FALSE);
;       }
    ))

;; Move to the start of screen line in already displayed text.

(defn- #_msgchunk_C msg_sb_start [#_msgchunk_C mps]
    (§
;       msgchunk_C mp = mps;

;       while (mp != null && mp.sb_prev != null && !mp.sb_prev.sb_eol)
;           mp = mp.sb_prev;

;       return mp;
    ))

;; Mark the last message chunk as finishing the line.

(defn- #_void msg_sb_eol []
    (§
;       if (@last_msgchunk != null)
;           @last_msgchunk.sb_eol = true;
    ))

;; Display a screen line from previously displayed text at row "row".
;; Returns a pointer to the text for the next line (can be null).

(defn- #_msgchunk_C disp_sb_line [#_int row, #_msgchunk_C smp]
    (§
;       msgchunk_C mp = smp;

;       for ( ; ; )
;       {
;           @msg_row = row;
;           @msg_col = mp.sb_msg_col;
;           Bytes p = mp.sb_text;
;           if (p.at(0) == (byte)'\n')             ;; don't display the line break
;               p = p.plus(1);
;           msg_puts_display(p, -1, mp.sb_attr, true);
;           if (mp.sb_eol || mp.sb_next == null)
;               break;
;           mp = mp.sb_next;
;       }

;       return mp.sb_next;
    ))

;; Output any postponed text for msg_puts_attr_len().

(defn- #_int t_puts [#_int t_col, #_Bytes t_s, #_Bytes s, #_int attr]
    (§
        ;; output postponed text
;       @msg_didout = true;          ;; remember that line is not empty
;       screen_puts_len(t_s, BDIFF(s, t_s), @msg_row, @msg_col, attr);
;       @msg_col += t_col;
;       t_col = 0;
        ;; If the string starts with a composing character,
        ;; don't increment the column position for it.
;       if (utf_iscomposing(us_ptr2char(t_s)))
;           --@msg_col;
;       if ((int)@Columns <= @msg_col)
;       {
;           @msg_col = 0;
;           @msg_row++;
;       }
;       return t_col;
    ))

;; Returns true when messages should be printed with mch_errmsg().
;; This is used when there is no valid screen, so we can see error messages.
;; If termcap is not active, we may be writing in an alternate console window,
;; cursor positioning may not work correctly (window size may be different)
;; or we just don't know where the cursor is.

(defn- #_boolean msg_use_printf []
    (§
;       return (!msg_check_screen() || (swapping_screen() && !@termcap_active));
    ))

;; Print a message when there is no valid screen.

(defn- #_void msg_puts_printf [#_Bytes str, #_int maxlen]
    (§
;       for (Bytes s = str; s.at(0) != NUL && (maxlen < 0 || BDIFF(s, str) < maxlen); s = s.plus(1))
;       {
;           if (!(@silent_mode && @p_verbose == 0))
;           {
;               Bytes buf = new Bytes(4);
;               Bytes p = buf;

                ;; NL --> CR NL translation (for Unix, not for "--version")
;               if (s.at(0) == (byte)'\n' && !@info_message)
;                   (p = p.plus(1)).be(-1, (byte)'\r');
;               (p = p.plus(1)).be(-1, s.at(0));
;               p.be(0, NUL);
;               if (@info_message)   ;; informative message, not an error
;                   libC.fprintf(stdout, u8("%s"), buf);
;               else
;                   libC.fprintf(stderr, u8("%s"), buf);
;           }

            ;; primitive way to compute the current column
;           if (@cmdmsg_rl)
;           {
;               if (s.at(0) == (byte)'\r' || s.at(0) == (byte)'\n')
;                   @msg_col = (int)@Columns - 1;
;               else
;                   --@msg_col;
;           }
;           else
;           {
;               if (s.at(0) == (byte)'\r' || s.at(0) == (byte)'\n')
;                   @msg_col = 0;
;               else
;                   @msg_col++;
;           }
;       }

;       @msg_didout = true;      ;; assume that line is not empty
    ))

;; Show the more-prompt and handle the user response.
;; This takes care of scrolling back and displaying previously displayed text.
;; When at hit-enter prompt "typed_char" is the already typed character,
;; otherwise it's NUL.
;; Returns true when jumping ahead to "confirm_msg_tail".

(defn- #_boolean do_more_prompt [#_int typed_char]
    (§
;       boolean retval = false;

;       int used_typed_char = typed_char;
;       int oldState = @State;

;       msgchunk_C mp_last = null;
;       if (typed_char == 'G')
;       {
            ;; "g<": Find first line on the last page.
;           mp_last = msg_sb_start(@last_msgchunk);
;           for (int i = 0; i < @Rows - 2 && mp_last != null && mp_last.sb_prev != null; i++)
;               mp_last = msg_sb_start(mp_last.sb_prev);
;       }

;       @State = ASKMORE;
;       setmouse();
;       if (typed_char == NUL)
;           msg_moremsg(false);

;       for ( ; ; )
;       {
;           int c;

            ;; Get a typed character directly from the user.

;           if (used_typed_char != NUL)
;           {
;               c = used_typed_char;        ;; was typed at hit-enter prompt
;               used_typed_char = NUL;
;           }
;           else
;               c = get_keystroke();

;           int toscroll = 0;
;           switch (c)
;           {
;               case BS:                    ;; scroll one line back
;               case K_BS:
;               case 'k':
;               case K_UP:
;                   toscroll = -1;
;                   break;

;               case CAR:                   ;; one extra line
;               case NL:
;               case 'j':
;               case K_DOWN:
;                   toscroll = 1;
;                   break;

;               case 'u':                   ;; Up half a page
;                   toscroll = -((int)@Rows / 2);
;                   break;

;               case 'd':                   ;; Down half a page
;                   toscroll = (int)@Rows / 2;
;                   break;

;               case 'b':                   ;; one page back
;               case K_PAGEUP:
;                   toscroll = -((int)@Rows - 1);
;                   break;

;               case ' ':                   ;; one extra page
;               case 'f':
;               case K_PAGEDOWN:
;               case K_LEFTMOUSE:
;                   toscroll = (int)@Rows - 1;
;                   break;

;               case 'g':                   ;; all the way back to the start
;                   toscroll = -999999;
;                   break;

;               case 'G':                   ;; all the way to the end
;                   toscroll = 999999;
;                   @lines_left = 999999;
;                   break;

;               case ':':                   ;; start new command line
;                   if (@confirm_msg_used == 0)
;                   {
                        ;; Since got_int is set all typeahead will be flushed, but we
                        ;; want to keep this ':', remember that in a special way.
;                       typeahead_noflush(':');
;                       @cmdline_row = (int)@Rows - 1;         ;; put ':' on this line
;                       @skip_redraw = true;             ;; skip redraw once
;                       @need_wait_return = false;       ;; don't wait in main()
;                   }
                    ;; FALLTHROUGH
;               case 'q':                   ;; quit
;               case Ctrl_C:
;               case ESC:
;                   if (@confirm_msg_used != 0)
;                   {
                        ;; Jump to the choices of the dialog.
;                       retval = true;
;                   }
;                   else
;                   {
;                       @got_int = true;
;                       @quit_more = true;
;                   }
                    ;; When there is some more output (wrapping line)
                    ;; display that without another prompt.
;                   @lines_left = (int)@Rows - 1;
;                   break;

;               case Ctrl_Y:
                    ;; Strange way to allow copying (yanking) a modeless
                    ;; selection at the more prompt.  Use CTRL-Y,
                    ;; because the same is used in Cmdline-mode and at the
                    ;; hit-enter prompt.  However, scrolling one line up
                    ;; might be expected...
;                   if (@clip_star.state == SELECT_DONE)
;                       clip_copy_modeless_selection(true);
;                   continue;

;               default:                    ;; no valid response
;                   msg_moremsg(true);
;                   continue;
;           }

;           if (toscroll != 0)
;           {
;               if (toscroll < 0)
;               {
;                   msgchunk_C mp;
                    ;; go to start of last line
;                   if (mp_last == null)
;                       mp = msg_sb_start(@last_msgchunk);
;                   else if (mp_last.sb_prev != null)
;                       mp = msg_sb_start(mp_last.sb_prev);
;                   else
;                       mp = null;

                    ;; go to start of line at top of the screen
;                   for (int i = 0; i < @Rows - 2 && mp != null && mp.sb_prev != null; i++)
;                       mp = msg_sb_start(mp.sb_prev);

;                   if (mp != null && mp.sb_prev != null)
;                   {
                        ;; Find line to be displayed at top.
;                       for (int i = 0; toscroll < i; --i)
;                       {
;                           if (mp == null || mp.sb_prev == null)
;                               break;
;                           mp = msg_sb_start(mp.sb_prev);
;                           if (mp_last == null)
;                               mp_last = msg_sb_start(@last_msgchunk);
;                           else
;                               mp_last = msg_sb_start(mp_last.sb_prev);
;                       }

;                       if (toscroll == -1 && screen_ins_lines(0, 0, 1, (int)@Rows, null) == true)
;                       {
                            ;; display line at top
;                           disp_sb_line(0, mp);
;                       }
;                       else
;                       {
                            ;; redisplay all lines
;                           screenclear();
;                           for (int i = 0; mp != null && i < @Rows - 1; i++)
;                           {
;                               mp = disp_sb_line(i, mp);
;                               @msg_scrolled++;
;                           }
;                       }
;                       toscroll = 0;
;                   }
;               }
;               else
;               {
                    ;; First display any text that we scrolled back.
;                   while (0 < toscroll && mp_last != null)
;                   {
                        ;; scroll up, display line at bottom
;                       msg_scroll_up();
;                       inc_msg_scrolled();
;                       screen_fill((int)@Rows - 2, (int)@Rows - 1, 0, (int)@Columns, ' ', ' ', 0);
;                       mp_last = disp_sb_line((int)@Rows - 2, mp_last);
;                       --toscroll;
;                   }
;               }

;               if (toscroll <= 0)
;               {
                    ;; displayed the requested text, more prompt again
;                   screen_fill((int)@Rows - 1, (int)@Rows, 0, (int)@Columns, ' ', ' ', 0);
;                   msg_moremsg(false);
;                   continue;
;               }

                ;; display more text, return to caller
;               @lines_left = toscroll;
;           }

;           break;
;       }

        ;; clear the --more-- message
;       screen_fill((int)@Rows - 1, (int)@Rows, 0, (int)@Columns, ' ', ' ', 0);
;       @State = oldState;
;       setmouse();
;       if (@quit_more)
;       {
;           @msg_row = (int)@Rows - 1;
;           @msg_col = 0;
;       }
;       else if (@cmdmsg_rl)
;           @msg_col = (int)@Columns - 1;

;       return retval;
    ))

;; Put a character on the screen at the current message position and advance
;; to the next position.  Only for printable ASCII!

(defn- #_void msg_screen_putchar [#_int c, #_int attr]
    (§
;       @msg_didout = true;          ;; remember that line is not empty
;       screen_putchar(c, @msg_row, @msg_col, attr);
;       if (@cmdmsg_rl)
;       {
;           if (--@msg_col == 0)
;           {
;               @msg_col = (int)@Columns;
;               @msg_row++;
;           }
;       }
;       else
;       {
;           if ((int)@Columns <= ++@msg_col)
;           {
;               @msg_col = 0;
;               @msg_row++;
;           }
;       }
    ))

(defn- #_void msg_moremsg [#_boolean full]
    (§
;       Bytes s = u8("-- More --");

;       int attr = hl_attr(HLF_M);
;       screen_puts(s, (int)@Rows - 1, 0, attr);
;       if (full)
;           screen_puts(u8(" SPACE/d/j: screen/page/line down, b/u/k: up, q: quit "),
;                   (int)@Rows - 1, mb_string2cells(s, -1), attr);
    ))

;; Repeat the message for the current mode: ASKMORE, CONFIRM or exmode_active.

(defn- #_void repeat_message []
    (§
;       if (@State == ASKMORE)
;       {
;           msg_moremsg(true);      ;; display --more-- message again
;           @msg_row = (int)@Rows - 1;
;       }
;       else if (@State == CONFIRM)
;       {
;           display_confirm_msg();  ;; display ":confirm" message again
;           @msg_row = (int)@Rows - 1;
;       }
;       else if (@State == HITRETURN || @State == SETWSIZE)
;       {
;           if (@msg_row == (int)@Rows - 1)
;           {
                ;; Avoid drawing the "hit-enter" prompt below the previous one,
                ;; overwrite it.  Esp. useful when regaining focus and a
                ;; FocusGained autocmd exists but didn't draw anything.
;               @msg_didout = false;
;               @msg_col = 0;
;               msg_clr_eos();
;           }
;           hit_return_msg();
;           @msg_row = (int)@Rows - 1;
;       }
    ))

;; msg_check_screen - check if the screen is initialized.
;; Also check msg_row and msg_col, if they are too big it may cause a crash.
;; While starting the GUI the terminal codes will be set for the GUI, but the
;; output goes to the terminal.  Don't use the terminal codes then.

(defn- #_boolean msg_check_screen []
    (§
;       if (!@full_screen || !screen_valid(false))
;           return false;

;       if ((int)@Rows <= @msg_row)
;           @msg_row = (int)@Rows - 1;
;       if ((int)@Columns <= @msg_col)
;           @msg_col = (int)@Columns - 1;
;       return true;
    ))

;; Clear from current message position to end of screen.
;; Skip this when ":silent" was used, no need to clear for redirection.

(defn- #_void msg_clr_eos []
    (§
;       if (@msg_silent == 0)
;           msg_clr_eos_force();
    ))

;; Clear from current message position to end of screen.
;; Note: msg_col is not updated, so we remember the end of the message for msg_check().

(defn- #_void msg_clr_eos_force []
    (§
;       if (msg_use_printf())
;       {
;           if (@full_screen)        ;; only when termcap codes are valid
;           {
;               if (@T_CD.at(0) != NUL)
;                   out_str(@T_CD);  ;; clear to end of display
;               else if (@T_CE.at(0) != NUL)
;                   out_str(@T_CE);  ;; clear to end of line
;           }
;       }
;       else
;       {
;           if (@cmdmsg_rl)
;           {
;               screen_fill(@msg_row, @msg_row + 1, 0, @msg_col + 1, ' ', ' ', 0);
;               screen_fill(@msg_row + 1, (int)@Rows, 0, (int)@Columns, ' ', ' ', 0);
;           }
;           else
;           {
;               screen_fill(@msg_row, @msg_row + 1, @msg_col, (int)@Columns, ' ', ' ', 0);
;               screen_fill(@msg_row + 1, (int)@Rows, 0, (int)@Columns, ' ', ' ', 0);
;           }
;       }
    ))

;; Clear the command line.

(defn- #_void msg_clr_cmdline []
    (§
;       @msg_row = @cmdline_row;
;       @msg_col = 0;
;       msg_clr_eos_force();
    ))

;; end putting a message on the screen
;; call wait_return if the message does not fit in the available space
;; return true if wait_return not called.

(defn- #_boolean msg_end []
    (§
        ;; If the string is larger than the window,
        ;; or the ruler option is set and we run into it,
        ;; we have to redraw the window.
        ;; Do not do this if we are abandoning the file or editing the command line.

;       if (!@exiting && @need_wait_return && (@State & CMDLINE) == 0)
;       {
;           wait_return(FALSE);
;           return false;
;       }
;       out_flush();
;       return true;
    ))

;; If the written message runs into the shown command or ruler, we have to
;; wait for hit-return and redraw the window later.

(defn- #_void msg_check []
    (§
;       if (@msg_row == (int)@Rows - 1 && @sc_col <= @msg_col)
;       {
;           @need_wait_return = true;
;           @redraw_cmdline = true;
;       }
    ))

;; Give a warning message (for searching).
;; Use 'w' highlighting and may repeat the message after redrawing

(defn- #_void give_warning [#_Bytes message, #_boolean hl]
    (§
        ;; Don't do this for ":silent".
;       if (@msg_silent != 0)
;           return;

        ;; Don't want a hit-enter prompt here.
;       @no_wait_return++;

;       @keep_msg = null;
;       if (hl)
;           @keep_msg_attr = hl_attr(HLF_W);
;       else
;           @keep_msg_attr = 0;
;       if (msg_attr(message, @keep_msg_attr) && @msg_scrolled == 0)
;           set_keep_msg(message, @keep_msg_attr);
;       @msg_didout = false;     ;; overwrite this message
;       @msg_nowait = true;      ;; don't wait for this message
;       @msg_col = 0;

;       --@no_wait_return;
    ))

;; Advance msg cursor to column "col".

(defn- #_void msg_advance [#_int col]
    (§
;       if (@msg_silent != 0)        ;; nothing to advance to
;       {
;           @msg_col = col;          ;; for redirection, may fill it up later
;           return;
;       }
;       if ((int)@Columns <= col)         ;; not enough room
;           col = (int)@Columns - 1;
;       if (@cmdmsg_rl)
;       {
;           while ((int)@Columns - col < @msg_col)
;               msg_putchar(' ');
;       }
;       else
;       {
;           while (@msg_col < col)
;               msg_putchar(' ');
;       }
    ))

;; Used for "confirm()" function, and the :confirm command prefix.
;; Versions which haven't got flexible dialogs yet, and console
;; versions, get this generic handler which uses the command line.
;;
;; Format of the "buttons" string:
;; "Button1Name\nButton2Name\nButton3Name"
;; The first button should normally be the default/accept
;; The second button should be the 'Cancel' button
;; Other buttons- use your imagination!
;; A '&' in a button name becomes a shortcut, so each '&' should be before a different letter.

(defn- #_int do_dialog [#_Bytes message, #_Bytes buttons, #_int dfltbutton, #_boolean ex_cmd]
    ;; ex_cmd: when true pressing : accepts default and starts Ex command
    (§
;       int retval = 0;

        ;; Don't output anything in silent mode ("ex -s").
;       if (@silent_mode)
;           return dfltbutton;      ;; return default option

;       int oldState = @State;
;       @State = CONFIRM;
;       setmouse();

        ;; Since we wait for a keypress,
        ;; don't make the user press RETURN as well afterwards.

;       @no_wait_return++;
;       Bytes hotkeys = msg_show_console_dialog(message, buttons, dfltbutton);

;       if (hotkeys != null)
;       {
;           for ( ; ; )
;           {
                ;; Get a typed character directly from the user.
;               int c = get_keystroke();
;               switch (c)
;               {
;                   case CAR:           ;; User accepts default option
;                   case NL:
;                       retval = dfltbutton;
;                       break;

;                   case Ctrl_C:        ;; User aborts/cancels
;                   case ESC:
;                       retval = 0;
;                       break;

;                   default:            ;; Could be a hotkey?
;                       if (c < 0)      ;; special keys are ignored here
;                           continue;
;                       if (c == ':' && ex_cmd)
;                       {
;                           retval = dfltbutton;
;                           ins_char_typebuf(':');
;                           break;
;                       }

                        ;; Make the character lowercase, as chars in "hotkeys" are.
;                       c = utf_tolower(c);
;                       retval = 1;
;                       int i;
;                       for (i = 0; hotkeys.at(i) != NUL; i++)
;                       {
;                           if (us_ptr2char(hotkeys.plus(i)) == c)
;                               break;
;                           i += us_ptr2len_cc(hotkeys.plus(i)) - 1;
;                           retval++;
;                       }
;                       if (hotkeys.at(i) != NUL)
;                           break;
                        ;; No hotkey match, so keep waiting.
;                       continue;
;               }
;               break;
;           }
;       }

;       @State = oldState;
;       setmouse();
;       --@no_wait_return;
;       msg_end_prompt();

;       return retval;
    ))

;; Copy one character from "*from" to "*to", taking care of multi-byte characters.
;; Return the length of the character in bytes.

(defn- #_int copy_char [#_Bytes from, #_Bytes to, #_boolean lowercase]
    ;; lowercase: make character lower case
    (§
;       if (lowercase)
;       {
;           int c = utf_tolower(us_ptr2char(from));
;           return utf_char2bytes(c, to);
;       }
;       else
;       {
;           int len = us_ptr2len_cc(from);
;           BCOPY(to, from, len);
;           return len;
;       }
    ))

;; Format the dialog string, and display it at the bottom of the screen.
;; Return a string of hotkey chars (if defined) for each 'button'.
;; If a button has no hotkey defined, the first character of the button is used.
;; The hotkeys can be multi-byte characters, but without combining chars.
;;
;; Returns an allocated string with hotkeys, or null for error.

(defn- #_Bytes msg_show_console_dialog [#_Bytes message, #_Bytes buttons, #_int dfltbutton]
    (§
;       Bytes hotk = null;

;       final int HOTK_LEN = MB_MAXBYTES;
;       int lenhotkey = HOTK_LEN;           ;; count first button
;       int len = 0;

;       Bytes msgp = null;
;       Bytes hotkp = null;

;       final int HAS_HOTKEY_LEN = 30;

;       boolean[] has_hotkey = new boolean[HAS_HOTKEY_LEN];
;       has_hotkey[0] = false;
;       boolean first_hotkey = false;       ;; first char of button is hotkey

        ;; First loop: compute the size of memory to allocate.
        ;; Second loop: copy to the allocated memory.

;       for (int copy = 0; copy <= 1; copy++)
;       {
;           Bytes r = buttons;
;           int idx = 0;
;           while (r.at(0) != NUL)
;           {
;               if (r.at(0) == DLG_BUTTON_SEP)
;               {
;                   if (copy != 0)
;                   {
;                       (msgp = msgp.plus(1)).be(-1, (byte)',');
;                       (msgp = msgp.plus(1)).be(-1, (byte)' ');        ;; '\n' -> ', '

                        ;; advance to next hotkey and set default hotkey
;                       hotkp = hotkp.plus(STRLEN(hotkp));
;                       hotkp.be(copy_char(r.plus(1), hotkp, true), NUL);
;                       if (dfltbutton != 0)
;                           --dfltbutton;

                        ;; If no hotkey is specified first char is used.
;                       if (idx < HAS_HOTKEY_LEN - 1 && !has_hotkey[++idx])
;                           first_hotkey = true;
;                   }
;                   else
;                   {
;                       len += 3;               ;; '\n' -> ', '; 'x' -> '(x)'
;                       lenhotkey += HOTK_LEN;  ;; each button needs a hotkey
;                       if (idx < HAS_HOTKEY_LEN - 1)
;                           has_hotkey[++idx] = false;
;                   }
;               }
;               else if (r.at(0) == DLG_HOTKEY_CHAR || first_hotkey)
;               {
;                   if (r.at(0) == DLG_HOTKEY_CHAR)
;                       r = r.plus(1);
;                   first_hotkey = false;
;                   if (copy != 0)
;                   {
;                       if (r.at(0) == DLG_HOTKEY_CHAR)             ;; '&&a' -> '&a'
;                           (msgp = msgp.plus(1)).be(-1, r.at(0));
;                       else
;                       {
                            ;; '&a' -> '[a]'
;                           (msgp = msgp.plus(1)).be(-1, (dfltbutton == 1) ? (byte)'[' : (byte)'(');
;                           msgp = msgp.plus(copy_char(r, msgp, false));
;                           (msgp = msgp.plus(1)).be(-1, (dfltbutton == 1) ? (byte)']' : (byte)')');

                            ;; redefine hotkey
;                           hotkp.be(copy_char(r, hotkp, true), NUL);
;                       }
;                   }
;                   else
;                   {
;                       len++;          ;; '&a' -> '[a]'
;                       if (idx < HAS_HOTKEY_LEN - 1)
;                           has_hotkey[idx] = true;
;                   }
;               }
;               else
;               {
                    ;; everything else copy literally
;                   if (copy != 0)
;                       msgp = msgp.plus(copy_char(r, msgp, false));
;               }

                ;; advance to the next character
;               r = r.plus(us_ptr2len_cc(r));
;           }

;           if (copy != 0)
;           {
;               (msgp = msgp.plus(1)).be(-1, (byte)':');
;               (msgp = msgp.plus(1)).be(-1, (byte)' ');
;               msgp.be(0, NUL);
;           }
;           else
;           {
;               len += STRLEN(message)
;                          + 2                      ;; for the NL's
;                          + STRLEN(buttons)
;                          + 3;                    ;; for the ": " and NUL
;               lenhotkey++;                        ;; for the NUL

                ;; If no hotkey is specified first char is used.
;               if (!has_hotkey[0])
;               {
;                   first_hotkey = true;
;                   len += 2;               ;; "x" -> "[x]"
;               }

                ;; Now allocate and load the strings

;               @confirm_msg = new Bytes(len);
;               @confirm_msg.be(0, (byte)'\n');
;               STRCPY(@confirm_msg.plus(1), message);

;               msgp = @confirm_msg.plus(1 + STRLEN(message));

;               hotk = new Bytes(lenhotkey);
;               hotkp = hotk;

                ;; Define first default hotkey.
                ;; Keep the hotkey string NUL terminated to avoid reading past the end.
;               hotkp.be(copy_char(buttons, hotkp, true), NUL);

                ;; Remember where the choices start,
                ;; displaying starts here when "hotkp" typed at the more prompt.
;               @confirm_msg_tail = msgp;
;               (msgp = msgp.plus(1)).be(-1, (byte)'\n');
;           }
;       }

;       display_confirm_msg();

;       return hotk;
    ))

;; Display the ":confirm" message.  Also called when screen resized.

(defn- #_void display_confirm_msg []
    (§
        ;; avoid that 'q' at the more prompt truncates the message here
;       @confirm_msg_used++;
;       if (@confirm_msg != null)
;           msg_puts_attr(@confirm_msg, hl_attr(HLF_M));
;       --@confirm_msg_used;
    ))

;; This code was included to provide a portable snprintf().
;; Some systems may provide their own, but we always use this one for consistency.
;;
;; This code is based on snprintf.c - a portable implementation of snprintf
;; by Mark Martinec <mark.martinec@ijs.si>, Version 2.2, 2000-10-06.
;; Included with permission.  It was heavily modified to fit in Vim.
;; The original code, including useful comments, can be found here:
;;      http://www.ijs.si/software/snprintf/
;;
;; This snprintf() only supports the following conversion specifiers:
;; s, c, d, u, o, x, X, p  (and synonyms: i, D, U, O - see below)
;; with flags: '-', '+', ' ', '0' and '#'.
;; An asterisk is supported for field width as well as precision.
;;
;; Limited support for floating point was added: 'f', 'e', 'E', 'g', 'G'.
;;
;; Length modifiers 'h' (short int) and 'l' (long int) are supported.
;; 'll' (long long int) is not supported.
;;
;; The locale is not used, the string is used as a byte string.  This is only
;; relevant for double-byte encodings where the second byte may be '%'.
;;
;; It is permitted for "str_m" to be zero, and it is permitted to specify null
;; pointer for resulting string argument if "str_m" is zero (as per ISO C99).
;;
;; The return value is the number of characters which would be generated
;; for the given input, excluding the trailing NUL.  If this value
;; is greater or equal to "str_m", not all characters from the result
;; have been stored in str, output bytes beyond the ("str_m"-1) -th character
;; are discarded.  If "str_m" is greater than zero it is guaranteed
;; the resulting string will be NUL-terminated.

;; Like vim_snprintf() but append to the string.
(defn- #_int vim_snprintf_add [#_Bytes str, #_int str_m, #_Bytes fmt, #_Object... args]
    (§
;       int len = STRLEN(str), space = (len < str_m) ? str_m - len : 0;

;       return vim_snprintf(str.plus(len), space, fmt, args);
    ))

(defn- #_int vim_snprintf [#_Bytes str, #_int str_m, #_Bytes fmt, #_Object... args]
    (§
;       int str_l = 0;
;       int ai = 0;

;       Bytes p = fmt;
;       if (p == null)
;           p = u8("");

;       while (p.at(0) != NUL)
;       {
;           if (p.at(0) != (byte)'%')
;           {
;               Bytes q = STRCHR(p.plus(1), (byte)'%');
;               int n = (q == null) ? STRLEN(p) : BDIFF(q, p);

                ;; Copy up to the next '%' or NUL without any changes.
;               if (str_l < str_m)
;               {
;                   int avail = str_m - str_l;

;                   BCOPY(str, str_l, p, 0, (avail < n) ? avail : n);
;               }
;               p = p.plus(n);
;               str_l += n;
;           }
;           else
;           {
;               int min_field_width = 0, precision = 0;
;               boolean precision_specified = false;
;               boolean zero_padding = false, justify_left = false;
;               boolean alternate_form = false, force_sign = false;

                ;; If both the ' ' and '+' flags appear, the ' ' flag should be ignored.
;               boolean space_for_positive = true;

                ;; allowed values: \0, h, l, L
;               byte length_modifier = NUL;

                ;; On my system 1e308 is the biggest number possible.
                ;; That sounds reasonable to use as the maximum printable.

;               final int TMP_LEN = 350;
                ;; temporary buffer for simple numeric -> string conversion
;               Bytes tmp = new Bytes(TMP_LEN);

                ;; natural field width of arg without padding and sign
;               int str_arg_l;

                ;; unsigned char argument value - only defined for c conversion.
                ;; N.B. standard explicitly states the char argument for the c conversion is unsigned
;               Bytes uchar_arg = new Bytes(1);

                ;; number of zeros to be inserted for numeric conversions
                ;; as required by the precision or minimal field width
;               int number_of_zeros_to_pad = 0;

                ;; index into 'tmp' where zero padding is to be inserted
;               int zero_padding_insertion_ind = 0;

                ;; current conversion specifier character
;               byte fmt_spec = NUL;

                ;; string address in case of string argument
;               Bytes str_arg = null;

;               p = p.plus(1);              ;; skip '%'

                ;; parse flags
;               while (p.at(0) == (byte)'0' || p.at(0) == (byte)'-' || p.at(0) == (byte)'+' || p.at(0) == (byte)' ' || p.at(0) == (byte)'#' || p.at(0) == (byte)'\'')
;               {
;                   switch (p.at(0))
;                   {
;                       case '0': zero_padding = true; break;
;                       case '-': justify_left = true; break;
;                       case '+': force_sign = true; space_for_positive = false; break;
;                       case ' ': force_sign = true;
                                  ;; If both the ' ' and '+' flags appear,
                                  ;; the ' ' flag should be ignored.
;                                 break;
;                       case '#': alternate_form = true; break;
;                       case '\'': break;
;                   }
;                   p = p.plus(1);
;               }
                ;; If the '0' and '-' flags both appear, the '0' flag should be ignored.

                ;; parse field width
;               if (p.at(0) == (byte)'*')
;               {
;                   p = p.plus(1);
;                   int j = (int)args[ai++];
;                   if (0 <= j)
;                       min_field_width = j;
;                   else
;                   {
;                       min_field_width = -j;
;                       justify_left = true;
;                   }
;               }
;               else if (asc_isdigit((int)p.at(0)))
;               {
                    ;; size_t could be wider than unsigned int;
                    ;; make sure we treat argument like common implementations do
;                   long uj = (p = p.plus(1)).at(-1) - '0';

;                   while (asc_isdigit((int)p.at(0)))
;                       uj = 10 * uj + (long)((p = p.plus(1)).at(-1) - '0');

;                   min_field_width = (int)(uj & 0x7fffffffL);
;               }

                ;; parse precision
;               if (p.at(0) == (byte)'.')
;               {
;                   p = p.plus(1);
;                   precision_specified = true;
;                   if (p.at(0) == (byte)'*')
;                   {
;                       int j = (int)args[ai++];
;                       p = p.plus(1);
;                       if (0 <= j)
;                           precision = j;
;                       else
;                       {
;                           precision_specified = false;
;                           precision = 0;
;                       }
;                   }
;                   else if (asc_isdigit((int)p.at(0)))
;                   {
                        ;; size_t could be wider than unsigned int;
                        ;; make sure we treat argument like common implementations do
;                       long uj = (p = p.plus(1)).at(-1) - '0';

;                       while (asc_isdigit((int)p.at(0)))
;                           uj = 10 * uj + (long)((p = p.plus(1)).at(-1) - '0');

;                       precision = (int)(uj & 0x7fffffffL);
;                   }
;               }

                ;; parse 'h', 'l' and 'll' length modifiers
;               if (p.at(0) == (byte)'h' || p.at(0) == (byte)'l')
;               {
;                   length_modifier = p.at(0);
;                   p = p.plus(1);
;                   if (length_modifier == 'l' && p.at(0) == (byte)'l')
;                   {
                        ;; double l = long long
;                       length_modifier = 'l';      ;; treat it as a single 'l'
;                       p = p.plus(1);
;                   }
;               }
;               fmt_spec = p.at(0);

                ;; common synonyms:
;               switch (fmt_spec)
;               {
;                   case 'i': fmt_spec = 'd'; break;
;                   case 'D': fmt_spec = 'd'; length_modifier = 'l'; break;
;                   case 'U': fmt_spec = 'u'; length_modifier = 'l'; break;
;                   case 'O': fmt_spec = 'o'; length_modifier = 'l'; break;
;                   case 'F': fmt_spec = 'f'; break;
;                   default: break;
;               }

                ;; get parameter value, do initial processing
;               switch (fmt_spec)
;               {
                    ;; '%' and 'c' behave similar to 's' regarding flags and field widths
;                   case '%':
;                   case 'c':
;                   case 's':
;                   case 'S':
;                   {
;                       length_modifier = NUL;
;                       str_arg_l = 1;
;                       switch (fmt_spec)
;                       {
;                           case '%':
;                               str_arg = p;
;                               break;

;                           case 'c':
;                           {
;                               int c = (int)args[ai++];

                                ;; standard demands unsigned char
;                               uchar_arg.be(0, /*char_u(*/c/*)*/);
;                               str_arg = uchar_arg;
;                               break;
;                           }

;                           case 's':
;                           case 'S':
;                           {
;                               str_arg = (Bytes)args[ai++];
;                               if (str_arg == null)
;                               {
;                                   str_arg = u8("[NULL]");
;                                   str_arg_l = 6;
;                               }
                                ;; make sure not to address string beyond the specified precision !!!
;                               else if (!precision_specified)
;                                   str_arg_l = STRLEN(str_arg);
                                ;; truncate string if necessary as requested by precision
;                               else if (precision == 0)
;                                   str_arg_l = 0;
;                               else
;                               {
;                                   final int roof = 0x7fffffff;
                                    ;; memchr() on HP does not like n > 2^31 !!!
;                                   Bytes q = MEMCHR(str_arg, NUL, (precision <= roof) ? precision : roof);
;                                   str_arg_l = (q == null) ? precision : BDIFF(q, str_arg);
;                               }
;                               if (fmt_spec == 'S')
;                               {
;                                   if (min_field_width != 0)
;                                       min_field_width += STRLEN(str_arg) - us_string2cells(str_arg, -1);
;                                   if (precision != 0)
;                                   {
;                                       Bytes q = str_arg;

;                                       for (int i = 0; i < precision && q.at(0) != NUL; i++)
;                                           q = q.plus(us_ptr2len_cc(q));

;                                       str_arg_l = precision = BDIFF(q, str_arg);
;                                   }
;                               }
;                               break;
;                           }

;                           default:
;                               break;
;                       }
;                       break;
;                   }

;                   case 'd': case 'u': case 'o': case 'x': case 'X': case 'p':
;                   {
                        ;; u, o, x, X and p conversion specifiers imply the value is unsigned;
                        ;; d implies a signed value

                        ;; 0 if numeric argument is zero (or if pointer is null for 'p'),
                        ;; +1 if greater than zero (or nonzero for unsigned arguments),
                        ;; -1 if negative (unsigned argument is never negative)
;                       int arg_sign = 0;

                        ;; only defined for length modifier h, or for no length modifiers
;                       int int_arg = 0;

                        ;; only defined for length modifier l
;                       long long_arg = 0;

;                       if (fmt_spec == 'd')
;                       {
                            ;; signed
;                           switch (length_modifier)
;                           {
;                               case NUL:
;                               case 'h':
;                               {
                                    ;; char and short arguments are passed as int.
;                                   int_arg = (int)args[ai++];
;                                   if (0 < int_arg)
;                                       arg_sign =  1;
;                                   else if (int_arg < 0)
;                                       arg_sign = -1;
;                                   break;
;                               }
;                               case 'l':
;                               {
;                                   long_arg = (long)args[ai++];
;                                   if (0 < long_arg)
;                                       arg_sign =  1;
;                                   else if (long_arg < 0)
;                                       arg_sign = -1;
;                                   break;
;                               }
;                           }
;                       }
;                       else
;                       {
                            ;; unsigned
;                           switch (length_modifier)
;                           {
;                               case NUL:
;                               case 'h':
;                               {
;                                   int_arg = (int)args[ai++];
;                                   if (int_arg != 0)
;                                       arg_sign = 1;
;                                   break;
;                               }
;                               case 'l':
;                               {
;                                   long_arg = (long)args[ai++];
;                                   if (long_arg != 0)
;                                       arg_sign = 1;
;                                   break;
;                               }
;                           }
;                       }

;                       str_arg = tmp;
;                       str_arg_l = 0;

                        ;; NOTE:
                        ;;   For d, i, u, o, x, and X conversions, if precision is
                        ;;   specified, the '0' flag should be ignored.  This is so
                        ;;   with Solaris 2.6, Digital UNIX 4.0, HPUX 10, Linux,
                        ;;   FreeBSD, NetBSD; but not with Perl.

;                       if (precision_specified)
;                           zero_padding = false;
;                       if (fmt_spec == 'd')
;                       {
;                           if (force_sign && 0 <= arg_sign)
;                               tmp.be(str_arg_l++, space_for_positive ? (byte)' ' : (byte)'+');
                            ;; leave negative numbers for sprintf to handle, to
                            ;; avoid handling tricky cases like (short int)-32768
;                       }
;                       else if (alternate_form)
;                       {
;                           if (arg_sign != 0 && (fmt_spec == 'x' || fmt_spec == 'X') )
;                           {
;                               tmp.be(str_arg_l++, (byte)'0');
;                               tmp.be(str_arg_l++, fmt_spec);
;                           }
                            ;; alternate form should have no effect for 'p' conversion, but ...
;                       }

;                       zero_padding_insertion_ind = str_arg_l;
;                       if (!precision_specified)
;                           precision = 1;      ;; default precision is 1
;                       if (precision == 0 && arg_sign == 0)
;                       {
                            ;; When zero value is formatted with an explicit precision 0,
                            ;; the resulting formatted string is empty (d, i, u, o, x, X, p).

;                       }
;                       else
;                       {
;                           Bytes f = new Bytes(5);
;                           int f_l = 0;

                            ;; construct a simple format string for sprintf
;                           f.be(f_l++, (byte)'%');
;                           if (length_modifier == NUL)
                            ;
;                           else if (length_modifier == '2')
;                           {
;                               f.be(f_l++, (byte)'l');
;                               f.be(f_l++, (byte)'l');
;                           }
;                           else
;                               f.be(f_l++, length_modifier);
;                           f.be(f_l++, fmt_spec);
;                           f.be(f_l++, NUL);

;                           if (fmt_spec == 'd')
;                           {
                                ;; signed
;                               switch (length_modifier)
;                               {
;                                   case NUL:
;                                   case 'h':
;                                       str_arg_l += libC.sprintf(tmp.plus(str_arg_l), f, int_arg);
;                                       break;
;                                   case 'l':
;                                       str_arg_l += libC.sprintf(tmp.plus(str_arg_l), f, long_arg);
;                                       break;
;                               }
;                           }
;                           else
;                           {
                                ;; unsigned
;                               switch (length_modifier)
;                               {
;                                   case NUL:
;                                   case 'h':
;                                       str_arg_l += libC.sprintf(tmp.plus(str_arg_l), f, int_arg);
;                                       break;
;                                   case 'l':
;                                       str_arg_l += libC.sprintf(tmp.plus(str_arg_l), f, long_arg);
;                                       break;
;                               }
;                           }

                            ;; include the optional minus sign and possible "0x"
                            ;; in the region before the zero padding insertion point
;                           if (zero_padding_insertion_ind < str_arg_l
;                                   && tmp.at(zero_padding_insertion_ind) == (byte)'-')
;                               zero_padding_insertion_ind++;
;                           if (zero_padding_insertion_ind + 1 < str_arg_l
;                                   && tmp.at(zero_padding_insertion_ind) == (byte)'0'
;                                   && (tmp.at(zero_padding_insertion_ind + 1) == (byte)'x'
;                                           || tmp.at(zero_padding_insertion_ind + 1) == (byte)'X'))
;                               zero_padding_insertion_ind += 2;
;                       }

;                       int num_of_digits = str_arg_l - zero_padding_insertion_ind;

;                       if (alternate_form && fmt_spec == 'o'
                            ;; unless zero is already the first character
;                           && !(zero_padding_insertion_ind < str_arg_l && tmp.at(zero_padding_insertion_ind) == (byte)'0'))
;                       {
                            ;; assure leading zero for alternate-form octal numbers
;                           if (!precision_specified || precision < num_of_digits + 1)
;                           {
                                ;; precision is increased to force the first character to be zero,
                                ;; except if a zero value is formatted with an explicit precision of zero

;                               precision = num_of_digits + 1;
;                               precision_specified = true;
;                           }
;                       }
                        ;; zero padding to specified precision?
;                       if (num_of_digits < precision)
;                           number_of_zeros_to_pad = precision - num_of_digits;

                        ;; zero padding to specified minimal field width?
;                       if (!justify_left && zero_padding)
;                       {
;                           int n = min_field_width - (str_arg_l + number_of_zeros_to_pad);
;                           if (0 < n)
;                               number_of_zeros_to_pad += n;
;                       }
;                       break;
;                   }

;                   default:
;                   {
                        ;; unrecognized conversion specifier, keep format string as-is
;                       zero_padding = false;       ;; turn zero padding off for non-numeric conversion
;                       justify_left = true;
;                       min_field_width = 0;                ;; reset flags

                        ;; discard the unrecognized conversion,
                        ;; just keep the unrecognized conversion character
;                       str_arg = p;
;                       str_arg_l = 0;
;                       if (p.at(0) != NUL)
;                           str_arg_l++;        ;; include invalid conversion specifier
                                                ;; unchanged if not at end-of-string
;                       break;
;                   }
;               }

;               if (p.at(0) != NUL)
;                   p = p.plus(1);              ;; step over the just processed conversion specifier

                ;; insert padding to the left as requested by min_field_width;
                ;; this does not include the zero padding in case of numerical conversions
;               if (!justify_left)
;               {
                    ;; left padding with blank or zero
;                   int pn = min_field_width - (str_arg_l + number_of_zeros_to_pad);
;                   if (0 < pn)
;                   {
;                       if (str_l < str_m)
;                       {
;                           int avail = str_m - str_l;

;                           BFILL(str, str_l, zero_padding ? (byte)'0' : (byte)' ', (avail < pn) ? avail : pn);
;                       }
;                       str_l += pn;
;                   }
;               }

                ;; zero padding as requested by the precision or by the minimal
                ;; field width for numeric conversions required?
;               if (number_of_zeros_to_pad == 0)
;               {
                    ;; will not copy first part of numeric right now,
                    ;; force it to be copied later in its entirety
;                   zero_padding_insertion_ind = 0;
;               }
;               else
;               {
                    ;; insert first part of numerics (sign or '0x') before zero padding
;                   int zn = zero_padding_insertion_ind;
;                   if (0 < zn)
;                   {
;                       if (str_l < str_m)
;                       {
;                           int avail = str_m - str_l;

;                           BCOPY(str, str_l, str_arg, 0, (avail < zn) ? avail : zn);
;                       }
;                       str_l += zn;
;                   }

                    ;; insert zero padding as requested by the precision or min field width
;                   zn = number_of_zeros_to_pad;
;                   if (0 < zn)
;                   {
;                       if (str_l < str_m)
;                       {
;                           int avail = str_m - str_l;

;                           BFILL(str, str_l, (byte)'0', (avail < zn) ? avail : zn);
;                       }
;                       str_l += zn;
;                   }
;               }

                ;; insert formatted string (or as-is conversion specifier for unknown conversions)
;               {
;                   int sn = str_arg_l - zero_padding_insertion_ind;
;                   if (0 < sn)
;                   {
;                       if (str_l < str_m)
;                       {
;                           int avail = str_m - str_l;

;                           BCOPY(str, str_l, str_arg, zero_padding_insertion_ind, (avail < sn) ? avail : sn);
;                       }
;                       str_l += sn;
;                   }
;               }

                ;; insert right padding
;               if (justify_left)
;               {
                    ;; right blank padding to the field width
;                   int pn = min_field_width - (str_arg_l + number_of_zeros_to_pad);
;                   if (0 < pn)
;                   {
;                       if (str_l < str_m)
;                       {
;                           int avail = str_m - str_l;

;                           BFILL(str, str_l, (byte)' ', (avail < pn) ? avail : pn);
;                       }
;                       str_l += pn;
;                   }
;               }
;           }
;       }

;       if (0 < str_m)
;       {
            ;; make sure the string is nul-terminated even at the expense of
            ;; overwriting the last character (shouldn't happen, but just in case)

;           str.be((str_l <= str_m - 1) ? str_l : str_m - 1, NUL);
;       }

        ;; Return the number of characters formatted (excluding trailing nul character), that is,
        ;; the number of characters that would have been written to the buffer if it were large enough.

;       return str_l;
    ))

;; Code to handle user-settable options.  This is all pretty much table-
;; driven.  Checklist for adding a new option:
;; - Put it in the options array below (copy an existing entry).
;; - For a global option: Add a variable for it in option.h.
;; - For a buffer or window local option:
;;   - Add a PV_XX entry to the enum below.
;;   - Add a variable to the window or buffer struct in structs.h.
;;   - For a window option, add some code to copy_winopt().
;;   - For a buffer option, add some code to buf_copy_options().
;;   - For a buffer string option, add code to check_buf_options().
;; - If it's a numeric option, add any necessary bounds checks to do_set().
;; - If it's a list of flags, add some code in do_set(), search for WW_ALL.
;; When making changes:
;; - When an entry has the P_VIM flag, or is lacking the P_VI_DEF flag,
;;   add a comment at the help for the 'compatible' option.

;; The options that are local to a window or buffer have "indir" set to
;; one of these values.  Special values:
;; PV_NONE: global option.
;; PV_WIN is added: window-local option
;; PV_BUF is added: buffer-local option
;; PV_BOTH is added: global option which also has a local value.

(final int
    PV_NONE 0,
    PV_BOTH 0x1000,
    PV_WIN  0x2000,
    PV_BUF  0x4000,
    PV_MASK 0x0fff)

;; Definition of the PV_ values for buffer-local options.
;; The BV_ values are defined in option.h.

(final int
    PV_AI   (| BV_AI   PV_BUF),
    PV_BIN  (| BV_BIN  PV_BUF),
    PV_CI   (| BV_CI   PV_BUF),
    PV_CIN  (| BV_CIN  PV_BUF),
    PV_CINK (| BV_CINK PV_BUF),
    PV_CINO (| BV_CINO PV_BUF),
    PV_CINW (| BV_CINW PV_BUF),
    PV_CM   (| BV_CM   PV_BUF   PV_BOTH),
    PV_COM  (| BV_COM  PV_BUF),
    PV_ET   (| BV_ET   PV_BUF),
    PV_FLP  (| BV_FLP  PV_BUF),
    PV_FO   (| BV_FO   PV_BUF),
    PV_INF  (| BV_INF  PV_BUF),
    PV_ISK  (| BV_ISK  PV_BUF),
    PV_KP   (| BV_KP   PV_BUF   PV_BOTH),
    PV_LISP (| BV_LISP PV_BUF),
    PV_LW   (| BV_LW   PV_BUF   PV_BOTH),
    PV_MA   (| BV_MA   PV_BUF),
    PV_MOD  (| BV_MOD  PV_BUF),
    PV_MPS  (| BV_MPS  PV_BUF),
    PV_NF   (| BV_NF   PV_BUF),
    PV_PI   (| BV_PI   PV_BUF),
    PV_QE   (| BV_QE   PV_BUF),
    PV_RO   (| BV_RO   PV_BUF),
    PV_SI   (| BV_SI   PV_BUF),
    PV_STS  (| BV_STS  PV_BUF),
    PV_SW   (| BV_SW   PV_BUF),
    PV_TS   (| BV_TS   PV_BUF),
    PV_TW   (| BV_TW   PV_BUF),
    PV_UL   (| BV_UL   PV_BUF   PV_BOTH),
    PV_WM   (| BV_WM   PV_BUF))

;; Definition of the PV_ values for window-local options.
;; The WV_ values are defined in option.h.

(final int
    PV_LIST   (| WV_LIST   PV_WIN),
    PV_COCU   (| WV_COCU   PV_WIN),
    PV_COLE   (| WV_COLE   PV_WIN),
    PV_CRBIND (| WV_CRBIND PV_WIN),
    PV_BRI    (| WV_BRI    PV_WIN),
    PV_BRIOPT (| WV_BRIOPT PV_WIN),
    PV_LBR    (| WV_LBR    PV_WIN),
    PV_NU     (| WV_NU     PV_WIN),
    PV_RNU    (| WV_RNU    PV_WIN),
    PV_NUW    (| WV_NUW    PV_WIN),
    PV_RL     (| WV_RL     PV_WIN),
    PV_RLC    (| WV_RLC    PV_WIN),
    PV_SCBIND (| WV_SCBIND PV_WIN),
    PV_SCROLL (| WV_SCROLL PV_WIN),
    PV_CUC    (| WV_CUC    PV_WIN),
    PV_CUL    (| WV_CUL    PV_WIN),
    PV_CC     (| WV_CC     PV_WIN),
    PV_WFH    (| WV_WFH    PV_WIN),
    PV_WFW    (| WV_WFW    PV_WIN),
    PV_WRAP   (| WV_WRAP   PV_WIN))

;; Options local to a window have a value local to a buffer and global to all buffers.
;; Indicate this by setting "var" to VAR_WIN.

(final Object VAR_WIN (Object.))

;; These are the global values for options which are also local to a buffer.
;; Only to be used in option.c!

(atom! boolean p_ai)
(atom! boolean p_bin)
(atom! boolean p_ci)
(atom! boolean p_cin)
(atom! Bytes   p_cink)
(atom! Bytes   p_cino)
(atom! Bytes   p_cinw)
(atom! Bytes   p_com)
(atom! boolean p_et)
(atom! Bytes   p_fo)
(atom! Bytes   p_flp)
(atom! boolean p_inf)
(atom! Bytes   p_isk)
(atom! boolean p_lisp)
(atom! boolean p_ma)
(atom! boolean p_mod)
(atom! Bytes   p_mps)
(atom! Bytes   p_nf)
(atom! boolean p_pi)
(atom! Bytes   p_qe)
(atom! boolean p_ro)
(atom! boolean p_si)
(atom! long    p_sts)
(atom! long    p_sw)
(atom! long    p_ts)
(atom! long    p_tw)
(atom! long    p_wm)

;; Saved values for when 'bin' is set.
(atom! boolean  p_et_nobin)
(atom! long     p_tw_nobin)
(atom! long     p_wm_nobin)

;; Saved values for when 'paste' is set.
(atom! long     p_tw_nopaste)
(atom! long     p_wm_nopaste)
(atom! long     p_sts_nopaste)
(atom! boolean  p_ai_nopaste)

(class! #_final vimoption_C
    [
        (field Bytes    fullname)   ;; full option name
        (field Bytes    shortname)  ;; permissible abbreviation
        (atom' long     flags)      ;; see below
        (field Object   var)        ;; global option: pointer to variable;
                                    ;; window-local option: VAR_WIN;
                                    ;; buffer-local option: global value
        (field int      indir)      ;; global option: PV_NONE;
                                    ;; local option: indirect option index
        (field Object   def_val)    ;; default value for variable
    ])

(defn- #_vimoption_C new_vimoption [#_Bytes fullname, #_Bytes shortname, #_long flags, #_Object var, #_int indir, #_Object def_val]
    (§
;       vimoption_C v = §_vimoption_C();

;       v.fullname = fullname;
;       v.shortname = shortname;
;       v.@flags = flags;
;       v.var = var;
;       v.indir = indir;
;       v.def_val = def_val;

;       return v;
    ))

;; Flags

(final int P_BOOL               0x01)   ;; the option is boolean
(final int P_NUM                0x02)   ;; the option is numeric
(final int P_STRING             0x04)   ;; the option is a string

(final int P_NODEFAULT          0x40)   ;; don't set to default value
(final int P_WAS_SET           0x100)   ;; option has been set/reset

                                        ;; when option changed, what to display:
(final int P_RSTAT            0x1000)   ;; redraw status lines
(final int P_RWIN             0x2000)   ;; redraw current window
(final int P_RBUF             0x4000)   ;; redraw current buffer
(final int P_RALL             0x6000)   ;; redraw all windows
(final int P_RCLR             0x7000)   ;; clear and redraw all

(final int P_COMMA            0x8000)   ;; comma separated list
(final int P_NODUP           0x10000)   ;; don't allow duplicate strings
(final int P_FLAGLIST        0x20000)   ;; list of single-char flags

(final int P_SECURE          0x40000)   ;; cannot change in modeline or secure mode
(final int P_GETTEXT         0x80000)   ;; expand default value with _()
(final int P_NOGLOB         0x100000)   ;; do not use local value for global vimrc
(final int P_NFNAME         0x200000)   ;; only normal file name chars allowed
(final int P_INSECURE       0x400000)   ;; option was set from a modeline
(final int P_NO_ML         0x1000000)   ;; not allowed in modeline
(final int P_CURSWANT      0x2000000)   ;; update curswant required; not needed when there is a redraw flag

(final Bytes COMMENTS_INIT (u8 "s1:/*,mb:*,ex:*/,://,b:#,:%,:XCOMM,n:>,fb:-"))

(final Bytes HIGHLIGHT_INIT (u8 "8:SpecialKey,@:NonText,d:Directory,e:ErrorMsg,i:IncSearch,l:Search,m:MoreMsg,M:ModeMsg,n:LineNr,N:CursorLineNr,r:Question,s:StatusLine,S:StatusLineNC,c:VertSplit,t:Title,v:Visual,V:VisualNOS,w:WarningMsg,W:WildMenu,f:Folded,F:FoldColumn,A:DiffAdd,C:DiffChange,D:DiffDelete,T:DiffText,>:SignColumn,-:Conceal,B:SpellBad,P:SpellCap,R:SpellRare,L:SpellLocal,+:Pmenu,=:PmenuSel,x:PmenuSbar,X:PmenuThumb,*:TabLine,#:TabLineSel,_:TabLineFill,!:CursorColumn,.:CursorLine,o:ColorColumn"))

(defn- #_vimoption_C bool_opt [#_Bytes fname, #_Bytes sname, #_long flags, #_"/*boolean[]*/Object" var, #_int indir, #_boolean def]
    (§
;       return new_vimoption(fname, sname, P_BOOL | flags, var, indir, def);
    ))

(defn- #_vimoption_C long_opt [#_Bytes fname, #_Bytes sname, #_long flags, #_"/*long[]*/Object" var, #_int indir, #_long def]
    (§
;       return new_vimoption(fname, sname, P_NUM | flags, var, indir, def);
    ))

(defn- #_vimoption_C utf8_opt [#_Bytes fname, #_Bytes sname, #_long flags, #_"/*Bytes[]*/Object" var, #_int indir, #_Bytes def]
    (§
;       return new_vimoption(fname, sname, P_STRING | flags, var, indir, def);
    ))

(defn- #_vimoption_C term_opt [#_Bytes fname, #_Bytes* var]
    (§
;       return utf8_opt(fname, null, P_RALL|P_SECURE, var, PV_NONE, u8(""));
    ))

;; vimoptions[] are initialized here.
;;
;; The order of the options MUST be alphabetic for ":set all" and findoption().
;; All option names MUST start with a lowercase letter (for findoption()).
;; Exception: "t_" options are at the end.
;; The options with a null variable are 'hidden': a set command for them is
;; ignored and they are not printed.

(final vimoption_C* vimoptions
    [
        (bool_opt (u8 "allowrevins"),    (u8 "ari"),       0,                           p_ari,       PV_NONE,    false),
        (utf8_opt (u8 "ambiwidth"),      (u8 "ambw"),      P_RCLR,                      p_ambw,      PV_NONE,   (u8 "single")),
        (bool_opt (u8 "autoindent"),     (u8 "ai"),        0,                           p_ai,        PV_AI,      false),
        (utf8_opt (u8 "background"),     (u8 "bg"),        P_RCLR,                      p_bg,        PV_NONE,   (u8 "light")),
        (utf8_opt (u8 "backspace"),      (u8 "bs"),     (| P_COMMA P_NODUP),            p_bs,        PV_NONE,   (u8 "")),
        (bool_opt (u8 "binary"),         (u8 "bin"),       P_RSTAT,                     p_bin,       PV_BIN,     false),
        (utf8_opt (u8 "breakat"),        (u8 "brk"),    (| P_RALL P_FLAGLIST),          p_breakat,   PV_NONE,   (u8 " \t!@*-+;:,./?")),
        (bool_opt (u8 "breakindent"),    (u8 "bri"),       P_RWIN,                      VAR_WIN,     PV_BRI,     false),
        (utf8_opt (u8 "breakindentopt"), (u8 "briopt"), (| P_RBUF P_COMMA P_NODUP),     VAR_WIN,     PV_BRIOPT, (u8 "")),
        (utf8_opt (u8 "cedit"),           null,            0,                           p_cedit,     PV_NONE,    CTRL_F_STR),
        (bool_opt (u8 "cindent"),        (u8 "cin"),       0,                           p_cin,       PV_CIN,     false),
        (utf8_opt (u8 "cinkeys"),        (u8 "cink"),   (| P_COMMA P_NODUP),            p_cink,      PV_CINK,   (u8 "0{,0},0),:,0#,!^F,o,O,e")),
        (utf8_opt (u8 "cinoptions"),     (u8 "cino"),   (| P_COMMA P_NODUP),            p_cino,      PV_CINO,   (u8 "")),
        (utf8_opt (u8 "cinwords"),       (u8 "cinw"),   (| P_COMMA P_NODUP),            p_cinw,      PV_CINW,   (u8 "if,else,while,do,for,switch")),
        (utf8_opt (u8 "clipboard"),      (u8 "cb"),     (| P_COMMA P_NODUP),            p_cb,        PV_NONE,   (u8 "")),
        (long_opt (u8 "cmdheight"),      (u8 "ch"),        P_RALL,                      p_ch,        PV_NONE,    1#_L),
        (long_opt (u8 "cmdwinheight"),   (u8 "cwh"),       0,                           p_cwh,       PV_NONE,    7#_L),
        (utf8_opt (u8 "colorcolumn"),    (u8 "cc"),     (| P_COMMA P_NODUP P_RWIN),     VAR_WIN,     PV_CC,     (u8 "")),
        (long_opt (u8 "columns"),        (u8 "co"),     (| P_NODEFAULT P_RCLR),         Columns,     PV_NONE,    80#_L),
        (utf8_opt (u8 "comments"),       (u8 "com"),    (| P_COMMA P_NODUP P_CURSWANT), p_com,       PV_COM,     COMMENTS_INIT),
        (utf8_opt (u8 "concealcursor"),  (u8 "cocu"),      P_RWIN,                      VAR_WIN,     PV_COCU,   (u8 "")),
        (long_opt (u8 "conceallevel"),   (u8 "cole"),      P_RWIN,                      VAR_WIN,     PV_COLE,    0#_L),
        (bool_opt (u8 "copyindent"),     (u8 "ci"),        0,                           p_ci,        PV_CI,      false),
        (utf8_opt (u8 "cpoptions"),      (u8 "cpo"),    (| P_RALL P_FLAGLIST),          p_cpo,       PV_NONE,    CPO_VIM),
        (bool_opt (u8 "cursorbind"),     (u8 "crb"),       0,                           VAR_WIN,     PV_CRBIND,  false),
        (bool_opt (u8 "cursorcolumn"),   (u8 "cuc"),       P_RWIN,                      VAR_WIN,     PV_CUC,     false),
        (bool_opt (u8 "cursorline"),     (u8 "cul"),       P_RWIN,                      VAR_WIN,     PV_CUL,     false),
        (bool_opt (u8 "delcombine"),     (u8 "deco"),      0,                           p_deco,      PV_NONE,    false),
        (bool_opt (u8 "digraph"),        (u8 "dg"),        0,                           p_dg,        PV_NONE,    false),
        (utf8_opt (u8 "display"),        (u8 "dy"),     (| P_COMMA P_RALL P_NODUP),     p_dy,        PV_NONE,   (u8 "")),
        (utf8_opt (u8 "eadirection"),    (u8 "ead"),       0,                           p_ead,       PV_NONE,   (u8 "both")),
        (bool_opt (u8 "equalalways"),    (u8 "ea"),        P_RALL,                      p_ea,        PV_NONE,    true),
        (bool_opt (u8 "errorbells"),     (u8 "eb"),        0,                           p_eb,        PV_NONE,    false),
        (bool_opt (u8 "esckeys"),        (u8 "ek"),        0,                           p_ek,        PV_NONE,    true),
        (bool_opt (u8 "expandtab"),      (u8 "et"),        0,                           p_et,        PV_ET,      false),
        (utf8_opt (u8 "fillchars"),      (u8 "fcs"),    (| P_RALL P_COMMA P_NODUP),     p_fcs,       PV_NONE,   (u8 "vert:|,fold:-")),
        (utf8_opt (u8 "formatoptions"),  (u8 "fo"),        P_FLAGLIST,                  p_fo,        PV_FO,      DFLT_FO_VIM),
        (utf8_opt (u8 "formatlistpat"),  (u8 "flp"),       0,                           p_flp,       PV_FLP,    (u8 "^\\s*\\d\\+[\\]:.)}\\t ]\\s*")),
        (bool_opt (u8 "fsync"),          (u8 "fs"),        P_SECURE,                    p_fs,        PV_NONE,    true),
        (bool_opt (u8 "gdefault"),       (u8 "gd"),        0,                           p_gd,        PV_NONE,    false),
        (utf8_opt (u8 "highlight"),      (u8 "hl"),     (| P_RCLR P_COMMA P_NODUP),     p_hl,        PV_NONE,    HIGHLIGHT_INIT),
        (long_opt (u8 "history"),        (u8 "hi"),        0,                           p_hi,        PV_NONE,    50#_L),
        (bool_opt (u8 "hlsearch"),       (u8 "hls"),       P_RALL,                      p_hls,       PV_NONE,    false),
        (bool_opt (u8 "ignorecase"),     (u8 "ic"),        0,                           p_ic,        PV_NONE,    false),
        (bool_opt (u8 "incsearch"),      (u8 "is"),        0,                           p_is,        PV_NONE,    false),
        (bool_opt (u8 "infercase"),      (u8 "inf"),       0,                           p_inf,       PV_INF,     false),
        (bool_opt (u8 "insertmode"),     (u8 "im"),        0,                           p_im,        PV_NONE,    false),
        (utf8_opt (u8 "isfname"),        (u8 "isf"),    (| P_COMMA P_NODUP),            p_isf,       PV_NONE,   (u8 "@,48-57,/,.,-,_,+,,,#,$,%,~,=")),
        (utf8_opt (u8 "isident"),        (u8 "isi"),    (| P_COMMA P_NODUP),            p_isi,       PV_NONE,   (u8 "@,48-57,_,192-255")),
        (utf8_opt (u8 "iskeyword"),      (u8 "isk"),    (| P_COMMA P_NODUP),            p_isk,       PV_ISK,    (u8 "@,48-57,_,192-255")),
        (utf8_opt (u8 "isprint"),        (u8 "isp"),    (| P_RALL P_COMMA P_NODUP),     p_isp,       PV_NONE,   (u8 "@,161-255")),
        (bool_opt (u8 "joinspaces"),     (u8 "js"),        0,                           p_js,        PV_NONE,    true),
        (utf8_opt (u8 "keymodel"),       (u8 "km"),     (| P_COMMA P_NODUP),            p_km,        PV_NONE,   (u8 "")),
        (utf8_opt (u8 "keywordprg"),     (u8 "kp"),        P_SECURE,                    p_kp,        PV_KP,     (u8 ":echo")),
        (long_opt (u8 "laststatus"),     (u8 "ls"),        P_RALL,                      p_ls,        PV_NONE,    1#_L),
        (bool_opt (u8 "lazyredraw"),     (u8 "lz"),        0,                           p_lz,        PV_NONE,    false),
        (bool_opt (u8 "linebreak"),      (u8 "lbr"),       P_RWIN,                      VAR_WIN,     PV_LBR,     false),
        (long_opt (u8 "lines"),           null,         (| P_NODEFAULT P_RCLR),         Rows,        PV_NONE,    24#_L),
        (bool_opt (u8 "lisp"),            null,            0,                           p_lisp,      PV_LISP,    false),
        (utf8_opt (u8 "lispwords"),      (u8 "lw"),     (| P_COMMA P_NODUP),            p_lispwords, PV_LW,      LISPWORD_VALUE),
        (bool_opt (u8 "list"),            null,            P_RWIN,                      VAR_WIN,     PV_LIST,    false),
        (utf8_opt (u8 "listchars"),      (u8 "lcs"),    (| P_RALL P_COMMA P_NODUP),     p_lcs,       PV_NONE,   (u8 "eol:$")),
        (bool_opt (u8 "magic"),           null,            0,                           p_magic,     PV_NONE,    true),
        (utf8_opt (u8 "matchpairs"),     (u8 "mps"),    (| P_COMMA P_NODUP),            p_mps,       PV_MPS,    (u8 "(:),{:},[:]")),
        (long_opt (u8 "matchtime"),      (u8 "mat"),       0,                           p_mat,       PV_NONE,    5#_L),
        (long_opt (u8 "maxcombine"),     (u8 "mco"),       P_CURSWANT,                  p_mco,       PV_NONE,    2#_L),
        (long_opt (u8 "maxmapdepth"),    (u8 "mmd"),       0,                           p_mmd,       PV_NONE,    1000#_L),
        (long_opt (u8 "maxmempattern"),  (u8 "mmp"),       0,                           p_mmp,       PV_NONE,    1000#_L),
        (bool_opt (u8 "modifiable"),     (u8 "ma"),        P_NOGLOB,                    p_ma,        PV_MA,      true),
        (bool_opt (u8 "modified"),       (u8 "mod"),       P_RSTAT,                     p_mod,       PV_MOD,     false),
        (bool_opt (u8 "more"),            null,            0,                           p_more,      PV_NONE,    true),
        (utf8_opt (u8 "mouse"),           null,            P_FLAGLIST,                  p_mouse,     PV_NONE,   (u8 "")),
        (utf8_opt (u8 "mousemodel"),     (u8 "mousem"),    0,                           p_mousem,    PV_NONE,   (u8 "extend")),
        (long_opt (u8 "mousetime"),      (u8 "mouset"),    0,                           p_mouset,    PV_NONE,    500#_L),
        (utf8_opt (u8 "nrformats"),      (u8 "nf"),     (| P_COMMA P_NODUP),            p_nf,        PV_NF,     (u8 "octal,hex")),
        (bool_opt (u8 "number"),         (u8 "nu"),        P_RWIN,                      VAR_WIN,     PV_NU,      false),
        (long_opt (u8 "numberwidth"),    (u8 "nuw"),       P_RWIN,                      VAR_WIN,     PV_NUW,     4#_L),
        (utf8_opt (u8 "operatorfunc"),   (u8 "opfunc"),    P_SECURE,                    p_opfunc,    PV_NONE,   (u8 "")),
        (utf8_opt (u8 "paragraphs"),     (u8 "para"),      0,                           p_para,      PV_NONE,   (u8 "IPLPPPQPP TPHPLIPpLpItpplpipbp")),
        (bool_opt (u8 "paste"),           null,            0,                           p_paste,     PV_NONE,    false),
        (utf8_opt (u8 "pastetoggle"),    (u8 "pt"),        0,                           p_pt,        PV_NONE,   (u8 "")),
        (bool_opt (u8 "preserveindent"), (u8 "pi"),        0,                           p_pi,        PV_PI,      false),
        (bool_opt (u8 "prompt"),          null,            0,                           p_prompt,    PV_NONE,    true),
        (utf8_opt (u8 "quoteescape"),    (u8 "qe"),        0,                           p_qe,        PV_QE,     (u8 "\\")),
        (bool_opt (u8 "readonly"),       (u8 "ro"),     (| P_RSTAT P_NOGLOB),           p_ro,        PV_RO,      false),
        (long_opt (u8 "redrawtime"),     (u8 "rdt"),       0,                           p_rdt,       PV_NONE,    2000#_L),
        (long_opt (u8 "regexpengine"),   (u8 "re"),        0,                           p_re,        PV_NONE,    0#_L),
        (bool_opt (u8 "relativenumber"), (u8 "rnu"),       P_RWIN,                      VAR_WIN,     PV_RNU,     false),
        (bool_opt (u8 "remap"),           null,            0,                           p_remap,     PV_NONE,    true),
        (long_opt (u8 "report"),          null,            0,                           p_report,    PV_NONE,    2#_L),
        (bool_opt (u8 "revins"),         (u8 "ri"),        0,                           p_ri,        PV_NONE,    false),
        (bool_opt (u8 "rightleft"),      (u8 "rl"),        P_RWIN,                      VAR_WIN,     PV_RL,      false),
        (utf8_opt (u8 "rightleftcmd"),   (u8 "rlc"),       P_RWIN,                      VAR_WIN,     PV_RLC,    (u8 "search")),
        (bool_opt (u8 "ruler"),          (u8 "ru"),        P_RSTAT,                     p_ru,        PV_NONE,    false),
        (long_opt (u8 "scroll"),         (u8 "scr"),       0,                           VAR_WIN,     PV_SCROLL,  12#_L),
        (bool_opt (u8 "scrollbind"),     (u8 "scb"),       0,                           VAR_WIN,     PV_SCBIND,  false),
        (long_opt (u8 "scrolljump"),     (u8 "sj"),        0,                           p_sj,        PV_NONE,    1#_L),
        (long_opt (u8 "scrolloff"),      (u8 "so"),        P_RALL,                      p_so,        PV_NONE,    0#_L),
        (utf8_opt (u8 "scrollopt"),      (u8 "sbo"),    (| P_COMMA P_NODUP),            p_sbo,       PV_NONE,   (u8 "ver,jump")),
        (utf8_opt (u8 "sections"),       (u8 "sect"),      0,                           p_sections,  PV_NONE,   (u8 "SHNHH HUnhsh")),
        (utf8_opt (u8 "selection"),      (u8 "sel"),       0,                           p_sel,       PV_NONE,   (u8 "inclusive")),
        (utf8_opt (u8 "selectmode"),     (u8 "slm"),    (| P_COMMA P_NODUP),            p_slm,       PV_NONE,   (u8 "")),
        (bool_opt (u8 "shiftround"),     (u8 "sr"),        0,                           p_sr,        PV_NONE,    false),
        (long_opt (u8 "shiftwidth"),     (u8 "sw"),        0,                           p_sw,        PV_SW,      8#_L),
        (utf8_opt (u8 "shortmess"),      (u8 "shm"),       P_FLAGLIST,                  p_shm,       PV_NONE,   (u8 "filnxtToO")),
        (utf8_opt (u8 "showbreak"),      (u8 "sbr"),       P_RALL,                      p_sbr,       PV_NONE,   (u8 "")),
        (bool_opt (u8 "showcmd"),        (u8 "sc"),        0,                           p_sc,        PV_NONE,    false),
        (bool_opt (u8 "showmatch"),      (u8 "sm"),        0,                           p_sm,        PV_NONE,    false),
        (bool_opt (u8 "showmode"),       (u8 "smd"),       0,                           p_smd,       PV_NONE,    true),
        (long_opt (u8 "sidescroll"),     (u8 "ss"),        0,                           p_ss,        PV_NONE,    0#_L),
        (long_opt (u8 "sidescrolloff"),  (u8 "siso"),      P_RBUF,                      p_siso,      PV_NONE,    0#_L),
        (bool_opt (u8 "smartcase"),      (u8 "scs"),       0,                           p_scs,       PV_NONE,    false),
        (bool_opt (u8 "smartindent"),    (u8 "si"),        0,                           p_si,        PV_SI,      false),
        (bool_opt (u8 "smarttab"),       (u8 "sta"),       0,                           p_sta,       PV_NONE,    false),
        (long_opt (u8 "softtabstop"),    (u8 "sts"),       0,                           p_sts,       PV_STS,     0#_L),
        (bool_opt (u8 "splitbelow"),     (u8 "sb"),        0,                           p_sb,        PV_NONE,    false),
        (bool_opt (u8 "splitright"),     (u8 "spr"),       0,                           p_spr,       PV_NONE,    false),
        (bool_opt (u8 "startofline"),    (u8 "sol"),       0,                           p_sol,       PV_NONE,    true),
        (utf8_opt (u8 "tabline"),        (u8 "tal"),       P_RALL,                      p_tal,       PV_NONE,   (u8 "")),
        (long_opt (u8 "tabstop"),        (u8 "ts"),        P_RBUF,                      p_ts,        PV_TS,      8#_L),
        (utf8_opt (u8 "term"),            null,         (| P_NODEFAULT P_RALL),         T_NAME,      PV_NONE,   (u8 "")),
        (bool_opt (u8 "terse"),           null,            0,                           p_terse,     PV_NONE,    false),
        (long_opt (u8 "textwidth"),      (u8 "tw"),        P_RBUF,                      p_tw,        PV_TW,      0#_L),
        (bool_opt (u8 "tildeop"),        (u8 "top"),       0,                           p_to,        PV_NONE,    false),
        (bool_opt (u8 "timeout"),        (u8 "to"),        0,                           p_timeout,   PV_NONE,    true),
        (long_opt (u8 "timeoutlen"),     (u8 "tm"),        0,                           p_tm,        PV_NONE,    1000#_L),
        (bool_opt (u8 "ttimeout"),        null,            0,                           p_ttimeout,  PV_NONE,    false),
        (long_opt (u8 "ttimeoutlen"),    (u8 "ttm"),       0,                           p_ttm,       PV_NONE,    -1#_L),
        (bool_opt (u8 "ttyfast"),        (u8 "tf"),        0,                           p_tf,        PV_NONE,    false),
        (utf8_opt (u8 "ttymouse"),       (u8 "ttym"),      P_NODEFAULT,                 p_ttym,      PV_NONE,   (u8 "")),
        (long_opt (u8 "ttyscroll"),      (u8 "tsl"),       0,                           p_ttyscroll, PV_NONE,    999#_L),
        (long_opt (u8 "undolevels"),     (u8 "ul"),        0,                           p_ul,        PV_UL,      1000#_L),
        (long_opt (u8 "updatetime"),     (u8 "ut"),        0,                           p_ut,        PV_NONE,    4000#_L),
        (long_opt (u8 "verbose"),        (u8 "vbs"),       0,                           p_verbose,   PV_NONE,    0#_L),
        (utf8_opt (u8 "virtualedit"),    (u8 "ve"),     (| P_COMMA P_NODUP P_CURSWANT), p_ve,        PV_NONE,   (u8 "")),
        (bool_opt (u8 "visualbell"),     (u8 "vb"),        0,                           p_vb,        PV_NONE,    false),
        (utf8_opt (u8 "whichwrap"),      (u8 "ww"),     (| P_COMMA P_FLAGLIST),         p_ww,        PV_NONE,   (u8 "b,s")),
        (long_opt (u8 "wildchar"),       (u8 "wc"),        0,                           p_wc,        PV_NONE,   (long TAB)),
        (long_opt (u8 "window"),         (u8 "wi"),        0,                           p_window,    PV_NONE,    0#_L),
        (long_opt (u8 "winheight"),      (u8 "wh"),        0,                           p_wh,        PV_NONE,    1#_L),
        (bool_opt (u8 "winfixheight"),   (u8 "wfh"),       P_RSTAT,                     VAR_WIN,     PV_WFH,     false),
        (bool_opt (u8 "winfixwidth"),    (u8 "wfw"),       P_RSTAT,                     VAR_WIN,     PV_WFW,     false),
        (long_opt (u8 "winminheight"),   (u8 "wmh"),       0,                           p_wmh,       PV_NONE,    1#_L),
        (long_opt (u8 "winminwidth"),    (u8 "wmw"),       0,                           p_wmw,       PV_NONE,    1#_L),
        (long_opt (u8 "winwidth"),       (u8 "wiw"),       0,                           p_wiw,       PV_NONE,    20#_L),
        (bool_opt (u8 "wrap"),            null,            P_RWIN,                      VAR_WIN,     PV_WRAP,    true),
        (long_opt (u8 "wrapmargin"),     (u8 "wm"),        0,                           p_wm,        PV_WM,      0#_L),
        (bool_opt (u8 "wrapscan"),       (u8 "ws"),        0,                           p_ws,        PV_NONE,    true),
        (long_opt (u8 "writedelay"),     (u8 "wd"),        0,                           p_wd,        PV_NONE,    0#_L),

        ;; terminal output codes

        (term_opt (u8 "t_AB"), T_CAB),
        (term_opt (u8 "t_AF"), T_CAF),
        (term_opt (u8 "t_AL"), T_CAL),
        (term_opt (u8 "t_al"), T_AL),
        (term_opt (u8 "t_bc"), T_BC),
        (term_opt (u8 "t_cd"), T_CD),
        (term_opt (u8 "t_ce"), T_CE),
        (term_opt (u8 "t_cl"), T_CL),
        (term_opt (u8 "t_cm"), T_CM),
        (term_opt (u8 "t_Co"), T_CCO),
        (term_opt (u8 "t_CS"), T_CCS),
        (term_opt (u8 "t_cs"), T_CS),
        (term_opt (u8 "t_CV"), T_CSV),
        (term_opt (u8 "t_ut"), T_UT),
        (term_opt (u8 "t_da"), T_DA),
        (term_opt (u8 "t_db"), T_DB),
        (term_opt (u8 "t_DL"), T_CDL),
        (term_opt (u8 "t_dl"), T_DL),
        (term_opt (u8 "t_fs"), T_FS),
        (term_opt (u8 "t_IE"), T_CIE),
        (term_opt (u8 "t_IS"), T_CIS),
        (term_opt (u8 "t_ke"), T_KE),
        (term_opt (u8 "t_ks"), T_KS),
        (term_opt (u8 "t_le"), T_LE),
        (term_opt (u8 "t_mb"), T_MB),
        (term_opt (u8 "t_md"), T_MD),
        (term_opt (u8 "t_me"), T_ME),
        (term_opt (u8 "t_mr"), T_MR),
        (term_opt (u8 "t_ms"), T_MS),
        (term_opt (u8 "t_nd"), T_ND),
        (term_opt (u8 "t_op"), T_OP),
        (term_opt (u8 "t_RI"), T_CRI),
        (term_opt (u8 "t_RV"), T_CRV),
        (term_opt (u8 "t_u7"), T_U7),
        (term_opt (u8 "t_Sb"), T_CSB),
        (term_opt (u8 "t_Sf"), T_CSF),
        (term_opt (u8 "t_se"), T_SE),
        (term_opt (u8 "t_so"), T_SO),
        (term_opt (u8 "t_sr"), T_SR),
        (term_opt (u8 "t_ts"), T_TS),
        (term_opt (u8 "t_te"), T_TE),
        (term_opt (u8 "t_ti"), T_TI),
        (term_opt (u8 "t_ue"), T_UE),
        (term_opt (u8 "t_us"), T_US),
        (term_opt (u8 "t_vb"), T_VB),
        (term_opt (u8 "t_ve"), T_VE),
        (term_opt (u8 "t_vi"), T_VI),
        (term_opt (u8 "t_vs"), T_VS),
        (term_opt (u8 "t_WP"), T_CWP),
        (term_opt (u8 "t_WS"), T_CWS),
        (term_opt (u8 "t_SI"), T_CSI),
        (term_opt (u8 "t_EI"), T_CEI),
        (term_opt (u8 "t_SR"), T_CSR),
        (term_opt (u8 "t_xn"), T_XN),
        (term_opt (u8 "t_xs"), T_XS),
        (term_opt (u8 "t_ZH"), T_CZH),
        (term_opt (u8 "t_ZR"), T_CZR),

        ;; terminal key codes are not in here

        (new_vimoption null, null, 0, null, PV_NONE, null)
    ])

(final Bytes*
    p_ambw_values   [ (u8 "single"), (u8 "double"), null ],
    p_bg_values     [ (u8 "light"), (u8 "dark"), null ],
    p_nf_values     [ (u8 "octal"), (u8 "hex"), (u8 "alpha"), null ],
    p_mousem_values [ (u8 "extend"), (u8 "popup"), (u8 "popup_setpos"), (u8 "mac"), null ],
    p_sel_values    [ (u8 "inclusive"), (u8 "exclusive"), (u8 "old"), null ],
    p_slm_values    [ (u8 "mouse"), (u8 "key"), (u8 "cmd"), null ],
    p_km_values     [ (u8 "startsel"), (u8 "stopsel"), null ],
    p_scbopt_values [ (u8 "ver"), (u8 "hor"), (u8 "jump"), null ],
    p_ead_values    [ (u8 "both"), (u8 "ver"), (u8 "hor"), null ],
    p_bs_values     [ (u8 "indent"), (u8 "eol"), (u8 "start"), null ])

;; Initialize the options, first part.
;;
;; Called only once from main(), just after creating the first buffer.

(defn- #_void set_init_1 []
    (§
        ;; Set all the options (except the terminal options) to their default value.
        ;; Also set the global value for local options.

;       set_options_default(0);

;       @curbuf.b_p_initialized = true;
;       @curbuf.@b_p_ul = NO_LOCAL_UNDOLEVEL;
;       check_buf_options(@curbuf);
;       check_win_options(@curwin);
;       check_options();

;       didset_options();

        ;; initialize the table for 'breakat'.

;       fill_breakat_flags();

        ;; Initialize the highlight_attr[] table.
;       highlight_changed();

        ;; Parse default for 'fillchars'.
;       set_chars_option(p_fcs);

        ;; Parse default for 'clipboard'.
;       check_clipboard_option();

        ;; The cell width depends on the type of multi-byte characters.
;       init_chartab();

        ;; When enc_utf8 is set or reset, (de)allocate screenLinesUC[].
;       screenalloc(false);
    ))

;; Set an option to its default value.
;; This does not take care of side effects!

(defn- #_void set_option_default [#_int opt_idx, #_int opt_flags]
    ;; opt_flags: OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL
    (§
;       boolean both = (opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0;

;       Object varp = get_varp_scope(vimoptions[opt_idx], both ? OPT_LOCAL : opt_flags);
;       long flags = vimoptions[opt_idx].@flags;

;       if (varp != null)       ;; skip hidden option, nothing to do for it
;       {
;           if ((flags & P_STRING) != 0)
;           {
                ;; Use set_string_option_direct() for local options to handle freeing and allocating the value.
;               if (vimoptions[opt_idx].indir != PV_NONE)
;                   set_string_option_direct(null, opt_idx, (Bytes)vimoptions[opt_idx].def_val, opt_flags);
;               else
;                   ((Bytes[])varp)[0] = (Bytes)vimoptions[opt_idx].def_val;
;           }
;           else if ((flags & P_NUM) != 0)
;           {
;               if (vimoptions[opt_idx].indir == PV_SCROLL)
;                   win_comp_scroll(@curwin);
;               else
;               {
;                   ((long[])varp)[0] = (long)vimoptions[opt_idx].def_val;
                    ;; May also set global value for local option.
;                   if (both)
;                       ((long[])get_varp_scope(vimoptions[opt_idx], OPT_GLOBAL))[0] = ((long[])varp)[0];
;               }
;           }
;           else    ;; P_BOOL
;           {
;               ((boolean[])varp)[0] = (boolean)vimoptions[opt_idx].def_val;
                ;; May also set global value for local option.
;               if (both)
;                   ((boolean[])get_varp_scope(vimoptions[opt_idx], OPT_GLOBAL))[0] = ((boolean[])varp)[0];
;           }

            ;; The default value is not insecure.
;           long[] flagsp = insecure_flag(opt_idx, opt_flags);
;           flagsp[0] &= ~P_INSECURE;
;       }
    ))

;; Set all options (except terminal options) to their default value.

(defn- #_void set_options_default [#_int opt_flags]
    ;; opt_flags: OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL
    (§
;       for (int i = 0; !istermoption(vimoptions[i]); i++)
;           if ((vimoptions[i].@flags & P_NODEFAULT) == 0)
;               set_option_default(i, opt_flags);

        ;; The 'scroll' option must be computed for all windows.
;       for (tabpage_C tp = @first_tabpage; tp != null; tp = null)
;           for (window_C wp = (tp == @curtab) ? @firstwin : tp.tp_firstwin; wp != null; wp = wp.w_next)
;               win_comp_scroll(wp);

;       parse_cino(@curbuf);
    ))

;; Set the Vi-default value of a string option.
;; Used for 'term'.

(defn- #_void set_string_default [#_Bytes name, #_Bytes val]
    (§
;       int opt_idx = findoption(name);
;       if (0 <= opt_idx)
;           vimoptions[opt_idx].def_val = STRDUP(val);
    ))

;; Set the Vi-default value of a number option.
;; Used for 'lines' and 'columns'.

(defn- #_void set_number_default [#_Bytes name, #_long val]
    (§
;       int opt_idx = findoption(name);
;       if (0 <= opt_idx)
;           vimoptions[opt_idx].def_val = val;
    ))

;; Initialize the options, part two: After getting Rows and Columns and setting 'term'.

(defn- #_void set_init_2 []
    (§
        ;; 'scroll' defaults to half the window height.
        ;; Note that this default is wrong when the window height changes.

;       set_number_default(u8("scroll"), @Rows >>> 1);
;       int idx = findoption(u8("scroll"));
;       if (0 <= idx && (vimoptions[idx].@flags & P_WAS_SET) == 0)
;           set_option_default(idx, OPT_LOCAL);
;       comp_col();

        ;; 'window' is only for backwards compatibility with Vi.
        ;; Default is Rows - 1.

;       if (!option_was_set(u8("window")))
;           @p_window = @Rows - 1;
;       set_number_default(u8("window"), @Rows - 1);

        ;; If 'background' wasn't set by the user, try guessing the value,
        ;; depending on the terminal name.  Only need to check for terminals
        ;; with a dark background, that can handle color.

;       idx = findoption(u8("bg"));
;       if (0 <= idx && (vimoptions[idx].@flags & P_WAS_SET) == 0 && term_bg_default().at(0) == (byte)'d')
;       {
;           set_string_option_direct(null, idx, u8("dark"), OPT_FREE);
            ;; don't mark it as set, when starting the GUI it may be changed again
;           vimoptions[idx].@flags &= ~P_WAS_SET;
;       }
    ))

;; Return "dark" or "light" depending on the kind of terminal.
;; This is just guessing!  Recognized are:
;; "linux"          Linux console
;; "screen.linux"   Linux console with screen

(defn- #_Bytes term_bg_default []
    (§
;       if (STRCMP(@T_NAME, u8("linux")) == 0 || STRCMP(@T_NAME, u8("screen.linux")) == 0)
;           return u8("dark");

;       return u8("light");
    ))

;; Parse 'arg' for option settings.
;;
;; 'arg' may be ioBuff, but only when no errors can be present
;; and option does not need to be expanded with option_expand().
;; "opt_flags":
;; 0 for ":set"
;; OPT_GLOBAL   for ":setglobal"
;; OPT_LOCAL    for ":setlocal" and a modeline
;; OPT_MODELINE for a modeline
;; OPT_WINONLY  to only set window-local options
;; OPT_NOWIN    to skip setting window-local options
;;
;; returns false if an error is detected, true otherwise

(defn- #_boolean do_set [#_Bytes arg, #_int opt_flags]
    ;; arg: option string (may be written to!)
    (§
;       boolean did_show = false;       ;; already showed one value
;       if (arg.at(0) == NUL)
;       {
;           showoptions(0, opt_flags);
;           did_show = true;
;       }
;       else
;       {
;           Bytes errbuf = new Bytes(80);
;           Bytes key_name = new Bytes(2);

;           Object varp = null;                 ;; pointer to variable for current option

;           for ( ; arg.at(0) != NUL; arg = skipwhite(arg))             ;; loop to process all options
;           {
;               Bytes errmsg = null;
;               Bytes startarg = arg;      ;; remember for error message

;               if (STRNCMP(arg, u8("all"), 3) == 0 && !asc_isalpha(arg.at(3)) && (opt_flags & OPT_MODELINE) == 0)
;               {
                    ;; ":set all"  show all options.
                    ;; ":set all&" set all options to their default value.

;                   arg = arg.plus(3);
;                   if (arg.at(0) == (byte)'&')
;                   {
;                       arg = arg.plus(1);
                        ;; Only for :set command set global value of local options.
;                       set_options_default(OPT_FREE | opt_flags);
;                   }
;                   else
;                   {
;                       showoptions(1, opt_flags);
;                       did_show = true;
;                   }
;               }
;               else if (STRNCMP(arg, u8("termcap"), 7) == 0 && (opt_flags & OPT_MODELINE) == 0)
;               {
;                   showoptions(2, opt_flags);
;                   show_termcodes();
;                   did_show = true;
;                   arg = arg.plus(7);
;               }
;               else
;               {
;                   int prefix = 1;     ;; 1: nothing, 0: "no", 2: "inv" in front of name
;                   if (STRNCMP(arg, u8("no"), 2) == 0 && STRNCMP(arg, u8("novice"), 6) != 0)
;                   {
;                       prefix = 0;
;                       arg = arg.plus(2);
;                   }
;                   else if (STRNCMP(arg, u8("inv"), 3) == 0)
;                   {
;                       prefix = 2;
;                       arg = arg.plus(3);
;                   }

;                   skip:
;                   {
;                       int nextchar;           ;; next non-white char after option name
;                       int opt_idx;
;                       int len;

                        ;; find end of name
;                       int key = 0;
;                       if (arg.at(0) == (byte)'<')
;                       {
;                           nextchar = 0;
;                           opt_idx = -1;
                            ;; look out for <t_>;>
;                           if (arg.at(1) == (byte)'t' && arg.at(2) == (byte)'_' && arg.at(3) != NUL && arg.at(4) != NUL)
;                               len = 5;
;                           else
;                           {
;                               len = 1;
;                               while (arg.at(len) != NUL && arg.at(len) != (byte)'>')
;                                   len++;
;                           }
;                           if (arg.at(len) != (byte)'>')
;                           {
;                               errmsg = e_invarg;
;                               break skip;
;                           }
;                           arg.be(len, NUL);                           ;; put NUL after name
;                           if (arg.at(1) == (byte)'t' && arg.at(2) == (byte)'_') ;; could be term code
;                               opt_idx = findoption(arg.plus(1));
;                           arg.be(len++, (byte)'>');                   ;; restore '>'
;                           if (opt_idx == -1)
;                               key = find_key_option(arg.plus(1));
;                       }
;                       else
;                       {
;                           len = 0;

                            ;; The two characters after "t_" may not be alphanumeric.

;                           if (arg.at(0) == (byte)'t' && arg.at(1) == (byte)'_' && arg.at(2) != NUL && arg.at(3) != NUL)
;                               len = 4;
;                           else
;                               while (asc_isalnum(arg.at(len)) || arg.at(len) == (byte)'_')
;                                   len++;
;                           nextchar = arg.at(len);
;                           arg.be(len, NUL);                           ;; put NUL after name
;                           opt_idx = findoption(arg);
;                           arg.be(len, nextchar);                      ;; restore nextchar
;                           if (opt_idx == -1)
;                               key = find_key_option(arg);
;                       }

                        ;; remember character after option name
;                       byte afterchar = arg.at(len);

                        ;; skip white space, allow ":set ai  ?"
;                       while (vim_iswhite(arg.at(len)))
;                           len++;

;                       boolean adding = false;             ;; "opt+=arg"
;                       boolean prepending = false;         ;; "opt^=arg"
;                       boolean removing = false;           ;; "opt-=arg"

;                       if (arg.at(len) != NUL && arg.at(len + 1) == (byte)'=')
;                       {
;                           if (arg.at(len) == (byte)'+')
;                           {
;                               adding = true;              ;; "+="
;                               len++;
;                           }
;                           else if (arg.at(len) == (byte)'^')
;                           {
;                               prepending = true;          ;; "^="
;                               len++;
;                           }
;                           else if (arg.at(len) == (byte)'-')
;                           {
;                               removing = true;            ;; "-="
;                               len++;
;                           }
;                       }
;                       nextchar = arg.at(len);

;                       if (opt_idx == -1 && key == 0)      ;; found a mismatch: skip
;                       {
;                           errmsg = u8("E518: Unknown option");
;                           break skip;
;                       }

;                       long flags;             ;; flags for current option
;                       if (0 <= opt_idx)
;                       {
;                           if (vimoptions[opt_idx].var == null)   ;; hidden option: skip
;                           {
                                ;; Only give an error message when requesting
                                ;; the value of a hidden option, ignore setting it.
;                               if (vim_strchr(u8("=:!&<"), nextchar) == null
;                                       && ((vimoptions[opt_idx].@flags & P_BOOL) == 0 || nextchar == '?'))
;                                   errmsg = u8("E519: Option not supported");
;                               break skip;
;                           }

;                           flags = vimoptions[opt_idx].@flags;
;                           varp = get_varp_scope(vimoptions[opt_idx], opt_flags);
;                       }
;                       else
;                       {
;                           flags = P_STRING;
;                           if (key < 0)
;                           {
;                               key_name.be(0, KEY2TERMCAP0(key));
;                               key_name.be(1, KEY2TERMCAP1(key));
;                           }
;                           else
;                           {
;                               key_name.be(0, KS_KEY);
;                               key_name.be(1, (byte)(key & 0xff));
;                           }
;                       }

                        ;; Skip all options that are not window-local
                        ;; (used when showing an already loaded buffer in a window).
;                       if ((opt_flags & OPT_WINONLY) != 0 && (opt_idx < 0 || vimoptions[opt_idx].var != VAR_WIN))
;                           break skip;

                        ;; Skip all options that are window-local (used for :vimgrep).
;                       if ((opt_flags & OPT_NOWIN) != 0 && 0 <= opt_idx && vimoptions[opt_idx].var == VAR_WIN)
;                           break skip;

                        ;; Disallow changing some options from modelines.
;                       if ((opt_flags & OPT_MODELINE) != 0)
;                       {
;                           if ((flags & (P_SECURE | P_NO_ML)) != 0)
;                           {
;                               errmsg = u8("E520: Not allowed in a modeline");
;                               break skip;
;                           }
;                       }

                        ;; Disallow changing some options in the sandbox.
;                       if (@sandbox != 0 && (flags & P_SECURE) != 0)
;                       {
;                           errmsg = e_sandbox;
;                           break skip;
;                       }

;                       if (vim_strchr(u8("?=:!&<"), nextchar) != null)
;                       {
;                           arg = arg.plus(len);
;                           if (nextchar == '&' && arg.at(1) == (byte)'v' && arg.at(2) == (byte)'i')
;                           {
;                               if (arg.at(3) == (byte)'m')     ;; "opt&vim": set to Vim default
;                                   arg = arg.plus(3);
;                               else                ;; "opt&vi": set to Vi default
;                                   arg = arg.plus(2);
;                           }
;                           if (vim_strchr(u8("?!&<"), nextchar) != null && arg.at(1) != NUL && !vim_iswhite(arg.at(1)))
;                           {
;                               errmsg = e_trailing;
;                               break skip;
;                           }
;                       }

                        ;; allow '=' and ':' as MSDOS command.com allows
                        ;; only one '=' character per "set" command line

;                       if (nextchar == '?' || (prefix == 1 && vim_strchr(u8("=:&<"), nextchar) == null && (flags & P_BOOL) == 0))
;                       {
                            ;; print value
;                           if (did_show)
;                               msg_putchar('\n');      ;; cursor below last one
;                           else
;                           {
;                               gotocmdline(true);      ;; cursor at status line
;                               did_show = true;        ;; remember that we did a line
;                           }
;                           if (0 <= opt_idx)
;                           {
;                               showoneopt(vimoptions[opt_idx], opt_flags);
;                           }
;                           else
;                           {
;                               Bytes p = find_termcode(key_name);
;                               if (p == null)
;                               {
;                                   errmsg = u8("E846: Key code not set");
;                                   break skip;
;                               }
;                               else
;                                   show_one_termcode(key_name, p, true);
;                           }
;                           if (nextchar != '?' && nextchar != NUL && !vim_iswhite(afterchar))
;                               errmsg = e_trailing;
;                       }
;                       else
;                       {
;                           if ((flags & P_BOOL) != 0)          ;; boolean
;                           {
;                               if (nextchar == '=' || nextchar == ':')
;                               {
;                                   errmsg = e_invarg;
;                                   break skip;
;                               }

;                               boolean value;

                                ;; ":set opt!": invert
                                ;; ":set opt&": reset to default value
                                ;; ":set opt<": reset to global value

;                               if (nextchar == '!')
;                                   value = !((boolean[])varp)[0];
;                               else if (nextchar == '&')
;                                   value = (boolean)vimoptions[opt_idx].def_val;
;                               else if (nextchar == '<')
;                                   value = ((boolean[])get_varp_scope(vimoptions[opt_idx], OPT_GLOBAL))[0];
;                               else
;                               {
                                    ;; ":set invopt": invert
                                    ;; ":set opt" or ":set noopt": set or reset

;                                   if (nextchar != NUL && !vim_iswhite(afterchar))
;                                   {
;                                       errmsg = e_trailing;
;                                       break skip;
;                                   }
;                                   if (prefix == 2)            ;; inv
;                                       value = !((boolean[])varp)[0];
;                                   else
;                                       value = (prefix != 0);
;                               }

;                               errmsg = set_bool_option(opt_idx, (boolean[])varp, value, opt_flags);
;                           }
;                           else                                ;; numeric or string
;                           {
;                               if (vim_strchr(u8("=:&<"), nextchar) == null || prefix != 1)
;                               {
;                                   errmsg = e_invarg;
;                                   break skip;
;                               }

;                               if ((flags & P_NUM) != 0)       ;; numeric
;                               {
;                                   long value;

                                    ;; Different ways to set a number option:
                                    ;; &        set to default value
                                    ;; <        set to global value
                                    ;; <xx>     accept special key codes for 'wildchar'
                                    ;; c        accept any non-digit for 'wildchar'
                                    ;; [-]0-9   set number
                                    ;; other    error

;                                   arg = arg.plus(1);
;                                   if (nextchar == '&')
;                                       value = (long)vimoptions[opt_idx].def_val;
;                                   else if (nextchar == '<')
;                                   {
                                        ;; For 'undolevels' NO_LOCAL_UNDOLEVEL means to use the global value.
;                                       if (varp == @curbuf.b_p_ul && opt_flags == OPT_LOCAL)
;                                           value = NO_LOCAL_UNDOLEVEL;
;                                       else
;                                           value = ((long[])get_varp_scope(vimoptions[opt_idx], OPT_GLOBAL))[0];
;                                   }
;                                   else if ((varp == p_wc)
;                                           && (arg.at(0) == (byte)'<' || arg.at(0) == (byte)'^'
;                                               || ((arg.at(1) == NUL || vim_iswhite(arg.at(1)))
;                                                   && !asc_isdigit(arg.at(0)))))
;                                   {
;                                       value = parse_key(arg);
;                                       if (value == 0)
;                                       {
;                                           errmsg = e_invarg;
;                                           break skip;
;                                       }
;                                   }
;                                   else if (arg.at(0) == (byte)'-' || asc_isdigit(arg.at(0)))
;                                   {
;                                       int[] ip = new int[1];

                                        ;; Allow negative (for 'undolevels'), octal and hex numbers.
;                                       { long[] __ = new long[1]; vim_str2nr(arg, null, ip, TRUE, TRUE, __); value = __[0]; }
;                                       if (arg.at(ip[0]) != NUL && !vim_iswhite(arg.at(ip[0])))
;                                       {
;                                           errmsg = e_invarg;
;                                           break skip;
;                                       }
;                                   }
;                                   else
;                                   {
;                                       errmsg = u8("E521: Number required after =");
;                                       break skip;
;                                   }

;                                   if (adding)
;                                       value = ((long[])varp)[0] + value;
;                                   if (prepending)
;                                       value = ((long[])varp)[0] * value;
;                                   if (removing)
;                                       value = ((long[])varp)[0] - value;
;                                   errmsg = set_num_option(opt_idx, (long[])varp, value, errbuf, errbuf.size(), opt_flags);
;                               }
;                               else if (0 <= opt_idx)                  ;; string
;                               {
;                                   Bytes save_arg = null;

                                    ;; When using ":set opt=val" for a global option with a local value,
                                    ;; the local value will be reset, use the global value here.
;                                   if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0
;                                           && (vimoptions[opt_idx].indir & PV_BOTH) != 0)
;                                       varp = vimoptions[opt_idx].var;

;                                   Bytes newval;
                                    ;; The old value is kept until we are sure that the new value is valid.
;                                   Bytes oldval = ((Bytes[])varp)[0];
;                                   if (nextchar == '&')    ;; set to default val
;                                   {
;                                       newval = (Bytes)vimoptions[opt_idx].def_val;
;                                       if (varp == p_bg)
;                                       {
                                            ;; guess the value of 'background'
;                                           newval = term_bg_default();
;                                       }

;                                       if (newval == null)
;                                           newval = EMPTY_OPTION;
;                                       else
;                                           newval = STRDUP(newval);
;                                   }
;                                   else if (nextchar == '<')       ;; set to global val
;                                   {
;                                       newval = STRDUP(((Bytes[])get_varp_scope(vimoptions[opt_idx], OPT_GLOBAL))[0]);
;                                   }
;                                   else
;                                   {
;                                       arg = arg.plus(1);      ;; jump to after the '=' or ':'

                                        ;; Set 'keywordprg' to ":echo" if an empty
                                        ;; value was passed to :set by the user.
                                        ;; Misuse errbuf[] for the resulting string.

;                                       if (varp == p_kp && (arg.at(0) == NUL || arg.at(0) == (byte)' '))
;                                       {
;                                           STRCPY(errbuf, u8(":echo"));
;                                           save_arg = arg;
;                                           arg = errbuf;
;                                       }

                                        ;; Convert 'backspace' number to string, for
                                        ;; adding, prepending and removing string.

;                                       else if (varp == p_bs && asc_isdigit(@p_bs.at(0)))
;                                       {
;                                           int i = (int)getdigits(p_bs);
;                                           switch (i)
;                                           {
;                                               case 0:
;                                                   @p_bs = EMPTY_OPTION;
;                                                   break;
;                                               case 1:
;                                                   @p_bs = STRDUP(u8("indent,eol"));
;                                                   break;
;                                               case 2:
;                                                   @p_bs = STRDUP(u8("indent,eol,start"));
;                                                   break;
;                                           }
;                                           oldval = @p_bs;
;                                       }

                                        ;; Convert 'whichwrap' number to string, for
                                        ;; backwards compatibility with Vim 3.0.
                                        ;; Misuse errbuf[] for the resulting string.

;                                       else if (varp == p_ww && asc_isdigit(arg.at(0)))
;                                       {
;                                           errbuf.be(0, NUL);
;                                           int i;
;                                           { Bytes[] __ = { arg }; i = (int)getdigits(__); arg = __[0]; }
;                                           if ((i & 1) != 0)
;                                               STRCAT(errbuf, u8("b,"));
;                                           if ((i & 2) != 0)
;                                               STRCAT(errbuf, u8("s,"));
;                                           if ((i & 4) != 0)
;                                               STRCAT(errbuf, u8("h,l,"));
;                                           if ((i & 8) != 0)
;                                               STRCAT(errbuf, u8("<,>,"));
;                                           if ((i & 16) != 0)
;                                               STRCAT(errbuf, u8("[,],"));
;                                           if (errbuf.at(0) != NUL)        ;; remove trailing ,
;                                               errbuf.be(STRLEN(errbuf) - 1, NUL);
;                                           save_arg = arg;
;                                           arg = errbuf;
;                                       }

                                        ;; When setting the local value of a global option,
                                        ;; the old value may be the global value.
;                                       Bytes origval;
;                                       if ((vimoptions[opt_idx].indir & PV_BOTH) != 0 && (opt_flags & OPT_LOCAL) != 0)
;                                           origval = ((Bytes[])get_varp(vimoptions[opt_idx], false))[0];
;                                       else
;                                           origval = oldval;

                                        ;; Copy the new string into allocated memory.
                                        ;; Can't use set_string_option_direct(),
                                        ;; because we need to remove the backslashes.

                                        ;; get a bit too much
;                                       int newlen = STRLEN(arg) + 1;
;                                       if (adding || prepending || removing)
;                                           newlen += STRLEN(origval) + 1;
;                                       newval = new Bytes(newlen);
;                                       Bytes s = newval;

                                        ;; Copy the string, skip over escaped chars.
                                        ;; For MS-DOS and WIN32 backslashes before normal
                                        ;; file name characters are not removed, and keep
                                        ;; backslash at start, for "\\machine\path", but
                                        ;; do remove it for "\\\\machine\\path".
                                        ;; The reverse is found in expandOldSetting().

;                                       while (arg.at(0) != NUL && !vim_iswhite(arg.at(0)))
;                                       {
;                                           if (arg.at(0) == (byte)'\\' && arg.at(1) != NUL)
;                                               arg = arg.plus(1);      ;; remove backslash
;                                           int i = us_ptr2len_cc(arg);
;                                           if (1 < i)
;                                           {
                                                ;; copy multibyte char
;                                               BCOPY(s, arg, i);
;                                               arg = arg.plus(i);
;                                               s = s.plus(i);
;                                           }
;                                           else
;                                               (s = s.plus(1)).be(-1, (arg = arg.plus(1)).at(-1));
;                                       }
;                                       s.be(0, NUL);

                                        ;; Locate newval[] in origval[] when removing it
                                        ;; and when adding to avoid duplicates.
;                                       int i = 0;
;                                       if (removing || (flags & P_NODUP) != 0)
;                                       {
;                                           i = STRLEN(newval);
;                                           int bs = 0;
;                                           for (s = origval; s.at(0) != NUL; s = s.plus(1))
;                                           {
;                                               if (((flags & P_COMMA) == 0
;                                                           || BEQ(s, origval)
;                                                           || (s.at(-1) == (byte)',' && (bs & 1) == 0))
;                                                       && STRNCMP(s, newval, i) == 0
;                                                       && ((flags & P_COMMA) == 0
;                                                           || s.at(i) == (byte)','
;                                                           || s.at(i) == NUL))
;                                                   break;
                                                ;; Count backslashes.  Only a comma with an
                                                ;; even number of backslashes before it is
                                                ;; recognized as a separator
;                                               if (BLT(origval, s) && s.at(-1) == (byte)'\\')
;                                                   bs++;
;                                               else
;                                                   bs = 0;
;                                           }

                                            ;; do not add if already there
;                                           if ((adding || prepending) && s.at(0) != NUL)
;                                           {
;                                               prepending = false;
;                                               adding = false;
;                                               STRCPY(newval, origval);
;                                           }
;                                       }

                                        ;; concatenate the two strings; add a ',' if needed
;                                       if (adding || prepending)
;                                       {
;                                           boolean comma = ((flags & P_COMMA) != 0 && origval.at(0) != NUL && newval.at(0) != NUL);
;                                           if (adding)
;                                           {
;                                               i = STRLEN(origval);
;                                               BCOPY(newval, i + (comma ? 1 : 0), newval, 0, STRLEN(newval) + 1);
;                                               BCOPY(newval, origval, i);
;                                           }
;                                           else
;                                           {
;                                               i = STRLEN(newval);
;                                               BCOPY(newval, i + (comma ? 1 : 0), origval, 0, STRLEN(origval) + 1);
;                                           }
;                                           if (comma)
;                                               newval.be(i, (byte)',');
;                                       }

                                        ;; Remove newval[] from origval[].
                                        ;; (Note: "i" has been set above and is used here).
;                                       if (removing)
;                                       {
;                                           STRCPY(newval, origval);
;                                           if (s.at(0) != NUL)
;                                           {
                                                ;; may need to remove a comma
;                                               if ((flags & P_COMMA) != 0)
;                                               {
;                                                   if (BEQ(s, origval))
;                                                   {
                                                        ;; include comma after string
;                                                       if (s.at(i) == (byte)',')
;                                                           i++;
;                                                   }
;                                                   else
;                                                   {
                                                        ;; include comma before string
;                                                       s = s.minus(1);
;                                                       i++;
;                                                   }
;                                               }
;                                               BCOPY(newval, BDIFF(s, origval), s, i, STRLEN(s, i) + 1);
;                                           }
;                                       }

;                                       if ((flags & P_FLAGLIST) != 0)
;                                       {
                                            ;; Remove flags that appear twice.
;                                           for (s = newval; s.at(0) != NUL; s = s.plus(1))
;                                               if (((flags & P_COMMA) == 0 || s.at(0) != (byte)',') && vim_strbyte(s.plus(1), s.at(0)) != null)
;                                               {
;                                                   BCOPY(s, 0, s, 1, STRLEN(s, 1) + 1);
;                                                   s = s.minus(1);
;                                               }
;                                       }

;                                       if (save_arg != null)   ;; number for 'whichwrap'
;                                           arg = save_arg;
;                                   }

                                    ;; Set the new value.
;                                   ((Bytes[])varp)[0] = newval;

                                    ;; Handle side effects, and set the global value for ":set" on local options.
;                                   errmsg = did_set_string_option(opt_idx, (Bytes[])varp, oldval, errbuf, opt_flags);

                                    ;; If error detected, print the error message.
;                                   if (errmsg != null)
;                                       break skip;
;                               }
;                               else            ;; key code option
;                               {
;                                   if (nextchar == '&')
;                                   {
;                                       if (add_termcap_entry(key_name, true) == false)
;                                           errmsg = u8("E522: Not found in termcap");
;                                   }
;                                   else
;                                   {
;                                       arg = arg.plus(1); ;; jump to after the '=' or ':'
;                                       Bytes p;
;                                       for (p = arg; p.at(0) != NUL && !vim_iswhite(p.at(0)); p = p.plus(1))
;                                           if (p.at(0) == (byte)'\\' && p.at(1) != NUL)
;                                               p = p.plus(1);
;                                       nextchar = p.at(0);
;                                       p.be(0, NUL);
;                                       add_termcode(key_name, arg, FALSE);
;                                       p.be(0, nextchar);
;                                   }
;                                   if (@full_screen)
;                                       ttest(false);
;                                   redraw_all_later(CLEAR);
;                               }
;                           }

;                           if (0 <= opt_idx)
;                               did_set_option(opt_idx, opt_flags, !prepending && !adding && !removing);
;                       }
;                   }

                    ;; Advance to next argument.
                    ;; - skip until a blank found, taking care of backslashes
                    ;; - skip blanks
                    ;; - skip one "=val" argument (for hidden options ":set gfn =xx")

;                   for (int i = 0; i < 2 ; i++)
;                   {
;                       while (arg.at(0) != NUL && !vim_iswhite(arg.at(0)))
;                           if ((arg = arg.plus(1)).at(-1) == (byte)'\\' && arg.at(0) != NUL)
;                               arg = arg.plus(1);
;                       arg = skipwhite(arg);
;                       if (arg.at(0) != (byte)'=')
;                           break;
;                   }
;               }

;               if (errmsg != null)
;               {
;                   vim_strncpy(@ioBuff, errmsg, IOSIZE - 1);
;                   int i = STRLEN(@ioBuff) + 2;
;                   if (i + BDIFF(arg, startarg) < IOSIZE)
;                   {
                        ;; append the argument with the error
;                       STRCAT(@ioBuff, u8(": "));
;                       BCOPY(@ioBuff, i, startarg, 0, BDIFF(arg, startarg));
;                       @ioBuff.be(i + BDIFF(arg, startarg), NUL);
;                   }
                    ;; make sure all characters are printable
;                   trans_characters(@ioBuff, IOSIZE);

;                   @no_wait_return++;       ;; wait_return done later
;                   emsg(@ioBuff);           ;; show error highlighted
;                   --@no_wait_return;

;                   return false;
;               }
;           }
;       }

;       if (@silent_mode && did_show)
;       {
            ;; After displaying option values in silent mode.
;           @silent_mode = false;
;           @info_message = true;
;           msg_putchar('\n');
;           cursor_on();                ;; msg_start() switches it off
;           out_flush();
;           @silent_mode = true;
;           @info_message = false;
;       }

;       return true;
    ))

;; Call this when an option has been given a new value through a user command.
;; Sets the P_WAS_SET flag and takes care of the P_INSECURE flag.

(defn- #_void did_set_option [#_int opt_idx, #_int opt_flags, #_boolean new_value]
    ;; opt_flags: possibly with OPT_MODELINE
    ;; new_value: value was replaced completely
    (§
;       vimoptions[opt_idx].@flags |= P_WAS_SET;

        ;; When an option is set in the sandbox from a modeline or in secure mode,
        ;; set the P_INSECURE flag.  Otherwise, if a new value is stored reset the flag.
;       long[] p = insecure_flag(opt_idx, opt_flags);
;       if (@secure != 0 || @sandbox != 0 || (opt_flags & OPT_MODELINE) != 0)
;           p[0] |= P_INSECURE;
;       else if (new_value)
;           p[0] &= ~P_INSECURE;
    ))

(defn- #_Bytes illegal_char [#_Bytes errbuf, #_int c]
    (§
;       if (errbuf == null)
;           return u8("");

;       libC.sprintf(errbuf, u8("E539: Illegal character <%s>"), transchar(c));
;       return errbuf;
    ))

;; Convert a key name or ctrl into a key value.
;; Used for 'wildchar' and 'cedit' options.

(defn- #_int parse_key [#_Bytes arg]
    (§
;       if (arg.at(0) == (byte)'<')
;           return find_key_option(arg.plus(1));
;       if (arg.at(0) == (byte)'^')
;           return ctrl_key(arg.at(1));

;       return char_u(arg.at(0));
    ))

;; Check value of 'cedit' and set cedit_key.
;; Returns null if value is OK, error message otherwise.

(defn- #_Bytes check_cedit []
    (§
;       if (@p_cedit.at(0) == NUL)
;           @cedit_key = -1;
;       else
;       {
;           int key = parse_key(@p_cedit);
;           if (vim_isprintc(key))
;               return e_invarg;
;           @cedit_key = key;
;       }

;       return null;
    ))

;; set_options_bin -- called when 'bin' changes value.

(defn- #_void set_options_bin [#_boolean oldval, #_boolean newval, #_int opt_flags]
    ;; opt_flags: OPT_LOCAL and/or OPT_GLOBAL
    (§
        ;; The option values that are changed when 'bin' changes are
        ;; copied when 'bin is set and restored when 'bin' is reset.

;       if (newval)
;       {
;           if (!oldval)                    ;; switched on
;           {
;               if ((opt_flags & OPT_GLOBAL) == 0)
;               {
;                   @curbuf.b_p_tw_nobin = @curbuf.@b_p_tw;
;                   @curbuf.b_p_wm_nobin = @curbuf.@b_p_wm;
;                   @curbuf.b_p_et_nobin = @curbuf.@b_p_et;
;               }
;               if ((opt_flags & OPT_LOCAL) == 0)
;               {
;                   @p_tw_nobin = @p_tw;
;                   @p_wm_nobin = @p_wm;
;                   @p_et_nobin = @p_et;
;               }
;           }

;           if ((opt_flags & OPT_GLOBAL) == 0)
;           {
;               @curbuf.@b_p_tw = 0;          ;; no automatic line wrap
;               @curbuf.@b_p_wm = 0;          ;; no automatic line wrap
;               @curbuf.@b_p_et = false;          ;; no expandtab
;           }
;           if ((opt_flags & OPT_LOCAL) == 0)
;           {
;               @p_tw = 0;
;               @p_wm = 0;
;               @p_et = false;
;               @p_bin = true;               ;; needed when called for the "-b" argument
;           }
;       }
;       else if (oldval)                    ;; switched off
;       {
;           if ((opt_flags & OPT_GLOBAL) == 0)
;           {
;               @curbuf.@b_p_tw = @curbuf.b_p_tw_nobin;
;               @curbuf.@b_p_wm = @curbuf.b_p_wm_nobin;
;               @curbuf.@b_p_et = @curbuf.b_p_et_nobin;
;           }
;           if ((opt_flags & OPT_LOCAL) == 0)
;           {
;               @p_tw = @p_tw_nobin;
;               @p_wm = @p_wm_nobin;
;               @p_et = @p_et_nobin;
;           }
;       }
    ))

;; After setting various option values: recompute variables that depend on option values.

(defn- #_void didset_options []
    (§
        ;; initialize the table for 'iskeyword' et. al.
;       init_chartab();

;       opt_strings_flags(@p_dy, p_dy_values, dy_flags, true);
;       opt_strings_flags(@p_ve, p_ve_values, ve_flags, true);
;       opt_strings_flags(@p_ttym, p_ttym_values, ttym_flags, false);
        ;; set cedit_key
;       check_cedit();
;       briopt_check(@curwin);
    ))

;; Check for string options that are null (normally only termcap options).

(defn- #_void check_options []
    (§
;       for (int opt_idx = 0; vimoptions[opt_idx].fullname != null; opt_idx++)
;           if ((vimoptions[opt_idx].@flags & P_STRING) != 0 && vimoptions[opt_idx].var != null)
;               check_string_option((Bytes[])get_varp(vimoptions[opt_idx], false));
    ))

;; Check string options in a buffer for null value.

(defn- #_void check_buf_options [#_buffer_C buf]
    (§
;       check_string_option(buf.b_p_kp);
;       check_string_option(buf.b_p_mps);
;       check_string_option(buf.b_p_fo);
;       check_string_option(buf.b_p_flp);
;       check_string_option(buf.b_p_isk);
;       check_string_option(buf.b_p_com);
;       check_string_option(buf.b_p_nf);
;       check_string_option(buf.b_p_qe);
;       check_string_option(buf.b_p_cink);
;       check_string_option(buf.b_p_cino);
;       parse_cino(buf);
;       check_string_option(buf.b_p_cinw);
;       check_string_option(buf.b_p_lw);
    ))

(defn- #_void clear_string_option [#_Bytes* pp]
    (§
;       pp[0] = EMPTY_OPTION;
    ))

(defn- #_void check_string_option [#_Bytes* pp]
    (§
;       if (pp[0] == null)
;           pp[0] = EMPTY_OPTION;
    ))

;; Return true when option "opt" was set from a modeline or in secure mode.
;; Return false when it wasn't.
;; Return -1 for an unknown option.

(defn- #_boolean was_set_insecurely [#_Bytes opt, #_int opt_flags]
    (§
;       int idx = findoption(opt);
;       if (0 <= idx)
;       {
;           long[] flagp = insecure_flag(idx, opt_flags);
;           return ((flagp[0] & P_INSECURE) != 0);
;       }

;       emsg2(e_intern2, u8("was_set_insecurely()"));
;       return /*-1*/true;
    ))

;; Get a pointer to the flags used for the P_INSECURE flag of option
;; "opt_idx".  For some local options a local flags field is used.

(defn- #_long* insecure_flag [#_int opt_idx, #_int opt_flags]
    (§
        ;; Nothing special, return global flags field.
;       return vimoptions[opt_idx].flags;
    ))

;; Redraw the tab page text later.

(defn- #_void redraw_titles []
    (§
;       @redraw_tabline = true;
    ))

;; Set a string option to a new value (without checking the effect).
;; The string is copied into allocated memory.
;; If ("opt_idx" == -1) "name" is used, otherwise "opt_idx" is used.

(defn- #_void set_string_option_direct [#_Bytes name, #_int opt_idx, #_Bytes val, #_int opt_flags]
    ;; opt_flags: OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL
    (§
;       boolean both = (opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0;
;       int idx = opt_idx;

;       if (idx == -1)                      ;; use name
;       {
;           idx = findoption(name);
;           if (idx < 0)                    ;; not found (should not happen)
;           {
;               emsg2(e_intern2, u8("set_string_option_direct()"));
;               emsg2(u8("For option %s"), name);
;               return;
;           }
;       }

;       if (vimoptions[idx].var == null)       ;; can't set hidden option
;           return;

;       Bytes[] varp = (Bytes[])get_varp_scope(vimoptions[idx], both ? OPT_LOCAL : opt_flags);
;       varp[0] = STRDUP(val);

        ;; For buffer/window local option may also set the global value.
;       if (both)
;           set_string_option_global(idx, varp);

        ;; When setting both values of a global option with a local value,
        ;; make the local value empty, so that the global value is used.
;       if ((vimoptions[idx].indir & PV_BOTH) != 0 && both)
;           varp[0] = EMPTY_OPTION;
    ))

;; Set global value for string option when it's a local option.

(defn- #_void set_string_option_global [#_int opt_idx, #_Bytes* varp]
    ;; opt_idx: option index
    ;; varp: pointer to option variable
    (§
;       vimoption_C v = vimoptions[opt_idx];

        ;; the global value is always allocated
;       Bytes[] pp;
;       if (v.var == VAR_WIN)
;       {
            ;; transform a pointer to a "w_onebuf_opt" option into a "w_allbuf_opt" option
;           pp = (Bytes[])get_varp(v, true);
;       }
;       else
;           pp = (Bytes[])v.var;

;       if (v.indir != PV_NONE && pp != varp)
;           pp[0] = STRDUP(varp[0]);
    ))

;; Set a string option to a new value, and handle the effects.
;;
;; Returns null on success or error message on error.

(defn- #_Bytes set_string_option [#_int opt_idx, #_Bytes value, #_int opt_flags]
    ;; opt_flags: OPT_LOCAL and/or OPT_GLOBAL
    (§
;       if (vimoptions[opt_idx].var == null)   ;; don't set hidden option
;           return null;

;       Bytes[] varp = (Bytes[])get_varp_scope(vimoptions[opt_idx],
;               (opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0
;                   ? ((vimoptions[opt_idx].indir & PV_BOTH) != 0 ? OPT_GLOBAL : OPT_LOCAL)
;                   : opt_flags);

;       Bytes oldval = varp[0];
;       varp[0] = STRDUP(value);

;       Bytes r = did_set_string_option(opt_idx, varp, oldval, null, opt_flags);
;       if (r == null)
;           did_set_option(opt_idx, opt_flags, true);

;       return r;
    ))

;; Handle string options that need some action to perform when changed.
;; Returns null for success, or an error message for an error.

(defn- #_Bytes did_set_string_option [#_int opt_idx, #_Bytes* varp, #_Bytes oldval, #_Bytes errbuf, #_int opt_flags]
    ;; opt_idx: index in vimoptions[] table
    ;; varp: pointer to the option variable
    ;; oldval: previous value of the option
    ;; errbuf: buffer for errors, or null
    ;; opt_flags: OPT_LOCAL and/or OPT_GLOBAL
    (§
;       Bytes errmsg = null;
;       boolean did_chartab = false;

        ;; Get the global option to compare with,
        ;; otherwise we would have to check two values for all local options.
;       Object gvarp = get_varp_scope(vimoptions[opt_idx], OPT_GLOBAL);

        ;; Disallow changing some options from secure mode.
;       if ((@secure != 0 || @sandbox != 0) && (vimoptions[opt_idx].@flags & P_SECURE) != 0)
;       {
;           errmsg = e_secure;
;       }

        ;; Check for a "normal" file name in some options.
        ;; Disallow a path separator (slash and/or backslash),
        ;; wildcards and characters that are often illegal in a file name.
;       else if ((vimoptions[opt_idx].@flags & P_NFNAME) != 0 && STRPBRK(varp[0], u8("/\\*?[|<>")) != null)
;       {
;           errmsg = e_invarg;
;       }

        ;; 'term'
;       else if (varp == T_NAME)
;       {
;           if (@T_NAME.at(0) == NUL)
;               errmsg = u8("E529: Cannot set 'term' to empty string");
;           else if (set_termname(@T_NAME) == false)
;               errmsg = u8("E522: Not found in termcap");
;           else
                ;; Screen colors may have changed.
;               redraw_later_clear();
;       }

        ;; 'breakindentopt'
;       else if (varp == @curwin.w_onebuf_opt.wo_briopt)
;       {
;           if (briopt_check(@curwin) == false)
;               errmsg = e_invarg;
;       }

        ;; 'isident', 'iskeyword', 'isprint' or 'isfname' option: refill chartab[]
        ;; If the new option is invalid, use old value.
        ;; 'lisp' option: refill chartab[] for '-' char

;       else if (varp == p_isi || varp == @curbuf.b_p_isk || varp == p_isp || varp == p_isf)
;       {
;           if (init_chartab() == false)
;           {
;               did_chartab = true;     ;; need to restore it below
;               errmsg = e_invarg;      ;; error in value
;           }
;       }

        ;; 'colorcolumn'
;       else if (varp == @curwin.w_onebuf_opt.wo_cc)
;           errmsg = check_colorcolumn(@curwin);

        ;; 'highlight'
;       else if (varp == p_hl)
;       {
;           if (highlight_changed() == false)
;               errmsg = e_invarg;  ;; invalid flags
;       }

        ;; 'nrformats'
;       else if (gvarp == p_nf)
;       {
;           if (check_opt_strings(varp[0], p_nf_values, true) != true)
;               errmsg = e_invarg;
;       }

        ;; 'scrollopt'
;       else if (varp == p_sbo)
;       {
;           if (check_opt_strings(@p_sbo, p_scbopt_values, true) != true)
;               errmsg = e_invarg;
;       }

        ;; 'ambiwidth'
;       else if (varp == p_ambw)
;       {
;           if (check_opt_strings(@p_ambw, p_ambw_values, false) != true)
;               errmsg = e_invarg;
;           else if (set_chars_option(p_lcs) != null)
;               errmsg = u8("E834: Conflicts with value of 'listchars'");
;           else if (set_chars_option(p_fcs) != null)
;               errmsg = u8("E835: Conflicts with value of 'fillchars'");
;       }

        ;; 'background'
;       else if (varp == p_bg)
;       {
;           if (check_opt_strings(@p_bg, p_bg_values, false) == true)
;           {
;               init_highlight(false, false);
;           }
;           else
;               errmsg = e_invarg;
;       }

        ;; 'matchpairs'
;       else if (gvarp == p_mps)
;       {
;           for (Bytes p = varp[0]; p.at(0) != NUL; p = p.plus(1))
;           {
;               int x2 = -1;
;               int x3 = -1;

;               if (p.at(0) != NUL)
;                   p = p.plus(us_ptr2len_cc(p));
;               if (p.at(0) != NUL)
;                   x2 = (p = p.plus(1)).at(-1);
;               if (p.at(0) != NUL)
;               {
;                   x3 = us_ptr2char(p);
;                   p = p.plus(us_ptr2len_cc(p));
;               }
;               if (x2 != ':' || x3 == -1 || (p.at(0) != NUL && p.at(0) != (byte)','))
;               {
;                   errmsg = e_invarg;
;                   break;
;               }
;               if (p.at(0) == NUL)
;                   break;
;           }
;       }

        ;; 'comments'
;       else if (gvarp == p_com)
;       {
;           for (Bytes s = varp[0]; s.at(0) != NUL; )
;           {
;               while (s.at(0) != NUL && s.at(0) != (byte)':')
;               {
;                   if (vim_strchr(COM_ALL, s.at(0)) == null && !asc_isdigit(s.at(0)) && s.at(0) != (byte)'-')
;                   {
;                       errmsg = illegal_char(errbuf, s.at(0));
;                       break;
;                   }
;                   s = s.plus(1);
;               }
;               if ((s = s.plus(1)).at(-1) == NUL)
;                   errmsg = u8("E524: Missing colon");
;               else if (s.at(0) == (byte)',' || s.at(0) == NUL)
;                   errmsg = u8("E525: Zero length string");
;               if (errmsg != null)
;                   break;
;               while (s.at(0) != NUL && s.at(0) != (byte)',')
;               {
;                   if (s.at(0) == (byte)'\\' && s.at(1) != NUL)
;                       s = s.plus(1);
;                   s = s.plus(1);
;               }
;               s = skip_to_option_part(s);
;           }
;       }

        ;; 'listchars'
;       else if (varp == p_lcs)
;       {
;           errmsg = set_chars_option(varp);
;       }

        ;; 'fillchars'
;       else if (varp == p_fcs)
;       {
;           errmsg = set_chars_option(varp);
;       }

        ;; 'cedit'
;       else if (varp == p_cedit)
;       {
;           errmsg = check_cedit();
;       }

        ;; terminal options
;       else if (istermoption(vimoptions[opt_idx]) && @full_screen)
;       {
            ;; ":set t_Co=0" and ":set t_Co=1" do ":set t_Co="
;           if (varp == T_CCO)
;           {
;               int colors = libC.atoi(@T_CCO);

                ;; Only reinitialize colors if t_Co value has really changed to
                ;; avoid expensive reload of colorscheme if t_Co is set to the
                ;; same value multiple times.
;               if (colors != @t_colors)
;               {
;                   @t_colors = colors;
;                   if (@t_colors <= 1)
;                       @T_CCO = EMPTY_OPTION;

                    ;; We now have a different color setup, initialize it again.
;                   init_highlight(true, false);
;               }
;           }
;           ttest(false);
;           if (varp == T_ME)
;           {
;               out_str(@T_ME);
;               redraw_later(CLEAR);
;           }
;       }

        ;; 'showbreak'
;       else if (varp == p_sbr)
;       {
;           for (Bytes s = @p_sbr; s.at(0) != NUL; )
;           {
;               if (mb_ptr2cells(s) != 1)
;                   errmsg = u8("E595: contains unprintable or wide character");
;               s = s.plus(us_ptr2len_cc(s));
;           }
;       }

        ;; 'breakat'
;       else if (varp == p_breakat)
;           fill_breakat_flags();

        ;; 'ttymouse'
;       else if (varp == p_ttym)
;       {
            ;; Switch the mouse off before changing the escape sequences used for that.
;           mch_setmouse(false);
;           if (opt_strings_flags(@p_ttym, p_ttym_values, ttym_flags, false) != true)
;               errmsg = e_invarg;
;           else
;               check_mouse_termcode();
;           if (@termcap_active)
;               setmouse();         ;; may switch it on again
;       }

        ;; 'selection'
;       else if (varp == p_sel)
;       {
;           if (@p_sel.at(0) == NUL || check_opt_strings(@p_sel, p_sel_values, false) != true)
;               errmsg = e_invarg;
;       }

        ;; 'selectmode'
;       else if (varp == p_slm)
;       {
;           if (check_opt_strings(@p_slm, p_slm_values, true) != true)
;               errmsg = e_invarg;
;       }

        ;; 'keymodel'
;       else if (varp == p_km)
;       {
;           if (check_opt_strings(@p_km, p_km_values, true) != true)
;               errmsg = e_invarg;
;           else
;           {
;               @km_stopsel = (vim_strchr(@p_km, 'o') != null);
;               @km_startsel = (vim_strchr(@p_km, 'a') != null);
;           }
;       }

        ;; 'mousemodel'
;       else if (varp == p_mousem)
;       {
;           if (check_opt_strings(@p_mousem, p_mousem_values, false) != true)
;               errmsg = e_invarg;
;       }

        ;; 'display'
;       else if (varp == p_dy)
;       {
;           if (opt_strings_flags(@p_dy, p_dy_values, dy_flags, true) != true)
;               errmsg = e_invarg;
;           else
;               init_chartab();
;       }

        ;; 'eadirection'
;       else if (varp == p_ead)
;       {
;           if (check_opt_strings(@p_ead, p_ead_values, false) != true)
;               errmsg = e_invarg;
;       }

        ;; 'clipboard'
;       else if (varp == p_cb)
;           errmsg = check_clipboard_option();

        ;; 'pastetoggle': translate key codes like in a mapping
;       else if (varp == p_pt)
;       {
;           if (@p_pt.at(0) != NUL)
;               @p_pt = replace_termcodes(@p_pt, true, true, false);
;       }

        ;; 'backspace'
;       else if (varp == p_bs)
;       {
;           if (asc_isdigit(@p_bs.at(0)))
;           {
;               if ('2' < @p_bs.at(0) || @p_bs.at(1) != NUL)
;                   errmsg = e_invarg;
;           }
;           else if (check_opt_strings(@p_bs, p_bs_values, true) != true)
;               errmsg = e_invarg;
;       }

        ;; 'virtualedit'
;       else if (varp == p_ve)
;       {
;           if (opt_strings_flags(@p_ve, p_ve_values, ve_flags, true) != true)
;               errmsg = e_invarg;
;           else if (STRCMP(@p_ve, oldval) != 0)
;           {
                ;; Recompute cursor position in case the new 've' setting changes something.
;               validate_virtcol();
;               coladvance(@curwin.w_virtcol);
;           }
;       }

        ;; 'cinoptions'
;       else if (gvarp == p_cino)
;       {
            ;; TODO: recognize errors
;           parse_cino(@curbuf);
;       }

        ;; Options that are a list of flags.
;       else
;       {
;           Bytes p = null;
;           if (varp == p_ww)
;               p = WW_ALL;
;           else if (varp == p_shm)
;               p = SHM_ALL;
;           else if (varp == p_cpo)
;               p = CPO_ALL;
;           else if (varp == @curbuf.b_p_fo)
;               p = FO_ALL;
;           else if (varp == @curwin.w_onebuf_opt.wo_cocu)
;               p = COCU_ALL;
;           else if (varp == p_mouse)
;               p = MOUSE_ALL;
;           if (p != null)
;           {
;               for (Bytes s = varp[0]; s.at(0) != NUL; s = s.plus(1))
;                   if (vim_strchr(p, s.at(0)) == null)
;                   {
;                       errmsg = illegal_char(errbuf, s.at(0));
;                       break;
;                   }
;           }
;       }

        ;; If error detected, restore the previous value.

;       if (errmsg != null)
;       {
;           varp[0] = oldval;

            ;; When resetting some values, need to act on it.

;           if (did_chartab)
;               init_chartab();
;           if (varp == p_hl)
;               highlight_changed();
;       }
;       else
;       {
;           if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0 && (vimoptions[opt_idx].indir & PV_BOTH) != 0)
;           {
                ;; Global option with local value set to use global value;
                ;; free the local value and make it empty.
;               Object v = get_varp_scope(vimoptions[opt_idx], OPT_LOCAL);
;               ((Bytes[])v)[0] = EMPTY_OPTION;
;           }
;           else if ((opt_flags & OPT_LOCAL) == 0 && opt_flags != OPT_GLOBAL)
;           {
                ;; May set global value for local option.
;               set_string_option_global(opt_idx, varp);
;           }
;       }

;       if (varp == p_mouse)
;       {
;           if (@p_mouse.at(0) == NUL)
;               mch_setmouse(false);    ;; switch mouse off
;           else
;               setmouse();             ;; in case 'mouse' changed
;       }

;       if (@curwin.w_curswant != MAXCOL && (vimoptions[opt_idx].@flags & (P_CURSWANT | P_RALL)) != 0)
;           @curwin.w_set_curswant = true;
;       check_redraw(vimoptions[opt_idx].@flags);

;       return errmsg;
    ))

;; Handle setting 'colorcolumn' or 'textwidth' in window "wp".
;; Returns error message, null if it's OK.

(defn- #_Bytes check_colorcolumn [#_window_C wp]
    (§
;       int count = 0;
;       int[] color_cols = new int[256];

;       if (wp.w_buffer == null)
;           return null;    ;; buffer was closed

;       for (Bytes s = wp.w_onebuf_opt.@wo_cc; s.at(0) != NUL && count < 255; )
;       {
;           skip:
;           {
;               int col;
;               if (s.at(0) == (byte)'-' || s.at(0) == (byte)'+')
;               {
                    ;; -N and +N: add to 'textwidth'
;                   col = (s.at(0) == (byte)'-') ? -1 : 1;
;                   s = s.plus(1);
;                   if (!asc_isdigit(s.at(0)))
;                       return e_invarg;
;                   { Bytes[] __ = { s }; col *= getdigits(__); s = __[0]; }
;                   if (wp.w_buffer.@b_p_tw == 0)
;                       break skip;     ;; 'textwidth' not set, skip this item
;                   col += wp.w_buffer.@b_p_tw;
;                   if (col < 0)
;                       break skip;
;               }
;               else if (asc_isdigit(s.at(0)))
;               {
;                   Bytes[] __ = { s }; col = (int)getdigits(__); s = __[0];
;               }
;               else
;                   return e_invarg;
;               color_cols[count++] = col - 1;  ;; 1-based to 0-based
;           }

;           if (s.at(0) == NUL)
;               break;
;           if (s.at(0) != (byte)',')
;               return e_invarg;
;           if ((s = s.plus(1)).at(0) == NUL)
;               return e_invarg;    ;; illegal trailing comma as in "set cc=80,"
;       }

;       if (count == 0)
;           wp.w_p_cc_cols = null;
;       else
;       {
;           wp.w_p_cc_cols = new int[count + 1];

            ;; sort the columns for faster usage on screen redraw inside win_line()
;           Arrays.sort(color_cols, 0, count);

;           int j = 0;
;           for (int i = 0; i < count; i++)
;           {
                ;; skip duplicates
;               if (j == 0 || wp.w_p_cc_cols[j - 1] != color_cols[i])
;                   wp.w_p_cc_cols[j++] = color_cols[i];
;           }
;           wp.w_p_cc_cols[j] = -1;     ;; end marker
;       }

;       return null;    ;; no error
    ))

(class! #_final charstab_C
    [
        (atom' int      cp)
        (field Bytes    name)
    ])

(final charstab_C* filltab
    [
        (->charstab_C fill_stl,    (u8 "stl")     ),
        (->charstab_C fill_stlnc,  (u8 "stlnc")   ),
        (->charstab_C fill_vert,   (u8 "vert")    ),
        (->charstab_C fill_fold,   (u8 "fold")    ),
        (->charstab_C fill_diff,   (u8 "diff")    ),
    ])

(final charstab_C* lcstab
    [
        (->charstab_C lcs_eol,     (u8 "eol")     ),
        (->charstab_C lcs_ext,     (u8 "extends") ),
        (->charstab_C lcs_nbsp,    (u8 "nbsp")    ),
        (->charstab_C lcs_prec,    (u8 "precedes")),
        (->charstab_C lcs_tab2,    (u8 "tab")     ),
        (->charstab_C lcs_trail,   (u8 "trail")   ),
        (->charstab_C lcs_conceal, (u8 "conceal") ),
    ])

;; Handle setting 'listchars' or 'fillchars'.
;; Returns error message, null if it's OK.

(defn- #_Bytes set_chars_option [#_Bytes* varp]
    (§
;       int c1, c2 = 0;

;       charstab_C[] tab;
;       int entries;
;       if (varp == p_lcs)
;       {
;           tab = lcstab;
;           entries = lcstab.length;
;       }
;       else
;       {
;           tab = filltab;
;           entries = filltab.length;
;       }

        ;; first round: check for valid value, second round: assign values
;       for (int round = 0; round <= 1; round++)
;       {
;           if (0 < round)
;           {
                ;; After checking that the value is valid: set defaults:
                ;; space for 'fillchars', NUL for 'listchars'
;               for (int i = 0; i < entries; i++)
;                   if (tab[i].cp != null)
;                       tab[i].@cp = (varp == p_lcs) ? NUL : ' ';
;               if (varp == p_lcs)
;                   lcs_tab1[0] = NUL;
;               else
;                   @fill_diff = '-';
;           }

;           for (Bytes p = varp[0]; p.at(0) != NUL; )
;           {
;               int i;
;               for (i = 0; i < entries; i++)
;               {
;                   int len = STRLEN(tab[i].name);
;                   if (STRNCMP(p, tab[i].name, len) == 0 && p.at(len) == (byte)':' && p.at(len + 1) != NUL)
;                   {
;                       Bytes[] s = { p.plus(len + 1) };
;                       c1 = us_ptr2char_adv(s, true);
;                       if (1 < utf_char2cells(c1))
;                           continue;
;                       if (tab[i].cp == lcs_tab2)
;                       {
;                           if (s[0].at(0) == NUL)
;                               continue;
;                           c2 = us_ptr2char_adv(s, true);
;                           if (1 < utf_char2cells(c2))
;                               continue;
;                       }
;                       if (s[0].at(0) == (byte)',' || s[0].at(0) == NUL)
;                       {
;                           if (round != 0)
;                           {
;                               if (tab[i].cp == lcs_tab2)
;                               {
;                                   lcs_tab1[0] = c1;
;                                   lcs_tab2[0] = c2;
;                               }
;                               else if (tab[i].cp != null)
;                                   tab[i].@cp = c1;
;                           }
;                           p = s[0];
;                           break;
;                       }
;                   }
;               }

;               if (i == entries)
;                   return e_invarg;
;               if (p.at(0) == (byte)',')
;                   p = p.plus(1);
;           }
;       }

;       return null;        ;; no error
    ))

;; Extract the items in the 'clipboard' option and set global values.

(defn- #_Bytes check_clipboard_option []
    (§
;       int new_unnamed = 0;
;       boolean new_autoselect_star = false;
;       boolean new_autoselect_plus = false;
;       boolean new_autoselectml = false;
;       boolean new_html = false;
;       regprog_C new_exclude_prog = null;
;       Bytes errmsg = null;

;       for (Bytes p = @p_cb; p.at(0) != NUL; )
;       {
;           if (STRNCMP(p, u8("unnamed"), 7) == 0 && (p.at(7) == (byte)',' || p.at(7) == NUL))
;           {
;               new_unnamed |= CLIP_UNNAMED;
;               p = p.plus(7);
;           }
;           else if (STRNCMP(p, u8("unnamedplus"), 11) == 0 && (p.at(11) == (byte)',' || p.at(11) == NUL))
;           {
;               new_unnamed |= CLIP_UNNAMED_PLUS;
;               p = p.plus(11);
;           }
;           else if (STRNCMP(p, u8("autoselect"), 10) == 0 && (p.at(10) == (byte)',' || p.at(10) == NUL))
;           {
;               new_autoselect_star = true;
;               p = p.plus(10);
;           }
;           else if (STRNCMP(p, u8("autoselectplus"), 14) == 0 && (p.at(14) == (byte)',' || p.at(14) == NUL))
;           {
;               new_autoselect_plus = true;
;               p = p.plus(14);
;           }
;           else if (STRNCMP(p, u8("autoselectml"), 12) == 0 && (p.at(12) == (byte)',' || p.at(12) == NUL))
;           {
;               new_autoselectml = true;
;               p = p.plus(12);
;           }
;           else if (STRNCMP(p, u8("html"), 4) == 0 && (p.at(4) == (byte)',' || p.at(4) == NUL))
;           {
;               new_html = true;
;               p = p.plus(4);
;           }
;           else if (STRNCMP(p, u8("exclude:"), 8) == 0 && new_exclude_prog == null)
;           {
;               p = p.plus(8);
;               new_exclude_prog = vim_regcomp(p, RE_MAGIC);
;               if (new_exclude_prog == null)
;                   errmsg = e_invarg;
;               break;
;           }
;           else
;           {
;               errmsg = e_invarg;
;               break;
;           }
;           if (p.at(0) == (byte)',')
;               p = p.plus(1);
;       }

;       if (errmsg == null)
;       {
;           @clip_unnamed = new_unnamed;
;           @clip_autoselect_star = new_autoselect_star;
;           @clip_autoselect_plus = new_autoselect_plus;
;           @clip_autoselectml = new_autoselectml;
;           @clip_html = new_html;
;           @clip_exclude_prog = new_exclude_prog;
;       }

;       return errmsg;
    ))

;; Set the value of a boolean option, and take care of side effects.
;; Returns null for success, or an error message for an error.

(defn- #_Bytes set_bool_option [#_int opt_idx, #_boolean* varp, #_boolean value, #_int opt_flags]
    ;; opt_idx: index in vimoptions[] table
    ;; varp: pointer to the option variable
    ;; value: new value
    ;; opt_flags: OPT_LOCAL and/or OPT_GLOBAL
    (§
        ;; Disallow changing some options from secure mode.
;       if ((@secure != 0 || @sandbox != 0) && (vimoptions[opt_idx].@flags & P_SECURE) != 0)
;           return e_secure;

;       boolean old_value = varp[0];
;       varp[0] = value;                    ;; set the new value

        ;; May set global value for local option.
;       if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)
;           ((boolean[])get_varp_scope(vimoptions[opt_idx], OPT_GLOBAL))[0] = value;

        ;; Handle side effects of changing a bool option.

;       if (varp == @curbuf.b_p_ro)
;       {
            ;; when 'readonly' is reset globally, also reset readonlymode
;           if (!@curbuf.@b_p_ro && (opt_flags & OPT_LOCAL) == 0)
;               @readonlymode = false;

            ;; when 'readonly' is set may give W10 again
;           if (@curbuf.@b_p_ro)
;               @curbuf.b_did_warn = false;

;           redraw_titles();
;       }

        ;; when 'modifiable' is changed, redraw the window title
;       else if (varp == @curbuf.b_p_ma)
;       {
;           redraw_titles();
;       }

        ;; when 'bin' is set also set some other options
;       else if (varp == @curbuf.b_p_bin)
;       {
;           set_options_bin(old_value, @curbuf.@b_p_bin, opt_flags);
;           redraw_titles();
;       }

        ;; when 'terse' is set change 'shortmess'
;       else if (varp == p_terse)
;       {
;           Bytes p = vim_strchr(@p_shm, SHM_SEARCH);

            ;; insert 's' in "p_shm"
;           if (@p_terse && p == null)
;           {
;               STRCPY(@ioBuff, @p_shm);
;               STRCAT(@ioBuff, u8("s"));
;               set_string_option_direct(u8("shm"), -1, @ioBuff, OPT_FREE);
;           }
            ;; remove 's' from "p_shm"
;           else if (!@p_terse && p != null)
;               BCOPY(p, 0, p, 1, STRLEN(p, 1) + 1);
;       }

        ;; when 'paste' is set or reset also change other options
;       else if (varp == p_paste)
;       {
;           paste_option_changed();
;       }

        ;; when 'insertmode' is set from an autocommand need to do work here
;       else if (varp == p_im)
;       {
;           if (@p_im)
;           {
;               if ((@State & INSERT) == 0)
;                   @need_start_insertmode = true;
;               @stop_insert_mode = false;
;           }
;           else
;           {
;               @need_start_insertmode = false;
;               @stop_insert_mode = true;
;               if (@restart_edit != 0 && @mode_displayed)
;                   @clear_cmdline = true;   ;; remove "(insert)"
;               @restart_edit = 0;
;           }
;       }

        ;; when 'ignorecase' is set or reset and 'hlsearch' is set, redraw
;       else if (varp == p_ic && @p_hls)
;       {
;           redraw_all_later(SOME_VALID);
;       }

        ;; when 'hlsearch' is set or reset: reset no_hlsearch
;       else if (varp == p_hls)
;       {
;           @no_hlsearch = false;
;       }

        ;; when 'scrollbind' is set:
        ;; snapshot the current position to avoid a jump at the end of normal_cmd()
;       else if (varp == @curwin.w_onebuf_opt.wo_scb)
;       {
;           if (@curwin.w_onebuf_opt.@wo_scb)
;           {
;               do_check_scrollbind(false);
;               @curwin.w_scbind_pos = @curwin.w_topline;
;           }
;       }

        ;; When 'lisp' option changes include/exclude '-' in keyword characters.
;       else if (varp == @curbuf.b_p_lisp)
;       {
;           buf_init_chartab(@curbuf, false);        ;; ignore errors
;       }

;       else if (varp == @curbuf.b_changed)
;       {
;           redraw_titles();
;           @modified_was_set = value;
;       }

        ;; If 'wrap' is set, set w_leftcol to zero.
;       else if (varp == @curwin.w_onebuf_opt.wo_wrap)
;       {
;           if (@curwin.w_onebuf_opt.@wo_wrap)
;               @curwin.w_leftcol = 0;
;       }

;       else if (varp == p_ea)
;       {
;           if (@p_ea && !old_value)
;               win_equal(@curwin, false, 0);
;       }

        ;; End of handling side effects for bool options.

;       vimoptions[opt_idx].@flags |= P_WAS_SET;

;       comp_col();                     ;; in case 'ruler' or 'showcmd' changed
;       if (@curwin.w_curswant != MAXCOL && (vimoptions[opt_idx].@flags & (P_CURSWANT | P_RALL)) != 0)
;           @curwin.w_set_curswant = true;
;       check_redraw(vimoptions[opt_idx].@flags);

;       return null;
    ))

;; Set the value of a number option, and take care of side effects.
;; Returns null for success, or an error message for an error.

(defn- #_Bytes set_num_option [#_int opt_idx, #_long* varp, #_long value, #_Bytes errbuf, #_int errbuflen, #_int opt_flags]
    ;; opt_idx: index in vimoptions[] table
    ;; varp: pointer to the option variable
    ;; value: new value
    ;; errbuf: buffer for error messages
    ;; errbuflen: length of "errbuf"
    ;; opt_flags: OPT_LOCAL, OPT_GLOBAL and OPT_MODELINE
    (§
;       Bytes errmsg = null;
;       long old_value = varp[0];
;       long old_Rows = @Rows;               ;; remember old Rows
;       long old_Columns = @Columns;         ;; remember old Columns

        ;; Disallow changing some options from secure mode.
;       if ((@secure != 0 || @sandbox != 0) && (vimoptions[opt_idx].@flags & P_SECURE) != 0)
;           return e_secure;

;       varp[0] = value;

;       if (@curbuf.@b_p_sw < 0)
;       {
;           errmsg = e_positive;
;           @curbuf.@b_p_sw = @curbuf.@b_p_ts;
;       }

        ;; Number options that need some action when changed.

;       if (varp == p_wh)
;       {
;           if (@p_wh < 1)
;           {
;               errmsg = e_positive;
;               @p_wh = 1;
;           }
;           if (@p_wh < @p_wmh)
;           {
;               errmsg = e_winheight;
;               @p_wh = @p_wmh;
;           }

            ;; Change window height NOW.
;           if (@lastwin != @firstwin)
;           {
;               if (varp == p_wh && @curwin.w_height < @p_wh)
;                   win_setheight((int)@p_wh);
;           }
;       }

        ;; 'winminheight'
;       else if (varp == p_wmh)
;       {
;           if (@p_wmh < 0)
;           {
;               errmsg = e_positive;
;               @p_wmh = 0;
;           }
;           if (@p_wh < @p_wmh)
;           {
;               errmsg = e_winheight;
;               @p_wmh = @p_wh;
;           }
;           win_setminheight();
;       }

;       else if (varp == p_wiw)
;       {
;           if (@p_wiw < 1)
;           {
;               errmsg = e_positive;
;               @p_wiw = 1;
;           }
;           if (@p_wiw < @p_wmw)
;           {
;               errmsg = e_winwidth;
;               @p_wiw = @p_wmw;
;           }

            ;; Change window width NOW.
;           if (@lastwin != @firstwin && @curwin.w_width < @p_wiw)
;               win_setwidth((int)@p_wiw);
;       }

        ;; 'winminwidth'
;       else if (varp == p_wmw)
;       {
;           if (@p_wmw < 0)
;           {
;               errmsg = e_positive;
;               @p_wmw = 0;
;           }
;           if (@p_wiw < @p_wmw)
;           {
;               errmsg = e_winwidth;
;               @p_wmw = @p_wiw;
;           }
;           win_setminheight();
;       }

        ;; (re)set last window status line
;       else if (varp == p_ls)
;       {
;           last_status(false);
;       }

        ;; 'shiftwidth' or 'tabstop'
;       else if (varp == @curbuf.b_p_sw || varp == @curbuf.b_p_ts)
;       {
            ;; When 'shiftwidth' changes, or it's zero and 'tabstop' changes:
            ;; parse 'cinoptions'.
;           if (varp == @curbuf.b_p_sw || @curbuf.@b_p_sw == 0)
;               parse_cino(@curbuf);
;       }

        ;; 'maxcombine'
;       else if (varp == p_mco)
;       {
;           if (MAX_MCO < @p_mco)
;               @p_mco = MAX_MCO;
;           else if (@p_mco < 0)
;               @p_mco = 0;
;           screenclear();      ;; will re-allocate the screen
;       }

;       else if (varp == p_window)
;       {
;           if (@p_window < 1)
;               @p_window = 1;
;           else if (@Rows <= @p_window)
;               @p_window = @Rows - 1;
;       }

        ;; if "p_ch" changed value, change the command line height
;       else if (varp == p_ch)
;       {
;           if (@p_ch < 1)
;           {
;               errmsg = e_positive;
;               @p_ch = 1;
;           }
;           int min = min_rows();
;           if (@p_ch > @Rows - min + 1)
;               @p_ch = @Rows - min + 1;

            ;; Only compute the new window layout when startup has been completed,
            ;; otherwise the frame sizes may be wrong.
;           if (@p_ch != old_value && @full_screen)
;               command_height();
;       }

;       else if (varp == @curwin.w_onebuf_opt.wo_cole)
;       {
;           if (@curwin.w_onebuf_opt.@wo_cole < 0)
;           {
;               errmsg = e_positive;
;               @curwin.w_onebuf_opt.@wo_cole = 0;
;           }
;           else if (3 < @curwin.w_onebuf_opt.@wo_cole)
;           {
;               errmsg = e_invarg;
;               @curwin.w_onebuf_opt.@wo_cole = 3;
;           }
;       }

        ;; sync undo before 'undolevels' changes
;       else if (varp == p_ul)
;       {
            ;; use the old value, otherwise u_sync() may not work properly
;           @p_ul = old_value;
;           u_sync(true);
;           @p_ul = value;
;       }
;       else if (varp == @curbuf.b_p_ul)
;       {
            ;; use the old value, otherwise u_sync() may not work properly
;           @curbuf.@b_p_ul = old_value;
;           u_sync(true);
;           @curbuf.@b_p_ul = value;
;       }

        ;; 'numberwidth' must be positive
;       else if (varp == @curwin.w_onebuf_opt.wo_nuw)
;       {
;           if (@curwin.w_onebuf_opt.@wo_nuw < 1)
;           {
;               errmsg = e_positive;
;               @curwin.w_onebuf_opt.@wo_nuw = 1;
;           }
;           if (10 < @curwin.w_onebuf_opt.@wo_nuw)
;           {
;               errmsg = e_invarg;
;               @curwin.w_onebuf_opt.@wo_nuw = 10;
;           }
;           @curwin.w_nrwidth_line_count = 0;    ;; trigger a redraw
;       }

;       else if (varp == @curbuf.b_p_tw)
;       {
;           if (@curbuf.@b_p_tw < 0)
;           {
;               errmsg = e_positive;
;               @curbuf.@b_p_tw = 0;
;           }

;           for (tabpage_C tp = @first_tabpage; tp != null; tp = null)
;               for (window_C wp = (tp == @curtab) ? @firstwin : tp.tp_firstwin; wp != null; wp = wp.w_next)
;                   check_colorcolumn(wp);
;       }

        ;; Check the bounds for numeric options here.

;       if (@full_screen)
;       {
;           int min = min_rows();
;           if (@Rows < min)
;           {
;               if (errbuf != null)
;               {
;                   vim_snprintf(errbuf, errbuflen, u8("E593: Need at least %d lines"), min);
;                   errmsg = errbuf;
;               }
;               @Rows = min;
;           }
;           if ((int)@Columns < MIN_COLUMNS)
;           {
;               if (errbuf != null)
;               {
;                   vim_snprintf(errbuf, errbuflen, u8("E594: Need at least %d columns"), MIN_COLUMNS);
;                   errmsg = errbuf;
;               }
;               @Columns = MIN_COLUMNS;
;           }
;       }
;       limit_screen_size();

        ;; If the screen (shell) height has been changed, assume it is the physical screenheight.

;       if (old_Rows != @Rows || old_Columns != @Columns)
;       {
            ;; Changing the screen size is not allowed while updating the screen.
;           if (@updating_screen)
;               varp[0] = old_value;
;           else if (@full_screen)
;               set_shellsize((int)@Columns, (int)@Rows, true);
;           else
;           {
                ;; Postpone the resizing; check the size and cmdline position for messages.
;               check_shellsize();
;               if (@cmdline_row > @Rows - @p_ch && @p_ch < @Rows)
;                   @cmdline_row = (int)(@Rows - @p_ch);
;           }
;           if (@Rows <= @p_window || !option_was_set(u8("window")))
;               @p_window = @Rows - 1;
;       }

;       if (@curbuf.@b_p_ts <= 0)
;       {
;           errmsg = e_positive;
;           @curbuf.@b_p_ts = 8;
;       }
;       if (@p_tm < 0)
;       {
;           errmsg = e_positive;
;           @p_tm = 0;
;       }
;       if ((@curwin.w_onebuf_opt.@wo_scr <= 0 || (@curwin.w_height < @curwin.w_onebuf_opt.@wo_scr && 0 < @curwin.w_height))
;               && @full_screen)
;       {
;           if (varp == @curwin.w_onebuf_opt.wo_scr)
;           {
;               if (@curwin.w_onebuf_opt.@wo_scr != 0)
;                   errmsg = e_scroll;
;               win_comp_scroll(@curwin);
;           }
            ;; If 'scroll' became invalid because of a side effect silently adjust it.
;           else if (@curwin.w_onebuf_opt.@wo_scr <= 0)
;               @curwin.w_onebuf_opt.@wo_scr = 1;
;           else ;; @curwin.w_onebuf_opt.@wo_scr > @curwin.w_height
;               @curwin.w_onebuf_opt.@wo_scr = @curwin.w_height;
;       }
;       if (@p_hi < 0)
;       {
;           errmsg = e_positive;
;           @p_hi = 0;
;       }
;       else if (10000 < @p_hi)
;       {
;           errmsg = e_invarg;
;           @p_hi = 10000;
;       }
;       if (@p_re < 0 || 2 < @p_re)
;       {
;           errmsg = e_invarg;
;           @p_re = 0;
;       }
;       if (@p_report < 0)
;       {
;           errmsg = e_positive;
;           @p_report = 1;
;       }
;       if ((@p_sj < -100 || @Rows <= @p_sj) && @full_screen)
;       {
;           if (@Rows != old_Rows)   ;; Rows changed, just adjust "p_sj"
;               @p_sj = @Rows / 2;
;           else
;           {
;               errmsg = e_scroll;
;               @p_sj = 1;
;           }
;       }
;       if (@p_so < 0 && @full_screen)
;       {
;           errmsg = e_scroll;
;           @p_so = 0;
;       }
;       if (@p_siso < 0 && @full_screen)
;       {
;           errmsg = e_positive;
;           @p_siso = 0;
;       }
;       if (@p_cwh < 1)
;       {
;           errmsg = e_positive;
;           @p_cwh = 1;
;       }
;       if (@p_ut < 0)
;       {
;           errmsg = e_positive;
;           @p_ut = 2000;
;       }
;       if (@p_ss < 0)
;       {
;           errmsg = e_positive;
;           @p_ss = 0;
;       }

        ;; May set global value for local option.
;       if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)
;           ((long[])get_varp_scope(vimoptions[opt_idx], OPT_GLOBAL))[0] = varp[0];

;       vimoptions[opt_idx].@flags |= P_WAS_SET;

;       comp_col();                     ;; in case 'columns' or 'ls' changed
;       if (@curwin.w_curswant != MAXCOL && (vimoptions[opt_idx].@flags & (P_CURSWANT | P_RALL)) != 0)
;           @curwin.w_set_curswant = true;
;       check_redraw(vimoptions[opt_idx].@flags);

;       return errmsg;
    ))

;; Called after an option changed: check if something needs to be redrawn.

(defn- #_void check_redraw [#_long flags]
    (§
        ;; Careful: P_RCLR and P_RALL are a combination of other P_ flags.
;       boolean doclear = ((flags & P_RCLR) == P_RCLR);
;       boolean all = ((flags & P_RALL) == P_RALL || doclear);

;       if ((flags & P_RSTAT) != 0 || all)      ;; mark all status lines dirty
;           status_redraw_all();

;       if ((flags & P_RBUF) != 0 || (flags & P_RWIN) != 0 || all)
;           changed_window_setting();
;       if ((flags & P_RBUF) != 0)
;           redraw_curbuf_later(NOT_VALID);
;       if (doclear)
;           redraw_all_later(CLEAR);
;       else if (all)
;           redraw_all_later(NOT_VALID);
    ))

(atom! short* quick_tab 27)   ;; quick access table

;; Find index for option 'arg'.
;; Return -1 if not found.

(defn- #_int findoption [#_Bytes arg]
    (§
;       Bytes s;

        ;; For first call: Initialize the quick-access table.
        ;; It contains the index for the first option that starts with a certain letter.
        ;; There are 26 letters, plus the first "t_" option.

;       if (@quick_tab[1] == 0)
;       {
;           Bytes p = vimoptions[0].fullname;
;           for (int opt_idx = 1; (s = vimoptions[opt_idx].fullname) != null; opt_idx++)
;           {
;               if (s.at(0) != p.at(0))
;               {
;                   if (s.at(0) == (byte)'t' && s.at(1) == (byte)'_')
;                       @quick_tab[26] = (short)opt_idx;
;                   else
;                       @quick_tab[charOrdLow(s.at(0))] = (short)opt_idx;
;               }
;               p = s;
;           }
;       }

        ;; Check for name starting with an illegal character.

;       if (arg.at(0) < 'a' || 'z' < arg.at(0))
;           return -1;

;       int opt_idx;
;       boolean is_term_opt = (arg.at(0) == (byte)'t' && arg.at(1) == (byte)'_');
;       if (is_term_opt)
;           opt_idx = @quick_tab[26];
;       else
;           opt_idx = @quick_tab[charOrdLow(arg.at(0))];
;       for ( ; (s = vimoptions[opt_idx].fullname) != null; opt_idx++)
;       {
;           if (STRCMP(arg, s) == 0)                    ;; match full name
;               break;
;       }
;       if (s == null && !is_term_opt)
;       {
;           opt_idx = @quick_tab[charOrdLow(arg.at(0))];
;           for ( ; vimoptions[opt_idx].fullname != null; opt_idx++)
;           {
;               s = vimoptions[opt_idx].shortname;
;               if (s != null && STRCMP(arg, s) == 0)   ;; match short name
;                   break;
;               s = null;
;           }
;       }
;       if (s == null)
;           opt_idx = -1;
;       return opt_idx;
    ))

;; Get the value for an option.
;;
;; Returns:
;; Number or Toggle option: 1, numval[0] gets value.
;;           String option: 0, stringval[0] gets allocated string.
;; Hidden Number or Toggle option: -1.
;;           hidden String option: -2.
;;                 unknown option: -3.

(defn- #_int get_option_value [#_Bytes name, #_long* numval, #_Bytes* stringval, #_int opt_flags]
    ;; stringval: null when only checking existence
    (§
;       int opt_idx = findoption(name);
;       if (opt_idx < 0)                ;; unknown option
;           return -3;

;       Object varp = get_varp_scope(vimoptions[opt_idx], opt_flags);

;       if ((vimoptions[opt_idx].@flags & P_STRING) != 0)
;       {
;           if (varp == null)           ;; hidden option
;               return -2;
;           if (stringval != null)
;               stringval[0] = STRDUP(((Bytes[])varp)[0]);
;           return 0;
;       }

;       if (varp == null)               ;; hidden option
;           return -1;
;       if ((vimoptions[opt_idx].@flags & P_NUM) != 0)
;           numval[0] = ((long[])varp)[0];
;       else
;       {
            ;; Special case: 'modified' is "b_changed",
            ;; but we also want to consider it set when 'ff' or 'fenc' changed.
;           if (varp == @curbuf.b_changed)
;               numval[0] = curbufIsChanged() ? TRUE : FALSE;
;           else
;               numval[0] = ((int[])varp)[0];
;       }
;       return 1;
    ))

;; Set the value of option "name".
;; Use "string" for string options, use "number" for other options.
;;
;; Returns null on success or error message on error.

(defn- #_Bytes set_option_value [#_Bytes name, #_long number, #_Bytes string, #_int opt_flags]
    ;; opt_flags: OPT_LOCAL or 0 (both)
    (§
;       int opt_idx = findoption(name);
;       if (opt_idx < 0)
;       {
;           emsg2(u8("E355: Unknown option: %s"), name);
;           return null;
;       }

;       long flags = vimoptions[opt_idx].@flags;

        ;; Disallow changing some options in the sandbox.
;       if (0 < @sandbox && (flags & P_SECURE) != 0)
;       {
;           emsg(e_sandbox);
;           return null;
;       }

;       if ((flags & P_STRING) != 0)
;           return set_string_option(opt_idx, string, opt_flags);

;       Object varp = get_varp_scope(vimoptions[opt_idx], opt_flags);
;       if (varp != null)   ;; hidden option is not changed
;       {
;           if (number == 0 && string != null)
;           {
;               int idx;

                ;; Either we are given a string or we are setting option to zero.
;               for (idx = 0; string.at(idx) == (byte)'0'; idx++)
                ;
;               if (string.at(idx) != NUL || idx == 0)
;               {
                    ;; There's another character after zeros or the string is empty.
                    ;; In both cases, we are trying to set a num option using a string.
;                   emsg3(u8("E521: Number required: &%s = '%s'"), name, string);
;                   return null;        ;; do nothing as we hit an error
;               }
;           }

;           if ((flags & P_NUM) != 0)
;               return set_num_option(opt_idx, (long[])varp, number, null, 0, opt_flags);
;           else
;               return set_bool_option(opt_idx, (boolean[])varp, (number != 0), opt_flags);
;       }

;       return null;
    ))

;; Get the terminal code for a terminal option.
;; Returns null when not found.

(defn- #_Bytes get_term_code [#_Bytes tname]
    (§
;       if (tname.at(0) != (byte)'t' || tname.at(1) != (byte)'_' || tname.at(2) == NUL || tname.at(3) == NUL)
;           return null;
;       int opt_idx = findoption(tname);
;       if (0 <= opt_idx)
;       {
;           Object varp = get_varp(vimoptions[opt_idx], false);
;           return (varp != null) ? ((Bytes[])varp)[0] : null;
;       }
;       return find_termcode(tname.plus(2));
    ))

(defn- #_Bytes get_highlight_default []
    (§
;       int i = findoption(u8("hl"));
;       if (i < 0)
;           return null;

;       return (Bytes)vimoptions[i].def_val;
    ))

;; Translate a string like "t_xx", "<t_xx>" or "<S-Tab>" to a key number.

(defn- #_int find_key_option [#_Bytes _arg]
    (§
;       Bytes[] arg = { _arg };
;       int key;

        ;; Don't use get_special_key_code() for t_xx, we don't want it to call add_termcap_entry().

;       if (arg[0].at(0) == (byte)'t' && arg[0].at(1) == (byte)'_' && arg[0].at(2) != NUL && arg[0].at(3) != NUL)
;           key = TERMCAP2KEY(arg[0].at(2), arg[0].at(3));
;       else
;       {
;           arg[0] = arg[0].minus(1);                      ;; put "arg" at the '<'
;           int[] modifiers = { 0 };
;           key = find_special_key(arg, modifiers, true, true);
;           if (modifiers[0] != 0)              ;; can't handle modifiers here
;               key = 0;
;       }

;       return key;
    ))

;; if 'all' == 0: show changed options
;; if 'all' == 1: show all normal options
;; if 'all' == 2: show all terminal options

(defn- #_void showoptions [#_int all, #_int opt_flags]
    ;; opt_flags: OPT_LOCAL and/or OPT_GLOBAL
    (§
;       final int INC = 20, GAP = 3;

;       vimoption_C[] items = new vimoption_C[vimoptions.length];

        ;; Highlight title.
;       if (all == 2)
;           msg_puts_title(u8("\n--- Terminal codes ---"));
;       else if ((opt_flags & OPT_GLOBAL) != 0)
;           msg_puts_title(u8("\n--- Global option values ---"));
;       else if ((opt_flags & OPT_LOCAL) != 0)
;           msg_puts_title(u8("\n--- Local option values ---"));
;       else
;           msg_puts_title(u8("\n--- Options ---"));

        ;; do the loop two times:
        ;; 1. display the short items
        ;; 2. display the long items (only strings and numbers)

;       for (int run = 1; run <= 2 && !@got_int; run++)
;       {
            ;; collect the items in items[]

;           int item_count = 0;
;           for (int i = 0; vimoptions[i].fullname != null; i++)
;           {
;               boolean isterm = istermoption(vimoptions[i]);

;               Object varp = null;
;               if (opt_flags != 0)
;               {
;                   if (vimoptions[i].indir != PV_NONE && !isterm)
;                       varp = get_varp_scope(vimoptions[i], opt_flags);
;               }
;               else
;                   varp = get_varp(vimoptions[i], false);

;               if (varp != null
;                       && ((all == 2 && isterm)
;                           || (all == 1 && !isterm)
;                           || (all == 0 && !optval_default(vimoptions[i], varp))))
;               {
;                   int len;
;                   if ((vimoptions[i].@flags & P_BOOL) != 0)
;                       len = 1;            ;; a toggle option fits always
;                   else
;                   {
;                       option_value2string(vimoptions[i], opt_flags);
;                       len = STRLEN(vimoptions[i].fullname) + mb_string2cells(@nameBuff, -1) + 1;
;                   }
;                   if ((len <= INC - GAP && run == 1) || (INC - GAP < len && run == 2))
;                       items[item_count++] = vimoptions[i];
;               }
;           }

            ;; display the items

;           int rows;
;           if (run == 1)
;           {
;               int cols = ((int)@Columns + GAP - 3) / INC;
;               if (cols == 0)
;                   cols = 1;
;               rows = (item_count + cols - 1) / cols;
;           }
;           else    ;; run == 2
;               rows = item_count;

;           for (int row = 0; row < rows && !@got_int; row++)
;           {
;               msg_putchar('\n');                      ;; go to next line
;               if (@got_int)                            ;; 'q' typed in more
;                   break;
;               int col = 0;
;               for (int i = row; i < item_count; i += rows)
;               {
;                   @msg_col = col;                      ;; make columns
;                   showoneopt(items[i], opt_flags);
;                   col += INC;
;               }
;               out_flush();
;               ui_breakcheck();
;           }
;       }
    ))

;; Return true if option "p" has its default value.

(defn- #_boolean optval_default [#_vimoption_C v, #_Object varp]
    (§
;       if (varp == null)
;           return true;        ;; hidden option is always at default
;       if ((v.@flags & P_NUM) != 0)
;           return (((long[])varp)[0] == (long)v.def_val);
;       if ((v.@flags & P_BOOL) != 0)
;           return (((boolean[])varp)[0] == (boolean)v.def_val);
;       if ((v.@flags & P_STRING) != 0)
;           return (STRCMP(((Bytes[])varp)[0], (Bytes)v.def_val) == 0);

;       throw new IllegalArgumentException("invalid option type");
    ))

;; showoneopt: show the value of one option
;; must not be called with a hidden option!

(defn- #_void showoneopt [#_vimoption_C v, #_int opt_flags]
    ;; opt_flags: OPT_LOCAL or OPT_GLOBAL
    (§
;       boolean save_silent = @silent_mode;

;       @silent_mode = false;
;       @info_message = true;

;       Object varp = get_varp_scope(v, opt_flags);

        ;; for 'modified' we also need to check if 'ff' or 'fenc' changed.
;       if ((v.@flags & P_BOOL) != 0 && ((varp == @curbuf.b_changed) ? !curbufIsChanged() : !((boolean[])varp)[0]))
;           msg_puts(u8("no"));
;    /* else if ((v.@flags & P_BOOL) != 0 && ((boolean[])varp)[0] < 0)
;           msg_puts(u8("--")); */
;       else
;           msg_puts(u8("  "));
;       msg_puts(v.fullname);
;       if ((v.@flags & P_BOOL) == 0)
;       {
;           msg_putchar('=');
            ;; put value string in nameBuff
;           option_value2string(v, opt_flags);
;           msg_outtrans(@nameBuff);
;       }

;       @silent_mode = save_silent;
;       @info_message = false;
    ))

;; Clear all the terminal options.
;; If the option has been allocated, free the memory.
;; Terminal options are never hidden or indirect.

(defn- #_void clear_termoptions []
    (§
        ;; Reset a few things before clearing the old options.  This may cause
        ;; outputting a few things that the terminal doesn't understand, but the
        ;; screen will be cleared later, so this is OK.

;       mch_setmouse(false);            ;; switch mouse off

;       stoptermcap();                  ;; stop termcap mode

;       free_termoptions();
    ))

(defn- #_void free_termoptions []
    (§
;       for (int i = 0; vimoptions[i].fullname != null; i++)
;           if (istermoption(vimoptions[i]))
;           {
;               ((Bytes[])vimoptions[i].var)[0] = EMPTY_OPTION;
;               vimoptions[i].def_val = EMPTY_OPTION;
;           }

;       clear_termcodes();
    ))

;; Free the string for one term option, if it was allocated.
;; Set the string to EMPTY_OPTION and clear allocated flag.
;; "var" points to the option value.

(defn- #_void free_one_termoption [#_Bytes* varp]
    (§
;       for (int i = 0; vimoptions[i].fullname != null; i++)
;           if (vimoptions[i].var == varp)
;           {
;               ((Bytes[])vimoptions[i].var)[0] = EMPTY_OPTION;
;               break;
;           }
    ))

;; Set the terminal option defaults to the current value.
;; Used after setting the terminal name.

(defn- #_void set_term_defaults []
    (§
;       for (int i = 0; vimoptions[i].fullname != null; i++)
;       {
;           if (istermoption(vimoptions[i]) && vimoptions[i].def_val != ((Bytes[])vimoptions[i].var)[0])
;               vimoptions[i].def_val = ((Bytes[])vimoptions[i].var)[0];
;       }
    ))

;; return true if 'v' starts with 't_'

(defn- #_boolean istermoption [#_vimoption_C v]
    (§
;       return (v.fullname.at(0) == (byte)'t' && v.fullname.at(1) == (byte)'_');
    ))

;; Compute columns for ruler and shown command. 'sc_col' is also used to
;; decide what the maximum length of a message on the status line can be.
;; If there is a status line for the last window, 'sc_col' is independent
;; of 'ru_col'.

(final int COL_RULER 17)        ;; columns needed by standard ruler

(defn- #_void comp_col []
    (§
;       boolean last_has_status = (@p_ls == 2 || (@p_ls == 1 && @firstwin != @lastwin));

;       @sc_col = 0;
;       @ru_col = 0;
;       if (@p_ru)
;       {
;           @ru_col = (@ru_wid != 0 ? @ru_wid : COL_RULER) + 1;
            ;; no last status line, adjust sc_col
;           if (!last_has_status)
;               @sc_col = @ru_col;
;       }
;       if (@p_sc)
;       {
;           @sc_col += SHOWCMD_COLS;
;           if (!@p_ru || last_has_status)       ;; no need for separating space
;               @sc_col++;
;       }
;       @sc_col = (int)@Columns - @sc_col;
;       @ru_col = (int)@Columns - @ru_col;
;       if (@sc_col <= 0)            ;; screen too narrow, will become a mess
;           @sc_col = 1;
;       if (@ru_col <= 0)
;           @ru_col = 1;
    ))

;; Get pointer to option variable, depending on local or global scope.

(defn- #_Object get_varp_scope [#_vimoption_C v, #_int opt_flags]
    (§
;       if ((opt_flags & OPT_GLOBAL) != 0 && v.indir != PV_NONE)
;       {
;           if (v.var == VAR_WIN)
;           {
                ;; transform a pointer to a "w_onebuf_opt" option into a "w_allbuf_opt" option
;               return get_varp(v, true);
;           }

;           return v.var;
;       }

;       if ((opt_flags & OPT_LOCAL) != 0 && (v.indir & PV_BOTH) != 0)
;       {
;           switch (v.indir)
;           {
;               case PV_KP:   return @curbuf.b_p_kp;
;               case PV_LW:   return @curbuf.b_p_lw;
;               case PV_UL:   return @curbuf.b_p_ul;
;           }
;           return null;        ;; "cannot happen"
;       }

;       return get_varp(v, false);
    ))

;; Get pointer to option variable.

(defn- #_Object get_varp [#_vimoption_C v, #_boolean all]
    (§
        ;; hidden option, always return null
;       if (v.var == null)
;           return null;

;       winopt_C wop = (all) ? @curwin.w_allbuf_opt : @curwin.w_onebuf_opt;

;       switch (v.indir)
;       {
;           case PV_NONE:   return v.var;

            ;; global option with local value: use local value if it's been set
;           case PV_KP:     return (@curbuf.@b_p_kp.at(0) != NUL)          ? @curbuf.b_p_kp : v.var;
;           case PV_LW:     return (@curbuf.@b_p_lw.at(0) != NUL)          ? @curbuf.b_p_lw : v.var;
;           case PV_UL:     return (@curbuf.@b_p_ul != NO_LOCAL_UNDOLEVEL) ? @curbuf.b_p_ul : v.var;

;           case PV_BRI:    return wop.wo_bri;
;           case PV_BRIOPT: return wop.wo_briopt;
;           case PV_CC:     return wop.wo_cc;
;           case PV_COCU:   return wop.wo_cocu;
;           case PV_COLE:   return wop.wo_cole;
;           case PV_CRBIND: return wop.wo_crb;
;           case PV_CUC:    return wop.wo_cuc;
;           case PV_CUL:    return wop.wo_cul;
;           case PV_LBR:    return wop.wo_lbr;
;           case PV_LIST:   return wop.wo_list;
;           case PV_NU:     return wop.wo_nu;
;           case PV_NUW:    return wop.wo_nuw;
;           case PV_RL:     return wop.wo_rl;
;           case PV_RLC:    return wop.wo_rlc;
;           case PV_RNU:    return wop.wo_rnu;
;           case PV_SCBIND: return wop.wo_scb;
;           case PV_SCROLL: return wop.wo_scr;
;           case PV_WFH:    return wop.wo_wfh;
;           case PV_WFW:    return wop.wo_wfw;
;           case PV_WRAP:   return wop.wo_wrap;

;           case PV_AI:     return @curbuf.b_p_ai;
;           case PV_BIN:    return @curbuf.b_p_bin;
;           case PV_CI:     return @curbuf.b_p_ci;
;           case PV_CIN:    return @curbuf.b_p_cin;
;           case PV_CINK:   return @curbuf.b_p_cink;
;           case PV_CINO:   return @curbuf.b_p_cino;
;           case PV_CINW:   return @curbuf.b_p_cinw;
;           case PV_COM:    return @curbuf.b_p_com;
;           case PV_ET:     return @curbuf.b_p_et;
;           case PV_FLP:    return @curbuf.b_p_flp;
;           case PV_FO:     return @curbuf.b_p_fo;
;           case PV_INF:    return @curbuf.b_p_inf;
;           case PV_ISK:    return @curbuf.b_p_isk;
;           case PV_LISP:   return @curbuf.b_p_lisp;
;           case PV_MA:     return @curbuf.b_p_ma;
;           case PV_MOD:    return @curbuf.b_changed;
;           case PV_MPS:    return @curbuf.b_p_mps;
;           case PV_NF:     return @curbuf.b_p_nf;
;           case PV_PI:     return @curbuf.b_p_pi;
;           case PV_QE:     return @curbuf.b_p_qe;
;           case PV_RO:     return @curbuf.b_p_ro;
;           case PV_SI:     return @curbuf.b_p_si;
;           case PV_STS:    return @curbuf.b_p_sts;
;           case PV_SW:     return @curbuf.b_p_sw;
;           case PV_TS:     return @curbuf.b_p_ts;
;           case PV_TW:     return @curbuf.b_p_tw;
;           case PV_WM:     return @curbuf.b_p_wm;

;           default:
;               emsg(u8("E356: get_varp() ERROR"));
;               break;
;       }

;       return null;
    ))

;; Copy options from one window to another.
;; Used when splitting a window.

(defn- #_void win_copy_options [#_window_C wp_from, #_window_C wp_to]
    (§
;       copy_winopt(wp_from.w_onebuf_opt, wp_to.w_onebuf_opt);
;       copy_winopt(wp_from.w_allbuf_opt, wp_to.w_allbuf_opt);
;       briopt_check(wp_to);
    ))

;; Copy the options from one winopt_C to another.
;; Doesn't free the old option values in "to", use clear_winopt() for that.
;; The 'scroll' option is not copied, because it depends on the window height.
;; The 'previewwindow' option is reset, there can be only one preview window.

(defn- #_void copy_winopt [#_winopt_C from, #_winopt_C to]
    (§
;       to.@wo_list = from.@wo_list;
;       to.@wo_nu = from.@wo_nu;
;       to.@wo_rnu = from.@wo_rnu;
;       to.@wo_nuw = from.@wo_nuw;
;       to.@wo_rl  = from.@wo_rl;
;       to.@wo_rlc = STRDUP(from.@wo_rlc);
;       to.@wo_wrap = from.@wo_wrap;
;       to.@wo_lbr = from.@wo_lbr;
;       to.@wo_bri = from.@wo_bri;
;       to.@wo_briopt = STRDUP(from.@wo_briopt);
;       to.@wo_scb = from.@wo_scb;
;       to.@wo_crb = from.@wo_crb;
;       to.@wo_cuc = from.@wo_cuc;
;       to.@wo_cul = from.@wo_cul;
;       to.@wo_cc = STRDUP(from.@wo_cc);
;       to.@wo_cocu = STRDUP(from.@wo_cocu);
;       to.@wo_cole = from.@wo_cole;
;       check_winopt(to);           ;; don't want null pointers
    ))

;; Check string options in a window for a null value.

(defn- #_void check_win_options [#_window_C win]
    (§
;       check_winopt(win.w_onebuf_opt);
;       check_winopt(win.w_allbuf_opt);
    ))

;; Check for null pointers in a winopt_C and replace them with EMPTY_OPTION.

(defn- #_void check_winopt [#_winopt_C wop]
    (§
;       check_string_option(wop.wo_rlc);
;       check_string_option(wop.wo_cc);
;       check_string_option(wop.wo_cocu);
;       check_string_option(wop.wo_briopt);
    ))

;; Free the allocated memory inside a winopt_C.

(defn- #_void clear_winopt [#_winopt_C wop]
    (§
;       clear_string_option(wop.wo_briopt);
;       clear_string_option(wop.wo_rlc);
;       clear_string_option(wop.wo_cc);
;       clear_string_option(wop.wo_cocu);
    ))

;; Copy global option values to local options for one buffer.
;; Used when creating a new buffer and sometimes when entering a buffer.
;; flags:
;; BCO_ENTER    We will enter the buf buffer.
;; BCO_ALWAYS   Always copy the options, but only set b_p_initialized when appropriate.

(defn- #_void buf_copy_options [#_buffer_C buf, #_int flags]
    (§
;       boolean should_copy = true;
;       Bytes save_p_isk = null;
;       boolean did_isk = false;

        ;; Don't do anything if the buffer is invalid.

;       if (buf == null || !buf_valid(buf))
;           return;

        ;; Skip this when the option defaults have not been set yet.
        ;; Happens when main() allocates the first buffer.

;       if (@p_cpo != null)
;       {
            ;; Always copy when entering and 'cpo' contains 'S'.
            ;; Don't copy when already initialized.
            ;; Don't copy when 'cpo' contains 's' and not entering.
            ;; 'S'  BCO_ENTER  initialized  's'  should_copy
            ;; yes    yes          X         X      true
            ;; yes    no          yes        X      false
            ;; no      X          yes        X      false
            ;;  X     no          no        yes     false
            ;;  X     no          no        no      true
            ;; no     yes         no         X      true

;           if ((vim_strbyte(@p_cpo, CPO_BUFOPTGLOB) == null || (flags & BCO_ENTER) == 0)
;                   && (buf.b_p_initialized
;                       || ((flags & BCO_ENTER) == 0
;                           && vim_strbyte(@p_cpo, CPO_BUFOPT) != null)))
;               should_copy = false;

;           if (should_copy || (flags & BCO_ALWAYS) != 0)
;           {
                ;; Don't copy the options specific to a help buffer when the options were already initialized
                ;; (jumping back to a help file with CTRL-T or CTRL-O).
;               boolean dont_do_help = buf.b_p_initialized;
;               if (dont_do_help)           ;; don't free "b_p_isk"
;               {
;                   save_p_isk = buf.@b_p_isk;
;                   buf.@b_p_isk = null;
;               }

                ;; Always free the allocated strings.
                ;; If not already initialized, set 'readonly' and copy 'fileformat'.

;               if (!buf.b_p_initialized)
;               {
;                   free_buf_options(buf, true);
;                   buf.@b_p_ro = false;             ;; don't copy readonly
;               }
;               else
;                   free_buf_options(buf, false);

;               buf.@b_p_ai = @p_ai;
;               buf.b_p_ai_nopaste = @p_ai_nopaste;
;               buf.@b_p_sw = @p_sw;
;               buf.@b_p_tw = @p_tw;
;               buf.b_p_tw_nopaste = @p_tw_nopaste;
;               buf.b_p_tw_nobin = @p_tw_nobin;
;               buf.@b_p_wm = @p_wm;
;               buf.b_p_wm_nopaste = @p_wm_nopaste;
;               buf.b_p_wm_nobin = @p_wm_nobin;
;               buf.@b_p_bin = @p_bin;
;               buf.@b_p_et = @p_et;
;               buf.b_p_et_nobin = @p_et_nobin;
;               buf.@b_p_inf = @p_inf;
;               buf.@b_p_sts = @p_sts;
;               buf.b_p_sts_nopaste = @p_sts_nopaste;
;               buf.@b_p_com = STRDUP(@p_com);
;               buf.@b_p_fo = STRDUP(@p_fo);
;               buf.@b_p_flp = STRDUP(@p_flp);
;               buf.@b_p_nf = STRDUP(@p_nf);
;               buf.@b_p_mps = STRDUP(@p_mps);
;               buf.@b_p_si = @p_si;
;               buf.@b_p_ci = @p_ci;
;               buf.@b_p_cin = @p_cin;
;               buf.@b_p_cink = STRDUP(@p_cink);
;               buf.@b_p_cino = STRDUP(@p_cino);
;               buf.@b_p_pi = @p_pi;
;               buf.@b_p_cinw = STRDUP(@p_cinw);
;               buf.@b_p_lisp = @p_lisp;

                ;; Options that are normally global but also have a local value
                ;; are not copied: start using the global value.
;               buf.@b_p_ul = NO_LOCAL_UNDOLEVEL;
;               buf.@b_p_kp = EMPTY_OPTION;
;               buf.@b_p_qe = STRDUP(@p_qe);
;               buf.@b_p_lw = EMPTY_OPTION;

                ;; Don't copy the options set by ex_help(), use the saved values,
                ;; when going from a help buffer to a non-help buffer.

;               if (dont_do_help)
;                   buf.@b_p_isk = save_p_isk;
;               else
;               {
;                   buf.@b_p_isk = STRDUP(@p_isk);
;                   did_isk = true;
;                   buf.@b_p_ts = @p_ts;
;                   buf.@b_p_ma = @p_ma;
;               }
;           }

            ;; When the options should be copied (ignoring BCO_ALWAYS), set the
            ;; flag that indicates that the options have been initialized.

;           if (should_copy)
;               buf.b_p_initialized = true;
;       }

;       check_buf_options(buf);         ;; make sure we don't have NULLs
;       if (did_isk)
;           buf_init_chartab(buf, false);
    ))

;; Reset the 'modifiable' option and its default value.

(defn- #_void reset_modifiable []
    (§
;       @curbuf.@b_p_ma = false;
;       @p_ma = false;
;       int opt_idx = findoption(u8("ma"));
;       if (0 <= opt_idx)
;           vimoptions[opt_idx].def_val = false;
    ))

;; Get the value for the numeric or string option *opp in a nice format into nameBuff[].
;; Must not be called with a hidden option!

(defn- #_void option_value2string [#_vimoption_C v, #_int opt_flags]
    ;; opt_flags: OPT_GLOBAL and/or OPT_LOCAL
    (§
;       Object varp = get_varp_scope(v, opt_flags);

;       if ((v.@flags & P_NUM) != 0)
;       {
;           long[] wc = { 0 };

;           if (wc_use_keyname((long[])varp, wc))
;               STRCPY(@nameBuff, get_special_key_name((int)wc[0], 0));
;           else if (wc[0] != 0)
;               STRCPY(@nameBuff, transchar((int)wc[0]));
;           else
;               libC.sprintf(@nameBuff, u8("%ld"), ((long[])varp)[0]);
;       }
;       else    ;; P_STRING
;       {
;           Bytes s = ((Bytes[])varp)[0];

;           if (s == null)              ;; just in case
;               @nameBuff.be(0, NUL);
            ;; translate 'pastetoggle' into special key names
;           else if (v.var == p_pt)
;               str2specialbuf(@p_pt, @nameBuff, MAXPATHL);
;           else
;               vim_strncpy(@nameBuff, s, MAXPATHL - 1);
;       }
    ))

;; Return true if "varp" points to 'wildchar' or 'wildcharm' and it can be printed as a keyname.
;; "*wcp" is set to the value of the option if it's 'wildchar' or 'wildcharm'.

(defn- #_boolean wc_use_keyname [#_long* varp, #_long* wcp]
    (§
;       if (varp == p_wc)
;       {
;           wcp[0] = varp[0];
;           if (is_special((int)wcp[0]) || 0 <= find_special_key_in_table((int)wcp[0]))
;               return true;
;       }
;       return false;
    ))

;; Return true if format option 'x' is in effect.
;; Take care of no formatting when 'paste' is set.

(defn- #_boolean has_format_option [#_int x]
    (§
;       if (@p_paste)
;           return false;

;       return (vim_strchr(@curbuf.@b_p_fo, x) != null);
    ))

;; Return true if "x" is present in 'shortmess' option, or
;; 'shortmess' contains 'a' and "x" is present in SHM_A.

(defn- #_boolean shortmess [#_int x]
    (§
;       return (@p_shm != null
;           && (vim_strchr(@p_shm, x) != null || (vim_strchr(@p_shm, 'a') != null && vim_strchr(SHM_A, x) != null)));
    ))

(atom! boolean old_p_paste)
(atom! boolean save_sm)
(atom! boolean save_ru)
(atom! boolean save_ri)

;; paste_option_changed() - Called after "p_paste" was set or reset.

(defn- #_void paste_option_changed []
    (§
;       if (@p_paste)
;       {
            ;; Paste switched from off to on.
            ;; Save the current values, so they can be restored later.

;           if (!@old_p_paste)
;           {
                ;; save options for each buffer
;               for (buffer_C buf = @firstbuf; buf != null; buf = buf.b_next)
;               {
;                   buf.b_p_tw_nopaste = buf.@b_p_tw;
;                   buf.b_p_wm_nopaste = buf.@b_p_wm;
;                   buf.b_p_sts_nopaste = buf.@b_p_sts;
;                   buf.b_p_ai_nopaste = buf.@b_p_ai;
;               }

                ;; save global options
;               @save_sm = @p_sm;
;               @save_ru = @p_ru;
;               @save_ri = @p_ri;
                ;; save global values for local buffer options
;               @p_tw_nopaste = @p_tw;
;               @p_wm_nopaste = @p_wm;
;               @p_sts_nopaste = @p_sts;
;               @p_ai_nopaste = @p_ai;
;           }

            ;; Always set the option values, also when 'paste' is set when it is already on.

            ;; set options for each buffer
;           for (buffer_C buf = @firstbuf; buf != null; buf = buf.b_next)
;           {
;               buf.@b_p_tw = 0;         ;; textwidth is 0
;               buf.@b_p_wm = 0;         ;; wrapmargin is 0
;               buf.@b_p_sts = 0;        ;; softtabstop is 0
;               buf.@b_p_ai = false;         ;; no auto-indent
;           }

            ;; set global options
;           @p_sm = false;                   ;; no showmatch
;           if (@p_ru)
;               status_redraw_all();    ;; redraw to remove the ruler
;           @p_ru = false;                   ;; no ruler
;           @p_ri = false;                   ;; no reverse insert
            ;; set global values for local buffer options
;           @p_tw = 0;
;           @p_wm = 0;
;           @p_sts = 0;
;           @p_ai = false;
;       }

        ;; Paste switched from on to off: Restore saved values.

;       else if (@old_p_paste)
;       {
            ;; restore options for each buffer
;           for (buffer_C buf = @firstbuf; buf != null; buf = buf.b_next)
;           {
;               buf.@b_p_tw = buf.b_p_tw_nopaste;
;               buf.@b_p_wm = buf.b_p_wm_nopaste;
;               buf.@b_p_sts = buf.b_p_sts_nopaste;
;               buf.@b_p_ai = buf.b_p_ai_nopaste;
;           }

            ;; restore global options
;           @p_sm = @save_sm;
;           if (@p_ru != @save_ru)
;               status_redraw_all();    ;; redraw to draw the ruler
;           @p_ru = @save_ru;
;           @p_ri = @save_ri;
            ;; set global values for local buffer options
;           @p_tw = @p_tw_nopaste;
;           @p_wm = @p_wm_nopaste;
;           @p_sts = @p_sts_nopaste;
;           @p_ai = @p_ai_nopaste;
;       }

;       @old_p_paste = @p_paste;
    ))

;; Return true when option "name" has been set.
;; Only works correctly for global options.

(defn- #_boolean option_was_set [#_Bytes name]
    (§
;       int idx = findoption(name);
;       if (idx < 0)        ;; unknown option
;           return false;
;       if ((vimoptions[idx].@flags & P_WAS_SET) != 0)
;           return true;

;       return false;
    ))

;; Reset the flag indicating option "name" was set.

(defn- #_void reset_option_was_set [#_Bytes name]
    (§
;       int idx = findoption(name);

;       if (0 <= idx)
;           vimoptions[idx].@flags &= ~P_WAS_SET;
    ))

;; fill_breakat_flags() -- called when 'breakat' changes value.

(defn- #_void fill_breakat_flags []
    (§
;       for (int i = 0; i < 256; i++)
;           @breakat_flags[i] = false;

;       if (@p_breakat != null)
;           for (Bytes p = @p_breakat; p.at(0) != NUL; p = p.plus(1))
;               @breakat_flags[char_u(p.at(0))] = true;
    ))

;; Check an option that can be a range of string values.
;;
;; Return true for correct value, false otherwise.
;; Empty is always OK.

(defn- #_boolean check_opt_strings [#_Bytes val, #_Bytes* values, #_boolean list]
    ;; list: when true: accept a list of values
    (§
;       return opt_strings_flags(val, values, null, list);
    ))

;; Handle an option that can be a range of string values.
;; Set a flag in "*flagp" for each string present.
;;
;; Return true for correct value, false otherwise.
;; Empty is always OK.

(defn- #_boolean opt_strings_flags [#_Bytes val, #_Bytes* values, #_int* flagp, #_boolean list]
    ;; val: new value
    ;; values: array of valid string values
    ;; list: when true: accept a list of values
    (§
;       int new_flags = 0;

;       while (val.at(0) != NUL)
;       {
;           for (int i = 0; ; i++)
;           {
;               if (values[i] == null)      ;; "val" not found in values[]
;                   return false;

;               int len = STRLEN(values[i]);
;               if (STRNCMP(values[i], val, len) == 0 && ((list && val.at(len) == (byte)',') || val.at(len) == NUL))
;               {
;                   val = val.plus(len + ((val.at(len) == (byte)',') ? 1 : 0));
;                   new_flags |= (1 << i);
;                   break;                  ;; check next item in "val" list
;               }
;           }
;       }
;       if (flagp != null)
;           flagp[0] = new_flags;

;       return true;
    ))

;; Check if backspacing over something is allowed.

(defn- #_boolean can_bs [#_int what]
    ;; what: BS_INDENT, BS_EOL or BS_START
    (§
;       switch (@p_bs.at(0))
;       {
;           case '2': return true;
;           case '1': return (what != BS_START);
;           case '0': return false;
;       }

;       return (vim_strchr(@p_bs, what) != null);
    ))

;; When "ignore_empty" is true don't consider a new, empty buffer to be changed.

(defn- #_boolean file_ff_differs [#_buffer_C buf, #_boolean ignore_empty]
    (§
        ;; In a buffer that was never loaded the options are not valid.
;       if ((buf.b_flags & BF_NEVERLOADED) != 0)
;           return false;
;       if (ignore_empty
;               && (buf.b_flags & BF_NEW) != 0
;               && buf.b_ml.ml_line_count == 1
;               && ml_get_buf(buf, 1, false).at(0) == NUL)
;           return false;

;       return false;
    ))

;; Return the effective shiftwidth value for current buffer,
;; using the 'tabstop' value when 'shiftwidth' is zero.

(defn- #_long get_sw_value [#_buffer_C buf]
    (§
;       return (buf.@b_p_sw != 0) ? buf.@b_p_sw : buf.@b_p_ts;
    ))

;; Return the effective softtabstop value for the current buffer,
;; using the 'tabstop' value when 'softtabstop' is negative.

(defn- #_long get_sts_value []
    (§
;       return (@curbuf.@b_p_sts < 0) ? get_sw_value(@curbuf) : @curbuf.@b_p_sts;
    ))

;; Check matchpairs option for "*initc".
;; If there is a match set "*initc" to the matching character and "*findc" to the opposite.
;; Set "*backwards" to the direction.
;; When "switchit" is true, swap the direction.

(defn- #_void find_mps_values [#_int* initc, #_int* findc, #_boolean* backwards, #_boolean switchit]
    (§
;       Bytes ptr = @curbuf.@b_p_mps;
;       while (ptr.at(0) != NUL)
;       {
;           Bytes prev;

;           if (us_ptr2char(ptr) == initc[0])
;           {
;               if (switchit)
;               {
;                   findc[0] = initc[0];
;                   initc[0] = us_ptr2char(ptr.plus(us_ptr2len_cc(ptr) + 1));
;                   backwards[0] = true;
;               }
;               else
;               {
;                   findc[0] = us_ptr2char(ptr.plus(us_ptr2len_cc(ptr) + 1));
;                   backwards[0] = false;
;               }
;               return;
;           }
;           prev = ptr;
;           ptr = ptr.plus(us_ptr2len_cc(ptr) + 1);
;           if (us_ptr2char(ptr) == initc[0])
;           {
;               if (switchit)
;               {
;                   findc[0] = initc[0];
;                   initc[0] = us_ptr2char(prev);
;                   backwards[0] = false;
;               }
;               else
;               {
;                   findc[0] = us_ptr2char(prev);
;                   backwards[0] = true;
;               }
;               return;
;           }
;           ptr = ptr.plus(us_ptr2len_cc(ptr));

;           if (ptr.at(0) == (byte)',')
;               ptr = ptr.plus(1);
;       }
    ))

;; This is called when 'breakindentopt' is changed and when a window is initialized.

(defn- #_boolean briopt_check [#_window_C wp]
    (§
;       int bri_shift = 0;
;       int bri_min = 20;
;       boolean bri_sbr = false;

;       Bytes p = wp.w_onebuf_opt.@wo_briopt;
;       while (p.at(0) != NUL)
;       {
;           if (STRNCMP(p, u8("shift:"), 6) == 0 && ((p.at(6) == (byte)'-' && asc_isdigit(p.at(7))) || asc_isdigit(p.at(6))))
;           {
;               p = p.plus(6);
;               { Bytes[] __ = { p }; bri_shift = (int)getdigits(__); p = __[0]; }
;           }
;           else if (STRNCMP(p, u8("min:"), 4) == 0 && asc_isdigit(p.at(4)))
;           {
;               p = p.plus(4);
;               { Bytes[] __ = { p }; bri_min = (int)getdigits(__); p = __[0]; }
;           }
;           else if (STRNCMP(p, u8("sbr"), 3) == 0)
;           {
;               p = p.plus(3);
;               bri_sbr = true;
;           }
;           if (p.at(0) != (byte)',' && p.at(0) != NUL)
;               return false;
;           if (p.at(0) == (byte)',')
;               p = p.plus(1);
;       }

;       wp.w_p_brishift = bri_shift;
;       wp.w_p_brimin = bri_min;
;       wp.w_p_brisbr = bri_sbr;

;       return true;
    ))

;; ex_cmds.c: some functions for command line commands --------------------------------------------

;; ":ascii" and "ga".

(defn- #_void ex_ascii [#_exarg_C _eap]
    (§
;       int[] cc = new int[MAX_MCO];

;       int c = us_ptr2char_cc(ml_get_cursor(), cc);
;       if (c == NUL)
;       {
;           msg(u8("NUL"));
;           return;
;       }

;       int ci = 0;

;       @ioBuff.be(0, NUL);
;       if (c < 0x80)
;       {
;           if (c == NL)        ;; NUL is stored as NL
;               c = NUL;

;           int cval = c;

;           Bytes buf1 = new Bytes(20);
;           if (vim_isprintc(c) && (c < ' ' || '~' < c))
;           {
;               Bytes buf3 = new Bytes(7);
;               transchar_nonprint(buf3, c);
;               vim_snprintf(buf1, buf1.size(), u8("  <%s>"), buf3);
;           }
;           else
;               buf1.be(0, NUL);

;           Bytes buf2 = new Bytes(20);
;           if (0x80 <= c)
;               vim_snprintf(buf2, buf2.size(), u8("  <M-%s>"), transchar(c & 0x7f));
;           else
;               buf2.be(0, NUL);

;           vim_snprintf(@ioBuff, IOSIZE, u8("<%s>%s%s  %d,  Hex %02x,  Octal %03o"), transchar(c), buf1, buf2, cval, cval, cval);
;           c = cc[ci++];
;       }

            ;; Repeat for combining characters.
;       while (0x100 <= c || 0x80 <= c)
;       {
;           int len = STRLEN(@ioBuff);
                ;; This assumes every multi-byte char is printable...
;           if (0 < len)
;               @ioBuff.be(len++, (byte)' ');
;           @ioBuff.be(len++, (byte)'<');
;           if (utf_iscomposing(c))
;               @ioBuff.be(len++, (byte)' ');                ;; draw composing char on top of a space
;           len += utf_char2bytes(c, @ioBuff.plus(len));
;           vim_snprintf(@ioBuff.plus(len), IOSIZE - len,
;                       (c < 0x10000) ? u8("> %d, Hex %04x, Octal %o")
;                                       : u8("> %d, Hex %08x, Octal %o"), c, c, c);
;           if (ci == MAX_MCO)
;               break;
;           c = cc[ci++];
;       }

;       msg(@ioBuff);
    ))

;; ":left", ":center" and ":right": align text.

(defn- #_void ex_align [#_exarg_C eap]
    (§
;       int indent = 0;

;       if (@curwin.w_onebuf_opt.@wo_rl)
;       {
                ;; switch left and right aligning
;           if (eap.cmdidx == CMD_right)
;               eap.cmdidx = CMD_left;
;           else if (eap.cmdidx == CMD_left)
;               eap.cmdidx = CMD_right;
;       }

;       int width = libC.atoi(eap.arg);
;       pos_C save_curpos = §_pos_C();
;       COPY_pos(save_curpos, @curwin.w_cursor);
;       if (eap.cmdidx == CMD_left)     ;; width is used for new indent
;       {
;           if (0 <= width)
;               indent = width;
;       }
;       else
;       {
                ;; if 'textwidth' set, use it
                ;; else if 'wrapmargin' set, use it
                ;; if invalid value, use 80

;           if (width <= 0)
;               width = (int)@curbuf.@b_p_tw;
;           if (width == 0 && 0 < @curbuf.@b_p_wm)
;               width = @curwin.w_width - (int)@curbuf.@b_p_wm;
;           if (width <= 0)
;               width = 80;
;       }

;       if (!u_save(eap.line1 - 1, eap.line2 + 1))
;           return;

;       for (@curwin.w_cursor.lnum = eap.line1; @curwin.w_cursor.lnum <= eap.line2; @curwin.w_cursor.lnum++)
;       {
;           int new_indent;
;           if (eap.cmdidx == CMD_left)             ;; left align
;               new_indent = indent;
;           else
;           {
;               boolean[] has_tab = { false };      ;; avoid uninit warnings

;               int len = linelen(eap.cmdidx == CMD_right ? has_tab : null) - get_indent();
;               if (len <= 0)                       ;; skip blank lines
;                   continue;

;               if (eap.cmdidx == CMD_center)
;                   new_indent = (width - len) / 2;
;               else
;               {
;                   new_indent = width - len;       ;; right align

                        ;; Make sure that embedded TABs don't make the text go too far to the right.

;                   if (has_tab[0])
;                       while (0 < new_indent)
;                       {
;                           set_indent(new_indent, 0);
;                           if (linelen(null) <= width)
;                           {
                                    ;; Now try to move the line as much as possible to the right.
                                    ;; Stop when it moves too far.

;                               do
;                               {
;                                   set_indent(++new_indent, 0);
;                               } while (linelen(null) <= width);
;                               --new_indent;
;                               break;
;                           }
;                           --new_indent;
;                       }
;               }
;           }
;           if (new_indent < 0)
;               new_indent = 0;
;           set_indent(new_indent, 0);                  ;; set indent
;       }
;       changed_lines(eap.line1, 0, eap.line2 + 1, 0L);
;       COPY_pos(@curwin.w_cursor, save_curpos);
;       beginline(BL_WHITE | BL_FIX);
    ))

;; Get the length of the current line, excluding trailing white space.

(defn- #_int linelen [#_boolean* has_tab]
    (§
        ;; find the first non-blank character
;       Bytes line = ml_get_curline();
;       Bytes first = skipwhite(line);

        ;; find the character after the last non-blank character
;       Bytes last;
;       for (last = first.plus(STRLEN(first)); BLT(first, last) && vim_iswhite(last.at(-1)); last = last.minus(1))
        ;

;       byte save = last.at(0);
;       last.be(0, NUL);
;       int len = linetabsize(line);        ;; get line length
;       if (has_tab != null)                ;; check for embedded TAB
;           has_tab[0] = (vim_strrchr(first, TAB) != null);
;       last.be(0, save);

;       return len;
    ))

;; ":retab".

(defn- #_void ex_retab [#_exarg_C eap]
    (§
;       boolean got_tab = false;
;       int num_spaces = 0;
;       int start_col = 0;                          ;; for start of white-space string
;       int start_vcol = 0;                         ;; for start of white-space string
;       long first_line = 0;                        ;; first changed line
;       long last_line = 0;                         ;; last changed line

;       boolean save_list = @curwin.w_onebuf_opt.@wo_list;
;       @curwin.w_onebuf_opt.@wo_list = false;     ;; don't want list mode here

;       int new_ts;
;       { Bytes[] __ = { eap.arg }; new_ts = (int)getdigits(__); eap.arg = __[0]; }
;       if (new_ts < 0)
;       {
;           emsg(e_positive);
;           return;
;       }
;       if (new_ts == 0)
;           new_ts = (int)@curbuf.@b_p_ts;

;       loop:
;       for (long lnum = eap.line1; !@got_int && lnum <= eap.line2; lnum++)
;       {
;           Bytes ptr = ml_get(lnum);
;           int col = 0;
;           int vcol = 0;
;           boolean did_undo = false;           ;; called u_save() for current line
;           for ( ; ; )
;           {
;               if (vim_iswhite(ptr.at(col)))
;               {
;                   if (!got_tab && num_spaces == 0)
;                   {
                            ;; First consecutive white-space.
;                       start_vcol = vcol;
;                       start_col = col;
;                   }
;                   if (ptr.at(col) == (byte)' ')
;                       num_spaces++;
;                   else
;                       got_tab = true;
;               }
;               else
;               {
;                   if (got_tab || (eap.forceit && 1 < num_spaces))
;                   {
                            ;; Retabulate this string of white-space.

                            ;; len is virtual length of white string
;                       int len = num_spaces = vcol - start_vcol;
;                       int num_tabs = 0;
;                       if (!@curbuf.@b_p_et)
;                       {
;                           int temp = new_ts - (start_vcol % new_ts);
;                           if (temp <= num_spaces)
;                           {
;                               num_spaces -= temp;
;                               num_tabs++;
;                           }
;                           num_tabs += num_spaces / new_ts;
;                           num_spaces -= (num_spaces / new_ts) * new_ts;
;                       }
;                       if (@curbuf.@b_p_et || got_tab || (num_spaces + num_tabs < len))
;                       {
;                           if (did_undo == false)
;                           {
;                               did_undo = true;
;                               if (!u_save(lnum - 1, lnum + 1))
;                                   break loop;        ;; out-of-memory ???
;                           }

                                ;; len is actual number of white characters used
;                           len = num_spaces + num_tabs;
;                           int old_len = STRLEN(ptr);
;                           Bytes new_line = new Bytes(old_len - col + start_col + len + 1);

;                           if (0 < start_col)
;                               BCOPY(new_line, ptr, start_col);
;                           BCOPY(new_line, start_col + len, ptr, col, old_len - col + 1);
;                           ptr = new_line.plus(start_col);
;                           for (col = 0; col < len; col++)
;                               ptr.be(col, (col < num_tabs) ? (byte)'\t' : (byte)' ');
;                           ml_replace(lnum, new_line, false);
;                           if (first_line == 0)
;                               first_line = lnum;
;                           last_line = lnum;
;                           ptr = new_line;
;                           col = start_col + len;
;                       }
;                   }
;                   got_tab = false;
;                   num_spaces = 0;
;               }
;               if (ptr.at(col) == NUL)
;                   break;
;               vcol += chartabsize(ptr.plus(col), vcol);
;               col += us_ptr2len_cc(ptr.plus(col));
;           }
;           line_breakcheck();
;       }
;       if (@got_int)
;           emsg(e_interr);

;       if (@curbuf.@b_p_ts != new_ts)
;           redraw_curbuf_later(NOT_VALID);
;       if (first_line != 0)
;           changed_lines(first_line, 0, last_line + 1, 0L);

;       @curwin.w_onebuf_opt.@wo_list = save_list;     ;; restore 'list'

;       @curbuf.@b_p_ts = new_ts;
;       coladvance(@curwin.w_curswant);

;       u_clearline();
    ))

;; :move command - move lines line1-line2 to line dest
;;
;; return false for failure, true otherwise

(defn- #_boolean do_move [#_long line1, #_long line2, #_long dest]
    (§
;       if (line1 <= dest && dest < line2)
;       {
;           emsg(u8("E134: Move lines into themselves"));
;           return false;
;       }

;       long num_lines = line2 - line1 + 1;

        ;; First we copy the old text to its new location.
        ;; Also copy the flag that ":global" command uses.

;       if (!u_save(dest, dest + 1))
;           return false;

;       long l;

;       long extra; ;; num lines added before line1
;       for (extra = 0, l = line1; l <= line2; l++)
;       {
;           Bytes str = STRDUP(ml_get(l + extra));
;           ml_append(dest + l - line1, str, 0, false);
;           if (dest < line1)
;               extra++;
;       }

        ;; Now we must be careful adjusting our marks so that we don't overlap our
        ;; mark_adjust() calls.
        ;;
        ;; We adjust the marks within the old text so that they refer to the last lines
        ;; of the file (temporarily), because we know no other marks will be set there
        ;; since these line numbers did not exist until we added our new lines.
        ;;
        ;; Then we adjust the marks on lines between the old and new text positions
        ;; (either forwards or backwards).
        ;;
        ;; And finally we adjust the marks we put at the end of the file back to
        ;; their final destination at the new text position.

;       long last_line = @curbuf.b_ml.ml_line_count; ;; last line in file after adding new text
;       mark_adjust(line1, line2, last_line - line2, 0L);
;       changed_lines(last_line - num_lines + 1, 0, last_line + 1, num_lines);
;       if (line2 <= dest)
;       {
;           mark_adjust(line2 + 1, dest, -num_lines, 0L);
;           @curbuf.b_op_start.lnum = dest - num_lines + 1;
;           @curbuf.b_op_end.lnum = dest;
;       }
;       else
;       {
;           mark_adjust(dest + 1, line1 - 1, num_lines, 0L);
;           @curbuf.b_op_start.lnum = dest + 1;
;           @curbuf.b_op_end.lnum = dest + num_lines;
;       }
;       @curbuf.b_op_start.col = @curbuf.b_op_end.col = 0;
;       mark_adjust(last_line - num_lines + 1, last_line, -(last_line - dest - extra), 0L);
;       changed_lines(last_line - num_lines + 1, 0, last_line + 1, -extra);

        ;; Now we delete the original text.

;       if (!u_save(line1 + extra - 1, line2 + extra + 1))
;           return false;

;       for (l = line1; l <= line2; l++)
;           ml_delete(line1 + extra, true);

;       if (@global_busy == 0 && @p_report < num_lines)
;       {
;           if (num_lines == 1)
;               msg(u8("1 line moved"));
;           else
;               smsg(u8("%ld lines moved"), num_lines);
;       }

        ;; Leave the cursor on the last of the moved lines.

;       if (line1 <= dest)
;           @curwin.w_cursor.lnum = dest;
;       else
;           @curwin.w_cursor.lnum = dest + (line2 - line1) + 1;

;       if (line1 < dest)
;       {
;           dest += num_lines + 1;
;           last_line = @curbuf.b_ml.ml_line_count;
;           if (dest > last_line + 1)
;               dest = last_line + 1;
;           changed_lines(line1, 0, dest, 0L);
;       }
;       else
;           changed_lines(dest + 1, 0, line1 + num_lines, 0L);

;       return true;
    ))

;; ":copy"

(defn- #_void ex_copy [#_long line1, #_long line2, #_long n]
    (§
;       long count = line2 - line1 + 1;

;       @curbuf.b_op_start.lnum = n + 1;
;       @curbuf.b_op_end.lnum = n + count;
;       @curbuf.b_op_start.col = @curbuf.b_op_end.col = 0;

        ;; there are three situations:
        ;; 1. destination is above line1
        ;; 2. destination is between line1 and line2
        ;; 3. destination is below line2
        ;;
        ;; n = destination (when starting)
        ;; curwin.w_cursor.lnum = destination (while copying)
        ;; line1 = start of source (while copying)
        ;; line2 = end of source (while copying)

;       if (!u_save(n, n + 1))
;           return;

;       @curwin.w_cursor.lnum = n;
;       while (line1 <= line2)
;       {
            ;; need to use STRDUP() because the line will be unlocked within ml_append()
;           Bytes p = STRDUP(ml_get(line1));
;           ml_append(@curwin.w_cursor.lnum, p, 0, false);
            ;; situation 2: skip already copied lines
;           if (line1 == n)
;               line1 = @curwin.w_cursor.lnum;
;           line1++;
;           if (@curwin.w_cursor.lnum < line1)
;               line1++;
;           if (@curwin.w_cursor.lnum < line2)
;               line2++;
;           @curwin.w_cursor.lnum++;
;       }

;       appended_lines_mark(n, count);

;       msgmore(count);
    ))

;; Implementation of ":fixdel", also used by get_stty().
;;  <BS>    resulting <Del>
;;   ^?         ^H
;; not ^?       ^?

(defn- #_void ex_fixdel [#_exarg_C _eap]
    (§
;       Bytes p = find_termcode(u8("kb"));
;       add_termcode(u8("kD"), (p != null && p.at(0) == DEL) ? CTRL_H_STR : DEL_STR, FALSE);
    ))

(defn- #_void print_line_no_prefix [#_long lnum, #_boolean use_number, #_boolean list]
    (§
;       if (@curwin.w_onebuf_opt.@wo_nu || use_number)
;       {
;           Bytes numbuf = new Bytes(30);

;           vim_snprintf(numbuf, numbuf.size(), u8("%*ld "), number_width(@curwin), lnum);
;           msg_puts_attr(numbuf, hl_attr(HLF_N));      ;; Highlight line nrs
;       }
;       msg_prt_line(ml_get(lnum), list);
    ))

;; Print a text line.  Also in silent mode ("ex -s").

(defn- #_void print_line [#_long lnum, #_boolean use_number, #_boolean list]
    (§
;       boolean save_silent = @silent_mode;

;       msg_start();
;       @silent_mode = false;
;       @info_message = true;
;       print_line_no_prefix(lnum, use_number, list);
;       if (save_silent)
;       {
;           msg_putchar('\n');
;           cursor_on();            ;; msg_start() switches it off
;           out_flush();
;           @silent_mode = save_silent;
;       }
;       @info_message = false;
    ))

;; start editing a new file
;;
;;      eap: contains the command to be executed after loading the file and forced 'ff' and 'fenc'
;;  newlnum: if > 0: put cursor on this line number (if possible)
;;           if ECMD_LASTL: use last position in loaded file
;;           if ECMD_LAST: use last position in all files
;;           if ECMD_ONE: use first line
;;    flags:
;;         ECMD_HIDE: if true don't free the current buffer
;;      ECMD_FORCEIT: ! used for Ex command
;;   oldwin: Should be "curwin" when editing a new buffer in the current
;;           window, null when splitting the window first.  When not null info
;;           of the previous buffer for "oldwin" is stored.
;;
;; return false for failure, true otherwise

(defn- #_boolean do_ecmd [#_Bytes _ffname, #_exarg_C eap, #_long newlnum, #_int flags, #_window_C oldwin]
    ;; eap: can be null!
    (§
;       boolean auto_buf = false;   ;; true if autocommands brought us into the buffer unexpectedly

;       buffer_C old_curbuf = @curbuf;
;       long topline = 0;
;       int newcol = -1;
;       int solcol = -1;

;       Bytes command = null;
;       if (eap != null)
;           command = eap.do_ecmd_cmd;

        ;; if the file was changed we may not be allowed to abandon it
        ;; - if we are going to re-edit the same file
        ;; - or if we are the only window on this file and if ECMD_HIDE is false

;       if (@curbuf.b_nwindows == 1 && (flags & ECMD_HIDE) == 0
;           && check_changed(@curbuf, ((flags & ECMD_FORCEIT) != 0 ? CCGD_FORCEIT : 0) | (eap == null ? 0 : CCGD_EXCMD)))
;       {
;           return false;
;       }

        ;; End Visual mode before switching to another buffer,
        ;; so the text can be copied into the GUI selection buffer.

;       reset_VIsual();

        ;; We are starting to edit another file, open a (new) buffer.

;       if (!@cmdmod.keepalt)
;           @curwin.w_alt_fnum = @curbuf.b_fnum;
;       if (oldwin != null)
;           buflist_altfpos(oldwin);

;       buffer_C buf = newBuffer(0L);

        ;; autocommands may change curwin and curbuf
;       if (oldwin != null)
;           oldwin = @curwin;
;       old_curbuf = @curbuf;

;       boolean oldbuf;             ;; true if using existing buffer
;       if (buf.b_ml.ml_mfp == null)            ;; no memfile yet
;       {
;           oldbuf = false;
;       }
;       else                                    ;; existing memfile
;       {
;           oldbuf = true;
;           buf_check_timestamp(buf);
            ;; Check if autocommands made buffer invalid or changed the current buffer.
;           if (!buf_valid(buf) || @curbuf != old_curbuf)
;               return false;
;           if (aborting())                     ;; autocmds may abort script processing
;               return false;
;       }

        ;; May jump to last used line number for a loaded buffer or when asked for explicitly.
;       if ((oldbuf && newlnum == ECMD_LASTL) || newlnum == ECMD_LAST)
;       {
;           pos_C pos = buflist_findfpos(buf);
;           newlnum = pos.lnum;
;           solcol = pos.col;
;       }

        ;; Make the (new) buffer the one used by the current window.
        ;; If the old buffer becomes unused, free it if ECMD_HIDE is false.
        ;; If the current buffer was empty and has no file name, curbuf
        ;; is returned by newBuffer(), nothing to do here.

;       if (buf != @curbuf)
;       {
            ;; Be careful: The autocommands may delete any buffer and
            ;; change the current buffer.
            ;; - If the buffer we are going to edit is deleted, give up.
            ;; - If the current buffer is deleted, prefer to load the new
            ;;   buffer when loading a buffer is required.  This avoids
            ;;   loading another buffer which then must be closed again.
            ;; - If we ended up in the new buffer already, need to skip
            ;;   a few things, set auto_buf.

;           Bytes new_name = null;

;           if (!buf_valid(buf))                ;; new buffer has been deleted
;           {
;               delbuf_msg(new_name);
;               return false;
;           }
;           if (aborting())                     ;; autocmds may abort script processing
;               return false;
;           if (buf == @curbuf)                  ;; already in new buffer
;               auto_buf = true;
;           else
;           {
;               if (@curbuf == old_curbuf)
;                   buf_copy_options(buf, BCO_ENTER);

                ;; close the link to the current buffer
;               u_sync(false);
;               close_buffer(oldwin, @curbuf, (flags & ECMD_HIDE) != 0 ? 0 : DOBUF_UNLOAD, false);

                ;; Autocommands may open a new window and leave oldwin open
                ;; which leads to crashes since the above call sets oldwin.w_buffer to null.
;               if (@curwin != oldwin && oldwin != @aucmd_win && win_valid(oldwin) && oldwin.w_buffer == null)
;                   win_close(oldwin, false);

;               if (aborting())                 ;; autocmds may abort script processing
;                   return false;
                ;; Be careful again, like above.
;               if (!buf_valid(buf))            ;; new buffer has been deleted
;               {
;                   delbuf_msg(new_name);
;                   return false;
;               }
;               if (buf == @curbuf)              ;; already in new buffer
;                   auto_buf = true;
;               else
;               {
;                   @curwin.w_buffer = buf;
;                   @curbuf = buf;
;                   @curbuf.b_nwindows++;

                    ;; Set 'fileformat' and 'binary' when forced.
;                   if (!oldbuf && eap != null)
;                       set_file_options(eap);
;               }

                ;; May get the window options from the last time this buffer was in this
                ;; (or another) window.
                ;; If not used before, reset the local window options to the global values.
                ;; Also restores old folding stuff.
;               get_winopts(@curbuf);
;           }
;       }

;       @curwin.w_pcmark.lnum = 1;
;       @curwin.w_pcmark.col = 0;

;       buffer_C buf = @curbuf;

    ;; If we get here we are sure to start editing

        ;; don't redraw until the cursor is in the right line
;       @redrawingDisabled++;

        ;; Assume success now.
;       boolean retval = true;

        ;; Reset cursor position, could be used by autocommands.

;       check_cursor();

;       if (!auto_buf)
;       {
            ;; Set cursor and init window before reading the file and executing autocommands.
            ;; This allows for the autocommands to position the cursor.

;           curwin_init();

            ;; Careful: open_buffer() and apply_autocmds() may change the current buffer and window.

;           pos_C orig_pos = §_pos_C();
;           COPY_pos(orig_pos, @curwin.w_cursor);
;           topline = @curwin.w_topline;
;           if (!oldbuf)                        ;; need to read the file
;           {
;               @curbuf.b_flags |= BF_CHECK_RO; ;; set/reset 'ro' flag

                ;; Open the buffer and read the file.

;               if (should_abort(open_buffer(false, eap, 0)))
;                   retval = false;
;           }

            ;; If autocommands change the cursor position or topline,
            ;; we should keep it.  Also when it moves within a line.
;           if (!eqpos(@curwin.w_cursor, orig_pos))
;           {
;               newlnum = @curwin.w_cursor.lnum;
;               newcol = @curwin.w_cursor.col;
;           }
;           if (@curwin.w_topline == topline)
;               topline = 0;

            ;; Even when cursor didn't move we need to recompute topline.
;           changed_line_abv_curs();
;       }

;       if (command == null)
;       {
;           if (0 <= newcol)        ;; position set by autocommands
;           {
;               @curwin.w_cursor.lnum = newlnum;
;               @curwin.w_cursor.col = newcol;
;               check_cursor();
;           }
;           else if (0 < newlnum)   ;; line number from caller or old position
;           {
;               @curwin.w_cursor.lnum = newlnum;
;               check_cursor_lnum();
;               if (0 <= solcol && !@p_sol)
;               {
                    ;; 'sol' is off: Use last known column.
;                   @curwin.w_cursor.col = solcol;
;                   check_cursor_col();
;                   @curwin.w_cursor.coladd = 0;
;                   @curwin.w_set_curswant = true;
;               }
;               else
;                   beginline(BL_SOL | BL_FIX);
;           }
;           else                    ;; no line number, go to last line in Ex mode
;           {
;               if (@exmode_active != 0)
;                   @curwin.w_cursor.lnum = @curbuf.b_ml.ml_line_count;
;               beginline(BL_WHITE | BL_FIX);
;           }
;       }

        ;; Check if cursors in other windows on the same buffer are still valid.
;       check_lnums(false);

        ;; Did not read the file, need to show some info about the file.
        ;; Do this after setting the cursor.

;       if (oldbuf && !auto_buf)
;       {
;           boolean msg_scroll_save = @msg_scroll;

            ;; Obey the 'O' flag in 'cpoptions': overwrite any previous file message.
;           if (shortmess(SHM_OVERALL) && !@exiting && @p_verbose == 0)
;               @msg_scroll = false;
;           if (!@msg_scroll)        ;; wait a bit when overwriting an error msg
;               check_for_delay(false);
;           msg_start();
;           @msg_scroll = msg_scroll_save;
;           @msg_scrolled_ign = true;

;           fileinfo(0, false);

;           @msg_scrolled_ign = false;
;       }

;       if (command != null)
;           do_cmdline(command, null, null, DOCMD_VERBOSE);

;       --@redrawingDisabled;
;       if (!@skip_redraw)
;       {
;           long n = @p_so;
;           if (topline == 0 && command == null)
;               @p_so = 999;                 ;; force cursor halfway the window
;           update_topline();
;           @curwin.w_scbind_pos = @curwin.w_topline;
;           @p_so = n;
;           redraw_curbuf_later(NOT_VALID); ;; redraw this buffer later
;       }

;       if (@p_im)
;           @need_start_insertmode = true;

;       return retval;
    ))

(defn- #_void delbuf_msg [#_Bytes name]
    (§
;       emsg2(u8("E143: Autocommands unexpectedly deleted new buffer %s"), (name == null) ? u8("") : name);
    ))

(atom! int append_indent)       ;; autoindent for first line

;; ":insert" and ":append", also used by ":change"

(defn- #_void ex_append [#_exarg_C eap]
    (§
;       boolean did_undo = false;
;       long lnum = eap.line2;
;       int indent = 0;
;       boolean empty = ((@curbuf.b_ml.ml_flags & ML_EMPTY) != 0);

            ;; the ! flag toggles autoindent
;       if (eap.forceit)
;           @curbuf.@b_p_ai = !@curbuf.@b_p_ai;

            ;; First autoindent comes from the line we start on.
;       if (eap.cmdidx != CMD_change && @curbuf.@b_p_ai && 0 < lnum)
;           @append_indent = get_indent_lnum(lnum);

;       if (eap.cmdidx != CMD_append)
;           --lnum;

            ;; when the buffer is empty append to line 0 and delete the dummy line
;       if (empty && lnum == 1)
;           lnum = 0;

;       @State = INSERT;                 ;; behave like in Insert mode

;       for ( ; ; )
;       {
;           @msg_scroll = true;
;           @need_wait_return = false;
;           if (@curbuf.@b_p_ai)
;           {
;               if (0 <= @append_indent)
;               {
;                   indent = @append_indent;
;                   @append_indent = -1;
;               }
;               else if (0 < lnum)
;                   indent = get_indent_lnum(lnum);
;           }
;           @ex_keep_indent = false;
;           Bytes theline;
;           if (eap.getline == null)
;           {
                    ;; No getline() function, use the lines that follow.
                    ;; This ends when there is no more.
;               if (eap.nextcmd == null || eap.nextcmd.at(0) == NUL)
;                   break;
;               Bytes p = vim_strchr(eap.nextcmd, NL);
;               if (p == null)
;                   p = eap.nextcmd.plus(STRLEN(eap.nextcmd));
;               theline = STRNDUP(eap.nextcmd, BDIFF(p, eap.nextcmd));
;               if (p.at(0) != NUL)
;                   p = p.plus(1);
;               eap.nextcmd = p;
;           }
;           else
;           {
;               int save_State = @State;

                    ;; Set State to avoid the cursor shape to be set to INSERT mode when getline() returns.
;               @State = CMDLINE;
;               theline = eap.getline(NUL, eap.cookie, indent);
;               @State = save_State;
;           }
;           @lines_left = (int)@Rows - 1;
;           if (theline == null)
;               break;

                ;; Using ^ CTRL-D in getexmodeline() makes us repeat the indent.
;           if (@ex_keep_indent)
;               @append_indent = indent;

                ;; Look for the "." after automatic indent.
;           int vcol = 0;
;           Bytes p;
;           for (p = theline; vcol < indent; p = p.plus(1))
;           {
;               if (p.at(0) == (byte)' ')
;                   vcol++;
;               else if (p.at(0) == TAB)
;                   vcol += 8 - vcol % 8;
;               else
;                   break;
;           }
;           if ((p.at(0) == (byte)'.' && p.at(1) == NUL) || (!did_undo && !u_save(lnum, lnum + 1 + (empty ? 1 : 0))))
;               break;

                ;; don't use autoindent if nothing was typed.
;           if (p.at(0) == NUL)
;               theline.be(0, NUL);

;           did_undo = true;
;           ml_append(lnum, theline, 0, false);
;           appended_lines_mark(lnum, 1L);

;           lnum++;

;           if (empty)
;           {
;               ml_delete(2L, false);
;               empty = false;
;           }
;       }
;       @State = NORMAL;

;       if (eap.forceit)
;           @curbuf.@b_p_ai = !@curbuf.@b_p_ai;

            ;; "start" is set to eap.line2+1 unless that position is invalid
            ;; (when eap.line2 pointed to the end of the buffer and nothing was appended)
            ;; "end" is set to lnum when something has been appended,
            ;; otherwise it is the same than "start"
;       @curbuf.b_op_start.lnum =
;               (eap.line2 < @curbuf.b_ml.ml_line_count) ? eap.line2 + 1 : @curbuf.b_ml.ml_line_count;
;       if (eap.cmdidx != CMD_append)
;           --@curbuf.b_op_start.lnum;
;       @curbuf.b_op_end.lnum = (eap.line2 < lnum) ? lnum : @curbuf.b_op_start.lnum;
;       @curbuf.b_op_start.col = @curbuf.b_op_end.col = 0;
;       @curwin.w_cursor.lnum = lnum;
;       check_cursor_lnum();
;       beginline(BL_SOL | BL_FIX);

;       @need_wait_return = false;   ;; don't use wait_return() now
;       @ex_no_reprint = true;
    ))

;; ":change"

(defn- #_void ex_change [#_exarg_C eap]
    (§
;       if (eap.line1 <= eap.line2 && !u_save(eap.line1 - 1, eap.line2 + 1))
;           return;

            ;; the ! flag toggles autoindent
;       if (eap.forceit ? !@curbuf.@b_p_ai : @curbuf.@b_p_ai)
;           @append_indent = get_indent_lnum(eap.line1);

;       long lnum;
;       for (lnum = eap.line2; eap.line1 <= lnum; --lnum)
;       {
;           if ((@curbuf.b_ml.ml_flags & ML_EMPTY) != 0) ;; nothing to delete
;               break;
;           ml_delete(eap.line1, false);
;       }

            ;; make sure the cursor is not beyond the end of the file now
;       check_cursor_lnum();
;       deleted_lines_mark(eap.line1, eap.line2 - lnum);

            ;; ":append" on the line above the deleted lines.
;       eap.line2 = eap.line1;
;       ex_append(eap);
    ))

(defn- #_void ex_z [#_exarg_C eap]
    (§
;       long lnum = eap.line2;

            ;; Vi compatible: ":z!" uses display height, without a count uses 'scroll'.
;       int bigness;
;       if (eap.forceit)
;           bigness = @curwin.w_height;
;       else if (@firstwin != @lastwin)
;           bigness = @curwin.w_height - 3;
;       else
;           bigness = (int)@curwin.w_onebuf_opt.@wo_scr * 2;
;       if (bigness < 1)
;           bigness = 1;

;       Bytes x = eap.arg;
;       Bytes kind = x;
;       if (kind.at(0) == (byte)'-' || kind.at(0) == (byte)'+' || kind.at(0) == (byte)'=' || kind.at(0) == (byte)'^' || kind.at(0) == (byte)'.')
;           x = x.plus(1);
;       while (x.at(0) == (byte)'-' || x.at(0) == (byte)'+')
;           x = x.plus(1);

;       if (x.at(0) != 0)
;       {
;           if (!asc_isdigit(x.at(0)))
;           {
;               emsg(u8("E144: non-numeric argument to :z"));
;               return;
;           }
;           else
;           {
;               bigness = libC.atoi(x);
;               @p_window = bigness;
;               if (kind.at(0) == (byte)'=')
;                   bigness += 2;
;           }
;       }

            ;; the number of '-' and '+' multiplies the distance
;       if (kind.at(0) == (byte)'-' || kind.at(0) == (byte)'+')
;           for (x = kind.plus(1); x.at(0) == kind.at(0); x = x.plus(1))
                ;

;       long start, end, curs;
;       boolean minus = false;

;       switch (kind.at(0))
;       {
;           case '-':
;               start = lnum - bigness * BDIFF(x, kind) + 1;
;               end = start + bigness - 1;
;               curs = end;
;               break;

;           case '=':
;               start = lnum - (bigness + 1) / 2 + 1;
;               end = lnum + (bigness + 1) / 2 - 1;
;               curs = lnum;
;               minus = true;
;               break;

;           case '^':
;               start = lnum - bigness * 2;
;               end = lnum - bigness;
;               curs = lnum - bigness;
;               break;

;           case '.':
;               start = lnum - (bigness + 1) / 2 + 1;
;               end = lnum + (bigness + 1) / 2 - 1;
;               curs = end;
;               break;

;           default: ;; '+'
;               start = lnum;
;               if (kind.at(0) == (byte)'+')
;                   start += bigness * (BDIFF(x, kind) - 1) + 1;
;               else if (eap.addr_count == 0)
;                   start++;
;               end = start + bigness - 1;
;               curs = end;
;               break;
;       }

;       if (start < 1)
;           start = 1;

;       if (end > @curbuf.b_ml.ml_line_count)
;           end = @curbuf.b_ml.ml_line_count;

;       if (curs > @curbuf.b_ml.ml_line_count)
;           curs = @curbuf.b_ml.ml_line_count;

;       for (long i = start; i <= end; i++)
;       {
;           if (minus && i == lnum)
;           {
;               msg_putchar('\n');

;               for (int j = 1; j < (int)@Columns; j++)
;                   msg_putchar('-');
;           }

;           print_line(i, (eap.flags & EXFLAG_NR) != 0, (eap.flags & EXFLAG_LIST) != 0);

;           if (minus && i == lnum)
;           {
;               msg_putchar('\n');

;               for (int j = 1; j < (int)@Columns; j++)
;                   msg_putchar('-');
;           }
;       }

;       @curwin.w_cursor.lnum = curs;
;       @ex_no_reprint = true;
    ))

;; Check if the restricted flag is set.
;; If so, give an error message and return true.
;; Otherwise, return false.

(defn- #_boolean check_restricted []
    (§
;       if (@restricted)
;       {
;           emsg(u8("E145: Shell commands not allowed in rvim"));
;           return true;
;       }
;       return false;
    ))

;; Check if the secure flag is set (.exrc or .vimrc in current directory).
;; If so, give an error message and return true.
;; Otherwise, return false.

(defn- #_boolean check_secure []
    (§
;       if (@secure != 0)
;       {
;           @secure = 2;
;           emsg(e_curdir);
;           return true;
;       }

        ;; In the sandbox more things are not allowed, including the things
        ;; disallowed in secure mode.

;       if (@sandbox != 0)
;       {
;           emsg(e_sandbox);
;           return true;
;       }
;       return false;
    ))

(atom! Bytes old_sub)              ;; previous substitute pattern
(atom! boolean global_need_beginline)   ;; call beginline() after ":g"

(atom! boolean do__all)                 ;; do multiple substitutions per line
(atom! boolean do__ask)                 ;; ask for confirmation
(atom! boolean do__count)               ;; count only
(atom! boolean do__error true)        ;; if false, ignore errors
(atom! boolean do__print)               ;; print last line with subs.
(atom! boolean do__list)                ;; list last line with subs.
(atom! boolean do__number)              ;; list last line with line nr
(atom! int do__ic)                      ;; ignore case flag

;; Perform a substitution from line eap.line1 to line eap.line2 using
;; the command pointed to by eap.arg which should be of the form:
;;
;; /pattern/substitution/{flags}
;;
;; The usual escapes are supported as described in the regexp docs.

(defn- #_void ex_sub [#_exarg_C eap]
    (§
;       long i = 0;

;       Bytes pat = null, sub = null;
;       boolean got_quit = false;
;       boolean got_match = false;
;       long first_line = 0;                        ;; first changed line
;       long last_line= 0;                          ;; below last changed line AFTER the change
;       long old_line_count = @curbuf.b_ml.ml_line_count;
;       boolean endcolumn = false;                  ;; cursor in last column when done
;       pos_C old_cursor = §_pos_C();
;       COPY_pos(old_cursor, @curwin.w_cursor);
;       boolean save_ma = false;

;       Bytes cmd = eap.arg;
;       if (@global_busy == 0)
;       {
;           @sub_nsubs = 0;
;           @sub_nlines = 0;
;       }
;       long start_nsubs = @sub_nsubs;

;       int which_pat;
;       if (eap.cmdidx == CMD_tilde)
;           which_pat = RE_LAST;            ;; use last used regexp
;       else
;           which_pat = RE_SUBST;           ;; use last substitute regexp

                                                ;; new pattern and substitution
;       if (eap.cmd.at(0) == (byte)'s' && cmd.at(0) != NUL && !vim_iswhite(cmd.at(0))
;                   && vim_strbyte(u8("0123456789cegriIp|\""), cmd.at(0)) == null)
;       {
                                                ;; don't accept alphanumeric for separator
;           if (asc_isalpha(cmd.at(0)))
;           {
;               emsg(u8("E146: Regular expressions can't be delimited by letters"));
;               return;
;           }

;           byte delimiter;

                ;; undocumented vi feature:
                ;;  "\/sub/" and "\?sub?" use last used search pattern (almost like
                ;;  //sub/r).  "\&sub&" use last substitute pattern (like //sub/).

;           if (cmd.at(0) == (byte)'\\')
;           {
;               cmd = cmd.plus(1);
;               if (vim_strbyte(u8("/?&"), cmd.at(0)) == null)
;               {
;                   emsg(e_backslash);
;                   return;
;               }
;               if (cmd.at(0) != (byte)'&')
;                   which_pat = RE_SEARCH;      ;; use last '/' pattern
;               pat = u8("");                       ;; empty search pattern
;               delimiter = (cmd = cmd.plus(1)).at(-1);             ;; remember delimiter character
;           }
;           else            ;; find the end of the regexp
;           {
;               which_pat = RE_LAST;            ;; use last used regexp
;               delimiter = (cmd = cmd.plus(1)).at(-1);             ;; remember delimiter character
;               pat = cmd;                      ;; remember start of search pattern
;               { Bytes[] __ = { eap.arg }; cmd = skip_regexp(cmd, delimiter, @p_magic, __); eap.arg = __[0]; }
;               if (cmd.at(0) == delimiter)        ;; end delimiter found
;                   (cmd = cmd.plus(1)).be(-1, NUL);               ;; replace it with a NUL
;           }

                ;; Small incompatibility: vi sees '\n' as end of the command, but in
                ;; Vim we want to use '\n' to find/substitute a NUL.

;           sub = cmd;          ;; remember the start of the substitution

;           while (cmd.at(0) != NUL)
;           {
;               if (cmd.at(0) == delimiter)            ;; end delimiter found
;               {
;                   (cmd = cmd.plus(1)).be(-1, NUL);                   ;; replace it with a NUL
;                   break;
;               }
;               if (cmd.at(0) == (byte)'\\' && cmd.at(1) != 0)  ;; skip escaped characters
;                   cmd = cmd.plus(1);
;               cmd = cmd.plus(us_ptr2len_cc(cmd));
;           }

;           if (!eap.skip)
;           {
                    ;; In POSIX vi ":s/pat/%/" uses the previous subst. string.
;               if (STRCMP(sub, u8("%")) == 0 && vim_strbyte(@p_cpo, CPO_SUBPERCENT) != null)
;               {
;                   if (@old_sub == null)    ;; there is no previous command
;                   {
;                       emsg(e_nopresub);
;                       return;
;                   }
;                   sub = @old_sub;
;               }
;               else
;               {
;                   @old_sub = STRDUP(sub);
;               }
;           }
;       }
;       else if (!eap.skip)         ;; use previous pattern and substitution
;       {
;           if (@old_sub == null)    ;; there is no previous command
;           {
;               emsg(e_nopresub);
;               return;
;           }
;           pat = null;             ;; search_regcomp() will use previous pattern
;           sub = @old_sub;

                ;; Vi compatibility quirk:
                ;; repeating with ":s" keeps the cursor in the last column after using "$".
;           endcolumn = (@curwin.w_curswant == MAXCOL);
;       }

            ;; Recognize ":%s/\n//" and turn it into a join command, which is much more efficient.
            ;; TODO: find a generic solution to make line-joining operations more
            ;; efficient, avoid allocating a string that grows in size.

;       if (pat != null && STRCMP(pat, u8("\\n")) == 0 && sub.at(0) == NUL && (cmd.at(0) == NUL
;               || (cmd.at(1) == NUL
;                       && (cmd.at(0) == (byte)'g' || cmd.at(0) == (byte)'l' || cmd.at(0) == (byte)'p' || cmd.at(0) == (byte)'#'))))
;       {
;           @curwin.w_cursor.lnum = eap.line1;
;           if (cmd.at(0) == (byte)'l')
;               eap.flags = EXFLAG_LIST;
;           else if (cmd.at(0) == (byte)'#')
;               eap.flags = EXFLAG_NR;
;           else if (cmd.at(0) == (byte)'p')
;               eap.flags = EXFLAG_PRINT;

                ;; The number of lines joined is the number of lines in the range plus one.
                ;; One less when the last line is included.
;           int joined_lines_count = (int)(eap.line2 - eap.line1 + 1);
;           if (eap.line2 < @curbuf.b_ml.ml_line_count)
;               joined_lines_count++;
;           if (1 < joined_lines_count)
;           {
;               do_join(joined_lines_count, false, true, false, true);
;               @sub_nsubs = joined_lines_count - 1;
;               @sub_nlines = 1;
;               do_sub_msg(false);
;               ex_may_print(eap);
;           }

;           if (!@cmdmod.keeppatterns)
;               save_re_pat(RE_SUBST, pat, @p_magic);
                ;; put pattern in history
;           add_to_history(HIST_SEARCH, pat, true, NUL);

;           return;
;       }

            ;; Find trailing options.  When '&' is used, keep old options.

;       if (cmd.at(0) == (byte)'&')
;           cmd = cmd.plus(1);
;       else
;       {
;           @do__all = @p_gd;         ;; default is global on
;           @do__ask = false;
;           @do__error = true;
;           @do__print = false;
;           @do__count = false;
;           @do__number = false;
;           @do__ic = 0;
;       }
;       while (cmd.at(0) != NUL)
;       {
                ;; Note that 'g' and 'c' are always inverted.
                ;; 'r' is never inverted.

;           if (cmd.at(0) == (byte)'g')
;               @do__all = !@do__all;
;           else if (cmd.at(0) == (byte)'c')
;               @do__ask = !@do__ask;
;           else if (cmd.at(0) == (byte)'n')
;               @do__count = true;
;           else if (cmd.at(0) == (byte)'e')
;               @do__error = !@do__error;
;           else if (cmd.at(0) == (byte)'r')       ;; use last used regexp
;               which_pat = RE_LAST;
;           else if (cmd.at(0) == (byte)'p')
;               @do__print = true;
;           else if (cmd.at(0) == (byte)'#')
;           {
;               @do__print = true;
;               @do__number = true;
;           }
;           else if (cmd.at(0) == (byte)'l')
;           {
;               @do__print = true;
;               @do__list = true;
;           }
;           else if (cmd.at(0) == (byte)'i')       ;; ignore case
;               @do__ic = 'i';
;           else if (cmd.at(0) == (byte)'I')       ;; don't ignore case
;               @do__ic = 'I';
;           else
;               break;
;           cmd = cmd.plus(1);
;       }
;       if (@do__count)
;           @do__ask = false;

            ;; check for a trailing count

;       cmd = skipwhite(cmd);
;       if (asc_isdigit(cmd.at(0)))
;       {
;           { Bytes[] __ = { cmd }; i = getdigits(__); cmd = __[0]; }
;           if (i <= 0 && !eap.skip && @do__error)
;           {
;               emsg(e_zerocount);
;               return;
;           }
;           eap.line1 = eap.line2;
;           eap.line2 += i - 1;
;           if (eap.line2 > @curbuf.b_ml.ml_line_count)
;               eap.line2 = @curbuf.b_ml.ml_line_count;
;       }

            ;; check for trailing command or garbage

;       cmd = skipwhite(cmd);
;       if (cmd.at(0) != NUL && cmd.at(0) != (byte)'"')        ;; if not end-of-line or comment
;       {
;           eap.nextcmd = check_nextcmd(cmd);
;           if (eap.nextcmd == null)
;           {
;               emsg(e_trailing);
;               return;
;           }
;       }

;       if (eap.skip)       ;; not executing commands, only parsing
;           return;

;       if (!@do__count && !@curbuf.@b_p_ma)
;       {
                ;; Substitution is not allowed in non-'modifiable' buffer.
;           emsg(e_modifiable);
;           return;
;       }

;       regmmatch_C regmatch = §_regmmatch_C();
;       if (search_regcomp(pat, RE_SUBST, which_pat, SEARCH_HIS, regmatch) == false)
;       {
;           if (@do__error)
;               emsg(e_invcmd);
;           return;
;       }

            ;; the 'i' or 'I' flag overrules 'ignorecase' and 'smartcase'
;       if (@do__ic == 'i')
;           regmatch.rmm_ic = true;
;       else if (@do__ic == 'I')
;           regmatch.rmm_ic = false;

;       Bytes sub_firstline = null;        ;; allocated copy of first sub line

            ;; ~ in the substitute pattern is replaced with the old pattern.
            ;; We do it here once to avoid it to be replaced over and over again.
            ;; But don't do it when it starts with "\=", then it's an expression.

;       if (!(sub.at(0) == (byte)'\\' && sub.at(1) == (byte)'='))
;           sub = regtilde(sub, @p_magic);

            ;; Check for a match on each line.

;       long line2 = eap.line2;
;       for (long lnum = eap.line1; lnum <= line2 && !(got_quit || aborting()); lnum++)
;       {
;           long nmatch = vim_regexec_multi(regmatch, @curwin, @curbuf, lnum, 0, null);
;           if (nmatch != 0)                        ;; number of lines in match
;           {
                    ;; The new text is build up step by step, to avoid too much copying.
                    ;; There are these pieces:
                    ;;
                    ;; sub_firstline    The old text, unmodified.
                    ;; copycol          Column in the old text where we started looking for a match;
                    ;;                  from here old text still needs to be copied to the new text.
                    ;; matchcol         Column number of the old text where to look for the next match.
                    ;;                  It's just after the previous match or one further.
                    ;; prev_matchcol    Column just after the previous match (if any).
                    ;;                  Mostly equal to matchcol, except for the first
                    ;;                  match and after skipping an empty match.
                    ;; regmatch.*pos    Where the pattern matched in the old text.
                    ;; new_start        The new text, all that has been produced so far.
                    ;; new_end          The new text, where to append new text.
                    ;;
                    ;; lnum             The line number where we found the start of the match.
                    ;;                  Can be below the line we searched when there is a \n
                    ;;                  before a \zs in the pattern.
                    ;; sub_firstlnum    The line number in the buffer where to look for a match.
                    ;;                  Can be different from "lnum" when the pattern or substitute
                    ;;                  string contains line breaks.
                    ;;
                    ;; Special situations:
                    ;; - When the substitute string contains a line break, the part up to the line
                    ;;   break is inserted in the text, but the copy of the original line is kept.
                    ;;   "sub_firstlnum" is adjusted for the inserted lines.
                    ;; - When the matched pattern contains a line break, the old line is taken from
                    ;;   the line at the end of the pattern.  The lines in the match are deleted
                    ;;   later, "sub_firstlnum" is adjusted accordingly.
                    ;;
                    ;; The new text is built up in new_start[].  It has some extra room to avoid
                    ;; using calloc()/free() too often.  new_start_len is the length of the allocated
                    ;; memory at new_start.
                    ;;
                    ;; Make a copy of the old line, so it won't be taken away when updating the screen
                    ;; or handling a multi-line match.  The "old_" pointers point into this copy.

;               int prev_matchcol = MAXCOL;
;               Bytes new_start = null;
;               int new_start_len = 0;
;               boolean did_sub = false;
;               long nmatch_tl = 0;                     ;; nr of lines matched below lnum
;               boolean skip_match = false;

;               long sub_firstlnum = lnum;              ;; nr of first sub line
;               int copycol = 0;
;               int matchcol = 0;

                    ;; At first match, remember current cursor position.
;               if (!got_match)
;               {
;                   setpcmark();
;                   got_match = true;
;               }

                    ;; Loop until nothing more to replace in this line.
                    ;; 1. Handle match with empty string.
                    ;; 2. If do__ask is set, ask for confirmation.
                    ;; 3. Substitute the string.
                    ;; 4. If do__all is set, find next match.
                    ;; 5. Break if there isn't another match in this line.

;               for ( ; ; )
;               {
                        ;; Advance "lnum" to the line where the match starts.
                        ;; The match does not start in the first line when there is a line break before \zs.
;                   if (0 < regmatch.startpos[0].lnum)
;                   {
;                       lnum += regmatch.startpos[0].lnum;
;                       sub_firstlnum += regmatch.startpos[0].lnum;
;                       nmatch -= regmatch.startpos[0].lnum;
;                       sub_firstline = null;
;                   }

;                   if (sub_firstline == null)
;                       sub_firstline = STRDUP(ml_get(sub_firstlnum));

                        ;; Save the line number of the last change for the final cursor position (just like Vi).
;                   @curwin.w_cursor.lnum = lnum;
;                   boolean do_again = false;               ;; do it again after joining lines

;                   skip:
;                   {
                            ;; 1. Match empty string does not count, except for first match.
                            ;; This reproduces the strange vi behaviour.
                            ;; This also catches endless loops.

;                       if (matchcol == prev_matchcol
;                                   && regmatch.endpos[0].lnum == 0 && matchcol == regmatch.endpos[0].col)
;                       {
;                           if (sub_firstline.at(matchcol) == NUL)
                                    ;; We already were at the end of the line.
                                    ;; Don't look for a match in this line again.
;                               skip_match = true;
;                           else
;                           {
                                    ;; search for a match at next column
;                               matchcol += us_ptr2len_cc(sub_firstline.plus(matchcol));
;                           }
;                           break skip;
;                       }

                            ;; Normally we continue searching for a match just after the previous match.
;                       matchcol = regmatch.endpos[0].col;
;                       prev_matchcol = matchcol;

                            ;; 2. If do__count is set only increase the counter.
                            ;;    If do__ask is set, ask for confirmation.

;                       if (@do__count)
;                       {
                                ;; For a multi-line match, put matchcol at the NUL at
                                ;; the end of the line and set nmatch to one, so that
                                ;; we continue looking for a match on the next line.
                                ;; Avoids that ":s/\nB\@=//gc" get stuck.
;                           if (1 < nmatch)
;                           {
;                               matchcol = STRLEN(sub_firstline);
;                               nmatch = 1;
;                               skip_match = true;
;                           }
;                           @sub_nsubs++;
;                           did_sub = true;
                                ;; Skip the substitution, unless an expression is used,
                                ;; then it is evaluated in the sandbox.
;                           if (!(sub.at(0) == (byte)'\\' && sub.at(1) == (byte)'='))
;                               break skip;
;                       }

;                       if (@do__ask)
;                       {
;                           int typed = 0;

                                ;; change State to CONFIRM, so that the mouse works properly
;                           int save_State = @State;
;                           @State = CONFIRM;
;                           setmouse();         ;; disable mouse in xterm
;                           @curwin.w_cursor.col = regmatch.startpos[0].col;

                                ;; When 'cpoptions' contains "u" don't sync undo when asking for confirmation.
;                           if (vim_strbyte(@p_cpo, CPO_UNDO) != null)
;                               @no_u_sync++;

                                ;; Loop until 'y', 'n', 'q', CTRL-E or CTRL-Y typed.

;                           while (@do__ask)
;                           {
;                               if (@exmode_active != 0)
;                               {
;                                   int[] sc = new int[1];
;                                   int[] ec = new int[1];

;                                   print_line_no_prefix(lnum, @do__number, @do__list);

;                                   getvcol(@curwin, @curwin.w_cursor, sc, null, null);
;                                   @curwin.w_cursor.col = regmatch.endpos[0].col - 1;
;                                   getvcol(@curwin, @curwin.w_cursor, null, null, ec);
;                                   if (@do__number || @curwin.w_onebuf_opt.@wo_nu)
;                                   {
;                                       int numw = number_width(@curwin) + 1;
;                                       sc[0] += numw;
;                                       ec[0] += numw;
;                                   }
;                                   msg_start();
;                                   for (i = 0; i < (long)sc[0]; i++)
;                                       msg_putchar(' ');
;                                   for ( ; i <= (long)ec[0]; i++)
;                                       msg_putchar('^');

;                                   Bytes resp = getexmodeline('?', null, 0);
;                                   if (resp != null)
;                                       typed = resp.at(0);
;                               }
;                               else
;                               {
;                                   Bytes orig_line = null;
;                                   int len_change = 0;

                                        ;; Invert the matched string.  Remove the inversion afterwards.
;                                   int temp = @redrawingDisabled;
;                                   @redrawingDisabled = 0;

;                                   if (new_start != null)
;                                   {
                                            ;; There already was a substitution, we would like to show this
                                            ;; to the user.
                                            ;; We cannot really update the line, it would change what matches.
                                            ;; Temporarily replace the line and change it back afterwards.
;                                       orig_line = STRDUP(ml_get(lnum));

;                                       Bytes new_line = concat_str(new_start, sub_firstline.plus(copycol));

                                            ;; Position the cursor relative to the end of the line,
                                            ;; the previous substitute may have inserted or deleted
                                            ;; characters before the cursor.
;                                       len_change = STRLEN(new_line) - STRLEN(orig_line);
;                                       @curwin.w_cursor.col += len_change;
;                                       ml_replace(lnum, new_line, false);
;                                   }

;                                   @search_match_lines = regmatch.endpos[0].lnum - regmatch.startpos[0].lnum;
;                                   @search_match_endcol = regmatch.endpos[0].col + len_change;
;                                   @highlight_match = true;

;                                   update_topline();
;                                   validate_cursor();
;                                   update_screen(SOME_VALID);
;                                   @highlight_match = false;
;                                   redraw_later(SOME_VALID);

;                                   if (@msg_row == (int)@Rows - 1)
;                                       @msg_didout = false;         ;; avoid a scroll-up
;                                   msg_starthere();
;                                   boolean b = @msg_scroll;
;                                   @msg_scroll = false;             ;; truncate msg when needed
;                                   @msg_no_more = true;
                                        ;; write message same highlighting as for wait_return
;                                   smsg_attr(hl_attr(HLF_R), u8("replace with %s (y/n/a/q/l/^E/^Y)?"), sub);
;                                   @msg_no_more = false;
;                                   @msg_scroll = b;
;                                   showruler(true);
;                                   windgoto(@msg_row, @msg_col);
;                                   @redrawingDisabled = temp;

;                                   @no_mapping++;                   ;; don't map this key
;                                   @allow_keys++;                   ;; allow special keys
;                                   typed = plain_vgetc();
;                                   --@allow_keys;
;                                   --@no_mapping;

                                        ;; clear the question
;                                   @msg_didout = false;             ;; don't scroll up
;                                   @msg_col = 0;
;                                   gotocmdline(true);

                                        ;; restore the line
;                                   if (orig_line != null)
;                                       ml_replace(lnum, orig_line, false);
;                               }

;                               @need_wait_return = false;           ;; no hit-return prompt
;                               if (typed == 'q' || typed == ESC || typed == Ctrl_C || typed == @intr_char)
;                               {
;                                   got_quit = true;
;                                   break;
;                               }
;                               if (typed == 'n')
;                                   break;
;                               if (typed == 'y')
;                                   break;
;                               if (typed == 'l')
;                               {
                                        ;; last: replace and then stop
;                                   @do__all = false;
;                                   line2 = lnum;
;                                   break;
;                               }
;                               if (typed == 'a')
;                               {
;                                   @do__ask = false;
;                                   break;
;                               }
;                           }
;                           @State = save_State;
;                           setmouse();
;                           if (vim_strbyte(@p_cpo, CPO_UNDO) != null)
;                               --@no_u_sync;

;                           if (typed == 'n')
;                           {
                                    ;; For a multi-line match, put matchcol at the NUL at the end of the line and
                                    ;; set nmatch to one, so that we continue looking for a match on the next line.
                                    ;; Avoids that ":%s/\nB\@=//gc" and ":%s/\n/,\r/gc" get stuck when pressing 'n'.

;                               if (1 < nmatch)
;                               {
;                                   matchcol = STRLEN(sub_firstline);
;                                   skip_match = true;
;                               }
;                               break skip;
;                           }
;                           if (got_quit)
;                               break skip;
;                       }

                            ;; Move the cursor to the start of the match, so that we can use "\=col(".").
;                       @curwin.w_cursor.col = regmatch.startpos[0].col;

                            ;; 3. substitute the string.

;                       if (@do__count)
;                       {
                                ;; prevent accidentally changing the buffer by a function
;                           save_ma = @curbuf.@b_p_ma;
;                           @curbuf.@b_p_ma = false;
;                           @sandbox++;
;                       }
                            ;; get length of substitution part
;                       int sublen = vim_regsub_multi(regmatch,
;                                           sub_firstlnum - regmatch.startpos[0].lnum,
;                                           sub, sub_firstline, false, @p_magic, true);
;                       if (@do__count)
;                       {
;                           @curbuf.@b_p_ma = save_ma;
;                           @sandbox--;
;                           break skip;
;                       }

                            ;; When the match included the "$" of the last line it may
                            ;; go beyond the last line of the buffer.
;                       if (nmatch > @curbuf.b_ml.ml_line_count - sub_firstlnum + 1)
;                       {
;                           nmatch = @curbuf.b_ml.ml_line_count - sub_firstlnum + 1;
;                           skip_match = true;
;                       }

                            ;; Need room for:
                            ;; - result so far in "new_start" (not for first sub in line)
                            ;; - original text up to match
                            ;; - length of substituted part
                            ;; - original text after match

;                       Bytes p1;
;                       if (nmatch == 1)
;                           p1 = sub_firstline;
;                       else
;                       {
;                           p1 = ml_get(sub_firstlnum + nmatch - 1);
;                           nmatch_tl += nmatch - 1;
;                       }
;                       int copy_len = regmatch.startpos[0].col - copycol;
;                       int needed_len = copy_len + (STRLEN(p1) - regmatch.endpos[0].col) + sublen + 1;
;                       Bytes new_end;
;                       if (new_start == null)
;                       {
                                ;; Get some space for a temporary buffer to do the substitution into
                                ;; (and some extra space to avoid too many calls to calloc()/free()).

;                           new_start_len = needed_len + 50;
;                           new_start = new Bytes(new_start_len);
;                           new_start.be(0, NUL);
;                           new_end = new_start;
;                       }
;                       else
;                       {
                                ;; Check if the temporary buffer is long enough to do the
                                ;; substitution into.  If not, make it larger (with a bit
                                ;; extra to avoid too many calls to calloc()/free()).

;                           int len = STRLEN(new_start);
;                           needed_len += len;
;                           if (new_start_len < needed_len)
;                           {
;                               new_start_len = needed_len + 50;
;                               p1 = new Bytes(new_start_len);
;                               BCOPY(p1, new_start, len + 1);
;                               new_start = p1;
;                           }
;                           new_end = new_start.plus(len);
;                       }

                            ;; copy the text up to the part that matched

;                       BCOPY(new_end, 0, sub_firstline, copycol, copy_len);
;                       new_end = new_end.plus(copy_len);

;                       vim_regsub_multi(regmatch, sub_firstlnum - regmatch.startpos[0].lnum,
;                                               sub, new_end, true, @p_magic, true);
;                       @sub_nsubs++;
;                       did_sub = true;

                            ;; Move the cursor to the start of the line, to avoid that
                            ;; it is beyond the end of the line after the substitution.
;                       @curwin.w_cursor.col = 0;

                            ;; For a multi-line match, make a copy of the last matched
                            ;; line and continue in that one.
;                       if (1 < nmatch)
;                       {
;                           sub_firstlnum += nmatch - 1;
;                           sub_firstline = STRDUP(ml_get(sub_firstlnum));
                                ;; When going beyond the last line, stop substituting.
;                           if (sub_firstlnum <= line2)
;                               do_again = true;
;                           else
;                               @do__all = false;
;                       }

                            ;; Remember next character to be copied.
;                       copycol = regmatch.endpos[0].col;

;                       if (skip_match)
;                       {
                                ;; Already hit end of the buffer,
                                ;; sub_firstlnum is one less than what it ought to be.
;                           sub_firstline = STRDUP(u8(""));
;                           copycol = 0;
;                       }

                            ;; Now the trick is to replace CTRL-M chars with a real line break.
                            ;; This would make it impossible to insert a CTRL-M in the text.
                            ;; The line break can be avoided by preceding the CTRL-M with a backslash.
                            ;; To be able to insert a backslash, they must be doubled in the string
                            ;; and are halved here.
                            ;; That is Vi compatible.

;                       for (p1 = new_end; p1.at(0) != NUL; p1 = p1.plus(1))
;                       {
;                           if (p1.at(0) == (byte)'\\' && p1.at(1) != NUL)  ;; remove backslash
;                               BCOPY(p1, 0, p1, 1, STRLEN(p1, 1) + 1);
;                           else if (p1.at(0) == CAR)
;                           {
;                               if (u_inssub(lnum) == true)     ;; prepare for undo
;                               {
;                                   p1.be(0, NUL);                  ;; truncate up to the CR
;                                   ml_append(lnum - 1, new_start, BDIFF(p1, new_start) + 1, false);
;                                   mark_adjust(lnum + 1, MAXLNUM, 1L, 0L);
;                                   if (@do__ask)
;                                       appended_lines(lnum - 1, 1L);
;                                   else
;                                   {
;                                       if (first_line == 0)
;                                           first_line = lnum;
;                                       last_line = lnum + 1;
;                                   }
                                        ;; All line numbers increase.
;                                   sub_firstlnum++;
;                                   lnum++;
;                                   line2++;
                                        ;; move the cursor to the new line, like Vi
;                                   @curwin.w_cursor.lnum++;
                                        ;; copy the rest
;                                   BCOPY(new_start, 0, p1, 1, STRLEN(p1, 1) + 1);
;                                   p1 = new_start.minus(1);
;                               }
;                           }
;                           else
;                               p1 = p1.plus(us_ptr2len_cc(p1) - 1);
;                       }
;                   }

                        ;; 4. If do__all is set, find next match.
                        ;; Prevent endless loop with patterns that match empty
                        ;; strings, e.g. :s/$/pat/g or :s/[a-z]* /(&)/g.
                        ;; But ":s/\n/#/" is OK.

                        ;; We already know that we did the last subst when we are at the end of the line,
                        ;; except that a pattern like "bar\|\nfoo" may match at the NUL.
                        ;; "lnum" can be below "line2" when there is a \zs in the pattern after a line break.

;                   boolean lastone = (skip_match
;                                   || @got_int
;                                   || got_quit
;                                   || line2 < lnum
;                                   || !(@do__all || do_again)
;                                   || (sub_firstline.at(matchcol) == NUL && nmatch <= 1
;                                           && !re_multiline(regmatch.regprog)));
;                   nmatch = -1;

                        ;; Replace the line in the buffer when needed.
                        ;; This is skipped when there are more matches.
                        ;; The check for nmatch_tl is needed for when multi-line matching must replace
                        ;; the lines before trying to do another match, otherwise "\@<=" won't work.
                        ;; When the match starts below where we start searching
                        ;; also need to replace the line first (using \zs after \n).

;                   if (lastone
;                       || 0 < nmatch_tl
;                       || (nmatch = vim_regexec_multi(regmatch, @curwin, @curbuf, sub_firstlnum, matchcol, null)) == 0
;                       || 0 < regmatch.startpos[0].lnum)
;                   {
;                       if (new_start != null)
;                       {
                                ;; Copy the rest of the line, that didn't match.
                                ;; "matchcol" has to be adjusted, we use the end of the line as reference,
                                ;; because the substitute may have changed the number of characters.
                                ;; Same for "prev_matchcol".

;                           STRCAT(new_start, sub_firstline.plus(copycol));
;                           matchcol = STRLEN(sub_firstline) - matchcol;
;                           prev_matchcol = STRLEN(sub_firstline) - prev_matchcol;

;                           if (u_savesub(lnum) != true)
;                               break;
;                           ml_replace(lnum, new_start, true);

;                           if (0 < nmatch_tl)
;                           {
                                    ;; Matched lines have now been substituted and are useless, delete them.
                                    ;; The part after the match has been appended to "new_start", we don't need
                                    ;; it in the buffer.

;                               lnum++;
;                               if (u_savedel(lnum, nmatch_tl) != true)
;                                   break;
;                               for (i = 0; i < nmatch_tl; i++)
;                                   ml_delete(lnum, false);
;                               mark_adjust(lnum, lnum + nmatch_tl - 1, MAXLNUM, -nmatch_tl);
;                               if (@do__ask)
;                                   deleted_lines(lnum, nmatch_tl);
;                               --lnum;
;                               line2 -= nmatch_tl; ;; nr of lines decreases
;                               nmatch_tl = 0;
;                           }

                                ;; When asking, undo is saved each time, must also set changed flag each time.
;                           if (@do__ask)
;                               changed_bytes(lnum, 0);
;                           else
;                           {
;                               if (first_line == 0)
;                                   first_line = lnum;
;                               last_line = lnum + 1;
;                           }

;                           sub_firstlnum = lnum;
;                           sub_firstline = new_start;
;                           new_start = null;
;                           matchcol = STRLEN(sub_firstline) - matchcol;
;                           prev_matchcol = STRLEN(sub_firstline) - prev_matchcol;
;                           copycol = 0;
;                       }
;                       if (nmatch == -1 && !lastone)
;                           nmatch = vim_regexec_multi(regmatch, @curwin, @curbuf, sub_firstlnum, matchcol, null);

                            ;; 5. break if there isn't another match in this line

;                       if (nmatch <= 0)
;                       {
                                ;; If the match found didn't start where we were
                                ;; searching, do the next search in the line where we
                                ;; found the match.
;                           if (nmatch == -1)
;                               lnum -= regmatch.startpos[0].lnum;
;                           break;
;                       }
;                   }

;                   line_breakcheck();
;               }

;               if (did_sub)
;                   @sub_nlines++;
;               sub_firstline = null;
;           }

;           line_breakcheck();
;       }

;       if (first_line != 0)
;       {
                ;; Need to subtract the number of added lines from "last_line" to get
                ;; the line number before the change (same as adding the number of deleted lines).

;           i = @curbuf.b_ml.ml_line_count - old_line_count;
;           changed_lines(first_line, 0, last_line - i, i);
;       }

            ;; ":s/pat//n" doesn't move the cursor
;       if (@do__count)
;           COPY_pos(@curwin.w_cursor, old_cursor);

;       if (start_nsubs < @sub_nsubs)
;       {
                ;; Set the '[ and '] marks.
;           @curbuf.b_op_start.lnum = eap.line1;
;           @curbuf.b_op_end.lnum = line2;
;           @curbuf.b_op_start.col = @curbuf.b_op_end.col = 0;

;           if (@global_busy == 0)
;           {
;               if (!@do__ask)       ;; when interactive leave cursor on the match
;               {
;                   if (endcolumn)
;                       coladvance(MAXCOL);
;                   else
;                       beginline(BL_WHITE | BL_FIX);
;               }
;               if (!do_sub_msg(@do__count) && @do__ask)
;                   msg(u8(""));
;           }
;           else
;               @global_need_beginline = true;
;           if (@do__print)
;               print_line(@curwin.w_cursor.lnum, @do__number, @do__list);
;       }
;       else if (@global_busy == 0)
;       {
;           if (@got_int)                ;; interrupted
;               emsg(e_interr);
;           else if (got_match)         ;; did find something but nothing substituted
;               msg(u8(""));
;           else if (@do__error)         ;; nothing found
;               emsg2(e_patnotf2, get_search_pat());
;       }
    ))

;; Give message for number of substitutions.
;; Can also be used after a ":global" command.
;; Return true if a message was given.

(defn- #_boolean do_sub_msg [#_boolean count_only]
    ;; count_only: used 'n' flag for ":s"
    (§
        ;; Only report substitutions when:
        ;; - more than 'report' substitutions
        ;; - command was typed by user, or number of changed lines > 'report'
        ;; - giving messages is not disabled by 'lazyredraw'

;       if (((@p_report < @sub_nsubs && (@keyTyped || 1 < @sub_nlines || @p_report < 1)) || count_only)
;               && messaging())
;       {
;           if (@got_int)
;               STRCPY(msg_buf, u8("(Interrupted) "));
;           else
;               msg_buf.be(0, NUL);
;           if (@sub_nsubs == 1)
;               vim_snprintf_add(msg_buf, MSG_BUF_LEN, u8("%s"), (count_only) ? u8("1 match") : u8("1 substitution"));
;           else
;               vim_snprintf_add(msg_buf, MSG_BUF_LEN, (count_only) ? u8("%ld matches") : u8("%ld substitutions"), @sub_nsubs);
;           if (@sub_nlines == 1)
;               vim_snprintf_add(msg_buf, MSG_BUF_LEN, u8("%s"), u8(" on 1 line"));
;           else
;               vim_snprintf_add(msg_buf, MSG_BUF_LEN, u8(" on %ld lines"), @sub_nlines);
;           if (msg(msg_buf))
                ;; save message to display it after redraw
;               set_keep_msg(msg_buf, 0);
;           return true;
;       }
;       if (@got_int)
;       {
;           emsg(e_interr);
;           return true;
;       }
;       return false;
    ))

;; Execute a global command of the form:
;;
;; g/pattern/X : execute X on all lines where pattern matches
;; v/pattern/X : execute X on all lines where pattern does not match
;;
;; where 'X' is an EX command
;;
;; The command character (as well as the trailing slash) is optional, and
;; is assumed to be 'p' if missing.
;;
;; This is implemented in two passes: first we scan the file for the pattern and
;; set a mark for each line that (not) matches.  Secondly we execute the command
;; for each line that has a mark.  This is required because after deleting
;; lines we do not know where to search for the next match.

(defn- #_void ex_global [#_exarg_C eap]
    (§
;       if (@global_busy != 0)
;       {
;           emsg(u8("E147: Cannot do :global recursive")); ;; will increment global_busy
;           return;
;       }

;       int type;                               ;; first char of cmd: 'v' or 'g'
;       if (eap.forceit)                        ;; ":global!" is like ":vglobal"
;           type = 'v';
;       else
;           type = eap.cmd.at(0);
;       Bytes cmd = eap.arg;
;       int which_pat = RE_LAST;                ;; default: use last used regexp

            ;; undocumented vi feature:
            ;;  "\/" and "\?": use previous search pattern.
            ;;           "\&": use previous substitute pattern.

;       Bytes pat;
;       if (cmd.at(0) == (byte)'\\')
;       {
;           cmd = cmd.plus(1);
;           if (vim_strbyte(u8("/?&"), cmd.at(0)) == null)
;           {
;               emsg(e_backslash);
;               return;
;           }
;           if (cmd.at(0) == (byte)'&')
;               which_pat = RE_SUBST;           ;; use previous substitute pattern
;           else
;               which_pat = RE_SEARCH;          ;; use previous search pattern
;           cmd = cmd.plus(1);
;           pat = u8("");
;       }
;       else if (cmd.at(0) == NUL)
;       {
;           emsg(u8("E148: Regular expression missing from global"));
;           return;
;       }
;       else
;       {
;           byte delim = cmd.at(0);                 ;; delimiter, normally '/'
;           if (delim != NUL)
;               cmd = cmd.plus(1);                  ;; skip delimiter if there is one
;           pat = cmd;                              ;; remember start of pattern
;           { Bytes[] __ = { eap.arg }; cmd = skip_regexp(cmd, delim, @p_magic, __); eap.arg = __[0]; }
;           if (cmd.at(0) == delim)                 ;; end delimiter found
;               (cmd = cmd.plus(1)).be(-1, NUL);    ;; replace it with a NUL
;       }

;       regmmatch_C regmatch = §_regmmatch_C();
;       if (search_regcomp(pat, RE_BOTH, which_pat, SEARCH_HIS, regmatch) == false)
;       {
;           emsg(e_invcmd);
;           return;
;       }

;       int ndone = 0;

            ;; pass 1: set marks for each (not) matching line

;       for (long lnum = eap.line1; lnum <= eap.line2 && !@got_int; lnum++)
;       {
                ;; a match on this line?
;           long match = vim_regexec_multi(regmatch, @curwin, @curbuf, lnum, 0, null);
;           if ((type == 'g' && match != 0) || (type == 'v' && match == 0))
;           {
;               ml_setmarked(lnum);
;               ndone++;
;           }
;           line_breakcheck();
;       }

            ;; pass 2: execute the command for each line that has been marked

;       if (@got_int)
;           msg(e_interr);
;       else if (ndone == 0)
;       {
;           if (type == 'v')
;               smsg(u8("Pattern found in every line: %s"), pat);
;           else
;               smsg(u8("Pattern not found: %s"), pat);
;       }
;       else
;       {
;           start_global_changes();
;           global_exe(cmd);
;           end_global_changes();
;       }

;       ml_clearmarked();                   ;; clear rest of the marks
    ))

;; Execute "cmd" on lines marked with ml_setmarked().

(defn- #_void global_exe [#_Bytes cmd]
    (§
;       buffer_C old_buf = @curbuf;  ;; remember what buffer we started in

        ;; Set current position only once for a global command.
        ;; If global_busy is set, setpcmark() will not do anything.
        ;; If there is an error, global_busy will be incremented.

;       setpcmark();

        ;; When the command writes a message, don't overwrite the command.
;       @msg_didout = true;

;       @sub_nsubs = 0;
;       @sub_nlines = 0;
;       @global_need_beginline = false;
;       @global_busy = 1;

;       long old_lcount = @curbuf.b_ml.ml_line_count;

;       long lnum;                  ;; line number according to old situation
;       while (!@got_int && (lnum = ml_firstmarked()) != 0 && @global_busy == 1)
;       {
;           @curwin.w_cursor.lnum = lnum;
;           @curwin.w_cursor.col = 0;
;           if (cmd.at(0) == NUL || cmd.at(0) == (byte)'\n')
;               do_cmdline(u8("p"), null, null, DOCMD_NOWAIT);
;           else
;               do_cmdline(cmd, null, null, DOCMD_NOWAIT);
;           ui_breakcheck();
;       }

;       @global_busy = 0;
;       if (@global_need_beginline)
;           beginline(BL_WHITE | BL_FIX);
;       else
;           check_cursor(); ;; cursor may be beyond the end of the line

        ;; The cursor may have not moved in the text but a change
        ;; in a previous line may have moved it on the screen.
;       changed_line_abv_curs();

        ;; If it looks like no message was written,
        ;; allow overwriting the command with the report for number of changes.
;       if (@msg_col == 0 && @msg_scrolled == 0)
;           @msg_didout = false;

        ;; If substitutes done, report number of substitutes,
        ;; otherwise report number of extra or deleted lines.
        ;; Don't report extra or deleted lines in the edge case where the buffer
        ;; we are in after execution is different from the buffer we started in.
;       if (!do_sub_msg(false) && @curbuf == old_buf)
;           msgmore(@curbuf.b_ml.ml_line_count - old_lcount);
    ))

;; ex_getln.c: Functions for entering and editing an Ex command line ------------------------------

;; Variables shared between getcmdline(), redrawcmdline() and others.
;; These need to be saved when using CTRL-R |, that's why they are in a structure.

(class! #_final cmdline_info_C
    [
        (field Bytes        cmdbuff)        ;; pointer to command line buffer
        (field int          cmdbufflen)     ;; length of "cmdbuff"
        (field int          cmdlen)         ;; number of chars in command line
        (field int          cmdpos)         ;; current cursor position
        (field int          cmdspos)        ;; cursor column on screen
        (field int          cmdfirstc)      ;; ':', '/', '?', '=', '>' or NUL
        (field int          cmdindent)      ;; number of spaces before cmdline
        (field Bytes        cmdprompt)      ;; message in front of cmdline
        (field int          cmdattr)        ;; attributes for prompt
        (field boolean      overstrike)     ;; Typing mode on the command line.  Shared by getcmdline() and put_on_cmdline().
    ])

(defn- #_void COPY_cmdline_info [#_cmdline_info_C cli1, #_cmdline_info_C cli0]
    (§
;       cli1.cmdbuff = cli0.cmdbuff;
;       cli1.cmdbufflen = cli0.cmdbufflen;
;       cli1.cmdlen = cli0.cmdlen;
;       cli1.cmdpos = cli0.cmdpos;
;       cli1.cmdspos = cli0.cmdspos;
;       cli1.cmdfirstc = cli0.cmdfirstc;
;       cli1.cmdindent = cli0.cmdindent;
;       cli1.cmdprompt = cli0.cmdprompt;
;       cli1.cmdattr = cli0.cmdattr;
;       cli1.overstrike = cli0.overstrike;
    ))

;; The current cmdline_info.  It is initialized in getcmdline() and after that
;; used by other functions.  When invoking getcmdline() recursively it needs
;; to be saved with save_cmdline() and restored with restore_cmdline().
;; TODO: make it local to getcmdline() and pass it around.

(atom! cmdline_info_C ccline    (§_cmdline_info_C))

(atom! int new_cmdpos)  ;; position set by set_cmdline_pos()

(class! #_final histentry_C
    [
        (field int      hisnum)     ;; identifying number
        (field Bytes    hisstr)     ;; actual entry, separator char after the NUL
    ])

(defn- #_void COPY_histentry [#_histentry_C he1, #_histentry_C he0]
    (§
;       he1.hisnum = he0.hisnum;
;       he1.hisstr = he0.hisstr;
    ))

(defn- #_histentry_C* ARRAY_histentry [#_int n]
    (vec (repeatedly n §_histentry_C)))

(atom! histentry_C**    history     HIST_COUNT)
(atom! int*             hisidx      (repeat HIST_COUNT -1))     ;; last used entry
;; identifying (unique) number of newest history entry
(atom! int*             hisnum      HIST_COUNT)
(atom! int              hislen)                                 ;; actual length of history tables

;; getcmdline() - accept a command line starting with firstc.
;;
;; firstc == ':'            get ":" command line.
;; firstc == '/' or '?'     get search pattern
;; firstc == '='            get expression
;; firstc == '@'            get text for input() function
;; firstc == '>'            get text for debug mode
;; firstc == NUL            get text for :insert command
;; firstc == -1             like NUL, and break on CTRL-C
;;
;; The line is collected in ccline.cmdbuff, which is reallocated to fit the command line.
;;
;; Careful: getcmdline() can be called recursively!
;;
;; Return pointer to allocated string if there is a commandline, null otherwise.

(defn- #_Bytes getcmdline [#_int firstc, #_long count, #_int indent]
    ;; count: only used for incremental search
    ;; indent: indent for inside conditionals
    (§
;       boolean gotesc = false;                 ;; true when <ESC> just typed
;       Bytes lookfor = null;                  ;; string to match
;       boolean did_incsearch = false;
;       boolean incsearch_postponed = false;
;       boolean did_wild_list = false;          ;; did wild_list() recently
;       boolean save_msg_scroll = @msg_scroll;
;       int save_State = @State;                 ;; remember State when called
;       boolean some_key_typed = false;         ;; one of the keys was typed

        ;; mouse drag and release events are ignored,
        ;; unless they are preceded with a mouse down event

;       boolean ignore_drag_release = true;
;       boolean break_ctrl_c = false;

        ;; Everything that may work recursively should save and restore the current command line in save_cli.
        ;; That includes update_screen(), a custom status line may invoke ":normal".

;       cmdline_info_C save_cli = §_cmdline_info_C();

;       if (firstc == -1)
;       {
;           firstc = NUL;
;           break_ctrl_c = true;
;       }

;       @ccline.overstrike = false;                  ;; always start in insert mode
;       pos_C old_cursor = §_pos_C();
;       COPY_pos(old_cursor, @curwin.w_cursor);      ;; needs to be restored later
;       int old_curswant = @curwin.w_curswant;
;       int old_leftcol = @curwin.w_leftcol;
;       long old_topline = @curwin.w_topline;
;       long old_botline = @curwin.w_botline;

        ;; set some variables for redrawcmd()

;       @ccline.cmdfirstc = (firstc == '@') ? 0 : firstc;
;       @ccline.cmdindent = (0 < firstc) ? indent : 0;

        ;; alloc initial ccline.cmdbuff
;       alloc_cmdbuff((@exmode_active != 0) ? 250 : indent + 1);
;       @ccline.cmdlen = @ccline.cmdpos = 0;
;       @ccline.cmdbuff.be(0, NUL);

        ;; autoindent for :insert and :append
;       if (firstc <= 0)
;       {
;           copy_spaces(@ccline.cmdbuff, indent);
;           @ccline.cmdbuff.be(indent, NUL);
;           @ccline.cmdpos = indent;
;           @ccline.cmdspos = indent;
;           @ccline.cmdlen = indent;
;       }

;       if (@curwin.w_onebuf_opt.@wo_rl && @curwin.w_onebuf_opt.@wo_rlc.at(0) == (byte)'s' && (firstc == '/' || firstc == '?'))
;           @cmdmsg_rl = true;
;       else
;           @cmdmsg_rl = false;

;       if (!@cmd_silent)
;       {
;           int i = @msg_scrolled;
;           @msg_scrolled = 0;               ;; avoid wait_return message
;           gotocmdline(true);
;           @msg_scrolled += i;
;           redrawcmdprompt();              ;; draw prompt or indent
;           set_cmdspos();
;       }

        ;; Avoid scrolling when called by a recursive do_cmdline(),
        ;; e.g. when doing ":@0" when register 0 doesn't contain a CR.

;       @msg_scroll = false;

;       @State = CMDLINE;

;       if (firstc == '/' || firstc == '?' || firstc == '@')
;       {
            ;; Use ":lmap" mappings for search pattern and input().
            
;       }

;       setmouse();
;       ui_cursor_shape();          ;; may show different cursor shape

        ;; When inside an autocommand for writing "exiting" may be set and terminal mode set to cooked.
        ;; Need to set raw mode here then.
;       settmode(TMODE_RAW);

;       init_history();
;       int hiscnt = @hislen;        ;; current history line in use; set to impossible history value
;       int histype = hist_char2type(firstc);   ;; history type to be used

;       do_digraph(-1);             ;; init digraph typeahead

        ;; If something above caused an error, reset the flags, we do want to type and execute commands.
        ;; Display may be messed up a bit.
;       if (@did_emsg)
;           redrawcmd();
;       @did_emsg = false;
;       @got_int = false;

        ;; Collect the command string, handling editing keys.

;       returncmd:
;       for ( ; ; )
;       {
;           @quit_more = false;  ;; reset after CTRL-D which had a more-prompt

;           cursorcmd();        ;; set the cursor on the right spot

            ;; Get a character.
            ;; Ignore K_IGNORE, it should not do anything, such as stop completion.
;           int c;
;           do
;           {
;               c = safe_vgetc();
;           } while (c == K_IGNORE);

;           if (@keyTyped)
;           {
;               some_key_typed = true;

;               if (@cmdmsg_rl && !@keyStuffed)
;               {
                    ;; Invert horizontal movements and operations.
                    ;; Only when typed by the user directly, not when the result of a mapping.
;                   switch (c)
;                   {
;                       case K_RIGHT:   c = K_LEFT; break;
;                       case K_S_RIGHT: c = K_S_LEFT; break;
;                       case K_C_RIGHT: c = K_C_LEFT; break;
;                       case K_LEFT:    c = K_RIGHT; break;
;                       case K_S_LEFT:  c = K_S_RIGHT; break;
;                       case K_C_LEFT:  c = K_C_RIGHT; break;
;                   }
;               }
;           }

            ;; Ignore got_int when CTRL-C was typed here.
            ;; Don't ignore it in :global, we really need to break then,
            ;; e.g. for ":g/pat/normal /pat" (without the <CR>).
            ;; Don't ignore it for the input() function.

;           if ((c == Ctrl_C || c == @intr_char)
;                   && firstc != '@'
;                   && !break_ctrl_c
;                   && @global_busy == 0)
;               @got_int = false;

            ;; free old command line when finished moving around in the history list
;           if (lookfor != null
;                   && c != K_S_DOWN && c != K_S_UP
;                   && c != K_DOWN && c != K_UP
;                   && c != K_PAGEDOWN && c != K_PAGEUP
;                   && c != K_KPAGEDOWN && c != K_KPAGEUP
;                   && c != K_LEFT && c != K_RIGHT
;                   && c != Ctrl_P && c != Ctrl_N)
;           {
;               lookfor = null;
;           }

;           cmdline_changed:
;           {
;               cmdline_not_changed:
;               {
                    ;; CTRL-\ CTRL-N goes to Normal mode,
                    ;; CTRL-\ CTRL-G goes to Insert mode when 'insertmode' is set,
                    ;; CTRL-\ e prompts for an expression.
;                   if (c == Ctrl_BSL)
;                   {
;                       @no_mapping++;
;                       @allow_keys++;
;                       c = plain_vgetc();
;                       --@no_mapping;
;                       --@allow_keys;
                        ;; CTRL-\ e doesn't work when obtaining an expression, unless it is in a mapping.
;                       if (c != Ctrl_N && c != Ctrl_G && (c != 'e' || (@ccline.cmdfirstc == '=' && @keyTyped)))
;                       {
;                           vungetc(c);
;                           c = Ctrl_BSL;
;                       }
;                       else if (c == 'e')
;                       {
                            ;; Replace the command line with the result of an expression.
                            ;; Need to save and restore the current command line, to be
                            ;; able to enter a new one...

;                           if (@ccline.cmdpos == @ccline.cmdlen)
;                               @new_cmdpos = 99999; ;; keep it at the end
;                           else
;                               @new_cmdpos = @ccline.cmdpos;

;                           save_cmdline(save_cli);
;                           c = get_expr_register();
;                           restore_cmdline(save_cli);

;                           if (c == '=')
;                           {
                                ;; Need to save and restore ccline, and set "textlock" to avoid nasty things
                                ;; like going to another buffer when evaluating an expression.
;                               save_cmdline(save_cli);
;                               @textlock++;
;                               Bytes p = get_expr_line();
;                               --@textlock;
;                               restore_cmdline(save_cli);

;                               if (p != null)
;                               {
;                                   int len = STRLEN(p);
;                                   realloc_cmdbuff(len + 1);

;                                   @ccline.cmdlen = len;
;                                   STRCPY(@ccline.cmdbuff, p);

                                    ;; Restore the cursor or use the position set with set_cmdline_pos().
;                                   if (@ccline.cmdlen < @new_cmdpos)
;                                       @ccline.cmdpos = @ccline.cmdlen;
;                                   else
;                                       @ccline.cmdpos = @new_cmdpos;

;                                   @keyTyped = false;   ;; Don't do "p_wc" completion.
;                                   redrawcmd();
;                                   break cmdline_changed;
;                               }
;                           }

;                           beep_flush();
;                           @got_int = false;        ;; don't abandon the command line
;                           @did_emsg = false;
;                           @emsg_on_display = false;
;                           redrawcmd();
;                           break cmdline_not_changed;
;                       }
;                       else
;                       {
;                           if (c == Ctrl_G && @p_im && @restart_edit == 0)
;                               @restart_edit = 'a';
;                           gotesc = true;          ;; will free ccline.cmdbuff after putting it in history
;                           break returncmd;        ;; back to Normal mode
;                       }
;                   }

;                   if (c == @cedit_key || c == K_CMDWIN)
;                   {
;                       if (@ex_normal_busy == 0 && @got_int == false)
;                       {
                            ;; Open a window to edit the command line (and history).
;                           c = ex_window();
;                           some_key_typed = true;
;                       }
;                   }
;                   else
;                       c = do_digraph(c);

;                   if (c == '\n' || c == '\r' || c == K_KENTER || (c == ESC
;                                   && (!@keyTyped || vim_strbyte(@p_cpo, CPO_ESC) != null)))
;                   {
                        ;; In Ex mode a backslash escapes a newline.
;                       if (@exmode_active != 0
;                               && c != ESC
;                               && @ccline.cmdpos == @ccline.cmdlen
;                               && 0 < @ccline.cmdpos
;                               && @ccline.cmdbuff.at(@ccline.cmdpos - 1) == (byte)'\\')
;                       {
;                           if (c == K_KENTER)
;                               c = '\n';
;                       }
;                       else
;                       {
;                           gotesc = false;                     ;; Might have typed ESC previously,
                                                                ;; don't truncate the cmdline now.
;                           if (ccheck_abbr(c + ABBR_OFF))
;                               break cmdline_changed;
;                           if (!@cmd_silent)
;                           {
;                               windgoto(@msg_row, 0);
;                               out_flush();
;                           }
;                           break;
;                       }
;                   }

                    ;; Completion for 'wildchar' or 'wildcharm' key.
                    ;; - hitting <ESC> twice means: abandon command line.
                    ;; - wildcard expansion is only done when the 'wildchar' key is really
                    ;;   typed, not when it comes from a macro

;                   if (c == @p_wc && !gotesc && @keyTyped)
;                   {
;                       if (c == ESC)
;                           gotesc = true;
;                   }

;                   gotesc = false;

;                   if (c == NUL || c == K_ZERO)        ;; NUL is stored as NL
;                       c = NL;

;                   boolean do_abbr = true;             ;; default: check for abbreviation

                    ;; Big switch for a typed command line character.

;                   switch (c)
;                   {
;                       case K_BS:
;                       case Ctrl_H:
;                       case K_DEL:
;                       case K_KDEL:
;                       case Ctrl_W:
;                       {
;                           if (c == K_KDEL)
;                               c = K_DEL;

                            ;; delete current character is the same as backspace on next
                            ;; character, except at end of line

;                           if (c == K_DEL && @ccline.cmdpos != @ccline.cmdlen)
;                               @ccline.cmdpos++;
;                           if (c == K_DEL)
;                               @ccline.cmdpos += us_off_next(@ccline.cmdbuff, @ccline.cmdbuff.plus(@ccline.cmdpos));
;                           if (0 < @ccline.cmdpos)
;                           {
;                               int j = @ccline.cmdpos;
;                               Bytes p = us_prevptr(@ccline.cmdbuff, @ccline.cmdbuff.plus(j));

;                               if (c == Ctrl_W)
;                               {
;                                   while (BLT(@ccline.cmdbuff, p) && vim_isspace(p.at(0)))
;                                       p = us_prevptr(@ccline.cmdbuff, p);
;                                   int i = us_get_class(p, @curbuf);
;                                   while (BLT(@ccline.cmdbuff, p) && us_get_class(p, @curbuf) == i)
;                                       p = us_prevptr(@ccline.cmdbuff, p);
;                                   if (us_get_class(p, @curbuf) != i)
;                                       p = p.plus(us_ptr2len_cc(p));
;                               }

;                               @ccline.cmdpos = BDIFF(p, @ccline.cmdbuff);
;                               @ccline.cmdlen -= j - @ccline.cmdpos;
;                               int i = @ccline.cmdpos;
;                               while (i < @ccline.cmdlen)
;                                   @ccline.cmdbuff.be(i++, @ccline.cmdbuff.at(j++));

                                ;; Truncate at the end, required for multi-byte chars.
;                               @ccline.cmdbuff.be(@ccline.cmdlen, NUL);
;                               redrawcmd();
;                           }
;                           else if (@ccline.cmdlen == 0 && c != Ctrl_W && @ccline.cmdprompt == null && indent == 0)
;                           {
                                ;; In ex and debug mode it doesn't make sense to return.
;                               if (@exmode_active != 0 || @ccline.cmdfirstc == '>')
;                                   break cmdline_not_changed;

;                               @ccline.cmdbuff = null;      ;; no commandline to return
;                               if (!@cmd_silent)
;                               {
;                                   if (@cmdmsg_rl)
;                                       @msg_col = (int)@Columns;
;                                   else
;                                       @msg_col = 0;
;                                   msg_putchar(' ');       ;; delete ':'
;                               }
;                               @redraw_cmdline = true;
;                               break returncmd;            ;; back to cmd mode
;                           }
;                           break cmdline_changed;
;                       }

;                       case K_INS:
;                       case K_KINS:
;                       {
;                           @ccline.overstrike = !@ccline.overstrike;
;                           ui_cursor_shape();              ;; may show different cursor shape
;                           break cmdline_not_changed;
;                       }

;                       case Ctrl_HAT:
;                       {
                            
;                           ui_cursor_shape();      ;; may show different cursor shape
;                           break cmdline_not_changed;
;                       }

                     ;; case '@':   only in very old vi
;                       case Ctrl_U:
;                       {
                            ;; delete all characters left of the cursor
;                           int j = @ccline.cmdpos;
;                           @ccline.cmdlen -= j;
;                           int i = @ccline.cmdpos = 0;
;                           while (i < @ccline.cmdlen)
;                               @ccline.cmdbuff.be(i++, @ccline.cmdbuff.at(j++));
                            ;; Truncate at the end, required for multi-byte chars.
;                           @ccline.cmdbuff.be(@ccline.cmdlen, NUL);
;                           redrawcmd();
;                           break cmdline_changed;
;                       }

;                       case Ctrl_Y:
;                       {
                            ;; Copy the modeless selection, if there is one.
;                           if (@clip_star.state != SELECT_CLEARED)
;                           {
;                               if (@clip_star.state == SELECT_DONE)
;                                   clip_copy_modeless_selection(true);
;                               break cmdline_not_changed;
;                           }
;                           break;
;                       }

;                       case ESC:       ;; get here if p_wc != ESC or when ESC typed twice
;                       case Ctrl_C:
;                       {
                            ;; In exmode it doesn't make sense to return.
                            ;; Except when ":normal" runs out of characters.
;                           if (@exmode_active != 0 && (@ex_normal_busy == 0 || 0 < @typebuf.tb_len))
;                               break cmdline_not_changed;

;                           gotesc = true;              ;; will free ccline.cmdbuff after putting it in history
;                           break returncmd;            ;; back to cmd mode
;                       }

;                       case Ctrl_R:                    ;; insert register
;                       {
;                           putcmdline('"', true);
;                           @no_mapping++;
;                           int i = c = plain_vgetc();  ;; CTRL-R <char>
;                           if (i == Ctrl_O)
;                               i = Ctrl_R;             ;; CTRL-R CTRL-O == CTRL-R CTRL-R
;                           if (i == Ctrl_R)
;                               c = plain_vgetc();      ;; CTRL-R CTRL-R <char>
;                           --@no_mapping;

                            ;; Insert the result of an expression.
                            ;; Need to save the current command line, to be able to enter a new one...

;                           @new_cmdpos = -1;
;                           if (c == '=')
;                           {
;                               if (@ccline.cmdfirstc == '=')    ;; can't do this recursively
;                               {
;                                   beep_flush();
;                                   c = ESC;
;                               }
;                               else
;                               {
;                                   save_cmdline(save_cli);
;                                   c = get_expr_register();
;                                   restore_cmdline(save_cli);
;                               }
;                           }
;                           if (c != ESC)               ;; use ESC to cancel inserting register
;                           {
;                               cmdline_paste(c, i == Ctrl_R, false);

                                ;; When there was a serious error abort getting the command line.
;                               if (aborting())
;                               {
;                                   gotesc = true;      ;; will free ccline.cmdbuff after putting it in history
;                                   break returncmd;    ;; back to cmd mode
;                               }
;                               @keyTyped = false;       ;; Don't do "p_wc" completion.
;                               if (0 <= @new_cmdpos)
;                               {
                                    ;; set_cmdline_pos() was used
;                                   if (@ccline.cmdlen < @new_cmdpos)
;                                       @ccline.cmdpos = @ccline.cmdlen;
;                                   else
;                                       @ccline.cmdpos = @new_cmdpos;
;                               }
;                           }
;                           redrawcmd();
;                           break cmdline_changed;
;                       }

;                       case Ctrl_D:
;                       {
;                           break;      ;; Use ^D as normal char instead
;                       }

;                       case K_RIGHT:
;                       case K_S_RIGHT:
;                       case K_C_RIGHT:
;                       {
;                           do
;                           {
;                               if (@ccline.cmdlen <= @ccline.cmdpos)
;                                   break;
;                               int i = cmdline_charsize(@ccline.cmdpos);
;                               if (@keyTyped && (int)@Columns * (int)@Rows <= @ccline.cmdspos + i)
;                                   break;
;                               @ccline.cmdspos += i;
;                               @ccline.cmdpos += us_ptr2len_cc(@ccline.cmdbuff.plus(@ccline.cmdpos));
;                           }
;                           while ((c == K_S_RIGHT || c == K_C_RIGHT || (@mod_mask & (MOD_MASK_SHIFT|MOD_MASK_CTRL)) != 0)
;                                   && @ccline.cmdbuff.at(@ccline.cmdpos) != (byte)' ');
;                           set_cmdspos_cursor();
;                           break cmdline_not_changed;
;                       }

;                       case K_LEFT:
;                       case K_S_LEFT:
;                       case K_C_LEFT:
;                       {
;                           if (@ccline.cmdpos == 0)
;                               break cmdline_not_changed;
;                           do
;                           {
;                               --@ccline.cmdpos;
                                ;; move to first byte of char
;                               @ccline.cmdpos -= us_head_off(@ccline.cmdbuff, @ccline.cmdbuff.plus(@ccline.cmdpos));
;                               @ccline.cmdspos -= cmdline_charsize(@ccline.cmdpos);
;                           }
;                           while (0 < @ccline.cmdpos
;                                   && (c == K_S_LEFT || c == K_C_LEFT
;                                       || (@mod_mask & (MOD_MASK_SHIFT|MOD_MASK_CTRL)) != 0)
;                                   && @ccline.cmdbuff.at(@ccline.cmdpos - 1) != (byte)' ');
;                           set_cmdspos_cursor();
;                           break cmdline_not_changed;
;                       }

;                       case K_IGNORE:
;                           break cmdline_not_changed;          ;; Ignore mouse event or ex_window() result.

;                       case K_MIDDLEDRAG:
;                       case K_MIDDLERELEASE:
;                           break cmdline_not_changed;          ;; Ignore mouse

;                       case K_MIDDLEMOUSE:
;                       {
;                           if (!mouse_has(MOUSE_COMMAND))
;                               break cmdline_not_changed;      ;; Ignore mouse
;                           if (@clip_star.available)
;                               cmdline_paste('*', true, true);
;                           else
;                               cmdline_paste(0, true, true);
;                           redrawcmd();
;                           break cmdline_changed;
;                       }

;                       case K_DROP:
;                       {
;                           cmdline_paste('~', true, false);
;                           redrawcmd();
;                           break cmdline_changed;
;                       }

;                       case K_LEFTDRAG:
;                       case K_LEFTRELEASE:
;                       case K_RIGHTDRAG:
;                       case K_RIGHTRELEASE:
;                       {
                            ;; Ignore drag and release events when the button-down wasn't seen before.
;                           if (ignore_drag_release)
;                               break cmdline_not_changed;
                            ;; FALLTHROUGH
;                       }

;                       case K_LEFTMOUSE:
;                       case K_RIGHTMOUSE:
;                       {
;                           ignore_drag_release = (c == K_LEFTRELEASE || c == K_RIGHTRELEASE);

;                           if (!mouse_has(MOUSE_COMMAND))
;                               break cmdline_not_changed;      ;; Ignore mouse.

;                           if (@mouse_row < @cmdline_row && @clip_star.available)
;                           {
                                ;; Handle modeless selection.
;                               boolean[] is_click = new boolean[1];
;                               boolean[] is_drag = new boolean[1];
;                               int button = get_mouse_button(KEY2TERMCAP1(c), is_click, is_drag);
;                               if (mouse_model_popup() && button == MOUSE_LEFT && (@mod_mask & MOD_MASK_SHIFT) != 0)
;                               {
                                    ;; Translate shift-left to right button.
;                                   button = MOUSE_RIGHT;
;                                   @mod_mask &= ~MOD_MASK_SHIFT;
;                               }
;                               clip_modeless(button, is_click[0], is_drag[0]);
;                               break cmdline_not_changed;
;                           }

;                           set_cmdspos();
;                           for (@ccline.cmdpos = 0; @ccline.cmdpos < @ccline.cmdlen; @ccline.cmdpos++)
;                           {
;                               int i = cmdline_charsize(@ccline.cmdpos);
;                               if (@mouse_row <= @cmdline_row + @ccline.cmdspos / (int)@Columns
;                                           && @mouse_col < @ccline.cmdspos % (int)@Columns + i)
;                                   break;

                                ;; Count ">" for double-wide char that doesn't fit.
;                               correct_cmdspos(@ccline.cmdpos, i);
;                               @ccline.cmdpos += us_ptr2len_cc(@ccline.cmdbuff.plus(@ccline.cmdpos)) - 1;

;                               @ccline.cmdspos += i;
;                           }
;                           break cmdline_not_changed;
;                       }

                        ;; Mouse scroll wheel: ignored here.
;                       case K_MOUSEDOWN:
;                       case K_MOUSEUP:
;                       case K_MOUSELEFT:
;                       case K_MOUSERIGHT:
                        ;; Alternate buttons ignored here.
;                       case K_X1MOUSE:
;                       case K_X1DRAG:
;                       case K_X1RELEASE:
;                       case K_X2MOUSE:
;                       case K_X2DRAG:
;                       case K_X2RELEASE:
;                           break cmdline_not_changed;

;                       case K_SELECT:      ;; end of Select mode mapping - ignore
;                           break cmdline_not_changed;

;                       case Ctrl_B:        ;; begin of command line
;                       case K_HOME:
;                       case K_KHOME:
;                       case K_S_HOME:
;                       case K_C_HOME:
;                       {
;                           @ccline.cmdpos = 0;
;                           set_cmdspos();
;                           break cmdline_not_changed;
;                       }

;                       case Ctrl_E:        ;; end of command line
;                       case K_END:
;                       case K_KEND:
;                       case K_S_END:
;                       case K_C_END:
;                       {
;                           @ccline.cmdpos = @ccline.cmdlen;
;                           set_cmdspos_cursor();
;                           break cmdline_not_changed;
;                       }

;                       case Ctrl_A:        ;; all matches
;                       {
;                           break;
;                       }

;                       case Ctrl_L:
;                       {
;                           if (@p_is && !@cmd_silent && (firstc == '/' || firstc == '?'))
;                           {
                                ;; Add a character from under the cursor for 'incsearch'.
;                               if (did_incsearch && !eqpos(@curwin.w_cursor, old_cursor))
;                               {
;                                   c = gchar_cursor();
                                    ;; If 'ignorecase' and 'smartcase' are set and the command line
                                    ;; has no uppercase characters, convert the character to lowercase.
;                                   if (@p_ic && @p_scs && !pat_has_uppercase(@ccline.cmdbuff))
;                                       c = utf_tolower(c);
;                                   if (c != NUL)
;                                   {
;                                       if (c == firstc || vim_strchr(@p_magic ? u8("\\^$.*[") : u8("\\^$"), c) != null)
;                                       {
                                            ;; put a backslash before special characters
;                                           stuffcharReadbuff(c);
;                                           c = '\\';
;                                       }
;                                       break;
;                                   }
;                               }
;                               break cmdline_not_changed;
;                           }

;                           break;
;                       }

;                       case Ctrl_N:        ;; next match
;                       case Ctrl_P:        ;; previous match

;                       case K_UP:
;                       case K_DOWN:
;                       case K_S_UP:
;                       case K_S_DOWN:
;                       case K_PAGEUP:
;                       case K_KPAGEUP:
;                       case K_PAGEDOWN:
;                       case K_KPAGEDOWN:
;                       {
;                           if (@hislen == 0 || firstc == NUL)       ;; no history
;                               break cmdline_not_changed;

;                           int i = hiscnt;

                            ;; save current command string so it can be restored later
;                           if (lookfor == null)
;                           {
;                               lookfor = STRDUP(@ccline.cmdbuff);
;                               if (lookfor == null)
;                                   break cmdline_not_changed;
;                               lookfor.be(@ccline.cmdpos, NUL);
;                           }

;                           for (int n = STRLEN(lookfor); ; )
;                           {
                                ;; one step backwards
;                               if (c == K_UP|| c == K_S_UP || c == Ctrl_P || c == K_PAGEUP || c == K_KPAGEUP)
;                               {
;                                   if (hiscnt == @hislen)   ;; first time
;                                       hiscnt = @hisidx[histype];
;                                   else if (hiscnt == 0 && @hisidx[histype] != @hislen - 1)
;                                       hiscnt = @hislen - 1;
;                                   else if (hiscnt != @hisidx[histype] + 1)
;                                       --hiscnt;
;                                   else                    ;; at top of list
;                                   {
;                                       hiscnt = i;
;                                       break;
;                                   }
;                               }
;                               else    ;; one step forwards
;                               {
                                    ;; on last entry, clear the line
;                                   if (hiscnt == @hisidx[histype])
;                                   {
;                                       hiscnt = @hislen;
;                                       break;
;                                   }

                                    ;; not on a history line, nothing to do
;                                   if (hiscnt == @hislen)
;                                       break;
;                                   if (hiscnt == @hislen - 1)   ;; wrap around
;                                       hiscnt = 0;
;                                   else
;                                       hiscnt++;
;                               }
;                               if (hiscnt < 0 || @history[histype][hiscnt].hisstr == null)
;                               {
;                                   hiscnt = i;
;                                   break;
;                               }
;                               if ((c != K_UP && c != K_DOWN)
;                                       || hiscnt == i
;                                       || STRNCMP(@history[histype][hiscnt].hisstr, lookfor, n) == 0)
;                                   break;
;                           }

;                           if (hiscnt != i)        ;; jumped to other entry
;                           {
;                               @ccline.cmdbuff = null;

;                               Bytes p;
;                               if (hiscnt == @hislen)
;                                   p = lookfor;    ;; back to the old one
;                               else
;                                   p = @history[histype][hiscnt].hisstr;

;                               int old_firstc;
;                               if (histype == HIST_SEARCH && BNE(p, lookfor) && (old_firstc = p.at(STRLEN(p) + 1)) != firstc)
;                               {
                                    ;; Correct for the separator character used when
                                    ;; adding the history entry vs the one used now.
                                    ;; First loop: count length.
                                    ;; Second loop: copy the characters.
;                                   for (int round = 0; round <= 1; round++)
;                                   {
;                                       int len = 0;

;                                       for (/*int */i = 0; p.at(i) != NUL; i++)
;                                       {
                                            ;; Replace old sep with new sep, unless it is escaped.
;                                           if (p.at(i) == old_firstc && (i == 0 || p.at(i - 1) != (byte)'\\'))
;                                           {
;                                               if (0 < round)
;                                                   @ccline.cmdbuff.be(len, firstc);
;                                           }
;                                           else
;                                           {
                                                ;; Escape new sep, unless it is already escaped.
;                                               if (p.at(i) == firstc && (i == 0 || p.at(i - 1) != (byte)'\\'))
;                                               {
;                                                   if (0 < round)
;                                                       @ccline.cmdbuff.be(len, (byte)'\\');
;                                                   len++;
;                                               }
;                                               if (0 < round)
;                                                   @ccline.cmdbuff.be(len, p.at(i));
;                                           }
;                                           len++;
;                                       }

;                                       if (0 < round)
;                                           @ccline.cmdbuff.be(len, NUL);
;                                       else
;                                           alloc_cmdbuff(len);
;                                   }
;                               }
;                               else
;                               {
;                                   alloc_cmdbuff(STRLEN(p));
;                                   STRCPY(@ccline.cmdbuff, p);
;                               }

;                               @ccline.cmdpos = @ccline.cmdlen = STRLEN(@ccline.cmdbuff);
;                               redrawcmd();
;                               break cmdline_changed;
;                           }
;                           beep_flush();
;                           break cmdline_not_changed;
;                       }

;                       case Ctrl_V:
;                       case Ctrl_Q:
;                       {
;                           ignore_drag_release = true;
;                           putcmdline('^', true);
;                           c = get_literal();          ;; get next (two) character(s)
;                           do_abbr = false;            ;; don't do abbreviation now
                            ;; may need to remove ^ when composing char was typed
;                           if (utf_iscomposing(c) && !@cmd_silent)
;                           {
;                               draw_cmdline(@ccline.cmdpos, @ccline.cmdlen - @ccline.cmdpos);
;                               msg_putchar(' ');
;                               cursorcmd();
;                           }
;                           break;
;                       }

;                       case Ctrl_K:
;                       {
;                           ignore_drag_release = true;
;                           putcmdline('?', true);
;                           c = get_digraph(true);
;                           if (c != NUL)
;                               break;

;                           redrawcmd();
;                           break cmdline_not_changed;
;                       }

;                       case Ctrl__:        ;; CTRL-_: switch language mode
;                       {
;                           if (!@p_ari)
;                               break;

;                           break cmdline_not_changed;
;                       }

;                       default:
;                       {
;                           if (c == @intr_char)
;                           {
;                               gotesc = true;      ;; will free ccline.cmdbuff after putting it in history
;                               break returncmd;    ;; back to Normal mode
;                           }

                            ;; Normal character with no special meaning.  Just set mod_mask
                            ;; to 0x0 so that typing Shift-Space in the GUI doesn't enter
                            ;; the string <S-Space>.  This should only happen after ^V.

;                           if (!is_special(c))
;                               @mod_mask = 0x0;
;                           break;
;                       }
;                   }

                    ;; End of switch on command line character.
                    ;; We come here if we have a normal character.

;                   if (do_abbr && (is_special(c) || !vim_iswordc(c, @curbuf))
                            ;; Add ABBR_OFF for characters above 0x100, this is what check_abbr() expects.
;                           && (ccheck_abbr((0x100 <= c) ? (c + ABBR_OFF) : c) || c == Ctrl_RSB))
;                       break cmdline_changed;

                    ;; put the character in the command line

;                   if (is_special(c) || @mod_mask != 0)
;                       put_on_cmdline(get_special_key_name(c, @mod_mask), -1, true);
;                   else
;                   {
;                       int j = utf_char2bytes(c, @ioBuff);
;                       @ioBuff.be(j, NUL);          ;; exclude composing chars
;                       put_on_cmdline(@ioBuff, j, true);
;                   }
;                   break cmdline_changed;
;               }

                ;; This part implements incremental searches for "/" and "?"
                ;; Jump to cmdline_not_changed when a character has been read but the command
                ;; line did not change.  Then we only search and redraw if something changed in the past.
                ;; Jump to cmdline_changed when the command line did change.
                ;; (Sorry for the goto's, I know it is ugly).

;               if (!incsearch_postponed)
;                   continue;
;           }

            ;; 'incsearch' highlighting.

;           if (@p_is && !@cmd_silent && (firstc == '/' || firstc == '?'))
;           {
                ;; if there is a character waiting, search and redraw later
;               if (char_avail())
;               {
;                   incsearch_postponed = true;
;                   continue;
;               }
;               incsearch_postponed = false;
;               COPY_pos(@curwin.w_cursor, old_cursor); ;; start at old position

                ;; If there is no command line, don't do anything.
;               int i;
;               if (@ccline.cmdlen == 0)
;                   i = 0;
;               else
;               {
;                   cursor_off();               ;; so the user knows we're busy
;                   out_flush();
;                   @emsg_off++;                 ;; so it doesn't beep if bad expr
                    ;; Set the time limit to half a second.
;                   timeval_C tm = new timeval_C();
;                   profile_setlimit(500L, tm);
;                   i = do_search(null, (byte)firstc, @ccline.cmdbuff, count,
;                           SEARCH_KEEP + SEARCH_OPT + SEARCH_NOOF + SEARCH_PEEK, tm);
;                   --@emsg_off;
                    ;; if interrupted while searching, behave like it failed
;                   if (@got_int)
;                   {
;                       vpeekc();               ;; remove <C-C> from input stream
;                       @got_int = false;        ;; don't abandon the command line
;                       i = 0;
;                   }
;                   else if (char_avail())
                        ;; cancelled searching because a char was typed
;                       incsearch_postponed = true;
;               }
;               if (i != 0)
;                   @highlight_match = true;         ;; highlight position
;               else
;                   @highlight_match = false;        ;; remove highlight

                ;; First restore the old curwin values, so the screen is
                ;; positioned in the same way as the actual search command.
;               @curwin.w_leftcol = old_leftcol;
;               @curwin.w_topline = old_topline;
;               @curwin.w_botline = old_botline;
;               changed_cline_bef_curs();
;               update_topline();

;               pos_C end_pos = §_pos_C();
;               if (i != 0)
;               {
;                   pos_C save_pos = §_pos_C();
;                   COPY_pos(save_pos, @curwin.w_cursor);

                    ;; First move the cursor to the end of the match, then to the start.
                    ;; This moves the whole match onto the screen when 'nowrap' is set.

;                   @curwin.w_cursor.lnum += @search_match_lines;
;                   @curwin.w_cursor.col = @search_match_endcol;
;                   if (@curwin.w_cursor.lnum > @curbuf.b_ml.ml_line_count)
;                   {
;                       @curwin.w_cursor.lnum = @curbuf.b_ml.ml_line_count;
;                       coladvance(MAXCOL);
;                   }
;                   validate_cursor();
;                   COPY_pos(end_pos, @curwin.w_cursor);
;                   COPY_pos(@curwin.w_cursor, save_pos);
;               }
;               else
;                   COPY_pos(end_pos, @curwin.w_cursor);

;               validate_cursor();
                ;; May redraw the status line to show the cursor position.
;               if (@p_ru && 0 < @curwin.w_status_height)
;                   @curwin.w_redr_status = true;

;               save_cmdline(save_cli);
;               update_screen(SOME_VALID);
;               restore_cmdline(save_cli);

                ;; Leave it at the end to make CTRL-R CTRL-W work.
;               if (i != 0)
;                   COPY_pos(@curwin.w_cursor, end_pos);

;               msg_starthere();
;               redrawcmdline();
;               did_incsearch = true;
;           }

;           if (@cmdmsg_rl)
                ;; Always redraw the whole command line to fix shaping and right-left typing.
                ;; Not efficient, but it works.  Do it only when there are no characters left
                ;; to read to avoid useless intermediate redraws.
;               if (vpeekc() == NUL)
;                   redrawcmd();
;       }

;       @cmdmsg_rl = false;

;       if (did_incsearch)
;       {
;           COPY_pos(@curwin.w_cursor, old_cursor);
;           @curwin.w_curswant = old_curswant;
;           @curwin.w_leftcol = old_leftcol;
;           @curwin.w_topline = old_topline;
;           @curwin.w_botline = old_botline;
;           @highlight_match = false;
;           validate_cursor();      ;; needed for TAB
;           redraw_later(SOME_VALID);
;       }

;       if (@ccline.cmdbuff != null)
;       {
            ;; Put line in history buffer (":" and "=" only when it was typed).

;           if (@ccline.cmdlen != 0 && firstc != NUL && (some_key_typed || histype == HIST_SEARCH))
;           {
;               add_to_history(histype, @ccline.cmdbuff, true, histype == HIST_SEARCH ? firstc : NUL);
;               if (firstc == ':')
;                   @new_last_cmdline = STRDUP(@ccline.cmdbuff);
;           }

;           if (gotesc)         ;; abandon command line
;           {
;               @ccline.cmdbuff = null;
;               if (@msg_scrolled == 0)
;                   compute_cmdrow();
;               msg(u8(""));
;               @redraw_cmdline = true;
;           }
;       }

        ;; If the screen was shifted up, redraw the whole screen (later).
        ;; If the line is too long, clear it, so ruler and shown command
        ;; do not get printed in the middle of it.

;       msg_check();
;       @msg_scroll = save_msg_scroll;

        ;; When the command line was typed, no need for a wait-return prompt.
;       if (some_key_typed)
;           @need_wait_return = false;

;       @State = save_State;
;       setmouse();
;       ui_cursor_shape();          ;; may show different cursor shape

;       Bytes p = @ccline.cmdbuff;
        ;; Make ccline empty, getcmdline() may try to use it.
;       @ccline.cmdbuff = null;
;       return p;
    ))

;; Return true when the text must not be changed and we can't switch to
;; another window or buffer.  Used when editing the command line, evaluating
;; 'balloonexpr', etc.

(defn- #_boolean text_locked []
    (§
;       if (@cmdwin_type != 0)
;           return true;

;       return @textlock != 0;
    ))

;; Give an error message for a command that isn't allowed while the cmdline
;; window is open or editing the cmdline in another way.

(defn- #_void text_locked_msg []
    (§
;       if (@cmdwin_type != 0)
;           emsg(e_cmdwin);
;       else
;           emsg(e_secure);
    ))

;; Check if "curbuf_lock" or "allbuf_lock" is set and return true when it is
;; and give an error message.

(defn- #_boolean curbuf_locked []
    (§
;       if (0 < @curbuf_lock)
;       {
;           emsg(u8("E788: Not allowed to edit another buffer now"));
;           return true;
;       }
;       return allbuf_locked();
    ))

;; Check if "allbuf_lock" is set and return true when it is and give an error message.

(defn- #_boolean allbuf_locked []
    (§
;       if (0 < @allbuf_lock)
;       {
;           emsg(u8("E811: Not allowed to change buffer information now"));
;           return true;
;       }
;       return false;
    ))

(defn- #_int cmdline_charsize [#_int idx]
    (§
;       if (0 < @cmdline_star)           ;; showing '*', always 1 position
;           return 1;

;       return mb_ptr2cells(@ccline.cmdbuff.plus(idx));
    ))

;; Compute the offset of the cursor on the command line for the prompt and indent.

(defn- #_void set_cmdspos []
    (§
;       if (@ccline.cmdfirstc != NUL)
;           @ccline.cmdspos = 1 + @ccline.cmdindent;
;       else
;           @ccline.cmdspos = 0 + @ccline.cmdindent;
    ))

;; Compute the screen position for the cursor on the command line.

(defn- #_void set_cmdspos_cursor []
    (§
;       int i, m, c;

;       set_cmdspos();
;       if (@keyTyped)
;       {
;           m = (int)@Columns * (int)@Rows;
;           if (m < 0)      ;; overflow, Columns or Rows at weird value
;               m = MAXCOL;
;       }
;       else
;           m = MAXCOL;
;       for (i = 0; i < @ccline.cmdlen && i < @ccline.cmdpos; i++)
;       {
;           c = cmdline_charsize(i);
            ;; Count ">" for double-wide multi-byte char that doesn't fit.
;           correct_cmdspos(i, c);
            ;; If the cmdline doesn't fit, show cursor on last visible char.
            ;; Don't move the cursor itself, so we can still append.
;           if (m <= (@ccline.cmdspos += c))
;           {
;               @ccline.cmdspos -= c;
;               break;
;           }
;           i += us_ptr2len_cc(@ccline.cmdbuff.plus(i)) - 1;
;       }
    ))

;; Check if the character at "idx", which is "cells" wide, is a multi-byte
;; character that doesn't fit, so that a ">" must be displayed.

(defn- #_void correct_cmdspos [#_int idx, #_int cells]
    (§
;       if (1 < us_ptr2len_cc(@ccline.cmdbuff.plus(idx))
;                   && 1 < us_ptr2cells(@ccline.cmdbuff.plus(idx))
;                   && (int)@Columns < @ccline.cmdspos % (int)@Columns + cells)
;           @ccline.cmdspos++;
    ))

;; Get an Ex command line for the ":" command.

(defn- #_Bytes getexline [#_int c, #_Object _cookie, #_int indent]
    ;; c: normally ':', NUL for ":append"
    ;; indent: indent for inside conditionals
    (§
            ;; When executing a register, remove ':' that's in front of each line.
;       if (@exec_from_reg && vpeekc() == ':')
;           vgetc();
;       return getcmdline(c, 1L, indent);
    ))

;; Get an Ex command line for Ex mode.
;; In Ex mode we only use the OS supplied line editing features and no mappings or abbreviations.
;; Returns a string in allocated memory or null.

(defn- #_Bytes getexmodeline [#_int promptc, #_Object _cookie, #_int indent]
    ;; promptc: normally ':', NUL for ":append" and '?' for :s prompt
    ;; indent: indent for inside conditionals
    (§
            ;; Switch cursor on now.  This avoids that it happens after the "\n",
            ;; which confuses the system function that computes tabstops.
;       cursor_on();

            ;; always start in column 0; write a newline if necessary
;       compute_cmdrow();
;       if ((@msg_col != 0 || @msg_didout) && promptc != '?')
;           msg_putchar('\n');
;       int startcol = 0;
;       if (promptc == ':')
;       {
                ;; indent that is only displayed, not in the line itself
;           if (@p_prompt)
;               msg_putchar(':');
;           while (0 < indent--)
;               msg_putchar(' ');
;           startcol = @msg_col;
;       }

;       barray_C line_ba = new barray_C(30);

            ;; autoindent for :insert and :append is in the line itself
;       int vcol = 0;
;       if (promptc <= 0)
;       {
;           vcol = indent;
;           while (8 <= indent)
;           {
;               ba_append(line_ba, TAB);
;               msg_puts(u8("        "));
;               indent -= 8;
;           }
;           while (0 < indent--)
;           {
;               ba_append(line_ba, (byte)' ');
;               msg_putchar(' ');
;           }
;       }
;       @no_mapping++;
;       @allow_keys++;

;       int c1 = 0;
;       boolean escaped = false;        ;; CTRL-V typed

            ;; Get the line, one character at a time.

;       @got_int = false;
;       loop:
;       while (!@got_int)
;       {
                ;; Get one character at a time.
                ;; Don't use inchar(), it can't handle special characters.
;           int prev_char = c1;
;           c1 = vgetc();

                ;; Handle line editing.
                ;; Previously this was left to the system, putting the terminal in
                ;; cooked mode, but then CTRL-D and CTRL-T can't be used properly.

;           if (@got_int)
;           {
;               msg_putchar('\n');
;               break loop;
;           }

;           ba_grow(line_ba, 40);

;           redraw:
;           {
;               Bytes p;

;               add_indent:
;               {
;                   if (!escaped)
;                   {
                            ;; CR typed means "enter", which is NL
;                       if (c1 == '\r')
;                           c1 = '\n';

;                       if (c1 == BS || c1 == K_BS || c1 == DEL || c1 == K_DEL || c1 == K_KDEL)
;                       {
;                           if (0 < line_ba.ba_len)
;                           {
;                               p = new Bytes(line_ba.ba_data);
;                               p.be(line_ba.ba_len, NUL);
;                               int len = us_head_off(p, p.plus(line_ba.ba_len - 1)) + 1;
;                               line_ba.ba_len -= len;
;                               break redraw;
;                           }
;                           continue loop;
;                       }

;                       if (c1 == Ctrl_U)
;                       {
;                           @msg_col = startcol;
;                           msg_clr_eos();
;                           line_ba.ba_len = 0;
;                           break redraw;
;                       }

;                       if (c1 == Ctrl_T)
;                       {
;                           long sw = get_sw_value(@curbuf);
;                           p = new Bytes(line_ba.ba_data);
;                           p.be(line_ba.ba_len, NUL);
;                           indent = get_indent_str(p, 8, false);
;                           indent += sw - indent % sw;
;                           break add_indent;
;                       }

;                       if (c1 == Ctrl_D)
;                       {
                                ;; Delete one shiftwidth.
;                           p = new Bytes(line_ba.ba_data);
;                           if (prev_char == '0' || prev_char == '^')
;                           {
;                               if (prev_char == '^')
;                                   @ex_keep_indent = true;
;                               indent = 0;
;                               p.be(--line_ba.ba_len, NUL);
;                           }
;                           else
;                           {
;                               p.be(line_ba.ba_len, NUL);
;                               indent = get_indent_str(p, 8, false);
;                               if (0 < indent)
;                               {
;                                   --indent;
;                                   indent -= indent % get_sw_value(@curbuf);
;                               }
;                           }
;                           while (indent < get_indent_str(p, 8, false))
;                           {
;                               Bytes s = skipwhite(p);
;                               BCOPY(s, -1, s, 0, line_ba.ba_len - BDIFF(s, p) + 1);
;                               --line_ba.ba_len;
;                           }
;                           break add_indent;
;                       }

;                       if (c1 == Ctrl_V || c1 == Ctrl_Q)
;                       {
;                           escaped = true;
;                           continue loop;
;                       }

                            ;; Ignore special key codes: mouse movement, K_IGNORE, etc.
;                       if (is_special(c1))
;                           continue loop;
;                   }

;                   if (is_special(c1))
;                       c1 = '?';
;                   int len = utf_char2bytes(c1, new Bytes(line_ba.ba_data, line_ba.ba_len));
;                   if (c1 == '\n')
;                       msg_putchar('\n');
;                   else if (c1 == TAB)
;                   {
                            ;; Don't use chartabsize(), 'ts' can be different.
;                       do
;                       {
;                           msg_putchar(' ');
;                       } while (++vcol % 8 != 0);
;                   }
;                   else
;                   {
;                       msg_outtrans_len(new Bytes(line_ba.ba_data, line_ba.ba_len), len);
;                       vcol += mb_char2cells(c1);
;                   }
;                   line_ba.ba_len += len;
;                   escaped = false;

;                   windgoto(@msg_row, @msg_col);
;                   Bytes pend = new Bytes(line_ba.ba_data, line_ba.ba_len);

                        ;; We are done when a NL is entered, but not when it comes after
                        ;; an odd number of backslashes, that results in a NUL.
;                   if (0 < line_ba.ba_len && pend.at(-1) == (byte)'\n')
;                   {
;                       int bcount = 0;

;                       while (bcount <= line_ba.ba_len - 2 && pend.at(-2 - bcount) == (byte)'\\')
;                           bcount++;

;                       if (0 < bcount)
;                       {
                                ;; Halve the number of backslashes: "\NL" -> "NUL", "\\NL" -> "\NL", etc.
;                           line_ba.ba_len -= (bcount + 1) / 2;
;                           pend = pend.minus((bcount + 1) / 2);
;                           pend.be(-1, (byte)'\n');
;                       }

;                       if ((bcount & 1) == 0)
;                       {
;                           --line_ba.ba_len;
;                           pend = pend.minus(1);
;                           pend.be(0, NUL);
;                           break loop;
;                       }
;                   }

;                   continue loop;
;               }

;               while (get_indent_str(p, 8, false) < indent)
;               {
;                   p = new Bytes(ba_grow(line_ba, 2)); ;; one more for the NUL
;                   Bytes s = skipwhite(p);
;                   BCOPY(s, 1, s, 0, line_ba.ba_len - BDIFF(s, p) + 1);
;                   s.be(0, (byte)' ');
;                   line_ba.ba_len++;
;               }
;           }

                ;; redraw the line
;           @msg_col = startcol;
;           vcol = 0;
;           Bytes p = new Bytes(line_ba.ba_data);
;           p.be(line_ba.ba_len, NUL);
;           for (int i = 0; i < line_ba.ba_len; )
;           {
;               if (p.at(0) == TAB)
;               {
;                   do
;                   {
;                       msg_putchar(' ');
;                   } while (++vcol % 8 != 0);
;                   p = p.plus(1);
;                   i++;
;               }
;               else
;               {
;                   int len = us_ptr2len_cc(p);
;                   msg_outtrans_len(p, len);
;                   vcol += mb_ptr2cells(p);
;                   p = p.plus(len);
;                   i += len;
;               }
;           }
;           msg_clr_eos();
;           windgoto(@msg_row, @msg_col);
;       }

;       --@no_mapping;
;       --@allow_keys;

            ;; make following messages go to the next line
;       @msg_didout = false;
;       @msg_col = 0;
;       if (@msg_row < @Rows - 1)
;           @msg_row++;
;       @emsg_on_display = false;            ;; don't want ui_delay()

;       if (@got_int)
;           ba_clear(line_ba);

;       return new Bytes(line_ba.ba_data);
    ))

;; Allocate a new command line buffer.
;; Assigns the new buffer to ccline.cmdbuff and ccline.cmdbufflen.
;; Returns the new value of ccline.cmdbuff and ccline.cmdbufflen.

(defn- #_void alloc_cmdbuff [#_int len]
    (§
        ;; give some extra space to avoid having to allocate all the time

;       if (len < 80)
;           len = 100;
;       else
;           len += 20;

;       @ccline.cmdbuff = new Bytes(len);
;       @ccline.cmdbufflen = len;
    ))

;; Re-allocate the command line to length len + something extra.

(defn- #_void realloc_cmdbuff [#_int len]
    (§
;       if (len < @ccline.cmdbufflen)
;           return;                             ;; no need to resize

;       Bytes p = @ccline.cmdbuff;
;       alloc_cmdbuff(len);                     ;; will get some more
        ;; There isn't always a NUL after the command, but it may need to be there,
        ;; thus copy up to the NUL and add a NUL.
;       BCOPY(@ccline.cmdbuff, p, @ccline.cmdlen);
;       @ccline.cmdbuff.be(@ccline.cmdlen, NUL);
    ))

;; Draw part of the cmdline at the current cursor position;
;; but draw stars when cmdline_star is true.

(defn- #_void draw_cmdline [#_int start, #_int len]
    (§
;       if (0 < @cmdline_star)
;           for (int i = 0; i < len; i++)
;           {
;               msg_putchar('*');
;               i += us_ptr2len_cc(@ccline.cmdbuff.plus(start + i)) - 1;
;           }
;       else
;           msg_outtrans_len(@ccline.cmdbuff.plus(start), len);
    ))

;; Put a character on the command line.  Shifts the following text to the
;; right when "shift" is true.  Used for CTRL-V, CTRL-K, etc.
;; "c" must be printable (fit in one display cell)!

(defn- #_void putcmdline [#_int c, #_boolean shift]
    (§
;       if (@cmd_silent)
;           return;
;       @msg_no_more = true;
;       msg_putchar(c);
;       if (shift)
;           draw_cmdline(@ccline.cmdpos, @ccline.cmdlen - @ccline.cmdpos);
;       @msg_no_more = false;
;       cursorcmd();
    ))

;; Undo a putcmdline(c, false).

(defn- #_void unputcmdline []
    (§
;       if (@cmd_silent)
;           return;
;       @msg_no_more = true;
;       if (@ccline.cmdlen == @ccline.cmdpos)
;           msg_putchar(' ');
;       else
;           draw_cmdline(@ccline.cmdpos, us_ptr2len_cc(@ccline.cmdbuff.plus(@ccline.cmdpos)));
;       @msg_no_more = false;
;       cursorcmd();
    ))

;; Put the given string, of the given length, onto the command line.
;; If len is -1, then STRLEN() is used to calculate the length.
;; If 'redraw' is true then the new part of the command line, and the remaining part
;; will be redrawn, otherwise it will not.  If this function is called twice in a row,
;; then 'redraw' should be false and redrawcmd() should be called afterwards.

(defn- #_void put_on_cmdline [#_Bytes str, #_int len, #_boolean redraw]
    (§
;       if (len < 0)
;           len = STRLEN(str);

        ;; Check if ccline.cmdbuff needs to be longer.
;       if (@ccline.cmdbufflen <= @ccline.cmdlen + len + 1)
;           realloc_cmdbuff(@ccline.cmdlen + len + 1);

;       if (!@ccline.overstrike)
;       {
;           BCOPY(@ccline.cmdbuff, @ccline.cmdpos + len, @ccline.cmdbuff, @ccline.cmdpos, @ccline.cmdlen - @ccline.cmdpos);
;           @ccline.cmdlen += len;
;       }
;       else
;       {
            ;; Count nr of characters in the new string.
;           int m = 0, n;
;           for (n = 0; n < len; n += us_ptr2len_cc(str.plus(n)))
;               m++;
            ;; Count nr of bytes in cmdline that are overwritten by these characters.
;           for (n = @ccline.cmdpos; n < @ccline.cmdlen && 0 < m; n += us_ptr2len_cc(@ccline.cmdbuff.plus(n)))
;               --m;
;           if (n < @ccline.cmdlen)
;           {
;               BCOPY(@ccline.cmdbuff, @ccline.cmdpos + len, @ccline.cmdbuff, n, @ccline.cmdlen - n);
;               @ccline.cmdlen += @ccline.cmdpos + len - n;
;           }
;           else
;               @ccline.cmdlen = @ccline.cmdpos + len;
;       }
;       BCOPY(@ccline.cmdbuff, @ccline.cmdpos, str, 0, len);
;       @ccline.cmdbuff.be(@ccline.cmdlen, NUL);

        ;; When the inserted text starts with a composing character,
        ;; backup to the character before it.  There could be two of them.

;       int i = 0;
;       int c = us_ptr2char(@ccline.cmdbuff.plus(@ccline.cmdpos));
;       while (0 < @ccline.cmdpos && utf_iscomposing(c))
;       {
;           i = us_head_off(@ccline.cmdbuff, @ccline.cmdbuff.plus(@ccline.cmdpos - 1)) + 1;
;           @ccline.cmdpos -= i;
;           len += i;
;           c = us_ptr2char(@ccline.cmdbuff.plus(@ccline.cmdpos));
;       }
;       if (i != 0)
;       {
            ;; Also backup the cursor position.
;           i = mb_ptr2cells(@ccline.cmdbuff.plus(@ccline.cmdpos));
;           @ccline.cmdspos -= i;
;           @msg_col -= i;
;           if (@msg_col < 0)
;           {
;               @msg_col += (int)@Columns;
;               --@msg_row;
;           }
;       }

;       if (redraw && !@cmd_silent)
;       {
;           @msg_no_more = true;
;           i = @cmdline_row;
;           cursorcmd();
;           draw_cmdline(@ccline.cmdpos, @ccline.cmdlen - @ccline.cmdpos);
            ;; Avoid clearing the rest of the line too often.
;           if (@cmdline_row != i || @ccline.overstrike)
;               msg_clr_eos();
;           @msg_no_more = false;
;       }

;       int m;
;       if (@keyTyped)
;       {
;           m = (int)@Columns * (int)@Rows;
;           if (m < 0)      ;; overflow, Columns or Rows at weird value
;               m = MAXCOL;
;       }
;       else
;           m = MAXCOL;

;       for (i = 0; i < len; i++)
;       {
;           c = cmdline_charsize(@ccline.cmdpos);
            ;; count ">" for a double-wide char that doesn't fit.
;           correct_cmdspos(@ccline.cmdpos, c);
            ;; Stop cursor at the end of the screen, but do increment the insert position,
            ;; so that entering a very long command works, even though you can't see it.
;           if (@ccline.cmdspos + c < m)
;               @ccline.cmdspos += c;

;           c = us_ptr2len_cc(@ccline.cmdbuff.plus(@ccline.cmdpos)) - 1;
;           if (c > len - i - 1)
;               c = len - i - 1;
;           @ccline.cmdpos += c;
;           i += c;

;           @ccline.cmdpos++;
;       }

;       if (redraw)
;           msg_check();
    ))

(atom! cmdline_info_C prev_ccline)

;; Save ccline, because obtaining the "=" register may execute "normal :cmd" and overwrite it.
;; But get_cmdline_str() may need it, thus make it available globally in prev_ccline.

(defn- #_void save_cmdline [#_cmdline_info_C cli]
    (§
;       if (@prev_ccline == null)
;           @prev_ccline = §_cmdline_info_C();

;       COPY_cmdline_info(cli, @prev_ccline);
;       COPY_cmdline_info(@prev_ccline, @ccline);

;       @ccline.cmdbuff = null;
;       @ccline.cmdprompt = null;
    ))

;; Restore ccline after it has been saved with save_cmdline().

(defn- #_void restore_cmdline [#_cmdline_info_C cli]
    (§
;       COPY_cmdline_info(@ccline, @prev_ccline);
;       COPY_cmdline_info(@prev_ccline, cli);
    ))

;; Save the command line into allocated memory.
;; Returns a pointer to be passed to restore_cmdline_alloc() later.

(defn- #_cmdline_info_C save_cmdline_alloc []
    (§
;       cmdline_info_C cli = §_cmdline_info_C();
;       save_cmdline(cli);
;       return cli;
    ))

;; Restore the command line from the return value of save_cmdline_alloc().

(defn- #_void restore_cmdline_alloc [#_cmdline_info_C cli]
    (§
;       if (cli != null)
;           restore_cmdline(cli);
    ))

;; Paste a yank register into the command line.
;; Used by CTRL-R command in command-line mode.
;; insert_reg() can't be used here, because special characters
;; from the register contents will be interpreted as commands.
;;
;; return false for failure, true otherwise

(defn- #_boolean cmdline_paste [#_int regname, #_boolean literally, #_boolean remcr]
    ;; literally: Insert text literally instead of "as typed"
    ;; remcr: remove trailing CR
    (§
        ;; check for valid regname; also accept special characters for CTRL-R in the command line
;       if (regname != Ctrl_F && regname != Ctrl_P && regname != Ctrl_W && regname != Ctrl_A
;               && !valid_yank_reg(regname, false))
;           return false;

        ;; A register containing CTRL-R can cause an endless loop.
        ;; Allow using CTRL-C to break the loop.
;       line_breakcheck();
;       if (@got_int)
;           return false;

;       regname = may_get_selection(regname);

        ;; Need to save and restore ccline.  And set "textlock" to avoid nasty
        ;; things like going to another buffer when evaluating an expression.
;       cmdline_info_C save_cli = save_cmdline_alloc();
;       @textlock++;

;       Bytes[] arg = new Bytes[1];
;       boolean[] allocated = new boolean[1];
;       boolean got = get_spec_reg(regname, arg, allocated, true);

;       --@textlock;
;       restore_cmdline_alloc(save_cli);

;       if (got)
;       {
            ;; Got the value of a special register in "arg".
;           if (arg[0] == null)
;               return false;

            ;; When 'incsearch' is set and CTRL-R CTRL-W used: skip the duplicate part of the word.
;           Bytes p = arg[0];

;           if (@p_is && regname == Ctrl_W)
;           {
                ;; Locate start of last word in the cmd buffer.
;               Bytes w;
;               for (w = @ccline.cmdbuff.plus(@ccline.cmdpos); BLT(@ccline.cmdbuff, w); )
;               {
;                   int len = us_head_off(@ccline.cmdbuff, w.minus(1)) + 1;
;                   if (!vim_iswordc(us_ptr2char(w.minus(len)), @curbuf))
;                       break;
;                   w = w.minus(len);
;               }
;               int len = BDIFF(@ccline.cmdbuff.plus(@ccline.cmdpos), w);
;               if (@p_ic ? STRNCASECMP(w, arg[0], len) == 0 : STRNCMP(w, arg[0], len) == 0)
;                   p = p.plus(len);
;           }

;           cmdline_paste_str(p, literally);

;           return true;
;       }

;       return cmdline_paste_reg(regname, literally, remcr);
    ))

;; Put a string on the command line.
;; When "literally" is true, insert literally.
;; When "literally" is false, insert as typed, but don't leave the command line.

(defn- #_void cmdline_paste_str [#_Bytes _s, #_boolean literally]
    (§
;       Bytes[] s = { _s };
;       if (literally)
;           put_on_cmdline(s[0], -1, true);
;       else
;           while (s[0].at(0) != NUL)
;           {
;               int cv = s[0].at(0);
;               if (cv == Ctrl_V && s[0].at(1) != NUL)
;                   s[0] = s[0].plus(1);
;               int c = us_ptr2char_adv(s, false);
;               if (cv == Ctrl_V || c == ESC || c == Ctrl_C
;                       || c == CAR || c == NL || c == Ctrl_L
;                       || c == @intr_char
;                       || (c == Ctrl_BSL && s[0].at(0) == Ctrl_N))
;                   stuffcharReadbuff(Ctrl_V);
;               stuffcharReadbuff(c);
;           }
    ))

;; this function is called when the screen size changes and with incremental search

(defn- #_void redrawcmdline []
    (§
;       if (@cmd_silent)
;           return;

;       @need_wait_return = false;
;       compute_cmdrow();
;       redrawcmd();
;       cursorcmd();
    ))

(defn- #_void redrawcmdprompt []
    (§
;       if (@cmd_silent)
;           return;

;       if (@ccline.cmdfirstc != NUL)
;           msg_putchar(@ccline.cmdfirstc);
;       if (@ccline.cmdprompt != null)
;       {
;           msg_puts_attr(@ccline.cmdprompt, @ccline.cmdattr);
;           @ccline.cmdindent = @msg_col + (@msg_row - @cmdline_row) * (int)@Columns;
            ;; do the reverse of set_cmdspos()
;           if (@ccline.cmdfirstc != NUL)
;               --@ccline.cmdindent;
;       }
;       else
;           for (int i = @ccline.cmdindent; 0 < i; --i)
;               msg_putchar(' ');
    ))

;; Redraw what is currently on the command line.

(defn- #_void redrawcmd []
    (§
;       if (@cmd_silent)
;           return;

        ;; when 'incsearch' is set there may be no command line while redrawing
;       if (@ccline.cmdbuff == null)
;       {
;           windgoto(@cmdline_row, 0);
;           msg_clr_eos();
;           return;
;       }

;       msg_start();
;       redrawcmdprompt();

        ;; Don't use more prompt, truncate the cmdline if it doesn't fit.
;       @msg_no_more = true;
;       draw_cmdline(0, @ccline.cmdlen);
;       msg_clr_eos();
;       @msg_no_more = false;

;       set_cmdspos_cursor();

        ;; An emsg() before may have set msg_scroll.  This is used in normal mode,
        ;; in cmdline mode we can reset them now.

;       @msg_scroll = false;         ;; next message overwrites cmdline

        ;; Typing ':' at the more prompt may set skip_redraw.  We don't want this in cmdline mode.
;       @skip_redraw = false;
    ))

(defn- #_void compute_cmdrow []
    (§
;       if (@exmode_active != 0 || @msg_scrolled != 0)
;           @cmdline_row = (int)@Rows - 1;
;       else
;           @cmdline_row = @lastwin.w_winrow + @lastwin.w_height + @lastwin.w_status_height;
    ))

(defn- #_void cursorcmd []
    (§
;       if (@cmd_silent)
;           return;

;       if (@cmdmsg_rl)
;       {
;           @msg_row = @cmdline_row  + (@ccline.cmdspos / ((int)@Columns - 1));
;           @msg_col = (int)@Columns - (@ccline.cmdspos % ((int)@Columns - 1)) - 1;
;           if (@msg_row <= 0)
;               @msg_row = (int)@Rows - 1;
;       }
;       else
;       {
;           @msg_row = @cmdline_row + (@ccline.cmdspos / (int)@Columns);
;           @msg_col = @ccline.cmdspos % (int)@Columns;
;           if (@Rows <= @msg_row)
;               @msg_row = (int)@Rows - 1;
;       }

;       windgoto(@msg_row, @msg_col);
    ))

(defn- #_void gotocmdline [#_boolean clr]
    (§
;       msg_start();
;       if (@cmdmsg_rl)
;           @msg_col = (int)@Columns - 1;
;       else
;           @msg_col = 0;        ;; always start in column 0
;       if (clr)                ;; clear the bottom line(s)
;           msg_clr_eos();      ;; will reset clear_cmdline
;       windgoto(@cmdline_row, 0);
    ))

;; Check the word in front of the cursor for an abbreviation.
;; Called when the non-id character "c" has been entered.
;; When an abbreviation is recognized it is removed from the text with
;; backspaces and the replacement string is inserted, followed by "c".

(defn- #_boolean ccheck_abbr [#_int c]
    (§
;       if (@p_paste || @no_abbr)         ;; no abbreviations or in paste mode
;           return false;

;       return check_abbr(c, @ccline.cmdbuff, @ccline.cmdpos, 0);
    ))

;; Command line history stuff

;; Translate a history character to the associated type number.

(defn- #_int hist_char2type [#_int c]
    (§
;       if (c == ':')
;           return HIST_CMD;
;       if (c == '=')
;           return HIST_EXPR;
;       if (c == '@')
;           return HIST_INPUT;

;       return HIST_SEARCH;     ;; must be '?' or '/'
    ))

;; Table of history names.
;; These names are used in :history and various hist...() functions.
;; It is sufficient to give the significant prefix of a history name.

(final Bytes* history_names
    [
        (u8 "cmd"), (u8 "search"), (u8 "expr"), (u8 "input"), null
    ])

;; init_history() - Initialize the command line history.
;; Also used to re-allocate the history when the size changes.

(defn- #_void init_history []
    (§
        ;; If size of history table changed, reallocate it.

;       int newlen = (int)@p_hi;
;       if (newlen != @hislen)                                   ;; history length changed
;       {
;           for (int type = 0; type < HIST_COUNT; type++)       ;; adjust the tables
;           {
;               histentry_C[] temp = null;

;               if (newlen != 0)
;                   temp = ARRAY_histentry(newlen);

;               if (newlen == 0 || temp != null)
;               {
;                   if (@hisidx[type] < 0)                       ;; there are no entries yet
;                   {
;                       for (int i = 0; i < newlen; i++)
;                           clear_hist_entry(temp[i]);
;                   }
;                   else if (@hislen < newlen)                   ;; array becomes bigger
;                   {
;                       int i;
;                       for (i = 0; i <= @hisidx[type]; i++)
;                           COPY_histentry(temp[i], @history[type][i]);
;                       int j = i;
;                       for ( ; i <= newlen - (@hislen - @hisidx[type]); i++)
;                           clear_hist_entry(temp[i]);
;                       for ( ; j < @hislen; i++, j++)
;                           COPY_histentry(temp[i], @history[type][j]);
;                   }
;                   else                                        ;; array becomes smaller or 0
;                   {
;                       int j = @hisidx[type];
;                       for (int i = newlen - 1; ; --i)
;                       {
;                           if (0 <= i)                         ;; copy newest entries
;                               COPY_histentry(temp[i], @history[type][j]);
;                           else                                ;; remove older entries
;                               @history[type][j].hisstr = null;
;                           if (--j < 0)
;                               j = @hislen - 1;
;                           if (j == @hisidx[type])
;                               break;
;                       }
;                       @hisidx[type] = newlen - 1;
;                   }
;                   @history[type] = temp;
;               }
;           }
;           @hislen = newlen;
;       }
    ))

(defn- #_void clear_hist_entry [#_histentry_C hisptr]
    (§
;       hisptr.hisnum = 0;
;       hisptr.hisstr = null;
    ))

;; Check if command line 'str' is already in history.
;; If 'move_to_front' is true, matching entry is moved to end of history.

(defn- #_boolean in_history [#_int type, #_Bytes str, #_boolean move_to_front, #_int sep]
    ;; move_to_front: Move the entry to the front if it exists
    (§
;       if (@hisidx[type] < 0)
;           return false;

;       int last_i = -1;

;       int i = @hisidx[type];
;       do
;       {
;           if (@history[type][i].hisstr == null)
;               return false;

            ;; For search history, check that the separator character matches as well.
;           Bytes p = @history[type][i].hisstr;
;           if (STRCMP(str, p) == 0 && (type != HIST_SEARCH || sep == p.at(STRLEN(p) + 1)))
;           {
;               if (!move_to_front)
;                   return true;
;               last_i = i;
;               break;
;           }
;           if (--i < 0)
;               i = @hislen - 1;
;       } while (i != @hisidx[type]);

;       if (0 <= last_i)
;       {
;           str = @history[type][i].hisstr;
;           while (i != @hisidx[type])
;           {
;               if (@hislen <= ++i)
;                   i = 0;
;               COPY_histentry(@history[type][last_i], @history[type][i]);
;               last_i = i;
;           }
;           @history[type][i].hisnum = ++@hisnum[type];
;           @history[type][i].hisstr = str;
;           return true;
;       }

;       return false;
    ))

;; Convert history name (from table above) to its HIST_ equivalent.
;; When "name" is empty, return "cmd" history.
;; Returns -1 for unknown history name.

(defn- #_int get_histtype [#_Bytes name]
    (§
;       int len = STRLEN(name);

        ;; No argument: use current history.
;       if (len == 0)
;           return hist_char2type(@ccline.cmdfirstc);

;       for (int i = 0; history_names[i] != null; i++)
;           if (STRNCASECMP(name, history_names[i], len) == 0)
;               return i;

;       if (vim_strbyte(u8(":=@>?/"), name.at(0)) != null && name.at(1) == NUL)
;           return hist_char2type(name.at(0));

;       return -1;
    ))

(atom! int      last_maptick -1)      ;; last seen maptick

;; Add the given string to the given history.  If the string is already in the
;; history then it is moved to the front.  "histype" may be one of he HIST_ values.

(defn- #_void add_to_history [#_int histype, #_Bytes new_entry, #_boolean in_map, #_int sep]
    ;; in_map: consider maptick when inside a mapping
    ;; sep: separator character used (search hist)
    (§
;       if (@hislen == 0)            ;; no history
;           return;

;       if (@cmdmod.keeppatterns && histype == HIST_SEARCH)
;           return;

        ;; Searches inside the same mapping overwrite each other, so that only
        ;; the last line is kept.  Be careful not to remove a line that was moved
        ;; down, only lines that were added.

;       if (histype == HIST_SEARCH && in_map)
;       {
;           if (@maptick == @last_maptick)
;           {
                ;; Current line is from the same mapping, remove it.
;               histentry_C hisptr = @history[HIST_SEARCH][@hisidx[HIST_SEARCH]];
;               hisptr.hisstr = null;
;               clear_hist_entry(hisptr);
;               --@hisnum[histype];
;               if (--@hisidx[HIST_SEARCH] < 0)
;                   @hisidx[HIST_SEARCH] = @hislen - 1;
;           }
;           @last_maptick = -1;
;       }

;       if (!in_history(histype, new_entry, true, sep))
;       {
;           if (++@hisidx[histype] == @hislen)
;               @hisidx[histype] = 0;

;           histentry_C hisptr = @history[histype][@hisidx[histype]];

            ;; Store the separator after the NUL of the string.
;           int len = STRLEN(new_entry);
;           hisptr.hisstr = STRNDUP(new_entry, len + 2);
;           hisptr.hisstr.be(len + 1, sep);

;           hisptr.hisnum = ++@hisnum[histype];
;           if (histype == HIST_SEARCH && in_map)
;               @last_maptick = @maptick;
;       }
    ))

;; Get identifier of newest history entry.
;; "histype" may be one of the HIST_ values.

(defn- #_int get_history_idx [#_int histype]
    (§
;       if (@hislen == 0 || histype < 0 || HIST_COUNT <= histype || @hisidx[histype] < 0)
;           return -1;

;       return @history[histype][@hisidx[histype]].hisnum;
    ))

;; Get pointer to the command line info to use.
;; cmdline_paste() may clear ccline and put the previous value in prev_ccline.

(defn- #_cmdline_info_C get_ccline_ptr []
    (§
;       if ((@State & CMDLINE) == 0)
;           return null;
;       if (@ccline.cmdbuff != null)
;           return @ccline;
;       if (@prev_ccline != null && @prev_ccline.cmdbuff != null)
;           return @prev_ccline;

;       return null;
    ))

;; Get the current command line in allocated memory.
;; Only works when the command line is being edited.
;; Returns null when something is wrong.

(defn- #_Bytes get_cmdline_str []
    (§
;       cmdline_info_C p = get_ccline_ptr();
;       if (p == null)
;           return null;

;       return STRNDUP(p.cmdbuff, p.cmdlen);
    ))

;; Get the current command line position, counted in bytes.
;; Zero is the first position.
;; Only works when the command line is being edited.
;; Returns -1 when something is wrong.

(defn- #_int get_cmdline_pos []
    (§
;       cmdline_info_C p = get_ccline_ptr();
;       if (p == null)
;           return -1;

;       return p.cmdpos;
    ))

;; Set the command line byte position to "pos".
;; Zero is the first position.
;; Only works when the command line is being edited.
;; Returns 1 when failed, 0 when OK.

(defn- #_int set_cmdline_pos [#_int pos]
    (§
;       cmdline_info_C p = get_ccline_ptr();
;       if (p == null)
;           return 1;

        ;; The position is not set directly but after CTRL-\ e or CTRL-R = has changed the command line.
;       if (pos < 0)
;           @new_cmdpos = 0;
;       else
;           @new_cmdpos = pos;
;       return 0;
    ))

;; Get the current command-line type.
;; Returns ':' or '/' or '?' or '@' or '>' or '-'
;; Only works when the command line is being edited.
;; Returns NUL when something is wrong.

(defn- #_int get_cmdline_type []
    (§
;       cmdline_info_C p = get_ccline_ptr();

;       if (p == null)
;           return NUL;
;       if (p.cmdfirstc == NUL)
;           return '-';

;       return p.cmdfirstc;
    ))

;; Calculate history index from a number:
;;   num > 0: seen as identifying number of a history entry
;;   num < 0: relative position in history wrt newest entry
;; "histype" may be one of the HIST_ values.

(defn- #_int calc_hist_idx [#_int histype, #_int num]
    (§
;       int i;
;       if (@hislen == 0 || histype < 0 || HIST_COUNT <= histype || (i = @hisidx[histype]) < 0 || num == 0)
;           return -1;

;       boolean wrapped = false;

;       histentry_C[] hist = @history[histype];
;       if (0 < num)
;       {
;           while (num < hist[i].hisnum)
;               if (--i < 0)
;               {
;                   if (wrapped)
;                       break;
;                   i += @hislen;
;                   wrapped = true;
;               }
;           if (hist[i].hisnum == num && hist[i].hisstr != null)
;               return i;
;       }
;       else if (-num <= @hislen)
;       {
;           i += num + 1;
;           if (i < 0)
;               i += @hislen;
;           if (hist[i].hisstr != null)
;               return i;
;       }

;       return -1;
    ))

;; Get a history entry by its index.
;; "histype" may be one of the HIST_ values.

(defn- #_Bytes get_history_entry [#_int histype, #_int idx]
    (§
;       idx = calc_hist_idx(histype, idx);
;       if (0 <= idx)
;           return @history[histype][idx].hisstr;

;       return u8("");
    ))

;; Clear all entries of a history.
;; "histype" may be one of the HIST_ values.

(defn- #_boolean clr_history [#_int histype]
    (§
;       if (@hislen != 0 && 0 <= histype && histype < HIST_COUNT)
;       {
;           histentry_C[] hist = @history[histype];
;           for (int i = @hislen; 0 < i--; )
;           {
;               hist[i].hisstr = null;
;               clear_hist_entry(hist[i]);
;           }
;           @hisidx[histype] = -1;   ;; mark history as cleared
;           @hisnum[histype] = 0;    ;; reset identifier counter
;           return true;
;       }

;       return false;
    ))

;; Remove all entries matching {str} from a history.
;; "histype" may be one of the HIST_ values.

(defn- #_boolean del_history_entry [#_int histype, #_Bytes str]
    (§
;       boolean found = false;

;       regmatch_C regmatch = §_regmatch_C();
;       regmatch.regprog = null;
;       regmatch.rm_ic = false;     ;; always match case

;       int idx;
;       if (@hislen != 0
;               && 0 <= histype
;               && histype < HIST_COUNT
;               && str.at(0) != NUL
;               && 0 <= (idx = @hisidx[histype])
;               && (regmatch.regprog = vim_regcomp(str, RE_MAGIC + RE_STRING)) != null)
;       {
;           int last = idx;
;           int i = last;
;           do
;           {
;               histentry_C hisptr = @history[histype][i];
;               if (hisptr.hisstr == null)
;                   break;
;               if (vim_regexec(regmatch, hisptr.hisstr, 0))
;               {
;                   found = true;
;                   hisptr.hisstr = null;
;                   clear_hist_entry(hisptr);
;               }
;               else
;               {
;                   if (i != last)
;                   {
;                       COPY_histentry(@history[histype][last], hisptr);
;                       clear_hist_entry(hisptr);
;                   }
;                   if (--last < 0)
;                       last += @hislen;
;               }
;               if (--i < 0)
;                   i += @hislen;
;           } while (i != idx);

;           if (@history[histype][idx].hisstr == null)
;               @hisidx[histype] = -1;
;       }

;       return found;
    ))

;; Remove an indexed entry from a history.
;; "histype" may be one of the HIST_ values.

(defn- #_boolean del_history_idx [#_int histype, #_int idx]
    (§
;       int i = calc_hist_idx(histype, idx);
;       if (i < 0)
;           return false;

;       idx = @hisidx[histype];
;       @history[histype][i].hisstr = null;

        ;; When deleting the last added search string in a mapping, reset
        ;; last_maptick, so that the last added search string isn't deleted again.

;       if (histype == HIST_SEARCH && @maptick == @last_maptick && i == idx)
;           @last_maptick = -1;

;       while (i != idx)
;       {
;           int j = (i + 1) % @hislen;
;           COPY_histentry(@history[histype][i], @history[histype][j]);
;           i = j;
;       }
;       clear_hist_entry(@history[histype][i]);
;       if (--i < 0)
;           i += @hislen;
;       @hisidx[histype] = i;

;       return true;
    ))

;; Get indices "num1,num2" that specify a range within a list (not a range of
;; text lines in a buffer!) from a string.  Used for ":history" and ":clist".
;; Returns true if parsed successfully, otherwise false.

(defn- #_boolean get_list_range [#_Bytes* str, #_int* num1, #_int* num2]
    (§
;       boolean first = false;

;       str[0] = skipwhite(str[0]);
;       if (str[0].at(0) == (byte)'-' || asc_isdigit(str[0].at(0)))     ;; parse "from" part of range
;       {
;           int[] len = new int[1];
;           long[] num = new long[1];
;           vim_str2nr(str[0], null, len, FALSE, FALSE, num);
;           str[0] = str[0].plus(len[0]);
;           num1[0] = (int)num[0];
;           first = true;
;       }
;       str[0] = skipwhite(str[0]);
;       if (str[0].at(0) == (byte)',')                  ;; parse "to" part of range
;       {
;           str[0] = skipwhite(str[0].plus(1));
;           int[] len = new int[1];
;           long[] num = new long[1];
;           vim_str2nr(str[0], null, len, FALSE, FALSE, num);
;           if (0 < len[0])
;           {
;               num2[0] = (int)num[0];
;               str[0] = skipwhite(str[0].plus(len[0]));
;           }
;           else if (!first)                ;; no number given at all
;               return false;
;       }
;       else if (first)                     ;; only one number given
;           num2[0] = num1[0];

;       return true;
    ))

;; :history command - print a history

(defn- #_void ex_history [#_exarg_C eap]
    (§
;       int histype1 = HIST_CMD;
;       int histype2 = HIST_CMD;
;       int[] hisidx1 = { 1 };
;       int[] hisidx2 = { -1 };

;       Bytes arg = eap.arg;

;       if (@hislen == 0)
;       {
;           msg(u8("'history' option is zero"));
;           return;
;       }

;       Bytes[] end = new Bytes[1];
;       if (!(asc_isdigit(arg.at(0)) || arg.at(0) == (byte)'-' || arg.at(0) == (byte)','))
;       {
;           end[0] = arg;
;           while (asc_isalpha(end[0].at(0)) || vim_strbyte(u8(":=@>/?"), end[0].at(0)) != null)
;               end[0] = end[0].plus(1);
;           byte save_end = end[0].at(0);
;           end[0].be(0, NUL);
;           histype1 = get_histtype(arg);
;           if (histype1 == -1)
;           {
;               if (STRNCASECMP(arg, u8("all"), STRLEN(arg)) == 0)
;               {
;                   histype1 = 0;
;                   histype2 = HIST_COUNT-1;
;               }
;               else
;               {
;                   end[0].be(0, save_end);
;                   emsg(e_trailing);
;                   return;
;               }
;           }
;           else
;               histype2 = histype1;
;           end[0].be(0, save_end);
;       }
;       else
;           end[0] = arg;
;       if (!get_list_range(end, hisidx1, hisidx2) || end[0].at(0) != NUL)
;       {
;           emsg(e_trailing);
;           return;
;       }

;       for ( ; !@got_int && histype1 <= histype2; ++histype1)
;       {
;           STRCPY(@ioBuff, u8("\n      #  "));
;           STRCAT(STRCAT(@ioBuff, history_names[histype1]), u8(" history"));
;           msg_puts_title(@ioBuff);
;           int idx = @hisidx[histype1];
;           histentry_C[] hist = @history[histype1];
;           int j = hisidx1[0];
;           if (j < 0)
;               j = (@hislen < -j) ? 0 : hist[(@hislen+j+idx+1) % @hislen].hisnum;
;           int k = hisidx2[0];
;           if (k < 0)
;               k = (@hislen < -k) ? 0 : hist[(@hislen+k+idx+1) % @hislen].hisnum;
;           if (0 <= idx && j <= k)
;               for (int i = idx + 1; !@got_int; i++)
;               {
;                   if (i == @hislen)
;                       i = 0;
;                   if (hist[i].hisstr != null && j <= hist[i].hisnum && hist[i].hisnum <= k)
;                   {
;                       msg_putchar('\n');
;                       libC.sprintf(@ioBuff, u8("%c%6d  "), (i == idx) ? (byte)'>' : (byte)' ', hist[i].hisnum);
;                       if ((int)@Columns - 10 < mb_string2cells(hist[i].hisstr, -1))
;                           trunc_string(hist[i].hisstr, @ioBuff.plus(STRLEN(@ioBuff)),
;                               (int)@Columns - 10, IOSIZE - STRLEN(@ioBuff));
;                       else
;                           STRCAT(@ioBuff, hist[i].hisstr);
;                       msg_outtrans(@ioBuff);
;                       out_flush();
;                   }
;                   if (i == idx)
;                       break;
;               }
;       }
    ))

;; Open a window on the current command line and history.  Allow editing in
;; the window.  Returns when the window is closed.
;; Returns:
;;      CR       if the command is to be executed
;;      Ctrl_C   if it is to be abandoned
;;      K_IGNORE if editing continues

(defn- #_int ex_window []
    (§
;       buffer_C old_curbuf = @curbuf;
;       window_C old_curwin = @curwin;

;       int save_restart_edit = @restart_edit;
;       int save_State = @State;
;       int save_exmode = @exmode_active;
;       boolean save_cmdmsg_rl = @cmdmsg_rl;

        ;; Can't do this recursively.  Can't do it when typing a password.
;       if (@cmdwin_type != 0 || 0 < @cmdline_star)
;       {
;           beep_flush();
;           return K_IGNORE;
;       }

        ;; Save current window sizes.
;       iarray_C winsizes = new iarray_C(1);
;       win_size_save(winsizes);

        ;; Create a window for the command-line buffer.
;       if (win_split((int)@p_cwh, WSP_BOT) == false)
;       {
;           beep_flush();
;           return K_IGNORE;
;       }
;       @cmdwin_type = get_cmdline_type();

        ;; Create the command-line buffer empty.
;       do_ecmd(null, null, ECMD_ONE, ECMD_HIDE, null);
;       setfname(@curbuf, u8("[Command Line]"), true);
;       set_option_value(u8("bt"), 0L, u8("nofile"), OPT_LOCAL);
;       @curbuf.@b_p_ma = true;
;       @curwin.w_onebuf_opt.@wo_rl = @cmdmsg_rl;
;       @cmdmsg_rl = false;
;       @curwin.w_onebuf_opt.@wo_scb = false;
;       @curwin.w_onebuf_opt.@wo_crb = false;

        ;; Showing the prompt may have set need_wait_return, reset it.
;       @need_wait_return = false;

;       int histtype = hist_char2type(@cmdwin_type);
;       if (histtype == HIST_CMD)
;       {
;           if (@p_wc == TAB)
;           {
;               add_map(u8("<buffer> <Tab> <C-X><C-V>"), INSERT);
;               add_map(u8("<buffer> <Tab> a<C-X><C-V>"), NORMAL);
;           }
;           set_option_value(u8("ft"), 0L, u8("vim"), OPT_LOCAL);
;       }

        ;; Reset 'textwidth' after setting 'filetype' (the Vim filetype plugin sets 'textwidth' to 78).
;       @curbuf.@b_p_tw = 0;

        ;; Fill the buffer with the history.
;       init_history();
;       if (0 < @hislen)
;       {
;           int i = @hisidx[histtype];
;           if (0 <= i)
;           {
;               long lnum = 0;
;               do
;               {
;                   if (++i == @hislen)
;                       i = 0;
;                   if (@history[histtype][i].hisstr != null)
;                       ml_append(lnum++, @history[histtype][i].hisstr, 0, false);
;               } while (i != @hisidx[histtype]);
;           }
;       }

        ;; Replace the empty last line with the current command-line and put the cursor there.
;       ml_replace(@curbuf.b_ml.ml_line_count, @ccline.cmdbuff, true);
;       @curwin.w_cursor.lnum = @curbuf.b_ml.ml_line_count;
;       @curwin.w_cursor.col = @ccline.cmdpos;
;       changed_line_abv_curs();
;       invalidate_botline();
;       redraw_later(SOME_VALID);

        ;; Save the command line info, can be used recursively.
;       cmdline_info_C save_cli = §_cmdline_info_C();
;       COPY_cmdline_info(save_cli, @ccline);
;       @ccline.cmdbuff = null;
;       @ccline.cmdprompt = null;

        ;; No Ex mode here!
;       @exmode_active = 0;

;       @State = NORMAL;
;       setmouse();

;       if (@restart_edit != 0)      ;; autocmd with ":startinsert"
;           stuffcharReadbuff(K_NOP);

;       int i = @redrawingDisabled;
;       @redrawingDisabled = 0;

        ;; Call the main loop until <CR> or CTRL-C is typed.

;       @cmdwin_result = 0;
;       main_loop(true, false);

;       @redrawingDisabled = i;

        ;; Restore the command line info.
;       COPY_cmdline_info(@ccline, save_cli);
;       @cmdwin_type = 0;

;       @exmode_active = save_exmode;

        ;; Safety check: The old window or buffer was deleted: It's a bug when this happens!
;       if (!win_valid(old_curwin) || !buf_valid(old_curbuf))
;       {
;           @cmdwin_result = Ctrl_C;
;           emsg(u8("E199: Active window or buffer deleted"));
;       }
;       else
;       {
            ;; autocmds may abort script processing
;           if (aborting() && @cmdwin_result != K_IGNORE)
;               @cmdwin_result = Ctrl_C;

            ;; Set the new command line from the cmdline buffer.
;           if (@cmdwin_result == K_XF1 || @cmdwin_result == K_XF2) ;; :qa[!] typed
;           {
;               Bytes p = (@cmdwin_result == K_XF2) ? u8("qa") : u8("qa!");

;               if (histtype == HIST_CMD)
;               {
                    ;; Execute the command directly.
;                   @ccline.cmdbuff = STRDUP(p);
;                   @cmdwin_result = CAR;
;               }
;               else
;               {
                    ;; First need to cancel what we were doing.
;                   @ccline.cmdbuff = null;
;                   stuffcharReadbuff(':');
;                   stuffReadbuff(p);
;                   stuffcharReadbuff(CAR);
;               }
;           }
;           else if (@cmdwin_result == K_XF2)        ;; :qa typed
;           {
;               @ccline.cmdbuff = STRDUP(u8("qa"));
;               @cmdwin_result = CAR;
;           }
;           else if (@cmdwin_result == Ctrl_C)
;           {
                ;; :q or :close, don't execute any command and don't modify the cmd window.
;               @ccline.cmdbuff = null;
;           }
;           else
;               @ccline.cmdbuff = STRDUP(ml_get_curline());

;           if (@ccline.cmdbuff == null)
;               @cmdwin_result = Ctrl_C;
;           else
;           {
;               @ccline.cmdlen = STRLEN(@ccline.cmdbuff);
;               @ccline.cmdbufflen = @ccline.cmdlen + 1;
;               @ccline.cmdpos = @curwin.w_cursor.col;
;               if (@ccline.cmdlen < @ccline.cmdpos)
;                   @ccline.cmdpos = @ccline.cmdlen;
;               if (@cmdwin_result == K_IGNORE)
;               {
;                   set_cmdspos_cursor();
;                   redrawcmd();
;               }
;           }

;           window_C wp = @curwin;
;           buffer_C bp = @curbuf;
;           win_goto(old_curwin);
;           win_close(wp, true);

            ;; win_close() may have already wiped the buffer when 'bh' is set to 'wipe'
;           if (buf_valid(bp))
;               close_buffer(null, bp, DOBUF_WIPE, false);

            ;; Restore window sizes.
;           win_size_restore(winsizes);
;       }

;       @restart_edit = save_restart_edit;
;       @cmdmsg_rl = save_cmdmsg_rl;

;       @State = save_State;
;       setmouse();

;       return @cmdwin_result;
    ))

;; Used for commands that either take a simple command string argument, or:
;;      cmd << endmarker
;;        {script}
;;      endmarker
;; Returns a pointer to allocated memory with {script} or null.

(defn- #_Bytes script_get [#_exarg_C eap, #_Bytes cmd]
    (§
;       if (cmd.at(0) != (byte)'<' || cmd.at(1) != (byte)'<' || eap.getline == null)
;           return null;

;       barray_C ba = new barray_C(0x400);

;       Bytes dot = u8(".");

;       Bytes end_pattern;
;       if (cmd.at(2) != NUL)
;           end_pattern = skipwhite(cmd.plus(2));
;       else
;           end_pattern = dot;

;       for ( ; ; )
;       {
;           Bytes line = eap.getline(NUL, eap.cookie, 0);

;           if (line == null || STRCMP(end_pattern, line) == 0)
;               break;

;           ba_concat(ba, line);
;           ba_append(ba, (byte)'\n');
;       }
;       ba_append(ba, NUL);

;       return new Bytes(ba.ba_data);
    ))

;; ex_docmd.c: functions for executing an Ex command line -----------------------------------------

(atom! int      quitmore)
(atom! boolean  ex_pressedreturn)

;;; ============================================================================================== VimI

;; This file defines the Ex commands.
;;
;; When adding an Ex command:
;; 1. Add an entry in the table below.  Keep it sorted on the shortest
;;    version of the command name that works.  If it doesn't start with a
;;    lower case letter, add it at the end.
;; 2. Add a "case: CMD_xxx" in the big switch in ex_docmd.c.

;; This array maps ex command names to command codes.
;; The order in which command names are listed below is significant --
;; ambiguous abbreviations are always resolved to be the first possible match
;; (e.g. "r" is taken to mean "read", not "rewind", because "read" comes before "rewind").
;; Not supported commands are included to avoid ambiguities.

(class! #_final cmdname_C
    [
        (field Bytes        cmd_name)       ;; name of the command
        (field ex_func_F    cmd_func)       ;; function for this command
        (field long         cmd_argt)       ;; flags declared above
        (field int          cmd_addr_type)  ;; flag for address type
    ])

;; ----------------------------------------------------------------------- ;;

;; Table used to quickly search for a command, based on its first character.

(final int* cmdidxs
    [
        CMD_append,
        CMD_buffer,
        CMD_change,
        CMD_delete,
        CMD_edit,
        CMD_fixdel,
        CMD_global,
        CMD_hide,
        CMD_insert,
        CMD_join,
        CMD_k,
        CMD_list,
        CMD_move,
        CMD_new,
        CMD_omap,
        CMD_print,
        CMD_quit,
        CMD_redo,
        CMD_substitute,
        CMD_t,
        CMD_undo,
        CMD_vglobal,
        CMD_wincmd,
        CMD_xmap,
        CMD_yank,
        CMD_z,
        CMD_pound
    ])

;; do_exmode(): Repeatedly get commands for the "Ex" mode, until the ":vi" command is given.

(defn- #_void do_exmode [#_boolean improved]
    ;; improved: true for "improved Ex" mode
    (§
;       if (improved)
;           @exmode_active = EXMODE_VIM;
;       else
;           @exmode_active = EXMODE_NORMAL;
;       @State = NORMAL;

        ;; When using ":global /pat/ visual" and then "Q" we return to continue the :global command.
;       if (@global_busy != 0)
;           return;

;       boolean save_msg_scroll = @msg_scroll;
;       @redrawingDisabled++;            ;; don't redisplay the window
;       @no_wait_return++;               ;; don't wait for return

;       msg(u8("Entering Ex mode.  Type \"visual\" to go to Normal mode."));
;       while (@exmode_active != 0)
;       {
            ;; Check for a ":normal" command and no more characters left.
;           if (0 < @ex_normal_busy && @typebuf.tb_len == 0)
;           {
;               @exmode_active = 0;
;               break;
;           }
;           @msg_scroll = true;
;           @need_wait_return = false;
;           @ex_pressedreturn = false;
;           @ex_no_reprint = false;
;           int changedtick = @curbuf.b_changedtick;
;           int prev_msg_row = @msg_row;
;           long prev_line = @curwin.w_cursor.lnum;
;           if (improved)
;           {
;               @cmdline_row = @msg_row;
;               do_cmdline(null, getexline, null, 0);
;           }
;           else
;               do_cmdline(null, getexmodeline, null, DOCMD_NOWAIT);
;           @lines_left = (int)@Rows - 1;

;           if ((prev_line != @curwin.w_cursor.lnum || changedtick != @curbuf.b_changedtick) && !@ex_no_reprint)
;           {
;               if ((@curbuf.b_ml.ml_flags & ML_EMPTY) != 0)
;                   emsg(e_emptybuf);
;               else
;               {
;                   if (@ex_pressedreturn)
;                   {
                        ;; Go up one line, to overwrite the ":<CR>" line,
                        ;; so the output doesn't contain empty lines.
;                       @msg_row = prev_msg_row;
;                       if (prev_msg_row == (int)@Rows - 1)
;                           @msg_row--;
;                   }
;                   @msg_col = 0;
;                   print_line_no_prefix(@curwin.w_cursor.lnum, false, false);
;                   msg_clr_eos();
;               }
;           }
;           else if (@ex_pressedreturn && !@ex_no_reprint)    ;; must be at EOF
;           {
;               if ((@curbuf.b_ml.ml_flags & ML_EMPTY) != 0)
;                   emsg(e_emptybuf);
;               else
;                   emsg(u8("E501: At end-of-file"));
;           }
;       }

;       --@redrawingDisabled;
;       --@no_wait_return;
;       update_screen(CLEAR);
;       @need_wait_return = false;
;       @msg_scroll = save_msg_scroll;
    ))

;; Execute a simple command line.  Used for translated commands like "*".

(defn- #_boolean do_cmdline_cmd [#_Bytes cmd]
    (§
;       return do_cmdline(cmd, null, null, DOCMD_VERBOSE|DOCMD_NOWAIT|DOCMD_KEYTYPED);
    ))

(atom! int _0_recurse)              ;; recursive depth
(atom! int call_depth)              ;; recursiveness

;; do_cmdline(): execute one Ex command line
;;
;; 1. Execute "cmdline" when it is not null.
;;    If "cmdline" is null, or more lines are needed, fgetline() is used.
;; 2. Split up in parts separated with '|'.
;;
;; This function can be called recursively!
;;
;; flags:
;; DOCMD_VERBOSE  - The command will be included in the error message.
;; DOCMD_NOWAIT   - Don't call wait_return() and friends.
;; DOCMD_REPEAT   - Repeat execution until fgetline() returns null.
;; DOCMD_KEYTYPED - Don't reset keyTyped.
;; DOCMD_KEEPLINE - Store first typed line (for repeating with ".").
;;
;; return false if cmdline could not be executed, true otherwise

(defn- #_boolean do_cmdline [#_Bytes cmdline, #_getline_F fgetline, #_Object cookie, #_int flags]
    ;; cookie: argument for fgetline()
    (§
;       boolean retval = true;

;       boolean used_getline = false;               ;; used "fgetline" to obtain command

;       boolean msg_didout_before_start = false;
;       int count = 0;                              ;; line number count
;       boolean did_inc = false;                    ;; incremented redrawingDisabled

        ;; For every pair of do_cmdline()/do_one_cmd() calls, use an extra memory
        ;; location for storing error messages to be converted to an exception.
        ;; This ensures that the do_errthrow() call in do_one_cmd() does not
        ;; combine the messages stored by an earlier invocation of do_one_cmd()
        ;; with the command name of the later one.  This would happen when
        ;; BufWritePost autocommands are executed after a write error.
;       msglist_C[] saved_msg_list = @msg_list;
;       @msg_list = { null };

        ;; It's possible to create an endless loop with ":execute", catch that here.
        ;; The value of 200 allows nested function calls, ":source", etc.
;       if (@call_depth == 200)
;       {
;           emsg(u8("E169: Command too recursive"));
            ;; When converting to an exception, we do not include the command name
            ;; since this is not an error of the specific command.
;           do_errthrow(false, null);
;           @msg_list = saved_msg_list;
;           return false;
;       }
;       @call_depth++;

        ;; Initialize "force_abort" and "suppress_errthrow" at the top level.

;       if (@_0_recurse == 0)
;       {
;           @force_abort = false;
;           @suppress_errthrow = false;
;       }

        ;; "did_throw" will be set to true when an exception is being thrown.

;       @did_throw = false;

        ;; "did_emsg" will be set to true when emsg() is used,
        ;; in which case we cancel the whole command line, and any if/endif or loop.
        ;; If force_abort is set, we cancel everything.

;       @did_emsg = false;

        ;; keyTyped is only set when calling vgetc().
        ;; Reset it here when not calling vgetc() (sourced command lines).

;       if ((flags & DOCMD_KEYTYPED) == 0 && fgetline != getexline)
;           @keyTyped = false;

;       Bytes[] cmdline_copy = { null };                ;; copy of cmd line

        ;; Continue executing command lines:
        ;; - when inside an ":if", ":while" or ":for"
        ;; - for multiple commands on one line, separated with '|'
        ;; - when repeating until there are no more lines (for ":source")

;       Bytes next_cmdline = cmdline;
;       do
;       {
            ;; stop skipping cmds for an error msg after all endif/while/for
;           if (next_cmdline == null && !@force_abort)
;               @did_emsg = false;

            ;; "fgetline" and "cookie" passed to do_one_cmd()
;           getline_F cmd_getline = fgetline;
;           Object cmd_cookie = cookie;

            ;; 2. If no line given, get an allocated line with fgetline().
;           if (next_cmdline == null)
;           {
                ;; Need to set msg_didout for the first line after an ":if",
                ;; otherwise the ":if" will be overwritten.

;               if (count == 1 && fgetline == getexline)
;                   @msg_didout = true;
;               if (fgetline == null || (next_cmdline = fgetline(':', cookie, 0)) == null)
;               {
                    ;; Don't call wait_return for aborted command line.  The null
                    ;; returned for the end of a sourced file or executed function
                    ;; doesn't do this.
;                   if (@keyTyped && (flags & DOCMD_REPEAT) == 0)
;                       @need_wait_return = false;
;                   retval = false;
;                   break;
;               }
;               used_getline = true;

                ;; Keep the first typed line.  Clear it when more lines are typed.

;               if ((flags & DOCMD_KEEPLINE) != 0)
;               {
;                   if (count == 0)
;                       @repeat_cmdline = STRDUP(next_cmdline);
;                   else
;                       @repeat_cmdline = null;
;               }
;           }

            ;; 3. Make a copy of the command so we can mess with it.
;           else if (cmdline_copy[0] == null)
;           {
;               next_cmdline = STRDUP(next_cmdline);
;           }
;           cmdline_copy[0] = next_cmdline;

;           if (count++ == 0)
;           {
                ;; All output from the commands is put below each other, without waiting for a return.
                ;; Don't do this when executing commands from a script or when being called recursive
                ;; (e.g. for ":e +command file").

;               if ((flags & DOCMD_NOWAIT) == 0 && @_0_recurse == 0)
;               {
;                   msg_didout_before_start = @msg_didout;
;                   @msg_didany = false; ;; no output yet
;                   msg_start();
;                   @msg_scroll = true;  ;; put messages below each other
;                   @no_wait_return++;   ;; don't wait for return until finished
;                   @redrawingDisabled++;
;                   did_inc = true;
;               }
;           }

            ;; 2. Execute one '|' separated command.
            ;;    do_one_cmd() will return null if there is no trailing '|'.
            ;;    "cmdline_copy" can change, e.g. for '%' and '#' expansion.

;           @_0_recurse++;
;           next_cmdline = do_one_cmd(cmdline_copy, (flags & DOCMD_VERBOSE) != 0, cmd_getline, cmd_cookie);
;           --@_0_recurse;

;           if (next_cmdline == null)
;           {
;               cmdline_copy[0] = null;

                ;; If the command was typed, remember it for the ':' register.
                ;; Do this AFTER executing the command to make :@: work.

;               if (fgetline == getexline && @new_last_cmdline != null)
;               {
;                   @last_cmdline = @new_last_cmdline;
;                   @new_last_cmdline = null;
;               }
;           }
;           else
;           {
                ;; Need to copy the command after the '|' to 'cmdline_copy',
                ;; for the next do_one_cmd().
;               BCOPY(cmdline_copy[0], next_cmdline, STRLEN(next_cmdline) + 1);
;               next_cmdline = cmdline_copy[0];
;           }

            ;; If the outermost try conditional (across function calls and sourced files)
            ;; is aborted because of an error, an interrupt, or an uncaught exception,
            ;; cancel everything.  If it is left normally, reset force_abort to get
            ;; the non-EH compatible abortion behavior for the rest of the script.

;           if (!@did_emsg && !@got_int && !@did_throw)
;               @force_abort = false;

            ;; Convert an interrupt to an exception if appropriate.
;           do_intthrow();
;       }

        ;; Continue executing command lines when:
        ;; - no CTRL-C typed, no aborting error, no exception thrown or try conditionals need
        ;;   to be checked for executing finally clauses or catching an interrupt exception
        ;; - didn't get an error message or lines are not typed
        ;; - there is a command after '|', inside a :if, :while, :for or :try, or looping
        ;;   for ":source" command or function call.

;       while (!(@got_int || (@did_emsg && @force_abort) || @did_throw)
;               && !(@did_emsg
;                   && used_getline
;                           && (fgetline == getexmodeline || fgetline == getexline))
;               && (next_cmdline != null
;                           || (flags & DOCMD_REPEAT) != 0))
;           ;

;       @did_emsg_syntax = false;

        ;; If a missing ":endtry", ":endwhile", ":endfor", or ":endif" or a memory
        ;; lack was reported above and the error message is to be converted to an
        ;; exception, do this now after rewinding the cstack.
;       do_errthrow(true, null);

;       {
            ;; When an exception is being thrown out of the outermost try conditional,
            ;; discard the uncaught exception, disable the conversion of interrupts
            ;; or errors to exceptions, and ensure that no more commands are executed.

;           if (@did_throw)
;           {
;               Bytes p = null;
;               msglist_C messages = null;

                ;; If the uncaught exception is a user exception, report it as an error.
                ;; If it is an error exception, display the saved error message now.
                ;; For an interrupt exception, do nothing; the interrupt message is given elsewhere.

;               switch (@current_exception.type)
;               {
;                   case ET_USER:
;                       vim_snprintf(@ioBuff, IOSIZE, u8("E605: Exception not caught: %s"), @current_exception.value);
;                       p = STRDUP(@ioBuff);
;                       break;
;                   case ET_ERROR:
;                       messages = @current_exception.messages;
;                       @current_exception.messages = null;
;                       break;
;                   case ET_INTERRUPT:
;                       break;
;                   default:
;                       p = STRDUP(e_internal);
;                       break;
;               }

;               discard_current_exception();        ;; uses ioBuff if 'verbose'
;               @suppress_errthrow = true;
;               @force_abort = true;

;               if (messages != null)
;               {
;                   do
;                   {
;                       msglist_C next = messages.next;
;                       emsg(messages.msg);
;                       messages = next;
;                   } while (messages != null);
;               }
;               else if (p != null)
;               {
;                   emsg(p);
;               }
;           }

            ;; On an interrupt or an aborting error not converted to an exception,
            ;; disable the conversion of errors to exceptions.  (Interrupts are not
            ;; converted any more, here.) This enables also the interrupt message
            ;; when force_abort is set and did_emsg unset in case of an interrupt
            ;; from a finally clause after an error.

;           else if (@got_int || (@did_emsg && @force_abort))
;               @suppress_errthrow = true;
;       }

        ;; The current cstack will be freed when do_cmdline() returns.  An uncaught
        ;; exception will have to be rethrown in the previous cstack.  If a function
        ;; has just returned or a script file was just finished and the previous
        ;; cstack belongs to the same function or, respectively, script file, it
        ;; will have to be checked for finally clauses to be executed due to the
        ;; ":return" or ":finish".  This is done in do_one_cmd().

;       if (@did_throw)
;           @need_rethrow = true;

;       @msg_list = saved_msg_list;

        ;; If there was too much output to fit on the command line, ask the user to
        ;; hit return before redrawing the screen.  With the ":global" command we do
        ;; this only once after the command is finished.

;       if (did_inc)
;       {
;           --@redrawingDisabled;
;           --@no_wait_return;
;           @msg_scroll = false;

            ;; When just finished an ":if"-":else" which was typed, no need to
            ;; wait for hit-return.  Also for an error situation.

;           if (retval == false)
;           {
;               @need_wait_return = false;
;               @msg_didany = false;         ;; don't wait when restarting edit
;           }
;           else if (@need_wait_return)
;           {
                ;; The msg_start() above clears msg_didout.  The wait_return we do here
                ;; should not overwrite the command that may be shown before doing that.

;               @msg_didout |= msg_didout_before_start;
;               wait_return(FALSE);
;           }
;       }

;       --@call_depth;

;       return retval;
    ))

;; Helper function to apply an offset for buffer commands, i.e. ":bdelete", ":bwipeout", etc.
;; Returns the buffer number.

(defn- #_int compute_buffer_local_count [#_int addr_type, #_int fnum, #_int offset]
    (§
;       int count = offset;

;       buffer_C buf = @firstbuf;
;       while (buf.b_next != null && buf.b_fnum < fnum)
;           buf = buf.b_next;
;       while (count != 0)
;       {
;           count += (offset < 0) ? 1 : -1;
;           buffer_C nextbuf = (offset < 0) ? buf.b_prev : buf.b_next;
;           if (nextbuf == null)
;               break;
;           buf = nextbuf;
;           if (addr_type == ADDR_LOADED_BUFFERS)
                ;; skip over unloaded buffers
;               while (buf.b_ml.ml_mfp == null)
;               {
;                   nextbuf = (offset < 0) ? buf.b_prev : buf.b_next;
;                   if (nextbuf == null)
;                       break;
;                   buf = nextbuf;
;               }
;       }
        ;; we might have gone too far, last buffer is not loadedd
;       if (addr_type == ADDR_LOADED_BUFFERS)
;           while (buf.b_ml.ml_mfp == null)
;           {
;               buffer_C nextbuf = (0 <= offset) ? buf.b_prev : buf.b_next;
;               if (nextbuf == null)
;                   break;
;               buf = nextbuf;
;           }
;       return buf.b_fnum;
    ))

(defn- #_int current_win_nr [#_window_C win]
    (§
;       int nr = 0;

;       for (window_C wp = @firstwin; wp != null; wp = wp.w_next)
;       {
;           nr++;
;           if (wp == win)
;               break;
;       }

;       return nr;
    ))

;; Function called for command which is Not Implemented.  NI!

(defn- #_void ex_ni [#_exarg_C eap]
    (§
;       if (!eap.skip)
;           eap.errmsg = u8("E319: Sorry, the command is not available in this version");
    ))

;; Function called for script command which is Not Implemented.  NI!
;; Skips over ":perl <<EOF" constructs.

(defn- #_void ex_script_ni [#_exarg_C eap]
    (§
;       if (!eap.skip)
;           ex_ni(eap);
;       else
;           script_get(eap, eap.arg);
    ))

;; Execute one Ex command.
;;
;; If 'sourcing' is true, the command will be included in the error message.
;;
;; 1. skip comment lines and leading space
;; 2. handle command modifiers
;; 3. find the command
;; 4. parse range
;; 5. parse the command
;; 6. parse arguments
;; 7. switch on command name
;;
;; Note: "fgetline" can be null.
;;
;; This function may be called recursively!

(defn- #_Bytes do_one_cmd [#_Bytes* cmdlinep, #_boolean sourcing, #_getline_F fgetline, #_Object cookie]
    ;; cookie: argument for fgetline()
    (§
;       Bytes errormsg = null;         ;; error message
;       long verbose_save = -1;
;       boolean save_msg_scroll = @msg_scroll;
;       int save_msg_silent = -1;
;       int did_esilent = 0;
;       boolean did_sandbox = false;

;       exarg_C ea = §_exarg_C();     ;; Ex command arguments
;       ea.line1 = 1;
;       ea.line2 = 1;

        ;; When the last file has not been edited :q has to be typed twice.
;       if (@quitmore != 0)
;           --@quitmore;

        ;; Reset command modifiers.  They are restored when returning, for recursive calls.

;       cmdmod_C save_cmdmod = §_cmdmod_C();
;       COPY_cmdmod(save_cmdmod, @cmdmod);
;       ZER0_cmdmod(@cmdmod);

;       doend:
;       {
            ;; "#!anything" is handled like a comment.
;           if (cmdlinep[0].at(0) == (byte)'#' && cmdlinep[0].at(1) == (byte)'!')
;               break doend;

            ;; Repeat until no more command modifiers are found.

;           ea.cmd = cmdlinep[0];
;           for ( ; ; )
;           {
                ;; 1. Skip comment lines and leading white space and colons.

;               while (ea.cmd.at(0) == (byte)' ' || ea.cmd.at(0) == (byte)'\t' || ea.cmd.at(0) == (byte)':')
;                   ea.cmd = ea.cmd.plus(1);

                ;; in ex mode, an empty line works like :+
;               if (ea.cmd.at(0) == NUL && @exmode_active != 0
;                       && (fgetline == getexmodeline || fgetline == getexline)
;                       && @curwin.w_cursor.lnum < @curbuf.b_ml.ml_line_count)
;               {
;                   ea.cmd = u8("+");
;                   @ex_pressedreturn = true;
;               }

                ;; ignore comment and empty lines
;               if (ea.cmd.at(0) == (byte)'"')
;                   break doend;
;               if (ea.cmd.at(0) == NUL)
;               {
;                   @ex_pressedreturn = true;
;                   break doend;
;               }

                ;; 2. Handle command modifiers.

;               Bytes[] p = { ea.cmd };
;               if (asc_isdigit(p[0].at(0)))
;                   p[0] = skipwhite(skipdigits(p[0]));
;               switch (p[0].at(0))
;               {
                    ;; When adding an entry, also modify cmd_exists().
;                   case 'a':
;                   {
;                       if (checkforcmd(p, u8("aboveleft"), 3))
;                       {
;                           ea.cmd = p[0];
;                           @cmdmod.split |= WSP_ABOVE;
;                           continue;
;                       }
;                       break;
;                   }

;                   case 'b':
;                   {
;                       if (checkforcmd(p, u8("belowright"), 3))
;                       {
;                           ea.cmd = p[0];
;                           @cmdmod.split |= WSP_BELOW;
;                           continue;
;                       }
;                       if (checkforcmd(p, u8("botright"), 2))
;                       {
;                           ea.cmd = p[0];
;                           @cmdmod.split |= WSP_BOT;
;                           continue;
;                       }
;                       break;
;                   }

;                   case 'k':
;                   {
;                       if (checkforcmd(p, u8("keepmarks"), 3))
;                       {
;                           ea.cmd = p[0];
;                           @cmdmod.keepmarks = true;
;                           continue;
;                       }
;                       if (checkforcmd(p, u8("keepalt"), 5))
;                       {
;                           ea.cmd = p[0];
;                           @cmdmod.keepalt = true;
;                           continue;
;                       }
;                       if (checkforcmd(p, u8("keeppatterns"), 5))
;                       {
;                           ea.cmd = p[0];
;                           @cmdmod.keeppatterns = true;
;                           continue;
;                       }
;                       if (checkforcmd(p, u8("keepjumps"), 5))
;                       {
;                           ea.cmd = p[0];
;                           @cmdmod.keepjumps = true;
;                           continue;
;                       }
;                       break;
;                   }

;                   case 'h':
;                   {
                        ;; ":hide" and ":hide | cmd" are not modifiers
;                       if (BEQ(p[0], ea.cmd) && checkforcmd(p, u8("hide"), 3) && p[0].at(0) != NUL && !ends_excmd(p[0].at(0)))
;                       {
;                           ea.cmd = p[0];
;                           @cmdmod.hide = true;
;                           continue;
;                       }
;                       break;
;                   }

;                   case 'l':
;                   {
;                       if (checkforcmd(p, u8("lockmarks"), 3))
;                       {
;                           ea.cmd = p[0];
;                           @cmdmod.lockmarks = true;
;                           continue;
;                       }
;                       if (checkforcmd(p, u8("leftabove"), 5))
;                       {
;                           ea.cmd = p[0];
;                           @cmdmod.split |= WSP_ABOVE;
;                           continue;
;                       }
;                       break;
;                   }

;                   case 'r':
;                   {
;                       if (checkforcmd(p, u8("rightbelow"), 6))
;                       {
;                           ea.cmd = p[0];
;                           @cmdmod.split |= WSP_BELOW;
;                           continue;
;                       }
;                       break;
;                   }

;                   case 's':
;                   {
;                       if (checkforcmd(p, u8("sandbox"), 3))
;                       {
;                           ea.cmd = p[0];
;                           if (!did_sandbox)
;                               @sandbox++;
;                           did_sandbox = true;
;                           continue;
;                       }
;                       if (checkforcmd(p, u8("silent"), 3))
;                       {
;                           ea.cmd = p[0];
;                           if (save_msg_silent == -1)
;                               save_msg_silent = @msg_silent;
;                           @msg_silent++;
;                           if (ea.cmd.at(0) == (byte)'!' && !vim_iswhite(ea.cmd.at(-1)))
;                           {
                                ;; ":silent!", but not "silent !cmd"
;                               ea.cmd = skipwhite(ea.cmd.plus(1));
;                               @emsg_silent++;
;                               did_esilent++;
;                           }
;                           continue;
;                       }
;                       break;
;                   }

;                   case 't':
;                   {
;                       if (checkforcmd(p, u8("topleft"), 2))
;                       {
;                           ea.cmd = p[0];
;                           @cmdmod.split |= WSP_TOP;
;                           continue;
;                       }
;                       break;
;                   }

;                   case 'u':
;                   {
;                       if (checkforcmd(p, u8("unsilent"), 3))
;                       {
;                           ea.cmd = p[0];
;                           if (save_msg_silent == -1)
;                               save_msg_silent = @msg_silent;
;                           @msg_silent = 0;
;                           continue;
;                       }
;                       break;
;                   }

;                   case 'v':
;                   {
;                       if (checkforcmd(p, u8("vertical"), 4))
;                       {
;                           ea.cmd = p[0];
;                           @cmdmod.split |= WSP_VERT;
;                           continue;
;                       }
;                       if (checkforcmd(p, u8("verbose"), 4))
;                       {
;                           if (verbose_save < 0)
;                               verbose_save = @p_verbose;
;                           if (asc_isdigit(ea.cmd.at(0)))
;                               @p_verbose = libC.atoi(ea.cmd);
;                           else
;                               @p_verbose = 1;
;                           ea.cmd = p[0];
;                           continue;
;                       }
;                       break;
;                   }
;               }
;               break;
;           }

;           ea.skip = (@did_emsg || @got_int || @did_throw);

            ;; If the ">quit" debug command is used, throw an interrupt exception and skip the next command.
;           if (!ea.skip && @got_int)
;           {
;               ea.skip = true;
;               do_intthrow();
;           }

            ;; 3. Skip over the range to find the command.  Let "p" point to after it.
            ;;
            ;; We need the command to know what kind of range it uses.

;           Bytes cmd = ea.cmd;
;           ea.cmd = skip_range(ea.cmd);
;           if (ea.cmd.at(0) == (byte)'*' && vim_strbyte(@p_cpo, CPO_STAR) == null)
;               ea.cmd = skipwhite(ea.cmd.plus(1));

;           Bytes p = find_command(ea, null);

            ;; 4. parse a range specifier of the form: addr [,addr] [;addr] ..
            ;;
            ;; where 'addr' is:
            ;;
            ;; %          (entire file)
            ;; $  [+-NUM]
            ;; 'x [+-NUM] (where x denotes a currently defined mark)
            ;; .  [+-NUM]
            ;; [+-NUM]..
            ;; NUM
            ;;
            ;; The ea.cmd pointer is updated to point to the first character following the range spec.
            ;; If an initial address is found, but no second, the upper bound is equal to the lower.

;           {
;               if (ea.cmdidx != CMD_SIZE)
;                   ea.addr_type = cmdnames[ea.cmdidx].cmd_addr_type;
;               else
;                   ea.addr_type = ADDR_LINES;

                ;; :wincmd range depends on the argument.
;               if (ea.cmdidx == CMD_wincmd && p != null)
;                   get_wincmd_addr_type(skipwhite(p), ea);
;           }

;           long lnum;

            ;; repeat for all ',' or ';' separated addresses
;           ea.cmd = cmd;
;           for ( ; ; )
;           {
;               ea.line1 = ea.line2;
;               switch (ea.addr_type)
;               {
;                   case ADDR_LINES:
                        ;; default is current line number
;                       ea.line2 = @curwin.w_cursor.lnum;
;                       break;

;                   case ADDR_WINDOWS:
;                       lnum = current_win_nr(@curwin);
;                       ea.line2 = lnum;
;                       break;

;                   case ADDR_LOADED_BUFFERS:
;                   case ADDR_BUFFERS:
;                       ea.line2 = @curbuf.b_fnum;
;                       break;
;               }
;               ea.cmd = skipwhite(ea.cmd);
;               { Bytes[] __ = { ea.cmd }; lnum = get_address(__, ea.addr_type, ea.skip, ea.addr_count == 0); ea.cmd = __[0]; }
;               if (ea.cmd == null)                 ;; error detected
;                   break doend;
;               if (lnum == MAXLNUM)
;               {
;                   if (ea.cmd.at(0) == (byte)'%')             ;; '%' - all lines
;                   {
;                       ea.cmd = ea.cmd.plus(1);
;                       switch (ea.addr_type)
;                       {
;                           case ADDR_LINES:
;                               ea.line1 = 1;
;                               ea.line2 = @curbuf.b_ml.ml_line_count;
;                               break;

;                           case ADDR_LOADED_BUFFERS:
;                           {
;                               buffer_C buf = @firstbuf;

;                               while (buf.b_next != null && buf.b_ml.ml_mfp == null)
;                                   buf = buf.b_next;
;                               ea.line1 = buf.b_fnum;
;                               buf = @lastbuf;
;                               while (buf.b_prev != null && buf.b_ml.ml_mfp == null)
;                                   buf = buf.b_prev;
;                               ea.line2 = buf.b_fnum;
;                               break;
;                           }

;                           case ADDR_BUFFERS:
;                               ea.line1 = @firstbuf.b_fnum;
;                               ea.line2 = @lastbuf.b_fnum;
;                               break;

;                           case ADDR_WINDOWS:
                                ;; There is no Vim command which uses '%' and ADDR_WINDOWS.
;                               errormsg = e_invrange;
;                               break doend;
;                       }
;                       ea.addr_count++;
;                   }
                                                    ;; '*' - visual area
;                   else if (ea.cmd.at(0) == (byte)'*' && vim_strbyte(@p_cpo, CPO_STAR) == null)
;                   {
;                       if (ea.addr_type != ADDR_LINES)
;                       {
;                           errormsg = e_invrange;
;                           break doend;
;                       }

;                       ea.cmd = ea.cmd.plus(1);
;                       if (!ea.skip)
;                       {
;                           pos_C fp = getmark('<', false);
;                           if (check_mark(fp) == false)
;                               break doend;
;                           ea.line1 = fp.lnum;
;                           fp = getmark('>', false);
;                           if (check_mark(fp) == false)
;                               break doend;
;                           ea.line2 = fp.lnum;
;                           ea.addr_count++;
;                       }
;                   }
;               }
;               else
;                   ea.line2 = lnum;
;               ea.addr_count++;

;               if (ea.cmd.at(0) == (byte)';')
;               {
;                   if (!ea.skip)
;                       @curwin.w_cursor.lnum = ea.line2;
;               }
;               else if (ea.cmd.at(0) != (byte)',')
;                   break;
;               ea.cmd = ea.cmd.plus(1);
;           }

            ;; One address given: set start and end lines.
;           if (ea.addr_count == 1)
;           {
;               ea.line1 = ea.line2;
                    ;; ... but only implicit: really no address given
;               if (lnum == MAXLNUM)
;                   ea.addr_count = 0;
;           }

            ;; Don't leave the cursor on an illegal line (caused by ';').
;           check_cursor_lnum();

            ;; 5. Parse the command.

            ;; Skip ':' and any white space

;           ea.cmd = skipwhite(ea.cmd);
;           while (ea.cmd.at(0) == (byte)':')
;               ea.cmd = skipwhite(ea.cmd.plus(1));

            ;; If we got a line, but no command, then go to the line.
            ;; If we find a '|' or '\n' we set ea.nextcmd.

;           if (ea.cmd.at(0) == NUL || ea.cmd.at(0) == (byte)'"' || (ea.nextcmd = check_nextcmd(ea.cmd)) != null)
;           {
                ;; strange vi behaviour:
                ;; ":3"         jumps to line 3
                ;; ":3|..."     prints line 3
                ;; ":|"         prints current line

;               if (ea.skip)    ;; skip this if inside :if
;                   break doend;
;               if (ea.cmd.at(0) == (byte)'|' || (@exmode_active != 0 && ea.line1 != ea.line2))
;               {
;                   ea.cmdidx = CMD_print;
;                   ea.argt = RANGE + COUNT;
;                   if ((errormsg = invalid_range(ea)) == null)
;                   {
;                       correct_range(ea);
;                       ex_print(ea);
;                   }
;               }
;               else if (ea.addr_count != 0)
;               {
;                   if (@curbuf.b_ml.ml_line_count < ea.line2)
;                   {
                        ;; With '-' in 'cpoptions' a line number past the file is an error,
                        ;; otherwise put it at the end of the file.
;                       if (vim_strbyte(@p_cpo, CPO_MINUS) != null)
;                           ea.line2 = -1;
;                       else
;                           ea.line2 = @curbuf.b_ml.ml_line_count;
;                   }

;                   if (ea.line2 < 0)
;                       errormsg = e_invrange;
;                   else
;                   {
;                       if (ea.line2 == 0)
;                           @curwin.w_cursor.lnum = 1;
;                       else
;                           @curwin.w_cursor.lnum = ea.line2;
;                       beginline(BL_SOL | BL_FIX);
;                   }
;               }
;               break doend;
;           }

;           if (p == null)
;           {
;               if (!ea.skip)
;                   errormsg = u8("E464: Ambiguous use of user-defined command");
;               break doend;
;           }

;           if (ea.cmdidx == CMD_SIZE)
;           {
;               if (!ea.skip)
;               {
;                   STRCPY(@ioBuff, u8("E492: Not an editor command"));
;                   if (!sourcing)
;                       append_command(cmdlinep[0]);
;                   errormsg = @ioBuff;
;                   @did_emsg_syntax = true;
;               }
;               break doend;
;           }

            ;; set when Not Implemented
;           boolean ni = (cmdnames[ea.cmdidx].cmd_func == ex_ni || cmdnames[ea.cmdidx].cmd_func == ex_script_ni);

            ;; forced commands
;           if (p.at(0) == (byte)'!' && ea.cmdidx != CMD_substitute && ea.cmdidx != CMD_smagic && ea.cmdidx != CMD_snomagic)
;           {
;               p = p.plus(1);
;               ea.forceit = true;
;           }
;           else
;               ea.forceit = false;

            ;; 6. Parse arguments.

;           ea.argt = cmdnames[ea.cmdidx].cmd_argt;

;           if (!ea.skip)
;           {
;               if (@sandbox != 0 && (ea.argt & SBOXOK) == 0)
;               {
                    ;; Command not allowed in sandbox.
;                   errormsg = e_sandbox;
;                   break doend;
;               }
;               if (!@curbuf.@b_p_ma && (ea.argt & MODIFY) != 0)
;               {
                    ;; Command not allowed in non-'modifiable' buffer.
;                   errormsg = e_modifiable;
;                   break doend;
;               }

;               if (text_locked() && (ea.argt & CMDWIN) == 0)
;               {
                    ;; Command not allowed when editing the command line.
;                   if (@cmdwin_type != 0)
;                       errormsg = e_cmdwin;
;                   else
;                       errormsg = e_secure;
;                   break doend;
;               }
                ;; Disallow editing another buffer when "curbuf_lock" is set.
                ;; Do allow ":edit" (check for argument later).
                ;; Do allow ":checktime" (it's postponed).
;               if ((ea.argt & CMDWIN) == 0
;                       && ea.cmdidx != CMD_edit
;                       && curbuf_locked())
;                   break doend;

;               if (!ni && (ea.argt & RANGE) == 0 && 0 < ea.addr_count)
;               {
                    ;; no range allowed
;                   errormsg = e_norange;
;                   break doend;
;               }
;           }

;           if (!ni && (ea.argt & BANG) == 0 && ea.forceit) ;; no <!> allowed
;           {
;               errormsg = e_nobang;
;               break doend;
;           }

            ;; Don't complain about the range if it is not used
            ;; (could happen if line_count is accidentally set to 0).

;           if (!ea.skip && !ni)
;           {
                ;; If the range is backwards, ask for confirmation and, if given,
                ;; swap ea.line1 & ea.line2 so it's forwards again.
                ;; When global command is busy, don't ask, will fail below.

;               if (@global_busy == 0 && ea.line2 < ea.line1)
;               {
;                   if (@msg_silent == 0)
;                   {
;                       if (sourcing || @exmode_active != 0)
;                       {
;                           errormsg = u8("E493: Backwards range given");
;                           break doend;
;                       }
;                       if (ask_yesno(u8("Backwards range given, OK to swap"), false) != 'y')
;                           break doend;
;                   }
;                   lnum = ea.line1;
;                   ea.line1 = ea.line2;
;                   ea.line2 = lnum;
;               }
;               if ((errormsg = invalid_range(ea)) != null)
;                   break doend;
;           }

;           if ((ea.argt & NOTADR) != 0 && ea.addr_count == 0) ;; default is 1, not cursor
;               ea.line2 = 1;

;           correct_range(ea);

            ;; Skip to start of argument.

;           ea.arg = skipwhite(p);

            ;; Check for "++opt=val" argument.
            ;; Must be first, allow ":w ++enc=utf8 !cmd"

;           if ((ea.argt & ARGOPT) != 0)
;               while (ea.arg.at(0) == (byte)'+' && ea.arg.at(1) == (byte)'+')
;                   if (getargopt(ea) == false && !ni)
;                   {
;                       errormsg = e_invarg;
;                       break doend;
;                   }

;           if (ea.cmdidx == CMD_lshift || ea.cmdidx == CMD_rshift)
;           {
;               ea.amount = 1;
;               while (ea.arg.at(0) == ea.cmd.at(0))            ;; count number of '>' or '<'
;               {
;                   ea.arg = ea.arg.plus(1);
;                   ea.amount++;
;               }
;               ea.arg = skipwhite(ea.arg);
;           }

            ;; Check for "+command" argument, before checking for next command.

;           if ((ea.argt & EDITCMD) != 0)
;           {
;               Bytes[] __ = { ea.arg };
;               ea.do_ecmd_cmd = getargcmd(__);
;               ea.arg = __[0];
;           }

            ;; Check for <newline> to end a shell command.
            ;; Also do this for ":global".
            ;; Any others?

;           if (ea.cmdidx == CMD_global || ea.cmdidx == CMD_vglobal)
;           {
;               for (p = ea.arg; p.at(0) != NUL; p = p.plus(1))
;               {
                    ;; Remove one backslash before a newline, so that it's possible to
                    ;; pass a newline to the shell and also a newline that is preceded
                    ;; with a backslash.  This makes it impossible to end a shell
                    ;; command in a backslash, but that doesn't appear useful.
                    ;; Halving the number of backslashes is incompatible with previous
                    ;; versions.
;                   if (p.at(0) == (byte)'\\' && p.at(1) == (byte)'\n')
;                       BCOPY(p, 0, p, 1, STRLEN(p, 1) + 1);
;                   else if (p.at(0) == (byte)'\n')
;                   {
;                       ea.nextcmd = p.plus(1);
;                       p.be(0, NUL);
;                       break;
;                   }
;               }
;           }

;           if ((ea.argt & DFLALL) != 0 && ea.addr_count == 0)
;           {
;               ea.line1 = 1;
;               switch (ea.addr_type)
;               {
;                   case ADDR_LINES:
;                       ea.line2 = @curbuf.b_ml.ml_line_count;
;                       break;

;                   case ADDR_LOADED_BUFFERS:
;                   {
;                       buffer_C buf = @firstbuf;
;                       while (buf.b_next != null && buf.b_ml.ml_mfp == null)
;                           buf = buf.b_next;
;                       ea.line1 = buf.b_fnum;
;                       buf = @lastbuf;
;                       while (buf.b_prev != null && buf.b_ml.ml_mfp == null)
;                           buf = buf.b_prev;
;                       ea.line2 = buf.b_fnum;
;                       break;
;                   }

;                   case ADDR_BUFFERS:
;                       ea.line1 = @firstbuf.b_fnum;
;                       ea.line2 = @lastbuf.b_fnum;
;                       break;

;                   case ADDR_WINDOWS:
;                       ea.line2 = current_win_nr(null);
;                       break;
;               }
;           }

            ;; accept numbered register only when no count allowed (:put)
;           if ((ea.argt & REGSTR) != 0
;                   && ea.arg.at(0) != NUL
;                   && !((ea.argt & COUNT) != 0 && asc_isdigit(ea.arg.at(0))))
;           {
;               if (valid_yank_reg(ea.arg.at(0), (ea.cmdidx != CMD_put)))
;               {
;                   ea.regname = (ea.arg = ea.arg.plus(1)).at(-1);
                    ;; for '=' register: accept the rest of the line as an expression
;                   if (ea.arg.at(-1) == (byte)'=' && ea.arg.at(0) != NUL)
;                   {
;                       set_expr_line(STRDUP(ea.arg));
;                       ea.arg = ea.arg.plus(STRLEN(ea.arg));
;                   }
;                   ea.arg = skipwhite(ea.arg);
;               }
;           }

            ;; Check for a count.
            ;; When accepting a BUFNAME, don't use "123foo" as a count, it's a buffer name.

;           if ((ea.argt & COUNT) != 0 && asc_isdigit(ea.arg.at(0))
;               && ((ea.argt & BUFNAME) == 0 || (p = skipdigits(ea.arg)).at(0) == NUL || vim_iswhite(p.at(0))))
;           {
;               long n;
;               { Bytes[] __ = { ea.arg }; n = getdigits(__); ea.arg = __[0]; }
;               ea.arg = skipwhite(ea.arg);
;               if (n <= 0 && !ni && (ea.argt & ZEROR) == 0)
;               {
;                   errormsg = e_zerocount;
;                   break doend;
;               }
;               if ((ea.argt & NOTADR) != 0)    ;; e.g. :buffer 2, :sleep 3
;               {
;                   ea.line2 = n;
;                   if (ea.addr_count == 0)
;                       ea.addr_count = 1;
;               }
;               else
;               {
;                   ea.line1 = ea.line2;
;                   ea.line2 += n - 1;
;                   ea.addr_count++;

                    ;; Be vi compatible: no error message for out of range.

;                   if (ea.line2 > @curbuf.b_ml.ml_line_count)
;                       ea.line2 = @curbuf.b_ml.ml_line_count;
;               }
;           }

            ;; Check for flags: 'l', 'p' and '#'.

;           if ((ea.argt & EXFLAGS) != 0)
;               get_flags(ea);
                                                        ;; no arguments allowed
;           if (!ni && (ea.argt & EXTRA) == 0 && ea.arg.at(0) != NUL && ea.arg.at(0) != (byte)'"')
;           {
;               errormsg = e_trailing;
;               break doend;
;           }

;           if (!ni && (ea.argt & NEEDARG) != 0 && ea.arg.at(0) == NUL)
;           {
;               errormsg = e_argreq;
;               break doend;
;           }

            ;; Skip the command when it's not going to be executed.
            ;; The commands like :if, :endif, etc. always need to be executed.
            ;; Also make an exception for commands that handle a trailing command themselves.

;           if (ea.skip)
;           {
;               switch (ea.cmdidx)
;               {
                    ;; Commands that handle '|' themselves.  Check: A command should
                    ;; either have the TRLBAR flag, appear in this list or appear in
                    ;; the list at ":help :bar".
;                   case CMD_aboveleft:
;                   case CMD_and:
;                   case CMD_belowright:
;                   case CMD_botright:
;                   case CMD_hide:
;                   case CMD_keepalt:
;                   case CMD_keepjumps:
;                   case CMD_keepmarks:
;                   case CMD_keeppatterns:
;                   case CMD_leftabove:
;                   case CMD_lockmarks:
;                   case CMD_rightbelow:
;                   case CMD_silent:
;                   case CMD_smagic:
;                   case CMD_snomagic:
;                   case CMD_substitute:
;                   case CMD_tilde:
;                   case CMD_topleft:
;                   case CMD_verbose:
;                   case CMD_vertical:
;                   case CMD_wincmd:
;                       break;

;                   default:
;                       break doend;
;               }
;           }

            ;; Accept buffer name.  Cannot be used at the same time with a buffer number.
            ;; Don't do this for a user command.

;           if ((ea.argt & BUFNAME) != 0 && ea.arg.at(0) != NUL && ea.addr_count == 0)
;           {
                ;; :bdelete, :bwipeout and :bunload take several arguments, separated
                ;; by spaces: find next space (skipping over escaped characters).
                ;; The others take one argument: ignore trailing spaces.

;               if (ea.cmdidx == CMD_bdelete || ea.cmdidx == CMD_bwipeout || ea.cmdidx == CMD_bunload)
;                   p = skiptowhite_esc(ea.arg);
;               else
;               {
;                   p = ea.arg.plus(STRLEN(ea.arg));
;                   while (BLT(ea.arg, p) && vim_iswhite(p.at(-1)))
;                       p = p.minus(1);
;               }
;               ea.line2 = buflist_findpat(ea.arg, p);
;               if (ea.line2 < 0)       ;; failed
;                   break doend;
;               ea.addr_count = 1;
;               ea.arg = skipwhite(p);
;           }

            ;; 7. Switch on command name.
            ;;
            ;; The "ea" structure holds the arguments that can be used.

;           ea.cmdlinep = cmdlinep;
;           ea.getline = fgetline;
;           ea.cookie = cookie;

            ;; Call the function to execute the command.

;           ea.errmsg = null;
;           cmdnames[ea.cmdidx].cmd_func(ea);
;           if (ea.errmsg != null)
;               errormsg = ea.errmsg;

            ;; If the command just executed called do_cmdline(), any throw or ":return"
            ;; or ":finish" encountered there must also check the cstack of the still
            ;; active do_cmdline() that called this do_one_cmd().  Rethrow an uncaught
            ;; exception, or reanimate a returned function or finished script file and
            ;; return or finish it again.

;           if (@need_rethrow)
;               @did_throw = true;
;           @need_rethrow = false;
;       }

;       if (@curwin.w_cursor.lnum == 0)  ;; can happen with zero line number
;           @curwin.w_cursor.lnum = 1;

;       if (errormsg != null && errormsg.at(0) != NUL && !@did_emsg)
;       {
;           if (sourcing)
;           {
;               if (BNE(errormsg, @ioBuff))
;               {
;                   STRCPY(@ioBuff, errormsg);
;                   errormsg = @ioBuff;
;               }
;               append_command(cmdlinep[0]);
;           }
;           emsg(errormsg);
;       }

;       do_errthrow(true, (ea.cmdidx != CMD_SIZE) ? cmdnames[ea.cmdidx].cmd_name : null);

;       if (0 <= verbose_save)
;           @p_verbose = verbose_save;

;       COPY_cmdmod(@cmdmod, save_cmdmod);

;       if (save_msg_silent != -1)
;       {
            ;; Messages could be enabled for a serious error,
            ;; need to check if the counters don't become negative.
;           if (!@did_emsg || save_msg_silent < @msg_silent)
;               @msg_silent = save_msg_silent;
;           @emsg_silent -= did_esilent;
;           if (@emsg_silent < 0)
;               @emsg_silent = 0;
            ;; Restore msg_scroll, it's set by file I/O commands,
            ;; even when no message is actually displayed.
;           @msg_scroll = save_msg_scroll;
;       }

;       if (did_sandbox)
;           --@sandbox;

;       if (ea.nextcmd != null && ea.nextcmd.at(0) == NUL)      ;; not really a next command
;           ea.nextcmd = null;

;       return ea.nextcmd;
    ))

;; Check for an Ex command with optional tail.
;; If there is a match advance "pp" to the argument and return true.

(defn- #_boolean checkforcmd [#_Bytes* pp, #_Bytes cmd, #_int len]
    ;; pp: start of command
    ;; cmd: name of command
    ;; len: required length
    (§
;       int i;

;       for (i = 0; cmd.at(i) != NUL; i++)
;           if (cmd.at(i) != pp[0].at(i))
;               break;
;       if (len <= i && !asc_isalpha(pp[0].at(i)))
;       {
;           pp[0] = skipwhite(pp[0].plus(i));
;           return true;
;       }

;       return false;
    ))

;; Append "cmd" to the error message in ioBuff.
;; Takes care of limiting the length and handling 0xa0,
;; which would be invisible otherwise.

(defn- #_void append_command [#_Bytes cmd]
    (§
;       STRCAT(@ioBuff, u8(": "));

;       Bytes d = @ioBuff.plus(STRLEN(@ioBuff));
;       for (Bytes s = cmd; s.at(0) != NUL && BDIFF(d, @ioBuff) < IOSIZE - 7; )
;       {
;           if (char_u(s.at(0)) == 0xc2 && char_u(s.at(1)) == 0xa0)
;           {
;               s = s.plus(2);
;               STRCPY(d, u8("<a0>"));
;               d = d.plus(4);
;           }
;           else
;           {
;               int len = us_ptr2len_cc(s);
;               BCOPY(d, s, len);
;               d = d.plus(len);
;               s = s.plus(len);
;           }
;       }
;       d.be(0, NUL);
    ))

;; Find an Ex command by its name, either built-in or user.
;; Start of the name can be found at eap.cmd.
;; Returns pointer to char after the command name.
;; "full" is set to true if the whole command name matched.
;; Returns null for an ambiguous user command.

(defn- #_Bytes find_command [#_exarg_C eap, #_boolean* full]
    (§
        ;; Isolate the command and search for it in the command table.
        ;; Exceptions:
        ;; - the 'k' command can directly be followed by any character.
        ;; - the 's' command can be followed directly by 'c', 'g', 'i', 'I' or 'r'
        ;;      but :sre[wind] is another command, as are :scr[iptnames],
        ;;      :scs[cope], :sim[alt], :sig[ns] and :sil[ent].
        ;; - the "d" command can directly be followed by 'l' or 'p' flag.

;       Bytes p = eap.cmd;
;       if (p.at(0) == (byte)'k')
;       {
;           eap.cmdidx = CMD_k;
;           p = p.plus(1);
;       }
;       else if (p.at(0) == (byte)'s'
;               && ((p.at(1) == (byte)'c' && p.at(2) != (byte)'s' && p.at(2) != (byte)'r' && p.at(3) != (byte)'i' && p.at(4) != (byte)'p')
;                   || p.at(1) == (byte)'g'
;                   || (p.at(1) == (byte)'i' && p.at(2) != (byte)'m' && p.at(2) != (byte)'l' && p.at(2) != (byte)'g')
;                   || p.at(1) == (byte)'I'
;                   || (p.at(1) == (byte)'r' && p.at(2) != (byte)'e')))
;       {
;           eap.cmdidx = CMD_substitute;
;           p = p.plus(1);
;       }
;       else
;       {
;           while (asc_isalpha(p.at(0)))
;               p = p.plus(1);
            ;; for python 3.x support ":py3", ":python3", ":py3file", etc.
;           if (eap.cmd.at(0) == (byte)'p' && eap.cmd.at(1) == (byte)'y')
;               while (asc_isalnum(p.at(0)))
;                   p = p.plus(1);

            ;; check for non-alpha command
;           if (BEQ(p, eap.cmd) && vim_strbyte(u8("@*!=><&~#"), p.at(0)) != null)
;               p = p.plus(1);

;           int len = BDIFF(p, eap.cmd);

;           if (eap.cmd.at(0) == (byte)'d' && (p.at(-1) == (byte)'l' || p.at(-1) == (byte)'p'))
;           {
                ;; Check for ":dl", ":dell", etc. to ":deletel": that's
                ;; :delete with the 'l' flag.  Same for 'p'.
;               int i;
;               for (i = 0; i < len; i++)
;                   if (eap.cmd.at(i) != u8("delete").at(i))
;                       break;
;               if (i == len - 1)
;               {
;                   --len;
;                   if (p.at(-1) == (byte)'l')
;                       eap.flags |= EXFLAG_LIST;
;                   else
;                       eap.flags |= EXFLAG_PRINT;
;               }
;           }

;           if (asc_islower(eap.cmd.at(0)))
;               eap.cmdidx = cmdidxs[charOrdLow(eap.cmd.at(0))];
;           else
;               eap.cmdidx = cmdidxs[26];

;           for ( ; eap.cmdidx < CMD_SIZE; eap.cmdidx++)
;               if (STRNCMP(cmdnames[eap.cmdidx].cmd_name, eap.cmd, len) == 0)
;               {
;                   if (full != null && cmdnames[eap.cmdidx].cmd_name.at(len) == NUL)
;                       full[0] = true;
;                   break;
;               }

            ;; Look for a user defined command as a last resort.
;           if (eap.cmdidx == CMD_SIZE && 'A' <= eap.cmd.at(0) && eap.cmd.at(0) <= 'Z')
;           {
                ;; User defined commands may contain digits.
;               while (asc_isalnum(p.at(0)))
;                   p = p.plus(1);
;           }

;           if (BEQ(p, eap.cmd))
;               eap.cmdidx = CMD_SIZE;
;       }

;       return p;
    ))

(class! #_final cmdmods_C
    [
        (field Bytes    name)
        (field int      minlen)
        (field boolean  has_count)  ;; :123verbose  :3tab
    ])

(final cmdmods_C* cmdmods
    [
        (->cmdmods_C (u8 "aboveleft"),    3, false),
        (->cmdmods_C (u8 "belowright"),   3, false),
        (->cmdmods_C (u8 "botright"),     2, false),
        (->cmdmods_C (u8 "hide"),         3, false),
        (->cmdmods_C (u8 "keepalt"),      5, false),
        (->cmdmods_C (u8 "keepjumps"),    5, false),
        (->cmdmods_C (u8 "keepmarks"),    3, false),
        (->cmdmods_C (u8 "keeppatterns"), 5, false),
        (->cmdmods_C (u8 "leftabove"),    5, false),
        (->cmdmods_C (u8 "lockmarks"),    3, false),
        (->cmdmods_C (u8 "rightbelow"),   6, false),
        (->cmdmods_C (u8 "sandbox"),      3, false),
        (->cmdmods_C (u8 "silent"),       3, false),
        (->cmdmods_C (u8 "topleft"),      2, false),
        (->cmdmods_C (u8 "unsilent"),     3, false),
        (->cmdmods_C (u8 "verbose"),      4, true ),
        (->cmdmods_C (u8 "vertical"),     4, false),
    ])

;; Return length of a command modifier (including optional count).
;; Return zero when it's not a modifier.

(defn- #_int modifier_len [#_Bytes cmd]
    (§
;       Bytes p = cmd;

;       if (asc_isdigit(cmd.at(0)))
;           p = skipwhite(skipdigits(cmd));
;       for (int i = 0; i < cmdmods.length; i++)
;       {
;           int j;
;           for (j = 0; p.at(j) != NUL; j++)
;               if (p.at(j) != cmdmods[i].name.at(j))
;                   break;
;           if (!asc_isalpha(p.at(j)) && cmdmods[i].minlen <= j && (BEQ(p, cmd) || cmdmods[i].has_count))
;               return j + BDIFF(p, cmd);
;       }
;       return 0;
    ))

;; Return > 0 if an Ex command "name" exists.
;; Return 2 if there is an exact match.
;; Return 3 if there is an ambiguous match.

(defn- #_int cmd_exists [#_Bytes name]
    (§
        ;; Check command modifiers.
;       for (int i = 0; i < cmdmods.length; i++)
;       {
;           int j;
;           for (j = 0; name.at(j) != NUL; j++)
;               if (name.at(j) != cmdmods[i].name.at(j))
;                   break;
;           if (name.at(j) == NUL && cmdmods[i].minlen <= j)
;               return (cmdmods[i].name.at(j) == NUL) ? 2 : 1;
;       }

        ;; Check built-in commands and user defined commands.
        ;; For ":2match" and ":3match" we need to skip the number.
;       exarg_C ea = §_exarg_C();
;       ea.cmd = (name.at(0) == (byte)'2' || name.at(0) == (byte)'3') ? name.plus(1) : name;
;       ea.cmdidx = 0;

;       boolean[] full = { false };
;       Bytes p = find_command(ea, full);
;       if (p == null)
;           return 3;
;       if (asc_isdigit(name.at(0)))
;           return 0;
;       if (skipwhite(p).at(0) != NUL)
;           return 0;       ;; trailing garbage

;       return (ea.cmdidx == CMD_SIZE) ? 0 : (full[0] ? 2 : 1);
    ))

;; skip a range specifier of the form: addr [,addr] [;addr] ..
;;
;; Backslashed delimiters after / or ? will be skipped, and commands will
;; not be expanded between /'s and ?'s or after "'".
;;
;; Also skip white space and ":" characters.
;; Returns the "cmd" pointer advanced to beyond the range.

(defn- #_Bytes skip_range [#_Bytes cmd]
    (§
;       while (vim_strbyte(u8(" \t0123456789.$%'/?-+,;"), cmd.at(0)) != null)
;       {
;           if (cmd.at(0) == (byte)'\'')
;           {
;               cmd = cmd.plus(1);
;           }
;           else if (cmd.at(0) == (byte)'/' || cmd.at(0) == (byte)'?')
;           {
;               byte delim = (cmd = cmd.plus(1)).at(-1);
;               while (cmd.at(0) != NUL && cmd.at(0) != delim)
;                   if ((cmd = cmd.plus(1)).at(-1) == (byte)'\\' && cmd.at(0) != NUL)
;                       cmd = cmd.plus(1);
;           }
;           if (cmd.at(0) != NUL)
;               cmd = cmd.plus(1);
;       }

        ;; Skip ":" and white space.
;       while (cmd.at(0) == (byte)':')
;           cmd = skipwhite(cmd.plus(1));

;       return cmd;
    ))

;; get a single EX address
;;
;; Set ptr to the next character after the part that was interpreted.
;; Set ptr to null when an error is encountered.
;;
;; Return MAXLNUM when no Ex address was found.

(defn- #_long get_address [#_Bytes* ptr, #_int addr_type, #_boolean skip, #_boolean to_other_file]
    ;; addr_type: flag: one of ADDR_LINES, ...
    ;; skip: only skip the address, don't use it
    ;; to_other_file: flag: may jump to other file
    (§
;       long lnum = MAXLNUM;
;       Bytes cmd = skipwhite(ptr[0]);

;       error:
;       do
;       {
;           switch (cmd.at(0))
;           {
;               case '.':                       ;; '.' - Cursor position
;               {
;                   cmd = cmd.plus(1);
;                   switch (addr_type)
;                   {
;                       case ADDR_LINES:
;                           lnum = @curwin.w_cursor.lnum;
;                           break;

;                       case ADDR_WINDOWS:
;                           lnum = current_win_nr(@curwin);
;                           break;

;                       case ADDR_LOADED_BUFFERS:
;                       case ADDR_BUFFERS:
;                           lnum = @curbuf.b_fnum;
;                           break;
;                   }
;                   break;
;               }

;               case '$':                       ;; '$' - last line
;               {
;                   cmd = cmd.plus(1);
;                   switch (addr_type)
;                   {
;                       case ADDR_LINES:
;                           lnum = @curbuf.b_ml.ml_line_count;
;                           break;

;                       case ADDR_WINDOWS:
;                           lnum = current_win_nr(null);
;                           break;

;                       case ADDR_LOADED_BUFFERS:
;                       {
;                           buffer_C buf = @lastbuf;
;                           while (buf.b_ml.ml_mfp == null)
;                           {
;                               if (buf.b_prev == null)
;                                   break;
;                               buf = buf.b_prev;
;                           }
;                           lnum = buf.b_fnum;
;                           break;
;                       }

;                       case ADDR_BUFFERS:
;                           lnum = @lastbuf.b_fnum;
;                           break;
;                   }
;                   break;
;               }

;               case '\'':                      ;; ''' - mark
;               {
;                   if ((cmd = cmd.plus(1)).at(0) == NUL)
;                   {
;                       cmd = null;
;                       break error;
;                   }
;                   if (addr_type != ADDR_LINES)
;                   {
;                       emsg(e_invaddr);
;                       cmd = null;
;                       break error;
;                   }
;                   if (skip)
;                       cmd = cmd.plus(1);
;                   else
;                   {
                        ;; Only accept a mark in another file when it is used by itself: ":'M".
;                       pos_C fp = getmark(cmd.at(0), to_other_file && cmd.at(1) == NUL);
;                       cmd = cmd.plus(1);
;                       if (fp == NOPOS)
                            ;; Jumped to another file.
;                           lnum = @curwin.w_cursor.lnum;
;                       else
;                       {
;                           if (check_mark(fp) == false)
;                           {
;                               cmd = null;
;                               break error;
;                           }
;                           lnum = fp.lnum;
;                       }
;                   }
;                   break;
;               }

;               case '/':
;               case '?':                   ;; '/' or '?' - search
;               {
;                   byte c = (cmd = cmd.plus(1)).at(-1);
;                   if (addr_type != ADDR_LINES)
;                   {
;                       emsg(e_invaddr);
;                       cmd = null;
;                       break error;
;                   }
;                   if (skip)       ;; skip "/pat/"
;                   {
;                       cmd = skip_regexp(cmd, c, @p_magic, null);
;                       if (cmd.at(0) == c)
;                           cmd = cmd.plus(1);
;                   }
;                   else
;                   {
;                       pos_C save_pos = §_pos_C();
;                       COPY_pos(save_pos, @curwin.w_cursor);

                        ;; When '/' or '?' follows another address, start from there.

;                       if (lnum != MAXLNUM)
;                           @curwin.w_cursor.lnum = lnum;

                        ;; Start a forward search at the end of the line.
                        ;; Start a backward search at the start of the line.
                        ;; This makes sure we never match in the current line,
                        ;; and can match anywhere in the next/previous line.

;                       @curwin.w_cursor.col = (c == '/') ? MAXCOL : 0;
;                       @searchcmdlen = 0;
;                       if (do_search(null, c, cmd, 1L, SEARCH_HIS | SEARCH_MSG, null) == 0)
;                       {
;                           COPY_pos(@curwin.w_cursor, save_pos);
;                           cmd = null;
;                           break error;
;                       }
;                       lnum = @curwin.w_cursor.lnum;
;                       COPY_pos(@curwin.w_cursor, save_pos);
                        ;; adjust command string pointer
;                       cmd = cmd.plus(@searchcmdlen);
;                   }
;                   break;
;               }

;               case '\\':              ;; "\?", "\/" or "\&", repeat search
;               {
;                   cmd = cmd.plus(1);
;                   if (addr_type != ADDR_LINES)
;                   {
;                       emsg(e_invaddr);
;                       cmd = null;
;                       break error;
;                   }
;                   int i;
;                   if (cmd.at(0) == (byte)'&')
;                       i = RE_SUBST;
;                   else if (cmd.at(0) == (byte)'?' || cmd.at(0) == (byte)'/')
;                       i = RE_SEARCH;
;                   else
;                   {
;                       emsg(e_backslash);
;                       cmd = null;
;                       break error;
;                   }

;                   if (!skip)
;                   {
;                       pos_C pos = §_pos_C();

                        ;; When search follows another address, start from there.

;                       pos.lnum = (lnum != MAXLNUM) ? lnum : @curwin.w_cursor.lnum;

                        ;; Start the search just like for the above do_search().

;                       pos.col = (cmd.at(0) != (byte)'?') ? MAXCOL : 0;

;                       if (searchit(@curwin, @curbuf, pos, (cmd.at(0) == (byte)'?') ? BACKWARD : FORWARD, u8(""), 1L, SEARCH_MSG, i, 0, null) != 0)
;                           lnum = pos.lnum;
;                       else
;                       {
;                           cmd = null;
;                           break error;
;                       }
;                   }
;                   cmd = cmd.plus(1);
;                   break;
;               }

;               default:
;               {
;                   if (asc_isdigit(cmd.at(0)))     ;; absolute line number
;                   {
;                       Bytes[] __ = { cmd }; lnum = getdigits(__); cmd = __[0];
;                   }
;                   break;
;               }
;           }

;           for ( ; ; )
;           {
;               cmd = skipwhite(cmd);
;               if (cmd.at(0) != (byte)'-' && cmd.at(0) != (byte)'+' && !asc_isdigit(cmd.at(0)))
;                   break;

;               if (lnum == MAXLNUM)
;               {
;                   switch (addr_type)
;                   {
;                       case ADDR_LINES:
                            ;; "+1" is same as ".+1"
;                           lnum = @curwin.w_cursor.lnum;
;                           break;

;                       case ADDR_WINDOWS:
;                           lnum = current_win_nr(@curwin);
;                           break;

;                       case ADDR_LOADED_BUFFERS:
;                       case ADDR_BUFFERS:
;                           lnum = @curbuf.b_fnum;
;                           break;
;                   }
;               }

;               int m;
;               if (asc_isdigit(cmd.at(0)))
;                   m = '+';                    ;; "number" is same as "+number"
;               else
;                   m = (cmd = cmd.plus(1)).at(-1);
;               int n;
;               if (!asc_isdigit(cmd.at(0)))    ;; '+' is '+1', but '+0' is not '+1'
;                   n = 1;
;               else
;               {
;                   Bytes[] __ = { cmd }; n = (int)getdigits(__); cmd = __[0];
;               }
;               if (addr_type == ADDR_LOADED_BUFFERS || addr_type == ADDR_BUFFERS)
;                   lnum = compute_buffer_local_count(addr_type, (int)lnum, (m == '-') ? -n : n);
;               else if (m == '-')
;                   lnum -= n;
;               else
;                   lnum += n;
;           }
;       } while (cmd.at(0) == (byte)'/' || cmd.at(0) == (byte)'?');

;       ptr[0] = cmd;
;       return lnum;
    ))

;; Get flags from an Ex command argument.

(defn- #_void get_flags [#_exarg_C eap]
    (§
;       while (vim_strbyte(u8("lp#"), eap.arg.at(0)) != null)
;       {
;           if (eap.arg.at(0) == (byte)'l')
;               eap.flags |= EXFLAG_LIST;
;           else if (eap.arg.at(0) == (byte)'p')
;               eap.flags |= EXFLAG_PRINT;
;           else
;               eap.flags |= EXFLAG_NR;
;           eap.arg = skipwhite(eap.arg.plus(1));
;       }
    ))

;; Check range in Ex command for validity.
;; Return null when valid, error message when invalid.

(defn- #_Bytes invalid_range [#_exarg_C eap]
    (§
;       if (eap.line1 < 0 || eap.line2 < 0 || eap.line2 < eap.line1)
;           return e_invrange;

;       if ((eap.argt & RANGE) != 0)
;       {
;           switch (eap.addr_type)
;           {
;               case ADDR_LINES:
;                   if ((eap.argt & NOTADR) == 0 && @curbuf.b_ml.ml_line_count < eap.line2)
;                       return e_invrange;
;                   break;

;               case ADDR_BUFFERS:
;                   if (eap.line1 < @firstbuf.b_fnum || @lastbuf.b_fnum < eap.line2)
;                       return e_invrange;
;                   break;

;               case ADDR_LOADED_BUFFERS:
;               {
;                   buffer_C buf = @firstbuf;
;                   while (buf.b_ml.ml_mfp == null)
;                   {
;                       if (buf.b_next == null)
;                           return e_invrange;
;                       buf = buf.b_next;
;                   }
;                   if (eap.line1 < buf.b_fnum)
;                       return e_invrange;
;                   buf = @lastbuf;
;                   while (buf.b_ml.ml_mfp == null)
;                   {
;                       if (buf.b_prev == null)
;                           return e_invrange;
;                       buf = buf.b_prev;
;                   }
;                   if (buf.b_fnum < eap.line2)
;                       return e_invrange;
;                   break;
;               }

;               case ADDR_WINDOWS:
;                   if (current_win_nr(null) < eap.line2)
;                       return e_invrange;
;                   break;
;           }
;       }

;       return null;
    ))

;; Correct the range for zero line number, if required.

(defn- #_void correct_range [#_exarg_C eap]
    (§
;       if ((eap.argt & ZEROR) == 0)    ;; zero in range not allowed
;       {
;           if (eap.line1 == 0)
;               eap.line1 = 1;
;           if (eap.line2 == 0)
;               eap.line2 = 1;
;       }
    ))

;; get + command from ex argument

(final Bytes dollar_command (Bytes. (byte-array [ (byte \$), 0 ])))

(defn- #_Bytes getargcmd [#_Bytes* argp]
    (§
;       Bytes arg = argp[0];
;       Bytes command = null;

;       if (arg.at(0) == (byte)'+')                                ;; +[command]
;       {
;           arg = arg.plus(1);
;           if (vim_isspace(arg.at(0)) || arg.at(0) == NUL)
;               command = dollar_command;
;           else
;           {
;               command = arg;
;               arg = skip_cmd_arg(command, true);
;               if (arg.at(0) != NUL)
;                   (arg = arg.plus(1)).be(-1, NUL);                ;; terminate command with NUL
;           }

;           arg = skipwhite(arg);                       ;; skip over spaces
;           argp[0] = arg;
;       }

;       return command;
    ))

;; Find end of "+command" argument.  Skip over "\ " and "\\".

(defn- #_Bytes skip_cmd_arg [#_Bytes p, #_boolean rembs]
    ;; rembs: true to halve the number of backslashes
    (§
;       while (p.at(0) != NUL && !vim_isspace(p.at(0)))
;       {
;           if (p.at(0) == (byte)'\\' && p.at(1) != NUL)
;           {
;               if (rembs)
;                   BCOPY(p, 0, p, 1, STRLEN(p, 1) + 1);
;               else
;                   p = p.plus(1);
;           }
;           p = p.plus(us_ptr2len_cc(p));
;       }
;       return p;
    ))

;; Get "++opt=arg" argument.
;; Return false or true.

(defn- #_boolean getargopt [#_exarg_C eap]
    (§
;       Bytes arg = eap.arg.plus(2);

        ;; ":edit ++[no]bin[ary] file"
;       if (STRNCMP(arg, u8("bin"), 3) == 0 || STRNCMP(arg, u8("nobin"), 5) == 0)
;       {
;           if (arg.at(0) == (byte)'n')
;           {
;               arg = arg.plus(2);
;               eap.force_bin = FORCE_NOBIN;
;           }
;           else
;               eap.force_bin = FORCE_BIN;
;           Bytes[] p = { arg };
;           if (!checkforcmd(p, u8("binary"), 3))
;               return false;
;           eap.arg = skipwhite(p[0]);
;           return true;
;       }

        ;; ":read ++edit file"
;       if (STRNCMP(arg, u8("edit"), 4) == 0)
;       {
;           eap.read_edit = true;
;           eap.arg = skipwhite(arg.plus(4));
;           return true;
;       }

;       int[] bad_char_idx = new int[1];
;       int[] pp = null;

;       if (STRNCMP(arg, u8("bad"), 3) == 0)
;       {
;           arg = arg.plus(3);
;           pp = bad_char_idx;
;       }

;       if (pp == null || arg.at(0) != (byte)'=')
;           return false;

;       arg = arg.plus(1);
;       pp[0] = BDIFF(arg, eap.cmd);
;       arg = skip_cmd_arg(arg, false);
;       eap.arg = skipwhite(arg);
;       arg.be(0, NUL);

        ;; Check ++bad= argument.  Must be a single-byte character, "keep" or "drop".
;       Bytes p = eap.cmd.plus(bad_char_idx[0]);
;       if (STRCASECMP(p, u8("keep")) == 0)
;           eap.bad_char = BAD_KEEP;
;       else if (STRCASECMP(p, u8("drop")) == 0)
;           eap.bad_char = BAD_DROP;
;       else if (us_byte2len(p.at(0), false) == 1 && p.at(1) == NUL)
;           eap.bad_char = p.at(0);
;       else
;           return false;

;       return true;
    ))

;; ":abbreviate" and friends.

(defn- #_void ex_abbreviate [#_exarg_C eap]
    (§
;       do_exmap(eap, true);        ;; almost the same as mapping
    ))

;; ":map" and friends.

(defn- #_void ex_map [#_exarg_C eap]
    (§
            ;; If we are sourcing .exrc or .vimrc in current directory
            ;; we print the mappings for security reasons.
;       if (@secure != 0)
;       {
;           @secure = 2;
;           msg_outtrans(eap.cmd);
;           msg_putchar('\n');
;       }

;       do_exmap(eap, false);
    ))

;; ":unmap" and friends.

(defn- #_void ex_unmap [#_exarg_C eap]
    (§
;       do_exmap(eap, false);
    ))

;; ":mapclear" and friends.

(defn- #_void ex_mapclear [#_exarg_C eap]
    (§
;       map_clear(eap.cmd, eap.arg, eap.forceit, false);
    ))

;; ":abclear" and friends.

(defn- #_void ex_abclear [#_exarg_C eap]
    (§
;       map_clear(eap.cmd, eap.arg, true, true);
    ))

;; :[N]bunload[!] [N] [bufname] unload buffer
;; :[N]bdelete[!] [N] [bufname] delete buffer from buffer list
;; :[N]bwipeout[!] [N] [bufname] delete buffer really

(defn- #_void ex_bunload [#_exarg_C eap]
    (§
;       eap.errmsg = do_bufdel(
;               (eap.cmdidx == CMD_bdelete) ? DOBUF_DEL
;                   : (eap.cmdidx == CMD_bwipeout) ? DOBUF_WIPE
;                   : DOBUF_UNLOAD, eap.arg,
;               eap.addr_count, (int)eap.line1, (int)eap.line2, eap.forceit);
    ))

;; :[N]buffer [N]       to buffer N
;; :[N]sbuffer [N]      to buffer N

(defn- #_void ex_buffer [#_exarg_C eap]
    (§
;       if (eap.arg.at(0) != NUL)
;           eap.errmsg = e_trailing;
;       else
;       {
;           if (eap.addr_count == 0)    ;; default is current buffer
;               goto_buffer(eap, DOBUF_CURRENT, FORWARD, 0);
;           else
;               goto_buffer(eap, DOBUF_FIRST, FORWARD, (int)eap.line2);
;           if (eap.do_ecmd_cmd != null)
;               do_cmdline_cmd(eap.do_ecmd_cmd);
;       }
    ))

;; :[N]bmodified [N]    to next mod. buffer
;; :[N]sbmodified [N]   to next mod. buffer

(defn- #_void ex_bmodified [#_exarg_C eap]
    (§
;       goto_buffer(eap, DOBUF_MOD, FORWARD, (int)eap.line2);
;       if (eap.do_ecmd_cmd != null)
;           do_cmdline_cmd(eap.do_ecmd_cmd);
    ))

;; :[N]bnext [N]        to next buffer
;; :[N]sbnext [N]       split and to next buffer

(defn- #_void ex_bnext [#_exarg_C eap]
    (§
;       goto_buffer(eap, DOBUF_CURRENT, FORWARD, (int)eap.line2);
;       if (eap.do_ecmd_cmd != null)
;           do_cmdline_cmd(eap.do_ecmd_cmd);
    ))

;; :[N]bNext [N]        to previous buffer
;; :[N]bprevious [N]    to previous buffer
;; :[N]sbNext [N]       split and to previous buffer
;; :[N]sbprevious [N]   split and to previous buffer

(defn- #_void ex_bprevious [#_exarg_C eap]
    (§
;       goto_buffer(eap, DOBUF_CURRENT, BACKWARD, (int)eap.line2);
;       if (eap.do_ecmd_cmd != null)
;           do_cmdline_cmd(eap.do_ecmd_cmd);
    ))

;; :brewind             to first buffer
;; :bfirst              to first buffer
;; :sbrewind            split and to first buffer
;; :sbfirst             split and to first buffer

(defn- #_void ex_brewind [#_exarg_C eap]
    (§
;       goto_buffer(eap, DOBUF_FIRST, FORWARD, 0);
;       if (eap.do_ecmd_cmd != null)
;           do_cmdline_cmd(eap.do_ecmd_cmd);
    ))

;; :blast               to last buffer
;; :sblast              split and to last buffer

(defn- #_void ex_blast [#_exarg_C eap]
    (§
;       goto_buffer(eap, DOBUF_LAST, BACKWARD, 0);
;       if (eap.do_ecmd_cmd != null)
;           do_cmdline_cmd(eap.do_ecmd_cmd);
    ))

(defn- #_boolean ends_excmd [#_int c]
    (§
;       return (c == NUL || c == '|' || c == '"' || c == '\n');
    ))

;; Check if *p is a separator between Ex commands.
;; Return null if it isn't, (p + 1) if it is.

(defn- #_Bytes check_nextcmd [#_Bytes p]
    (§
;       p = skipwhite(p);
;       if (p.at(0) == (byte)'|' || p.at(0) == (byte)'\n')
;           return p.plus(1);
;       else
;           return null;
    ))

;; Call this function if we thought we were going to exit, but we won't
;; (because of an error).  May need to restore the terminal mode.

(defn- #_void not_exiting []
    (§
;       @exiting = false;
;       settmode(TMODE_RAW);
    ))

;; ":quit": quit current window, quit Vim if the last window is closed.

(defn- #_void ex_quit [#_exarg_C eap]
    (§
;       if (@cmdwin_type != 0)
;       {
;           @cmdwin_result = Ctrl_C;
;           return;
;       }

            ;; Don't quit while editing the command line.
;       if (text_locked())
;       {
;           text_locked_msg();
;           return;
;       }

;       window_C wp;

;       if (0 < eap.addr_count)
;       {
;           int wnr = (int)eap.line2;

;           for (wp = @firstwin; wp.w_next != null; wp = wp.w_next)
;               if (--wnr <= 0)
;                   break;
;       }
;       else
;           wp = @curwin;

            ;; Refuse to quit when locked or when the buffer in the last window
            ;; is being closed (can only happen in autocommands).
;       if (curbuf_locked() || (wp.w_buffer.b_nwindows == 1 && wp.w_buffer.b_closing))
;           return;

            ;; If there are more files or windows we won't exit.

;       if (only_one_window())
;           @exiting = true;
;       if ((!@cmdmod.hide && check_changed(@curbuf, (eap.forceit ? CCGD_FORCEIT : 0) | CCGD_EXCMD))
;               || (only_one_window() && check_changed_any(eap.forceit)))
;       {
;           not_exiting();
;       }
;       else
;       {
;           if (only_one_window())      ;; quit last window
;               getout(0);
                ;; close window; may free buffer
;           win_close(wp, !@cmdmod.hide || eap.forceit);
;       }
    ))

;; ":qall": try to quit all windows

(defn- #_void ex_quit_all [#_exarg_C eap]
    (§
;       if (@cmdwin_type != 0)
;       {
;           if (eap.forceit)
;               @cmdwin_result = K_XF1;      ;; ex_window() takes care of this
;           else
;               @cmdwin_result = K_XF2;
;           return;
;       }

            ;; Don't quit while editing the command line.
;       if (text_locked())
;       {
;           text_locked_msg();
;           return;
;       }

            ;; Refuse to quit when locked or when the buffer in the last window
            ;; is being closed (can only happen in autocommands).
;       if (curbuf_locked() || (@curbuf.b_nwindows == 1 && @curbuf.b_closing))
;           return;

;       @exiting = true;
;       if (eap.forceit || !check_changed_any(false))
;           getout(0);
;       not_exiting();
    ))

;; ":close": close current window, unless it is the last one

(defn- #_void ex_close [#_exarg_C eap]
    (§
;       if (@cmdwin_type != 0)
;           @cmdwin_result = Ctrl_C;
;       else if (!text_locked() && !curbuf_locked())
;       {
;           if (eap.addr_count == 0)
;               ex_win_close(eap.forceit, @curwin);
;           else
;           {
;               window_C win;
;               int winnr = 0;
;               for (win = @firstwin; win != null; win = win.w_next)
;                   if (++winnr == eap.line2)
;                       break;
;               if (win == null)
;                   win = @lastwin;
;               ex_win_close(eap.forceit, win);
;           }
;       }
    ))

;; Close window "win" and take care of handling closing the last window for a modified buffer.

(defn- #_void ex_win_close [#_boolean forceit, #_window_C win]
    (§
;       buffer_C buf = win.w_buffer;

;       boolean need_hide = (bufIsChanged(buf) && buf.b_nwindows <= 1);
;       if (need_hide && !@cmdmod.hide && !forceit)
;       {
;           emsg(e_nowrtmsg);
;           return;
;       }

        ;; free buffer when not hiding it or when it's a scratch buffer
;       win_close(win, !need_hide && !@cmdmod.hide);
    ))

;; ":only".

(defn- #_void ex_only [#_exarg_C eap]
    (§
;       if (0 < eap.addr_count)
;       {
;           int wnr = (int)eap.line2;
;           window_C wp;
;           for (wp = @firstwin; 0 < --wnr; )
;           {
;               if (wp.w_next == null)
;                   break;
;               else
;                   wp = wp.w_next;
;           }
;           win_goto(wp);
;       }
;       close_others(true, eap.forceit);
    ))

(defn- #_void ex_hide [#_exarg_C eap]
    (§
;       if (eap.arg.at(0) != NUL && check_nextcmd(eap.arg) == null)
;           eap.errmsg = e_invarg;
;       else
;       {
                ;; ":hide" or ":hide | cmd": hide current window
;           eap.nextcmd = check_nextcmd(eap.arg);
;           if (!eap.skip)
;           {
;               if (eap.addr_count == 0)
;                   win_close(@curwin, false);       ;; don't free buffer
;               else
;               {
;                   int winnr = 0;
;                   window_C win;
;                   for (win = @firstwin; win != null; win = win.w_next)
;                       if (++winnr == eap.line2)
;                           break;
;                   if (win == null)
;                       win = @lastwin;
;                   win_close(win, false);
;               }
;           }
;       }
    ))

;; ":stop" and ":suspend": Suspend Vim.

(defn- #_void ex_stop [#_exarg_C eap]
    (§
            ;; Disallow suspending for "rvim".

;       if (!check_restricted())
;       {
;           windgoto((int)@Rows - 1, 0);
;           out_char((byte)'\n');
;           out_flush();
;           stoptermcap();
;           out_flush();            ;; needed for SUN to restore xterm buffer
;           ui_suspend();           ;; call machine specific function
;           starttermcap();
;           scroll_start();         ;; scroll screen before redrawing
;           redraw_later_clear();
;           shell_resized();        ;; may have resized window
;       }
    ))

;; ":print", ":list", ":number".

(defn- #_void ex_print [#_exarg_C eap]
    (§
;       if ((@curbuf.b_ml.ml_flags & ML_EMPTY) != 0)
;           emsg(e_emptybuf);
;       else
;       {
;           for ( ; !@got_int; ui_breakcheck())
;           {
;               print_line(eap.line1,
;                       eap.cmdidx == CMD_number || eap.cmdidx == CMD_pound || (eap.flags & EXFLAG_NR) != 0,
;                       eap.cmdidx == CMD_list || (eap.flags & EXFLAG_LIST) != 0);
;               if (eap.line2 < ++eap.line1)
;                   break;
;               out_flush();            ;; show one line at a time
;           }
;           setpcmark();
                ;; put cursor at last line
;           @curwin.w_cursor.lnum = eap.line2;
;           beginline(BL_SOL | BL_FIX);
;       }

;       @ex_no_reprint = true;
    ))

(defn- #_void ex_goto [#_exarg_C eap]
    (§
;       goto_byte(eap.line2);
    ))

;; Command modifier used in a wrong way.

(defn- #_void ex_wrongmodifier [#_exarg_C eap]
    (§
;       eap.errmsg = e_invcmd;
    ))

;; :sview [+command] file       split window with new file, read-only
;; :split [[+command] file]     split window with current or new file
;; :vsplit [[+command] file]    split window vertically with current or new file
;; :new [[+command] file]       split window with no or new file
;; :vnew [[+command] file]      split vertically window with no or new file

(defn- #_void ex_splitview [#_exarg_C eap]
    (§
;       window_C old_curwin = @curwin;

;       if (win_split((0 < eap.addr_count) ? (int)eap.line2 : 0, (eap.cmd.at(0) == (byte)'v') ? WSP_VERT : 0) != false)
;       {
                ;; Reset 'scrollbind' when editing another file,
                ;; but keep it when doing ":split" without arguments.
;           if (eap.arg.at(0) != NUL)
;           {
;               @curwin.w_onebuf_opt.@wo_scb = false;
;               @curwin.w_onebuf_opt.@wo_crb = false;
;           }
;           else
;               do_check_scrollbind(false);

;           do_exedit(eap, old_curwin);
;       }
    ))

;; Open a new tab page.

(defn- #_void tabpage_new []
    (§
;       exarg_C ea = §_exarg_C();

;       ea.cmdidx = CMD_tabnew;
;       ea.cmd = u8("tabn");
;       ea.arg = u8("");

;       ex_splitview(ea);
    ))

;; ":mode": Set screen mode.
;; If no argument given, just get the screen size and redraw.

(defn- #_void ex_mode [#_exarg_C eap]
    (§
;       if (eap.arg.at(0) == NUL)
;           shell_resized();
;       else
;           mch_screenmode(eap.arg);
    ))

;; ":resize".
;; set, increment or decrement current window height

(defn- #_void ex_resize [#_exarg_C eap]
    (§
;       window_C wp = @curwin;

;       if (0 < eap.addr_count)
;       {
;           int n = (int)eap.line2;
;           for (wp = @firstwin; wp.w_next != null && 0 < --n; wp = wp.w_next)
                ;
;       }

;       int n = libC.atoi(eap.arg);
;       if ((@cmdmod.split & WSP_VERT) != 0)
;       {
;           if (eap.arg.at(0) == (byte)'-' || eap.arg.at(0) == (byte)'+')
;               n += @curwin.w_width;
;           else if (n == 0 && eap.arg.at(0) == NUL)   ;; default is very wide
;               n = 9999;
;           win_setwidth_win(n, wp);
;       }
;       else
;       {
;           if (eap.arg.at(0) == (byte)'-' || eap.arg.at(0) == (byte)'+')
;               n += @curwin.w_height;
;           else if (n == 0 && eap.arg.at(0) == NUL)   ;; default is very wide
;               n = 9999;
;           win_setheight_win(n, wp);
;       }
    ))

;; ":edit", ":badd", ":visual".

(defn- #_void ex_edit [#_exarg_C eap]
    (§
;       do_exedit(eap, null);
    ))

;; ":edit <file>" command and alikes.

(defn- #_void do_exedit [#_exarg_C eap, #_window_C old_curwin]
    ;; old_curwin: curwin before doing a split or null
    (§
;       int exmode_was = @exmode_active;

        ;; ":vi" command ends Ex mode.

;       if (@exmode_active != 0 && (eap.cmdidx == CMD_visual || eap.cmdidx == CMD_view))
;       {
;           @exmode_active = 0;
;           if (eap.arg.at(0) == NUL)
;           {
                ;; Special case: ":global/pat/visual\NLvi-commands".
;               if (@global_busy != 0)
;               {
;                   int rd = @redrawingDisabled;
;                   int nwr = @no_wait_return;
;                   boolean ms = @msg_scroll;

;                   if (eap.nextcmd != null)
;                   {
;                       stuffReadbuff(eap.nextcmd);
;                       eap.nextcmd = null;
;                   }

;                   if (exmode_was != EXMODE_VIM)
;                       settmode(TMODE_RAW);
;                   @redrawingDisabled = 0;
;                   @no_wait_return = FALSE;
;                   @need_wait_return = false;
;                   @msg_scroll = false;
;                   @must_redraw = CLEAR;

;                   main_loop(false, true);

;                   @redrawingDisabled = rd;
;                   @no_wait_return = nwr;
;                   @msg_scroll = ms;
;               }
;               return;
;           }
;       }

;       if ((eap.cmdidx == CMD_new || eap.cmdidx == CMD_vnew) && eap.arg.at(0) == NUL)
;       {
            ;; ":new" without argument: edit an new empty buffer
;           setpcmark();
;           do_ecmd(null, eap, ECMD_ONE,
;                         ECMD_HIDE + (eap.forceit ? ECMD_FORCEIT : 0),
;                         (old_curwin == null) ? @curwin : null);
;       }
;       else if ((eap.cmdidx != CMD_split && eap.cmdidx != CMD_vsplit) || eap.arg.at(0) != NUL)
;       {
            ;; Can't edit another file when "curbuf_lock" is set.
            ;; Only ":edit" can bring us here, others are stopped earlier.
;           if (eap.arg.at(0) != NUL && curbuf_locked())
;               return;

;           boolean rom = @readonlymode;
;           if (eap.cmdidx == CMD_view || eap.cmdidx == CMD_sview)
;               @readonlymode = true;
;           else if (eap.cmdidx == CMD_enew)
;               @readonlymode = false;   ;; 'readonly' doesn't make sense in an empty buffer
;           setpcmark();
;           if (do_ecmd((eap.cmdidx == CMD_enew) ? null : eap.arg,
;                       eap,
                        ;; ":edit" goes to first line if Vi compatible
;                       (eap.arg.at(0) == NUL && eap.do_ecmd_lnum == 0 && vim_strbyte(@p_cpo, CPO_GOTO1) != null) ? ECMD_ONE : eap.do_ecmd_lnum,
;                       (@cmdmod.hide ? ECMD_HIDE : 0) + (eap.forceit ? ECMD_FORCEIT : 0),
;                       (old_curwin == null) ? @curwin : null) == false)
;           {
                ;; Editing the file failed.  If the window was split, close it.
;               if (old_curwin != null)
;               {
;                   boolean need_hide = (curbufIsChanged() && @curbuf.b_nwindows <= 1);
;                   if (!need_hide || @cmdmod.hide)
;                   {
;                       cleanup_C cs = §_cleanup_C();

                        ;; Reset the error/interrupt/exception state here so that
                        ;; aborting() returns false when closing a window.
;                       enter_cleanup(cs);
;                       win_close(@curwin, !need_hide && !@cmdmod.hide);

                        ;; Restore the error/interrupt/exception state if not discarded
                        ;; by a new aborting error, interrupt, or uncaught exception.
;                       leave_cleanup(cs);
;                   }
;               }
;           }
;           else if (@readonlymode && @curbuf.b_nwindows == 1)
;           {
                ;; When editing an already visited buffer, 'readonly' won't be set
                ;; but the previous value is kept.  With ":view" and ":sview" we
                ;; want the  file to be readonly, except when another window is
                ;; editing the same buffer.
;               @curbuf.@b_p_ro = true;
;           }
;           @readonlymode = rom;
;       }
;       else
;       {
;           if (eap.do_ecmd_cmd != null)
;               do_cmdline_cmd(eap.do_ecmd_cmd);
;       }

        ;; if ":split file" worked, set alternate file name in old window to new file

;       if (old_curwin != null
;               && eap.arg.at(0) != NUL
;               && @curwin != old_curwin
;               && win_valid(old_curwin)
;               && old_curwin.w_buffer != @curbuf
;               && !@cmdmod.keepalt)
;           old_curwin.w_alt_fnum = @curbuf.b_fnum;

;       @ex_no_reprint = true;
    ))

;; ":syncbind" forces all 'scrollbind' windows to have the same relative offset.

(defn- #_void ex_syncbind [#_exarg_C _eap]
    (§
;       window_C save_curwin = @curwin;
;       buffer_C save_curbuf = @curbuf;
;       long old_linenr = @curwin.w_cursor.lnum;

;       setpcmark();

;       long topline;
            ;; determine max topline
;       if (@curwin.w_onebuf_opt.@wo_scb)
;       {
;           topline = @curwin.w_topline;
;           for (window_C wp = @firstwin; wp != null; wp = wp.w_next)
;           {
;               if (wp.w_onebuf_opt.@wo_scb && wp.w_buffer != null)
;               {
;                   long y = wp.w_buffer.b_ml.ml_line_count - @p_so;
;                   if (y < topline)
;                       topline = y;
;               }
;           }
;           if (topline < 1)
;               topline = 1;
;       }
;       else
;       {
;           topline = 1;
;       }

            ;; Set all scrollbind windows to the same topline.

;       for (@curwin = @firstwin; @curwin != null; @curwin = @curwin.w_next)
;       {
;           if (@curwin.w_onebuf_opt.@wo_scb)
;           {
;               @curbuf = @curwin.w_buffer;
;               long y = topline - @curwin.w_topline;
;               if (0 < y)
;                   scrollup(y);
;               else
;                   scrolldown(-y);
;               @curwin.w_scbind_pos = topline;
;               redraw_later(VALID);
;               cursor_correct();
;               @curwin.w_redr_status = true;
;           }
;       }
;       @curwin = save_curwin;
;       @curbuf = save_curbuf;
;       if (@curwin.w_onebuf_opt.@wo_scb)
;       {
;           @did_syncbind = true;
;           checkpcmark();
;           if (old_linenr != @curwin.w_cursor.lnum)
;           {
;               Bytes ctrl_o = new Bytes(2);

;               ctrl_o.be(0, Ctrl_O);
;               ctrl_o.be(1, NUL);
;               ins_typebuf(ctrl_o, REMAP_NONE, 0, true, false);
;           }
;       }
    ))

;; ":=".

(defn- #_void ex_equal [#_exarg_C eap]
    (§
;       smsg(u8("%ld"), eap.line2);
;       ex_may_print(eap);
    ))

;; Sleep for "msec" milliseconds, but keep checking for a CTRL-C every second.

(defn- #_void do_sleep [#_long msec]
    (§
;       cursor_on();
;       out_flush();
;       for (long done = 0; !@got_int && done < msec; done += 1000L)
;       {
;           ui_delay(1000L < msec - done ? 1000L : msec - done, true);
;           ui_breakcheck();
;       }
    ))

(defn- #_void do_exmap [#_exarg_C eap, #_boolean isabbrev]
    (§
;       Bytes[] cmdp = { eap.cmd };
;       int mode = get_map_mode(cmdp, eap.forceit || isabbrev);

;       switch (do_map((cmdp[0].at(0) == (byte)'n') ? 2 : (cmdp[0].at(0) == (byte)'u') ? 1 : 0, eap.arg, mode, isabbrev))
;       {
;           case 1: emsg(e_invarg);
;                   break;
;           case 2: emsg(isabbrev ? e_noabbr : e_nomap);
;                   break;
;       }
    ))

(defn- #_void ex_wincmd [#_exarg_C eap]
    (§
;       int xchar = NUL;
;       Bytes p;

;       if (eap.arg.at(0) == (byte)'g' || eap.arg.at(0) == Ctrl_G)
;       {
                ;; CTRL-W g and CTRL-W CTRL-G have an extra command character.
;           if (eap.arg.at(1) == NUL)
;           {
;               emsg(e_invarg);
;               return;
;           }
;           xchar = eap.arg.at(1);
;           p = eap.arg.plus(2);
;       }
;       else
;           p = eap.arg.plus(1);

;       eap.nextcmd = check_nextcmd(p);
;       p = skipwhite(p);
;       if (p.at(0) != NUL && p.at(0) != (byte)'"' && eap.nextcmd == null)
;           emsg(e_invarg);
;       else if (!eap.skip)
;       {
                ;; Pass flags on for ":vertical wincmd ]".
;           @postponed_split_flags = @cmdmod.split;
;           do_window(eap.arg.at(0), (0 < eap.addr_count) ? eap.line2 : 0L, xchar);
;           @postponed_split_flags = 0;
;       }
    ))

;; Handle command that work like operators: ":delete", ":yank", ":>" and ":<".

(defn- #_void ex_operators [#_exarg_C eap]
    (§
;       oparg_C oa = §_oparg_C();

;       oa.regname = eap.regname;
;       oa.op_start.lnum = eap.line1;
;       oa.op_end.lnum = eap.line2;
;       oa.line_count = eap.line2 - eap.line1 + 1;
;       oa.motion_type = MLINE;
;       @virtual_op = FALSE;

;       if (eap.cmdidx != CMD_yank)     ;; position cursor for undo
;       {
;           setpcmark();
;           @curwin.w_cursor.lnum = eap.line1;
;           beginline(BL_SOL | BL_FIX);
;       }

;       if (@VIsual_active)
;           end_visual_mode();

;       switch (eap.cmdidx)
;       {
;           case CMD_delete:
;               oa.op_type = OP_DELETE;
;               op_delete(oa);
;               break;

;           case CMD_yank:
;               oa.op_type = OP_YANK;
;               op_yank(oa, false, true);
;               break;

;           default:    ;; CMD_rshift or CMD_lshift
;               if ((eap.cmdidx == CMD_rshift) ^ @curwin.w_onebuf_opt.@wo_rl)
;                   oa.op_type = OP_RSHIFT;
;               else
;                   oa.op_type = OP_LSHIFT;
;               op_shift(oa, false, eap.amount);
;               break;
;       }
;       @virtual_op = MAYBE;
;       ex_may_print(eap);
    ))

;; ":put".

(defn- #_void ex_put [#_exarg_C eap]
    (§
            ;; ":0put" works like ":1put!".
;       if (eap.line2 == 0)
;       {
;           eap.line2 = 1;
;           eap.forceit = true;
;       }
;       @curwin.w_cursor.lnum = eap.line2;
;       do_put(eap.regname, eap.forceit ? BACKWARD : FORWARD, 1, PUT_LINE|PUT_CURSLINE);
    ))

;; Handle ":copy" and ":move".

(defn- #_void ex_copymove [#_exarg_C eap]
    (§
;       long n;
;       { Bytes[] __ = { eap.arg }; n = get_address(__, eap.addr_type, false, false); eap.arg = __[0]; }
;       if (eap.arg == null)        ;; error detected
;       {
;           eap.nextcmd = null;
;           return;
;       }
;       get_flags(eap);

            ;; move or copy lines from 'eap.line1'-'eap.line2' to below line 'n'
;       if (n == MAXLNUM || n < 0 || @curbuf.b_ml.ml_line_count < n)
;       {
;           emsg(e_invaddr);
;           return;
;       }

;       if (eap.cmdidx == CMD_move)
;       {
;           if (do_move(eap.line1, eap.line2, n) == false)
;               return;
;       }
;       else
;           ex_copy(eap.line1, eap.line2, n);
;       u_clearline();
;       beginline(BL_SOL | BL_FIX);
;       ex_may_print(eap);
    ))

;; Print the current line if flags were given to the Ex command.

(defn- #_void ex_may_print [#_exarg_C eap]
    (§
;       if (eap.flags != 0)
;       {
;           print_line(@curwin.w_cursor.lnum, (eap.flags & EXFLAG_NR) != 0, (eap.flags & EXFLAG_LIST) != 0);
;           @ex_no_reprint = true;
;       }
    ))

;; ":smagic" and ":snomagic".

(defn- #_void ex_submagic [#_exarg_C eap]
    (§
;       boolean magic_save = @p_magic;

;       @p_magic = (eap.cmdidx == CMD_smagic);
;       ex_sub(eap);
;       @p_magic = magic_save;
    ))

;; ":join".

(defn- #_void ex_join [#_exarg_C eap]
    (§
;       @curwin.w_cursor.lnum = eap.line1;
;       if (eap.line1 == eap.line2)
;       {
;           if (2 <= eap.addr_count)    ;; :2,2join does nothing
;               return;
;           if (eap.line2 == @curbuf.b_ml.ml_line_count)
;           {
;               beep_flush();
;               return;
;           }
;           eap.line2++;
;       }
;       do_join((int)(eap.line2 - eap.line1 + 1), !eap.forceit, true, true, true);
;       beginline(BL_WHITE | BL_FIX);
;       ex_may_print(eap);
    ))

;; ":undo".

(defn- #_void ex_undo [#_exarg_C eap]
    (§
;       if (eap.addr_count == 1)    ;; :undo 123
;           undo_time(eap.line2, false, false, true);
;       else
;           u_undo(1);
    ))

;; ":redo".

(defn- #_void ex_redo [#_exarg_C _eap]
    (§
;       u_redo(1);
    ))

;; ":earlier" and ":later".

(defn- #_void ex_later [#_exarg_C eap]
    (§
;       long count = 0;
;       boolean sec = false;
;       boolean file = false;
;       Bytes p = eap.arg;

;       if (p.at(0) == NUL)
;           count = 1;
;       else if (asc_isdigit(p.at(0)))
;       {
;           { Bytes[] __ = { p }; count = getdigits(__); p = __[0]; }
;           switch (p.at(0))
;           {
;               case 's': p = p.plus(1); sec = true; break;
;               case 'm': p = p.plus(1); sec = true; count *= 60; break;
;               case 'h': p = p.plus(1); sec = true; count *= 60 * 60; break;
;               case 'd': p = p.plus(1); sec = true; count *= 24 * 60 * 60; break;
;               case 'f': p = p.plus(1); file = true; break;
;           }
;       }

;       if (p.at(0) != NUL)
;           emsg2(e_invarg2, eap.arg);
;       else
;           undo_time(eap.cmdidx == CMD_earlier ? -count : count, sec, file, false);
    ))

;; ":redraw": force redraw

(defn- #_void ex_redraw [#_exarg_C eap]
    (§
;       int r = @redrawingDisabled;
;       boolean p = @p_lz;

;       @redrawingDisabled = 0;
;       @p_lz = false;
;       update_topline();
;       update_screen(eap.forceit ? CLEAR : @VIsual_active ? INVERTED : 0);
;       @redrawingDisabled = r;
;       @p_lz = p;

            ;; Reset msg_didout, so that a message that's there is overwritten.
;       @msg_didout = false;
;       @msg_col = 0;

            ;; No need to wait after an intentional redraw.
;       @need_wait_return = false;

;       out_flush();
    ))

;; ":redrawstatus": force redraw of status line(s)

(defn- #_void ex_redrawstatus [#_exarg_C eap]
    (§
;       int r = @redrawingDisabled;
;       boolean p = @p_lz;

;       @redrawingDisabled = 0;
;       @p_lz = false;
;       if (eap.forceit)
;           status_redraw_all();
;       else
;           status_redraw_curbuf();
;       update_screen(@VIsual_active ? INVERTED : 0);
;       @redrawingDisabled = r;
;       @p_lz = p;
;       out_flush();
    ))

;; ":mark" and ":k".

(defn- #_void ex_mark [#_exarg_C eap]
    (§
;       if (eap.arg.at(0) == NUL)                   ;; No argument?
;           emsg(e_argreq);
;       else if (eap.arg.at(1) != NUL)              ;; more than one character?
;           emsg(e_trailing);
;       else
;       {
;           pos_C pos = §_pos_C();
;           COPY_pos(pos, @curwin.w_cursor);
;           @curwin.w_cursor.lnum = eap.line2;
;           beginline(BL_WHITE | BL_FIX);
;           if (setmark(eap.arg.at(0)) == false)    ;; set mark
;               emsg(u8("E191: Argument must be a letter or forward/backward quote"));
;           COPY_pos(@curwin.w_cursor, pos);
;       }
    ))

;; Update w_topline, w_leftcol and the cursor position.

(defn- #_void update_topline_cursor []
    (§
;       check_cursor();             ;; put cursor on valid line
;       update_topline();
;       if (!@curwin.w_onebuf_opt.@wo_wrap)
;           validate_cursor();
;       update_curswant();
    ))

;; ":normal[!] {commands}": Execute normal mode commands.

(defn- #_void ex_normal [#_exarg_C eap]
    (§
;       boolean save_msg_didout = @msg_didout;
;       int save_State = @State;
;       boolean save_finish_op = @finish_op;
;       long save_opcount = @opcount;

;       if (0 < @ex_normal_lock)
;       {
;           emsg(e_secure);
;           return;
;       }
;       if (@p_mmd <= @ex_normal_busy)
;       {
;           emsg(u8("E192: Recursive use of :normal too deep"));
;           return;
;       }

;       @ex_normal_busy++;

;       boolean save_msg_scroll = @msg_scroll;
;       int save_restart_edit = @restart_edit;
;       boolean save_insertmode = @p_im;

;       @msg_scroll = false;     ;; no msg scrolling in Normal mode
;       @restart_edit = 0;       ;; don't go to Insert mode
;       @p_im = false;           ;; don't use 'insertmode'

            ;; vgetc() expects a CSI and KB_SPECIAL to have been escaped.
            ;; Don't do this for the KB_SPECIAL leading byte, otherwise special keys will not work.

            ;; Count the number of characters to be escaped.
;       int len = 0;
;       for (Bytes p = eap.arg; p.at(0) != NUL; p = p.plus(1))
;       {
;           for (int l = us_ptr2len_cc(p) - 1; 0 < l; --l)
;               if ((p = p.plus(1)).at(0) == KB_SPECIAL)        ;; trailbyte KB_SPECIAL or CSI
;                   len += 2;
;       }
;       Bytes arg = null;
;       if (0 < len)
;       {
;           arg = new Bytes(STRLEN(eap.arg) + len + 1);

;           len = 0;
;           for (Bytes p = eap.arg; p.at(0) != NUL; p = p.plus(1))
;           {
;               arg.be(len++, p.at(0));
;               for (int l = us_ptr2len_cc(p) - 1; 0 < l; --l)
;               {
;                   arg.be(len++, (p = p.plus(1)).at(0));
;                   if (p.at(0) == KB_SPECIAL)
;                   {
;                       arg.be(len++, KS_SPECIAL);
;                       arg.be(len++, KE_FILLER);
;                   }
;               }
;               arg.be(len, NUL);
;           }
;       }

            ;; Save the current typeahead.  This is required to allow using ":normal"
            ;; from an event handler and makes sure we don't hang when the argument
            ;; ends with half a command.

;       tasave_C tabuf = new_tasave();
;       save_typeahead(tabuf);

            ;; Repeat the :normal command for each line in the range.
            ;; When no range given, execute it just once, without positioning the cursor first.

;       do
;       {
;           if (eap.addr_count != 0)
;           {
;               @curwin.w_cursor.lnum = eap.line1++;
;               @curwin.w_cursor.col = 0;
;           }

;           exec_normal_cmd((arg != null) ? arg : eap.arg, eap.forceit ? REMAP_NONE : REMAP_YES, false);
;       } while (0 < eap.addr_count && eap.line1 <= eap.line2 && !@got_int);

            ;; Might not return to the main loop when in an event handler.
;       update_topline_cursor();

            ;; Restore the previous typeahead.
;       restore_typeahead(tabuf);

;       --@ex_normal_busy;

;       @msg_scroll = save_msg_scroll;
;       @restart_edit = save_restart_edit;
;       @p_im = save_insertmode;

;       @finish_op = save_finish_op;
;       @opcount = save_opcount;
;       @msg_didout |= save_msg_didout;      ;; don't reset msg_didout now

            ;; Restore the state (needed when called from a function executed for
            ;; 'indentexpr').  Update the mouse and cursor, they may have changed.
;       @State = save_State;
;       setmouse();
;       ui_cursor_shape();          ;; may show different cursor shape
    ))

;; ":startinsert", ":startreplace" and ":startgreplace"

(defn- #_void ex_startinsert [#_exarg_C eap]
    (§
;       if (eap.forceit)
;       {
;           coladvance(MAXCOL);
;           @curwin.w_curswant = MAXCOL;
;           @curwin.w_set_curswant = false;
;       }

            ;; Ignore the command when already in Insert mode.  Inserting an
            ;; expression register that invokes a function can do this.
;       if ((@State & INSERT) != 0)
;           return;

;       if (eap.cmdidx == CMD_startinsert)
;           @restart_edit = 'a';
;       else if (eap.cmdidx == CMD_startreplace)
;           @restart_edit = 'R';
;       else
;           @restart_edit = 'V';

;       if (!eap.forceit)
;       {
;           if (eap.cmdidx == CMD_startinsert)
;               @restart_edit = 'i';
;           @curwin.w_curswant = 0;  ;; avoid MAXCOL
;       }
    ))

;; ":stopinsert"

(defn- #_void ex_stopinsert [#_exarg_C _eap]
    (§
;       @restart_edit = 0;
;       @stop_insert_mode = true;
    ))

;; Execute normal mode command "cmd".
;; "remap" can be REMAP_NONE or REMAP_YES.

(defn- #_void exec_normal_cmd [#_Bytes cmd, #_int remap, #_boolean silent]
    (§
;       oparg_C oa = §_oparg_C();

        ;; Stuff the argument into the typeahead buffer.
        ;; Execute normal_cmd() until there is no typeahead left.

;       @finish_op = false;
;       ins_typebuf(cmd, remap, 0, true, silent);
;       while ((!stuff_empty() || (!typebuf_typed() && 0 < @typebuf.tb_len)) && !@got_int)
;       {
;           update_topline_cursor();
;           normal_cmd(oa, true);   ;; execute a Normal mode cmd
;       }
    ))

;; Make a dialog message in "buff[DIALOG_MSG_SIZE]".
;; "format" must contain "%s".

(defn- #_void dialog_msg [#_Bytes buff, #_Bytes format, #_Bytes fname]
    (§
;       if (fname == null)
;           fname = u8("Untitled");
;       vim_snprintf(buff, DIALOG_MSG_SIZE, format, fname);
    ))

(defn- #_void ex_digraphs [#_exarg_C eap]
    (§
;       if (eap.arg.at(0) != NUL)
;           putdigraph(eap.arg);
;       else
;           listdigraphs();
    ))

(defn- #_void ex_set [#_exarg_C eap]
    (§
;       int flags = 0;

;       if (eap.cmdidx == CMD_setlocal)
;           flags = OPT_LOCAL;
;       else if (eap.cmdidx == CMD_setglobal)
;           flags = OPT_GLOBAL;
;       do_set(eap.arg, flags);
    ))

;; ":nohlsearch"

(defn- #_void ex_nohlsearch [#_exarg_C _eap]
    (§
;       @no_hlsearch = true;
;       redraw_all_later(SOME_VALID);
    ))

;; ex_eval.c: functions for Ex command line for the +eval feature ---------------------------------

;; Exception handling terms:
;;
;;      :try            ":try" command          \
;;          ...         try block               |
;;      :catch RE       ":catch" command        |
;;          ...         catch clause            |- try conditional
;;      :finally        ":finally" command      |
;;          ...         finally clause          |
;;      :endtry         ":endtry" command       /
;;
;; The try conditional may have any number of catch clauses and at most one
;; finally clause.  A ":throw" command can be inside the try block, a catch
;; clause, the finally clause, or in a function called or script sourced from
;; there or even outside the try conditional.  Try conditionals may be nested.

;; Configuration whether an exception is thrown on error or interrupt.  When
;; the preprocessor macros below evaluate to false, an error (did_emsg) or
;; interrupt (got_int) under an active try conditional terminates the script
;; after the non-active finally clauses of all active try conditionals have been
;; executed.  Otherwise, errors and/or interrupts are converted into catchable
;; exceptions (did_throw additionally set), which terminate the script only if
;; not caught.  For user exceptions, only did_throw is set.  (Note: got_int can
;; be set asynchronously afterwards by a SIGINT, so did_throw && got_int is not
;; a reliant test that the exception currently being thrown is an interrupt
;; exception.  Similarly, did_emsg can be set afterwards on an error in an
;; (unskipped) conditional command inside an inactive conditional, so did_throw
;; && did_emsg is not a reliant test that the exception currently being thrown
;; is an error exception.)  -  The macros can be defined as expressions checking
;; for a variable that is allowed to be changed during execution of a script.

;; When several errors appear in a row, setting "force_abort" is delayed until
;; the failing command returned.  "cause_abort" is set to true meanwhile, in
;; order to indicate that situation.  This is useful when "force_abort" was set
;; during execution of a function call from an expression: the aborting of the
;; expression evaluation is done without producing any error messages, but all
;; error messages on parsing errors during the expression evaluation are given
;; (even if a try conditional is active).

(atom! boolean cause_abort)

;; Return true when immediately aborting on error, or when an interrupt
;; occurred or an exception was thrown but not caught.  Use for ":{range}call"
;; to check whether an aborted function that does not handle a range itself
;; should be called again for the next line in the range.  Also used for
;; cancelling expression evaluation after a function call caused an immediate
;; abort.  Note that the first emsg() call temporarily resets "force_abort"
;; until the throw point for error messages has been reached.  That is, during
;; cancellation of an expression evaluation after an aborting function call or
;; due to a parsing error, aborting() always returns the same value.

(defn- #_boolean aborting []
    (§
;       return (@did_emsg && @force_abort) || @got_int || @did_throw;
    ))

;; The value of "force_abort" is temporarily reset by the first emsg() call
;; during an expression evaluation, and "cause_abort" is used instead.  It might
;; be necessary to restore "force_abort" even before the throw point for the
;; error message has been reached.  update_force_abort() should be called then.

(defn- #_void update_force_abort []
    (§
;       if (@cause_abort)
;           @force_abort = true;
    ))

;; Return true if a command with a subcommand resulting in "retcode" should
;; abort the script processing.  Can be used to suppress an autocommand after
;; execution of a failing subcommand as long as the error message has not been
;; displayed and actually caused the abortion.

(defn- #_boolean should_abort [#_boolean retcode]
    (§
;       return aborting();
    ))

;; Return true if a function with the "abort" flag should not be considered
;; ended on an error.  This means that parsing commands is continued in order
;; to find finally clauses to be executed, and that some errors in skipped
;; commands are still reported.

(defn- #_boolean aborted_in_try []
    (§
        ;; This function is only called after an error.  In this case, "force_abort"
        ;; determines whether searching for finally clauses is necessary.
;       return @force_abort;
    ))

;; cause_errthrow(): Cause a throw of an error exception if appropriate.
;; Return true if the error message should not be displayed by emsg().
;; Sets "ignore", if the emsg() call should be ignored completely.
;;
;; When several messages appear in the same command, the first is usually the
;; most specific one and used as the exception value.  The "severe" flag can be
;; set to true, if a later but severer message should be used instead.

(defn- #_boolean cause_errthrow [#_Bytes mesg, #_boolean severe, #_boolean* ignore]
    (§
        ;; Do nothing when displaying the interrupt message or reporting an
        ;; uncaught exception (which has already been discarded then) at the top level.
        ;; Also when no exception can be thrown.  The message will be displayed by emsg().

;       if (@suppress_errthrow)
;           return false;

        ;; If emsg() has not been called previously, temporarily reset "force_abort" until
        ;; the throw point for error messages has been reached.  This ensures that aborting()
        ;; returns the same value for all errors that appear in the same command.
        ;; This means particularly that for parsing errors during expression evaluation
        ;; emsg() will be called multiply, even when the expression is evaluated from a finally
        ;; clause that was activated due to an aborting error, interrupt, or exception.

;       if (!@did_emsg)
;       {
;           @cause_abort = @force_abort;
;           @force_abort = false;
;       }

        ;; If no try conditional is active and no exception is being thrown and
        ;; there has not been an error in a try conditional or a throw so far, do
        ;; nothing (for compatibility of non-EH scripts).  The message will then
        ;; be displayed by emsg().  When ":silent!" was used and we are not
        ;; currently throwing an exception, do nothing.  The message text will
        ;; then be stored to v:errmsg by emsg() without displaying it.

;       if ((!@cause_abort || @emsg_silent != 0) && !@did_throw)
;           return false;

        ;; Ignore an interrupt message when inside a try conditional or when an
        ;; exception is being thrown or when an error in a try conditional or
        ;; throw has been detected previously.  This is important in order that an
        ;; interrupt exception is catchable by the innermost try conditional and
        ;; not replaced by an interrupt message error exception.

;       if (BEQ(mesg, e_interr))
;       {
;           ignore[0] = true;
;           return true;
;       }

        ;; Ensure that all commands in nested function calls and sourced files
        ;; are aborted immediately.

;       @cause_abort = true;

        ;; When an exception is being thrown, some commands (like conditionals) are
        ;; not skipped.  Errors in those commands may affect what of the subsequent
        ;; commands are regarded part of catch and finally clauses.  Catching the
        ;; exception would then cause execution of commands not intended by the
        ;; user, who wouldn't even get aware of the problem.  Therefor, discard the
        ;; exception currently being thrown to prevent it from being caught.  Just
        ;; execute finally clauses and terminate.

;       if (@did_throw)
;       {
            ;; When discarding an interrupt exception, reset got_int to prevent the
            ;; same interrupt being converted to an exception again and discarding
            ;; the error exception we are about to throw here.
;           if (@current_exception.type == ET_INTERRUPT)
;               @got_int = false;
;           discard_current_exception();
;       }

        ;; Prepare the throw of an error exception, so that everything will be aborted
        ;; (except for executing finally clauses), until the error exception is caught;
        ;; if still uncaught at the top level, the error message will be displayed and
        ;; the script processing terminated then.  This function has no access to the
        ;; conditional stack.  Thus, the actual throw is made after the failing command
        ;; has returned.  Throw only the first of several errors in a row, except
        ;; a severe error is following.

;       if (@msg_list != null)
;       {
;           msglist_C last = null;
;           for (msglist_C list = @msg_list[0]; list != null; list = list.next)
;               last = list;

;           msglist_C elem = §_msglist_C();

;           elem.msg = STRDUP(mesg);
;           elem.next = null;
;           elem.throw_msg = null;
;           if (last == null)
;               @msg_list[0] = elem;
;           else
;               last.next = elem;
;           if (last == null || severe)
;           {
                ;; Skip the extra "Vim " prefix for message "E458".
;               Bytes tmsg = elem.msg;
;               if (STRNCMP(tmsg, u8("Vim E"), 5) == 0
;                       && asc_isdigit(tmsg.at(5))
;                       && asc_isdigit(tmsg.at(6))
;                       && asc_isdigit(tmsg.at(7))
;                       && tmsg.at(8) == (byte)':'
;                       && tmsg.at(9) == (byte)' ')
;                   @msg_list[0].throw_msg = tmsg.plus(4);
;               else
;                   @msg_list[0].throw_msg = tmsg;
;           }
;       }

;       return true;
    ))

;; Free global "*msg_list" and the messages it contains, then set "*msg_list" to null.

(defn- #_void free_global_msglist []
    (§
;       @msg_list[0] = null;
    ))

;; Throw the message specified in the call to cause_errthrow() above as an error exception.
;; If !did, postpone the throw until do_cmdline() has returned (see do_one_cmd()).

(defn- #_void do_errthrow [#_boolean did, #_Bytes cmdname]
    (§
        ;; Ensure that all commands in nested function calls and sourced files
        ;; are aborted immediately.

;       if (@cause_abort)
;       {
;           @cause_abort = false;
;           @force_abort = true;
;       }

        ;; If no exception is to be thrown or the conversion should be done after
        ;; returning to a previous invocation of do_one_cmd(), do nothing.
;       if (@msg_list == null || @msg_list[0] == null)
;           return;

;       if (throw_exception(@msg_list[0], ET_ERROR, cmdname) != false)
;       {
;           if (did)
;               @did_throw = true;
;           else
;               @need_rethrow = true;
;       }
;       @msg_list[0] = null;
    ))

;; do_intthrow(): Replace the current exception by an interrupt or interrupt
;; exception if appropriate.  Return true if the current exception is discarded,
;; false otherwise.

(defn- #_boolean do_intthrow []
    (§
        ;; If no interrupt occurred or no try conditional is active and no exception
        ;; is being thrown, do nothing (for compatibility of non-EH scripts).

;       if (!@got_int || !@did_throw)
;           return false;

        ;; Throw an interrupt exception, so that everything will be aborted
        ;; (except for executing finally clauses), until the interrupt exception
        ;; is caught; if still uncaught at the top level, the script processing
        ;; will be terminated then.  -  If an interrupt exception is already
        ;; being thrown, do nothing.

;       if (@did_throw)
;       {
;           if (@current_exception.type == ET_INTERRUPT)
;               return false;

            ;; An interrupt exception replaces any user or error exception.
;           discard_current_exception();
;       }
;       if (throw_exception(u8("Vim:Interrupt"), ET_INTERRUPT, null) != false)
;           @did_throw = true;

;       return true;
    ))

;; Get an exception message that is to be stored in current_exception.value.

(defn- #_Bytes get_exception_string [#_"/*msglist_C|Bytes*/Object" value, #_int type, #_Bytes cmdname]
    (§
;       Bytes ret;

;       if (type == ET_ERROR)
;       {
;           Bytes mesg = ((msglist_C)value).throw_msg;

;           Bytes val;
;           if (cmdname != null && cmdname.at(0) != NUL)
;           {
;               int cmdlen = STRLEN(cmdname);
;               ret = STRNDUP(u8("Vim("), 4 + cmdlen + 2 + STRLEN(mesg));
;               STRCPY(ret.plus(4), cmdname);
;               STRCPY(ret.plus(4 + cmdlen), u8("):"));
;               val = ret.plus(4 + cmdlen + 2);
;           }
;           else
;           {
;               ret = STRNDUP(u8("Vim:"), 4 + STRLEN(mesg));
;               val = ret.plus(4);
;           }

            ;; msg_add_fname() may have been used to prefix the message with a file name in quotes.
            ;; In the exception value, put the file name in parentheses and move it to the end.
;           for (Bytes p = mesg; ; p = p.plus(1))
;           {
;               if (p.at(0) == NUL
;                       || (p.at(0) == (byte)'E'
;                           && asc_isdigit(p.at(1))
;                           && (p.at(2) == (byte)':'
;                               || (asc_isdigit(p.at(2))
;                                   && (p.at(3) == (byte)':'
;                                       || (asc_isdigit(p.at(3))
;                                           && p.at(4) == (byte)':'))))))
;               {
;                   if (p.at(0) == NUL || BEQ(p, mesg))
;                       STRCAT(val, mesg);          ;; 'E123' missing or at beginning
;                   else
;                   {
                        ;; '"filename" E123: message text'
;                       if (mesg.at(0) != (byte)'"' || BLT(p.minus(2), mesg.plus(1)) || p.at(-2) != (byte)'"' || p.at(-1) != (byte)' ')
                            ;; "E123:" is part of the file name.
;                           continue;

;                       STRCAT(val, p);
;                       p.be(-2, NUL);
;                       libC.sprintf(val.plus(STRLEN(p)), u8(" (%s)"), mesg.plus(1));
;                       p.be(-2, (byte)'"');
;                   }
;                   break;
;               }
;           }
;       }
;       else
;       {
;           ret = (Bytes)value;
;       }

;       return ret;
    ))

;; Throw a new exception.  Return false when out of memory or it was tried to throw
;; an illegal user exception.  "value" is the exception string for a user or
;; interrupt exception, or points to a message list in case of an error exception.

(defn- #_boolean throw_exception [#_"/*msglist_C|Bytes*/Object" value, #_int type, #_Bytes cmdname]
    (§
        ;; Disallow faking Interrupt or error exceptions as user exceptions.
        ;; They would be treated differently from real interrupt or error exceptions
        ;; when no active try block is found, see do_cmdline().

;       if (type == ET_USER)
;       {
;           Bytes v = (Bytes)value;
;           if (STRNCMP(v, u8("Vim"), 3) == 0 && (v.at(3) == NUL || v.at(3) == (byte)':' || v.at(3) == (byte)'('))
;           {
;               emsg(u8("E608: Cannot :throw exceptions with 'Vim' prefix"));
;               @current_exception = null;
;               return false;
;           }
;       }

;       except_C excp = §_except_C();

;       if (type == ET_ERROR)
            ;; Store the original message and prefix the exception value with
            ;; "Vim:" or, if a command name is given, "Vim(cmdname):".
;           excp.messages = (msglist_C)value;

;       excp.value = get_exception_string(value, type, cmdname);
;       excp.type = type;

;       @current_exception = excp;
;       return true;
    ))

;; Discard an exception.  "was_finished" is set when the exception
;; has been caught and the catch clause has been ended normally.

(defn- #_void discard_exception [#_except_C excp, #_boolean was_finished]
    (§
;       if (excp == null)
;           emsg(e_internal);
    ))

;; Discard the exception currently being thrown.

(defn- #_void discard_current_exception []
    (§
;       discard_exception(@current_exception, false);
;       @current_exception = null;
;       @did_throw = false;
;       @need_rethrow = false;
    ))

;; If something is made pending in a finally clause, report it if required by
;; the 'verbose' option.

(defn- #_void report_make_pending [#_int pending, #_Object value]
    (§
    ))

;; If something pending in a finally clause is resumed at the ":endtry", report
;; it if required by the 'verbose' option.

(defn- #_void report_resume_pending [#_int pending, #_Object value]
    (§
    ))

;; If something pending in a finally clause is discarded, report it if required
;; by the 'verbose' option.

(defn- #_void report_discard_pending [#_int pending, #_Object value]
    (§
    ))

;; enter_cleanup() and leave_cleanup()
;;
;; Functions to be called before/after invoking a sequence of autocommands for
;; cleanup for a failed command.  (Failure means here that a call to emsg()
;; has been made, an interrupt occurred, or there is an uncaught exception
;; from a previous autocommand execution of the same command.)
;;
;; Call enter_cleanup() with a pointer to a cleanup_C and pass the same
;; pointer to leave_cleanup().  The cleanup_C structure stores the pending
;; error/interrupt/exception state.

;; This function works a bit like ex_finally() except that there was not
;; actually an extra try block around the part that failed and an error or
;; interrupt has not (yet) been converted to an exception.  This function
;; saves the error/interrupt/ exception state and prepares for the call to
;; do_cmdline() that is going to be made for the cleanup autocommand execution.

(defn- #_void enter_cleanup [#_cleanup_C csp]
    (§
;       int pending = CSTP_NONE;

        ;; Postpone did_emsg, got_int, did_throw.  The pending values will be
        ;; restored by leave_cleanup() except if there was an aborting error,
        ;; interrupt, or uncaught exception after this function ends.

;       if (@did_emsg || @got_int || @did_throw || @need_rethrow)
;       {
;           csp.pending = (@did_emsg     ? CSTP_ERROR     : 0)
;                       | (@got_int      ? CSTP_INTERRUPT : 0)
;                       | (@did_throw    ? CSTP_THROW     : 0)
;                       | (@need_rethrow ? CSTP_THROW     : 0);

            ;; If we are currently throwing an exception (did_throw), save it as
            ;; well.  On an error not yet converted to an exception, update
            ;; "force_abort" and reset "cause_abort" (as do_errthrow() would do).
            ;; This is needed for the do_cmdline() call that is going to be made
            ;; for autocommand execution.  We need not save "*msg_list", because
            ;; there is an extra instance for every call of do_cmdline(), anyway.

;           if (@did_throw || @need_rethrow)
;               csp.exception = @current_exception;
;           else
;           {
;               csp.exception = null;
;               if (@did_emsg)
;               {
;                   @force_abort |= @cause_abort;
;                   @cause_abort = false;
;               }
;           }
;           @did_emsg = @got_int = @did_throw = @need_rethrow = false;

            ;; Report if required by the 'verbose' option.
;           report_make_pending(pending, csp.exception);
;       }
;       else
;       {
;           csp.pending = CSTP_NONE;
;           csp.exception = null;
;       }
    ))

;; See comment above enter_cleanup() for how this function is used.
;;
;; This function is a bit like ex_endtry() except that there was not actually
;; an extra try block around the part that failed and an error or interrupt
;; had not (yet) been converted to an exception when the cleanup autocommand
;; sequence was invoked.
;;
;; This function has to be called with the address of the cleanup_C structure
;; filled by enter_cleanup() as an argument; it restores the error/interrupt/
;; exception state saved by that function - except there was an aborting
;; error, an interrupt or an uncaught exception during execution of the
;; cleanup autocommands.  In the latter case, the saved error/interrupt/
;; exception state is discarded.

(defn- #_void leave_cleanup [#_cleanup_C csp]
    (§
;       int pending = csp.pending;

;       if (pending == CSTP_NONE)   ;; nothing to do
;           return;

        ;; If there was an aborting error, an interrupt, or an uncaught exception
        ;; after the corresponding call to enter_cleanup(), discard what has been
        ;; made pending by it.  Report this to the user if required by the
        ;; 'verbose' option.
;       if (aborting() || @need_rethrow)
;       {
;           if ((pending & CSTP_THROW) != 0)
                ;; Cancel the pending exception (includes report).
;               discard_exception(csp.exception, false);
;           else
;               report_discard_pending(pending, null);

            ;; If an error was about to be converted to an exception
            ;; when enter_cleanup() was called, free the message list.
;           if (@msg_list != null)
;               free_global_msglist();
;       }

        ;; If there was no new error, interrupt, or throw between the calls
        ;; to enter_cleanup() and leave_cleanup(), restore the pending
        ;; error/interrupt/exception state.

;       else
;       {
            ;; If there was an exception being thrown when enter_cleanup() was
            ;; called, we need to rethrow it.  Make it the exception currently being thrown.

;           if ((pending & CSTP_THROW) != 0)
;               @current_exception = csp.exception;

            ;; If an error was about to be converted to an exception when
            ;; enter_cleanup() was called, let "cause_abort" take the part of
            ;; "force_abort" (as done by cause_errthrow()).

;           else if ((pending & CSTP_ERROR) != 0)
;           {
;               @cause_abort = @force_abort;
;               @force_abort = false;
;           }

            ;; Restore the pending values of did_emsg, got_int, and did_throw.

;           if ((pending & CSTP_ERROR) != 0)
;               @did_emsg = true;
;           if ((pending & CSTP_INTERRUPT) != 0)
;               @got_int = true;
;           if ((pending & CSTP_THROW) != 0)
;               @need_rethrow = true;    ;; did_throw will be set by do_one_cmd()

            ;; Report if required by the 'verbose' option.
;           report_resume_pending(pending, (pending & CSTP_THROW) != 0 ? @current_exception : null);
;       }
    ))

;;; ============================================================================================== VimJ

;; eval.c: Expression evaluation ------------------------------------------------------------------

;; Top level evaluation function, returning a string.
;; When "convert" is true convert a List into a sequence of lines.
;; Return pointer to allocated memory, or null for failure.

(defn- #_Bytes eval_to_string [#_Bytes arg, #_Bytes* nextcmd, #_boolean convert]
    (§
;       return null;
    ))

;; Call eval_to_string() without using current local variables and using textlock.
;; When "use_sandbox" is true use the sandbox.

(defn- #_Bytes eval_to_string_safe [#_Bytes arg, #_Bytes* nextcmd, #_boolean use_sandbox]
    (§
;       Bytes retval;

;       if (use_sandbox)
;           @sandbox++;
;       @textlock++;
;       retval = eval_to_string(arg, nextcmd, false);
;       if (use_sandbox)
;           --@sandbox;
;       --@textlock;

;       return retval;
    ))

;; Put the time "msec" past now in "tm".

(defn- #_void profile_setlimit [#_long msec, #_timeval_C tm]
    (§
;       if (msec <= 0)      ;; no limit
;           profile_zero(tm);
;       else
;       {
;           libC._gettimeofday(tm);

;           long usec = tm.tv_usec() + msec * 1000;
;           tm.tv_usec(usec % 1000000L);
;           tm.tv_sec(tm.tv_sec() + usec / 1000000L);
;       }
    ))

;; Return true if the current time is past "tm".

(defn- #_boolean profile_passed_limit [#_timeval_C tm]
    (§
;       if (tm.tv_sec() == 0)       ;; timer was not set
;           return false;

;       timeval_C now = new timeval_C();

;       libC._gettimeofday(now);
;       return (tm.tv_sec() < now.tv_sec() || (now.tv_sec() == tm.tv_sec() && tm.tv_usec() < now.tv_usec()));
    ))

;; Set the time in "tm" to zero.

(defn- #_void profile_zero [#_timeval_C tm]
    (§
;       tm.tv_usec(0);
;       tm.tv_sec(0);
    ))

;; Return true if buffer was changed and cannot be abandoned.
;; For flags use the CCGD_ values.

(defn- #_boolean check_changed [#_buffer_C buf, #_int flags]
    (§
;       boolean forceit = ((flags & CCGD_FORCEIT) != 0);

;       if (!forceit && bufIsChanged(buf) && ((flags & CCGD_MULTWIN) != 0 || buf.b_nwindows <= 1))
;       {
;           if ((flags & CCGD_EXCMD) != 0)
;               emsg(e_nowrtmsg);
;           else
;               emsg(e_nowrtmsg_nobang);

;           return true;
;       }

;       return false;
    ))

;; Return true if the buffer "buf" can be abandoned, either by making it
;; hidden, autowriting it or unloading it.

(defn- #_boolean can_abandon [#_buffer_C buf, #_boolean forceit]
    (§
;       return (@cmdmod.hide
;                   || !bufIsChanged(buf)
;                   || 1 < buf.b_nwindows
;                   || forceit);
    ))

;; Add a buffer number to "bufnrs", unless it's already there.

(defn- #_int add_bufnum [#_int* bufnrs, #_int bufnum, #_int nr]
    (§
;       for (int i = 0; i < bufnum; i++)
;           if (bufnrs[i] == nr)
;               return bufnum;

;       bufnrs[bufnum++] = nr;
;       return bufnum;
    ))

;; Return true if any buffer was changed and cannot be abandoned.
;; That changed buffer becomes the current buffer.

(defn- #_boolean check_changed_any [#_boolean hidden]
    ;; hidden: only check hidden buffers
    (§
;       boolean retval = false;

;       int bufnum = 0;
;       int bufcount = 0;

;       buffer_C buf;
;       for (buf = @firstbuf; buf != null; buf = buf.b_next)
;           bufcount++;

;       if (bufcount == 0)
;           return false;

;       int[] bufnrs = new int[bufcount];

        ;; curbuf
;       bufnrs[bufnum++] = @curbuf.b_fnum;
        ;; buf in curtab
;       for (window_C wp = @firstwin; wp != null; wp = wp.w_next)
;           if (wp.w_buffer != @curbuf)
;               bufnum = add_bufnum(bufnrs, bufnum, wp.w_buffer.b_fnum);

        ;; buf in other tab
;       for (tabpage_C tp = @first_tabpage; tp != null; tp = null)
;           if (tp != @curtab)
;               for (window_C wp = tp.tp_firstwin; wp != null; wp = wp.w_next)
;                   bufnum = add_bufnum(bufnrs, bufnum, wp.w_buffer.b_fnum);
        ;; any other buf
;       for (buf = @firstbuf; buf != null; buf = buf.b_next)
;           bufnum = add_bufnum(bufnrs, bufnum, buf.b_fnum);

;       int i;
;       for (i = 0; i < bufnum; i++)
;       {
;           buf = buflist_findnr(bufnrs[i]);
;           if (buf == null)
;               continue;
;           if ((!hidden || buf.b_nwindows == 0) && bufIsChanged(buf))
;           {
                ;; Try auto-writing the buffer.  If this fails,
                ;; but the buffer no longer exists, it's not changed, that's OK.
;               if (check_changed(buf, CCGD_MULTWIN | CCGD_ALLBUF) && buf_valid(buf))
;                   break;      ;; didn't save - still changes
;           }
;       }

;       if (bufnum <= i)
;           return retval;

;       retval = true;
;       @exiting = false;

        ;; There must be a wait_return for this message, do_buffer() may cause a redraw.
        ;; But wait_return() is a no-op when vgetc() is busy (Quit used from window menu),
        ;; then make sure we don't cause a scroll up.
;       if (0 < @vgetc_busy)
;       {
;           @msg_row = @cmdline_row;
;           @msg_col = 0;
;           @msg_didout = false;
;       }
;       if (emsg2(u8("E162: No write since last change for buffer \"%s\""), buf_spname(buf, false)))
;       {
;           int save = @no_wait_return;
;           @no_wait_return = FALSE;
;           wait_return(FALSE);
;           @no_wait_return = save;
;       }

;       buf_found:
;       {
            ;; Try to find a window that contains the buffer.
;           if (buf != @curbuf)
;           {
;               for (tabpage_C tp = @first_tabpage; tp != null; tp = null)
;                   for (window_C wp = (tp == @curtab) ? @firstwin : tp.tp_firstwin; wp != null; wp = wp.w_next)
;                       if (wp.w_buffer == buf)
;                       {
;                           goto_tabpage_win(tp, wp);
                            ;; Paranoia: did autocmds wipe out the buffer with changes?
;                           if (!buf_valid(buf))
;                               return retval;
;                           break buf_found;
;                       }
;           }
;       }

        ;; Open the changed buffer in the current window.
;       if (buf != @curbuf)
;           set_curbuf(buf, DOBUF_GOTO);

;       return retval;
    ))

;;; ============================================================================================== VimK

;; normal.c ---------------------------------------------------------------------------------------
;; Contains the main routine for processing characters in command mode.
;; Communicates closely with the code in ops.c to handle the operators.

;; The Visual area is remembered for reselection.

(atom! int      resel_VIsual_mode NUL)        ;; 'v', 'V', or Ctrl-V
(atom! long     resel_VIsual_line_count)        ;; number of lines
(atom! int      resel_VIsual_vcol)              ;; nr of cols or end col
(atom! int      VIsual_mode_orig NUL)         ;; saved Visual mode

(atom! int      restart_VIsual_select)

;; nv_*(): functions called to handle Normal and Visual mode commands.
;; n_*(): functions called to handle Normal mode commands.
;; v_*(): functions called to handle Visual mode commands.

(final Bytes e_noident (u8 "E349: No identifier under cursor"))

;; Values for cmd_flags.
(final int NV_NCH      0x01)            ;; may need to get a second char
(final int NV_NCH_NOP  (| 0x02 NV_NCH))   ;; get second char when no operator pending
(final int NV_NCH_ALW  (| 0x04 NV_NCH))   ;; always get a second char
(final int NV_LANG     0x08)            ;; second char needs language adjustment

(final int NV_SS       0x10)            ;; may start selection
(final int NV_SSS      0x20)            ;; may start selection with shift modifier
(final int NV_STS      0x40)            ;; may stop selection without shift modif.
(final int NV_RL       0x80)            ;; 'rightleft' modifies command
(final int NV_KEEPREG  0x100)           ;; don't clear regname
(final int NV_NCW      0x200)           ;; not allowed in command-line window

;; Generally speaking, every Normal mode command should either clear any
;; pending operator (with *clearop*()), or set the motion type variable
;; oap.motion_type.
;;
;; When a cursor motion command is made, it is marked as being a character or
;; line oriented motion.  Then, if an operator is in effect, the operation
;; becomes character or line oriented accordingly.

;; Function to be called for a Normal or Visual mode command.
;; The argument is a cmdarg_C.

(class! #_final nv_cmd_C
    [
        (field int          cmd_char)           ;; (first) command character
        (field nv_func_F    cmd_func)           ;; function for this command
        (field int          cmd_flags)          ;; NV_ flags
        (field int          cmd_arg)            ;; value for ca.arg
    ])

;; Compare function for qsort() below, that checks the command
;; character through the index in nv_cmd_idx[].

;   static final Comparator<Short> nv_compare = new Comparator<Short>()
;   {
;       public int compare(Short s1, Short s2)
;       {
            ;; The commands are sorted on absolute value.
;           int c1 = nv_cmds[s1].cmd_char;
;           int c2 = nv_cmds[s2].cmd_char;
;           if (c1 < 0)
;               c1 = -c1;
;           if (c2 < 0)
;               c2 = -c2;
;           return c1 - c2;
;       }
;   };

;; Initialize the nv_cmd_idx[] table.

(defn- #_void init_normal_cmds []
    (§
        ;; Fill the index table with a one to one relation.
;       for (int i = 0; i < nv_cmds.length; i++)
;           nv_cmd_idx[i] = (short)i;

        ;; Sort the commands by the command character.
;       Arrays.sort(nv_cmd_idx, nv_compare);

        ;; Find the first entry that can't be indexed by the command character.
;       int i;
;       for (i = 0; i < nv_cmds.length; i++)
;           if (nv_cmds[nv_cmd_idx[i]].cmd_char != i)
;               break;
;       @nv_max_linear = i - 1;
    ))

;; Search for a command in the commands table.
;; Returns -1 for invalid command.

(defn- #_int find__command [#_int cmdchar]
    (§
        ;; A multi-byte character is never a command.
;       if (0x100 <= cmdchar)
;           return -1;

        ;; We use the absolute value of the character.
        ;; Special keys have a negative value, but are sorted on their absolute value.
;       if (cmdchar < 0)
;           cmdchar = -cmdchar;

        ;; If the character is in the first part: The character is the index into nv_cmd_idx[].
;       if (cmdchar <= @nv_max_linear)
;           return nv_cmd_idx[cmdchar];

        ;; Perform a binary search.
;       int bot = @nv_max_linear + 1;
;       int top = nv_cmds.length - 1;
;       int idx = -1;
;       while (bot <= top)
;       {
;           int i = (top + bot) / 2;
;           int c = nv_cmds[nv_cmd_idx[i]].cmd_char;
;           if (c < 0)
;               c = -c;
;           if (cmdchar == c)
;           {
;               idx = nv_cmd_idx[i];
;               break;
;           }
;           if (c < cmdchar)
;               bot = i + 1;
;           else
;               top = i - 1;
;       }
;       return idx;
    ))

(atom! int old_mapped_len)

;; Execute a command in Normal mode.

(defn- #_void normal_cmd [#_oparg_C oap, #_boolean toplevel]
    ;; toplevel: true when called from main()
    (§
;       int old_col = @curwin.w_curswant;

;       cmdarg_C ca = §_cmdarg_C();   ;; command arguments
;       ca.oap = oap;

        ;; Use a count remembered from before entering an operator.
        ;; After typing "3d" we return from normal_cmd() and come back here,
        ;; the "3" is remembered in "opcount".
;       ca.opcount = @opcount;

        ;; If there is an operator pending, then the command we take this time
        ;; will terminate it.  finish_op tells us to finish the operation before
        ;; returning this time (unless the operation was cancelled).

;       boolean save_finish_op = @finish_op;
;       @finish_op = (oap.op_type != OP_NOP);
;       if (@finish_op != save_finish_op)
;       {
;           ui_cursor_shape();              ;; may show different cursor shape
;       }

        ;; When not finishing an operator and no register name typed, reset the count.
;       if (!@finish_op && oap.regname == 0)
;       {
;           ca.opcount = 0;
;       }

        ;; Restore counts from before receiving K_CURSORHOLD.
        ;; This means after typing "3", handling K_CURSORHOLD
        ;; and then typing "2" we get "32", not "3 * 2".
;       if (0 < oap.prev_opcount || 0 < oap.prev_count0)
;       {
;           ca.opcount = oap.prev_opcount;
;           ca.count0 = oap.prev_count0;
;           oap.prev_opcount = 0;
;           oap.prev_count0 = 0;
;       }

;       int mapped_len = typebuf_maplen();

;       @State = NORMAL_BUSY;

        ;; Get the command character from the user.

;       int c = safe_vgetc();

        ;; If a mapping was started in Visual or Select mode, remember the length
        ;; of the mapping.  This is used below to not return to Insert mode for as
        ;; long as the mapping is being executed.

;       if (@restart_edit == 0)
;           @old_mapped_len = 0;
;       else if (@old_mapped_len != 0 || (@VIsual_active && mapped_len == 0 && 0 < typebuf_maplen()))
;           @old_mapped_len = typebuf_maplen();

;       if (c == NUL)
;           c = K_ZERO;

        ;; In Select mode, typed text replaces the selection.

;       if (@VIsual_active && @VIsual_select && (vim_isprintc(c) || c == NL || c == CAR || c == K_KENTER))
;       {
            ;; Fake a "c"hange command.
            ;; When "restart_edit" is set (e.g., because 'insertmode' is set)
            ;; fake a "d"elete command, Insert mode will restart automatically.
            ;; Insert the typed character in the typeahead buffer, so it can be
            ;; mapped in Insert mode.  Required for ":lmap" to work.
;           ins_char_typebuf(c);
;           if (@restart_edit != 0)
;               c = 'd';
;           else
;               c = 'c';
;           @msg_nowait = true;      ;; don't delay going to insert mode
;           @old_mapped_len = 0;     ;; do go to Insert mode
;       }

;       boolean need_flushbuf = add_to_showcmd(c);      ;; need to call out_flush()
;       boolean ctrl_w = false;                         ;; got CTRL-W command

;       getcount:
;       for ( ; ; )
;       {
;           if (!(@VIsual_active && @VIsual_select))
;           {
                ;; Handle a count before a command and compute ca.count0.
                ;; Note that '0' is a command and not the start of a count,
                ;; but it's part of a count after other digits.

;               while (('1' <= c && c <= '9') || (ca.count0 != 0 && (c == K_DEL || c == K_KDEL || c == '0')))
;               {
;                   if (c == K_DEL || c == K_KDEL)
;                   {
;                       ca.count0 /= 10;
;                       del_from_showcmd(4);    ;; delete the digit and ~@%
;                   }
;                   else
;                       ca.count0 = ca.count0 * 10 + (c - '0');
;                   if (ca.count0 < 0)          ;; got too large!
;                       ca.count0 = 999999999L;

;                   if (ctrl_w)
;                   {
;                       @no_mapping++;
;                       @allow_keys++;           ;; no mapping for nchar, but keys
;                   }
;                   @no_zero_mapping++;          ;; don't map zero here
;                   c = plain_vgetc();
;                   --@no_zero_mapping;
;                   if (ctrl_w)
;                   {
;                       --@no_mapping;
;                       --@allow_keys;
;                   }
;                   need_flushbuf |= add_to_showcmd(c);
;               }

                ;; If we got CTRL-W there may be a/another count

;               if (c == Ctrl_W && !ctrl_w && oap.op_type == OP_NOP)
;               {
;                   ctrl_w = true;
;                   ca.opcount = ca.count0;     ;; remember first count
;                   ca.count0 = 0;
;                   @no_mapping++;
;                   @allow_keys++;               ;; no mapping for nchar, but keys
;                   c = plain_vgetc();          ;; get next character
;                   --@no_mapping;
;                   --@allow_keys;
;                   need_flushbuf |= add_to_showcmd(c);
;                   continue getcount;              ;; jump back
;               }
;           }

;           break;
;       }

;       if (c == K_CURSORHOLD)
;       {
            ;; Save the count values so that ca.opcount and ca.count0 are exactly
            ;; the same when coming back here after handling K_CURSORHOLD.
;           oap.prev_opcount = ca.opcount;
;           oap.prev_count0 = ca.count0;
;       }
;       else if (ca.opcount != 0)
;       {
            ;; If we're in the middle of an operator (including after entering a
            ;; yank buffer with '"') AND we had a count before the operator, then
            ;; that count overrides the current value of ca.count0.
            ;; What this means effectively, is that commands like "3dw" get turned
            ;; into "d3w" which makes things fall into place pretty neatly.
            ;; If you give a count before AND after the operator, they are multiplied.

;           if (ca.count0 != 0)
;               ca.count0 *= ca.opcount;
;           else
;               ca.count0 = ca.opcount;
;       }

        ;; Always remember the count.
        ;; It will be set to zero (on the next call, above) when there is no pending operator.
        ;; When called from main(), save the count for use by the "count" built-in variable.

;       ca.opcount = ca.count0;
;       ca.count1 = (ca.count0 == 0) ? 1 : ca.count0;

        ;; Find the command character in the table of commands.
        ;; For CTRL-W we already got nchar when looking for a count.

;       if (ctrl_w)
;       {
;           ca.@nchar = c;
;           ca.cmdchar = Ctrl_W;
;       }
;       else
;           ca.cmdchar = c;

;       normal_end:
;       {
;           int idx = find__command(ca.cmdchar);
;           if (idx < 0)
;           {
                ;; Not a known command: beep.
;               clearopbeep(oap);
;               break normal_end;
;           }

;           if (text_locked() && (nv_cmds[idx].cmd_flags & NV_NCW) != 0)
;           {
                ;; This command is not allowed while editing a cmdline: beep.
;               clearopbeep(oap);
;               text_locked_msg();
;               break normal_end;
;           }
;           if ((nv_cmds[idx].cmd_flags & NV_NCW) != 0 && curbuf_locked())
;               break normal_end;

            ;; In Visual/Select mode, a few keys are handled in a special way.

;           if (@VIsual_active)
;           {
                ;; when 'keymodel' contains "stopsel" may stop Select/Visual mode
;               if (@km_stopsel
;                       && (nv_cmds[idx].cmd_flags & NV_STS) != 0
;                       && (@mod_mask & MOD_MASK_SHIFT) == 0)
;               {
;                   end_visual_mode();
;                   redraw_curbuf_later(INVERTED);
;               }

                ;; Keys that work different when 'keymodel' contains "startsel".
;               if (@km_startsel)
;               {
;                   if ((nv_cmds[idx].cmd_flags & NV_SS) != 0)
;                   {
;                       unshift_special(ca);
;                       idx = find__command(ca.cmdchar);
;                       if (idx < 0)
;                       {
                            ;; Just in case.
;                           clearopbeep(oap);
;                           break normal_end;
;                       }
;                   }
;                   else if ((nv_cmds[idx].cmd_flags & NV_SSS) != 0 && (@mod_mask & MOD_MASK_SHIFT) != 0)
;                   {
;                       @mod_mask &= ~MOD_MASK_SHIFT;
;                   }
;               }
;           }

;           if (@curwin.w_onebuf_opt.@wo_rl && @keyTyped && !@keyStuffed && (nv_cmds[idx].cmd_flags & NV_RL) != 0)
;           {
                ;; Invert horizontal movements and operations.
                ;; Only when typed by the user directly,
                ;; not when the result of a mapping or "x" translated to "dl".

;               switch (ca.cmdchar)
;               {
;                   case 'l':       ca.cmdchar = 'h'; break;
;                   case K_RIGHT:   ca.cmdchar = K_LEFT; break;
;                   case K_S_RIGHT: ca.cmdchar = K_S_LEFT; break;
;                   case K_C_RIGHT: ca.cmdchar = K_C_LEFT; break;
;                   case 'h':       ca.cmdchar = 'l'; break;
;                   case K_LEFT:    ca.cmdchar = K_RIGHT; break;
;                   case K_S_LEFT:  ca.cmdchar = K_S_RIGHT; break;
;                   case K_C_LEFT:  ca.cmdchar = K_C_RIGHT; break;
;                   case '>':       ca.cmdchar = '<'; break;
;                   case '<':       ca.cmdchar = '>'; break;
;               }
;               idx = find__command(ca.cmdchar);
;           }

            ;; Get an additional character if we need one.

;           if ((nv_cmds[idx].cmd_flags & NV_NCH) != 0
;                   && (((nv_cmds[idx].cmd_flags & NV_NCH_NOP) == NV_NCH_NOP
;                           && oap.op_type == OP_NOP)
;                       || (nv_cmds[idx].cmd_flags & NV_NCH_ALW) == NV_NCH_ALW
;                       || (ca.cmdchar == 'q'
;                           && oap.op_type == OP_NOP
;                           && !@Recording
;                           && !@execReg)
;                       || ((ca.cmdchar == 'a' || ca.cmdchar == 'i')
;                           && (oap.op_type != OP_NOP || @VIsual_active))))
;           {
;               boolean repl = false;                   ;; get character for replace mode
;               boolean lit = false;                    ;; get extra character literally

;               @no_mapping++;
;               @allow_keys++;                           ;; no mapping for nchar, but allow key codes
                ;; Don't generate a CursorHold event here,
                ;; most commands can't handle it, e.g. nv_replace(), nv_csearch().
;               @did_cursorhold = true;
;               int[] cp;
;               if (ca.cmdchar == 'g')
;               {
                    ;; For 'g' get the next character now, so that we can check for "gr", "g'" and "g`".

;                   ca.@nchar = plain_vgetc();
;                   need_flushbuf |= add_to_showcmd(ca.@nchar);
;                   if (ca.@nchar == 'r' || ca.@nchar == '\'' || ca.@nchar == '`' || ca.@nchar == Ctrl_BSL)
;                   {
;                       cp = ca.extra_char;            ;; need to get a third character
;                       if (ca.@nchar != 'r')
;                           lit = true;                 ;; get it literally
;                       else
;                           repl = true;                ;; get it in replace mode
;                   }
;                   else
;                       cp = null;                      ;; no third character needed
;               }
;               else
;               {
;                   if (ca.cmdchar == 'r')              ;; get it in replace mode
;                       repl = true;
;                   cp = ca.nchar;
;               }

;               boolean lang = (repl || (nv_cmds[idx].cmd_flags & NV_LANG) != 0);

                ;; Get a second or third character.

;               if (cp != null)
;               {
;                   if (repl)
;                   {
;                       @State = REPLACE;                ;; pretend Replace mode
;                       ui_cursor_shape();              ;; show different cursor shape
;                   }

;                   cp[0] = plain_vgetc();

;                   @State = NORMAL_BUSY;
;                   need_flushbuf |= add_to_showcmd(cp[0]);

;                   if (!lit)
;                   {
                        ;; Typing CTRL-K gets a digraph.
;                       if (cp[0] == Ctrl_K
;                               && ((nv_cmds[idx].cmd_flags & NV_LANG) != 0 || cp == ca.extra_char)
;                               && vim_strbyte(@p_cpo, CPO_DIGRAPH) == null)
;                       {
;                           c = get_digraph(false);
;                           if (0 < c)
;                           {
;                               cp[0] = c;
                                ;; Guessing how to update showcmd here...
;                               del_from_showcmd(3);
;                               need_flushbuf |= add_to_showcmd(cp[0]);
;                           }
;                       }
;                   }

                    ;; When the next character is CTRL-\ a following CTRL-N means
                    ;; the command is aborted and we go to Normal mode.

;                   if (cp == ca.extra_char
;                           && ca.@nchar == Ctrl_BSL
;                           && (ca.@extra_char == Ctrl_N || ca.@extra_char == Ctrl_G))
;                   {
;                       ca.cmdchar = Ctrl_BSL;
;                       ca.@nchar = ca.@extra_char;
;                       idx = find__command(ca.cmdchar);
;                   }
;                   else if ((ca.@nchar == 'n' || ca.@nchar == 'N') && ca.cmdchar == 'g')
;                       ca.oap.op_type = get_op_type(cp[0], NUL);
;                   else if (cp[0] == Ctrl_BSL)
;                   {
;                       long towait = (0 <= @p_ttm) ? @p_ttm : @p_tm;

                        ;; There is a busy wait here when typing "f<C-\>" and then
                        ;; something different from CTRL-N.  Can't be avoided.
;                       while ((c = vpeekc()) <= 0 && 0L < towait)
;                       {
;                           do_sleep(50L < towait ? 50L : towait);
;                           towait -= 50L;
;                       }
;                       if (0 < c)
;                       {
;                           c = plain_vgetc();
;                           if (c != Ctrl_N && c != Ctrl_G)
;                               vungetc(c);
;                           else
;                           {
;                               ca.cmdchar = Ctrl_BSL;
;                               ca.@nchar = c;
;                               idx = find__command(ca.cmdchar);
;                           }
;                       }
;                   }

                    ;; When getting a text character and the next character is a multi-byte character,
                    ;; it could be a composing character.  However, don't wait for it to arrive.
                    ;; Also, do enable mapping, because if it's put back with vungetc() it's too late
                    ;; to apply mapping.
;                   --@no_mapping;
;                   while (lang && 0 < (c = vpeekc()) && (0x100 <= c || 1 < mb_byte2len(vpeekc())))
;                   {
;                       c = plain_vgetc();
;                       if (!utf_iscomposing(c))
;                       {
;                           vungetc(c);         ;; it wasn't, put it back
;                           break;
;                       }
;                       else if (ca.ncharC1 == 0)
;                           ca.ncharC1 = c;
;                       else
;                           ca.ncharC2 = c;
;                   }
;                   @no_mapping++;
;               }
;               --@no_mapping;
;               --@allow_keys;
;           }

            ;; Flush the showcmd characters onto the screen so we can see them while the command
            ;; is being executed.  Only do this when the shown command was actually displayed,
            ;; otherwise this will slow down a lot when executing mappings.

;           if (need_flushbuf)
;               out_flush();
;           if (ca.cmdchar != K_IGNORE)
;               @did_cursorhold = false;

;           @State = NORMAL;

;           if (ca.@nchar == ESC)
;           {
;               clearop(oap);
;               if (@restart_edit == 0 && goto_im())
;                   @restart_edit = 'a';
;               break normal_end;
;           }

;           if (ca.cmdchar != K_IGNORE)
;           {
;               @msg_didout = false;         ;; don't scroll screen up for normal command
;               @msg_col = 0;
;           }

;           pos_C old_pos = §_pos_C();
;           COPY_pos(old_pos, @curwin.w_cursor);     ;; remember where cursor was

            ;; When 'keymodel' contains "startsel" some keys start Select/Visual mode.
;           if (!@VIsual_active && @km_startsel)
;           {
;               if ((nv_cmds[idx].cmd_flags & NV_SS) != 0)
;               {
;                   start_selection();
;                   unshift_special(ca);
;                   idx = find__command(ca.cmdchar);
;               }
;               else if ((nv_cmds[idx].cmd_flags & NV_SSS) != 0 && (@mod_mask & MOD_MASK_SHIFT) != 0)
;               {
;                   start_selection();
;                   @mod_mask &= ~MOD_MASK_SHIFT;
;               }
;           }

            ;; Execute the command!
            ;; Call the command function found in the commands table.

;           ca.arg = nv_cmds[idx].cmd_arg;
;           nv_cmds[idx].cmd_func(ca);

            ;; If we didn't start or finish an operator, reset oap.regname, unless we need it later.

;           if (!@finish_op && oap.op_type == OP_NOP && (idx < 0 || (nv_cmds[idx].cmd_flags & NV_KEEPREG) == 0))
;           {
;               clearop(oap);
;           }

            ;; Get the length of mapped chars again after typing a count,
            ;; second character or "z333<cr>".
;           if (0 < @old_mapped_len)
;               @old_mapped_len = typebuf_maplen();

            ;; If an operation is pending, handle it...

;           do_pending_operator(ca, old_col, false);

            ;; Wait for a moment when a message is displayed that will be overwritten by the mode message.
            ;; In Visual mode and with "^O" in Insert mode, a short message will be
            ;; overwritten by the mode message.  Wait a bit, until a key is hit.
            ;; In Visual mode, it's more important to keep the Visual area updated
            ;; than keeping a message (e.g. from a /pat search).
            ;; Only do this if the command was typed, not from a mapping.
            ;; Don't wait when emsg_silent is non-zero.
            ;; Also wait a bit after an error message, e.g. for "^O:".
            ;; Don't redraw the screen, it would remove the message.

;           if (((@p_smd
;                           && @msg_silent == 0
;                           && (@restart_edit != 0
;                               || (@VIsual_active
;                                   && old_pos.lnum == @curwin.w_cursor.lnum
;                                   && old_pos.col == @curwin.w_cursor.col))
;                           && (@clear_cmdline || @redraw_cmdline)
;                           && (@msg_didout || (@msg_didany && @msg_scroll))
;                           && !@msg_nowait
;                           && @keyTyped)
;                       || (@restart_edit != 0
;                           && !@VIsual_active
;                           && (@msg_scroll || @emsg_on_display)))
;                   && oap.regname == 0
;                   && (ca.retval & CA_COMMAND_BUSY) == 0
;                   && stuff_empty()
;                   && typebuf_typed()
;                   && @emsg_silent == 0
;                   && !@did_wait_return
;                   && oap.op_type == OP_NOP)
;           {
;               int save_State = @State;

                ;; Draw the cursor with the right shape here.
;               if (@restart_edit != 0)
;                   @State = INSERT;

                ;; If need to redraw, and there is a "keep_msg", redraw before the delay.
;               if (@must_redraw != 0 && @keep_msg != null && !@emsg_on_display)
;               {
;                   Bytes kmsg = @keep_msg;
;                   @keep_msg = null;
                    ;; showmode() will clear "keep_msg", but we want to use it anyway
;                   update_screen(0);
                    ;; now reset it, otherwise it's put in the history again
;                   @keep_msg = kmsg;
;                   msg_attr(kmsg, @keep_msg_attr);
;               }
;               setcursor();
;               cursor_on();
;               out_flush();
;               if (@msg_scroll || @emsg_on_display)
;                   ui_delay(1000L, true);      ;; wait at least one second
;               ui_delay(3000L, false);         ;; wait up to three seconds
;               @State = save_State;

;               @msg_scroll = false;
;               @emsg_on_display = false;
;           }
;       }

        ;; Finish up after executing a Normal mode command.

;       @msg_nowait = false;

        ;; Reset finish_op, in case it was set.
;       save_finish_op = @finish_op;
;       @finish_op = false;
        ;; Redraw the cursor with another shape,
        ;; if we were in Operator-pending mode or did a replace command.
;       if (save_finish_op || ca.cmdchar == 'r')
;       {
;           ui_cursor_shape();              ;; may show different cursor shape
;       }

;       if (oap.op_type == OP_NOP && oap.regname == 0 && ca.cmdchar != K_CURSORHOLD)
;           clear_showcmd();

;       checkpcmark();                      ;; check if we moved since setting pcmark
;       ca.searchbuf = null;

;       mb_adjust_pos(@curbuf, @curwin.w_cursor);

;       if (@curwin.w_onebuf_opt.@wo_scb && toplevel)
;       {
;           validate_cursor();              ;; may need to update w_leftcol
;           do_check_scrollbind(true);
;       }

;       if (@curwin.w_onebuf_opt.@wo_crb && toplevel)
;       {
;           validate_cursor();              ;; may need to update w_leftcol
;           do_check_cursorbind();
;       }

        ;; May restart edit(), if we got here with CTRL-O in Insert mode
        ;; (but not if still inside a mapping that started in Visual mode).
        ;; May switch from Visual to Select mode after CTRL-O command.

;       if (oap.op_type == OP_NOP
;               && ((@restart_edit != 0 && !@VIsual_active && @old_mapped_len == 0)
;                   || @restart_VIsual_select == 1)
;               && (ca.retval & CA_COMMAND_BUSY) == 0
;               && stuff_empty()
;               && oap.regname == 0)
;       {
;           if (@restart_VIsual_select == 1)
;           {
;               @VIsual_select = true;
;               showmode();
;               @restart_VIsual_select = 0;
;           }
;           if (@restart_edit != 0 && !@VIsual_active && @old_mapped_len == 0)
;               edit(@restart_edit, false, 1L);
;       }

;       if (@restart_VIsual_select == 2)
;           @restart_VIsual_select = 1;

        ;; Save count before an operator for next time.
;       @opcount = ca.opcount;
    ))

;; The visual area is remembered for redo.
(atom! int      redo_VIsual_mode NUL)     ;; 'v', 'V', or Ctrl-V
(atom! long     redo_VIsual_line_count)     ;; number of lines
(atom! int      redo_VIsual_vcol)           ;; number of cols or end column
(atom! long     redo_VIsual_count)          ;; count for Visual operator

;; Handle an operator after visual mode or when the movement is finished.

(defn- #_void do_pending_operator [#_cmdarg_C cap, #_int old_col, #_boolean gui_yank]
    (§
;       oparg_C oap = cap.oap;

;       boolean lbr_saved = @curwin.w_onebuf_opt.@wo_lbr;
;       boolean include_line_break = false;

        ;; Yank the visual area into the GUI selection register
        ;; before we operate on it and lose it forever.
        ;; Don't do it if a specific register was specified, so that ""x"*P works.
        ;; This could call do_pending_operator() recursively, but that's OK,
        ;; because gui_yank will be true for the nested call.

;       if ((@clip_star.available || @clip_plus.available)
;               && oap.op_type != OP_NOP
;               && !gui_yank
;               && @VIsual_active
;               && !@redo_VIsual_busy
;               && oap.regname == 0)
;           clip_auto_select();

;       pos_C old_cursor = §_pos_C();
;       COPY_pos(old_cursor, @curwin.w_cursor);

        ;; If an operation is pending, handle it...

;       if ((@finish_op || @VIsual_active) && oap.op_type != OP_NOP)
;       {
            ;; Avoid a problem with unwanted linebreaks in block mode.
;           @curwin.w_onebuf_opt.@wo_lbr = false;
;           oap.is_VIsual = @VIsual_active;
;           if (oap.motion_force == 'V')
;               oap.motion_type = MLINE;
;           else if (oap.motion_force == 'v')
;           {
                ;; If the motion was linewise, "inclusive" will not have been set.
                ;; Use "exclusive" to be consistent.  Makes "dvj" work nice.
;               if (oap.motion_type == MLINE)
;                   oap.inclusive = false;
                ;; If the motion already was characterwise, toggle "inclusive".
;               else if (oap.motion_type == MCHAR)
;                   oap.inclusive = !oap.inclusive;
;               oap.motion_type = MCHAR;
;           }
;           else if (oap.motion_force == Ctrl_V)
;           {
                ;; Change line- or characterwise motion into Visual block mode.
;               @VIsual_active = true;
;               COPY_pos(@VIsual, oap.op_start);
;               @VIsual_mode = Ctrl_V;
;               @VIsual_select = false;
;               @VIsual_reselect = false;
;           }

            ;; Only redo yank when 'y' flag is in 'cpoptions'.
;           if ((vim_strbyte(@p_cpo, CPO_YANK) != null || oap.op_type != OP_YANK)
;                   && ((!@VIsual_active || oap.motion_force != 0)
                        ;; Also redo Operator-pending Visual mode mappings.
;                       || (@VIsual_active && cap.cmdchar == ':' && oap.op_type != OP_COLON))
;                   && cap.cmdchar != 'D')
;           {
;               prep_redo(oap.regname, cap.count0,
;                       get_op_char(oap.op_type), get_extra_op_char(oap.op_type),
;                       oap.motion_force, cap.cmdchar, cap.@nchar);
;               if (cap.cmdchar == '/' || cap.cmdchar == '?') ;; was a search
;               {
                    ;; If 'cpoptions' does not contain 'r',
                    ;; insert the search pattern to really repeat the same command.

;                   if (vim_strbyte(@p_cpo, CPO_REDO) == null)
;                       appendToRedobuffLit(cap.searchbuf, -1);
;                   appendToRedobuff(NL_STR);
;               }
;               else if (cap.cmdchar == ':')
;               {
                    ;; do_cmdline() has stored the first typed line in "repeat_cmdline".
                    ;; When several lines are typed repeating won't be possible.

;                   if (@repeat_cmdline == null)
;                       resetRedobuff();
;                   else
;                   {
;                       appendToRedobuffLit(@repeat_cmdline, -1);
;                       appendToRedobuff(NL_STR);
;                       @repeat_cmdline = null;
;                   }
;               }
;           }

;           if (@redo_VIsual_busy)
;           {
                ;; Redo of an operation on a Visual area.
                ;; Use the same size from redo_VIsual_line_count and redo_VIsual_vcol.

;               COPY_pos(oap.op_start, @curwin.w_cursor);
;               @curwin.w_cursor.lnum += @redo_VIsual_line_count - 1;
;               if (@curwin.w_cursor.lnum > @curbuf.b_ml.ml_line_count)
;                   @curwin.w_cursor.lnum = @curbuf.b_ml.ml_line_count;
;               @VIsual_mode = @redo_VIsual_mode;
;               if (@redo_VIsual_vcol == MAXCOL || @VIsual_mode == 'v')
;               {
;                   if (@VIsual_mode == 'v')
;                   {
;                       if (@redo_VIsual_line_count <= 1)
;                       {
;                           validate_virtcol();
;                           @curwin.w_curswant = @curwin.w_virtcol + @redo_VIsual_vcol - 1;
;                       }
;                       else
;                           @curwin.w_curswant = @redo_VIsual_vcol;
;                   }
;                   else
;                   {
;                       @curwin.w_curswant = MAXCOL;
;                   }
;                   coladvance(@curwin.w_curswant);
;               }
;               cap.count0 = @redo_VIsual_count;
;               if (@redo_VIsual_count != 0)
;                   cap.count1 = @redo_VIsual_count;
;               else
;                   cap.count1 = 1;
;           }
;           else if (@VIsual_active)
;           {
;               if (!gui_yank)
;               {
                    ;; Save the current VIsual area for '< and '> marks, and "gv".
;                   COPY_pos(@curbuf.b_visual.vi_start, @VIsual);
;                   COPY_pos(@curbuf.b_visual.vi_end, @curwin.w_cursor);
;                   @curbuf.b_visual.vi_mode = @VIsual_mode;
;                   if (@VIsual_mode_orig != NUL)
;                   {
;                       @curbuf.b_visual.vi_mode = @VIsual_mode_orig;
;                       @VIsual_mode_orig = NUL;
;                   }
;                   @curbuf.b_visual.vi_curswant = @curwin.w_curswant;
;                   @curbuf.b_visual_mode_eval = @VIsual_mode;
;               }

                ;; In Select mode,
                ;; a linewise selection is operated upon like a characterwise selection.
;               if (@VIsual_select && @VIsual_mode == 'V')
;               {
;                   if (ltpos(@VIsual, @curwin.w_cursor))
;                   {
;                       @VIsual.col = 0;
;                       @curwin.w_cursor.col = STRLEN(ml_get(@curwin.w_cursor.lnum));
;                   }
;                   else
;                   {
;                       @curwin.w_cursor.col = 0;
;                       @VIsual.col = STRLEN(ml_get(@VIsual.lnum));
;                   }
;                   @VIsual_mode = 'v';
;               }
                ;; If 'selection' is "exclusive", backup one character for charwise selections.
;               else if (@VIsual_mode == 'v')
;               {
;                   include_line_break = unadjust_for_sel();
;               }

;               COPY_pos(oap.op_start, @VIsual);
;               if (@VIsual_mode == 'V')
;                   oap.op_start.col = 0;
;           }

            ;; Set oap.op_start to the first position of the operated text, oap.op_end
            ;; to the end of the operated text.  w_cursor is equal to oap.op_start.

;           if (ltpos(oap.op_start, @curwin.w_cursor))
;           {
;               COPY_pos(oap.op_end, @curwin.w_cursor);
;               COPY_pos(@curwin.w_cursor, oap.op_start);

                ;; w_virtcol may have been updated; if the cursor goes back to its previous
                ;; position, w_virtcol becomes invalid and isn't updated automatically.
;               @curwin.w_valid &= ~VALID_VIRTCOL;
;           }
;           else
;           {
;               COPY_pos(oap.op_end, oap.op_start);
;               COPY_pos(oap.op_start, @curwin.w_cursor);
;           }

;           oap.line_count = oap.op_end.lnum - oap.op_start.lnum + 1;

            ;; Set "virtual_op" before resetting VIsual_active.
;           @virtual_op = virtual_active() ? TRUE : FALSE;

;           if (@VIsual_active || @redo_VIsual_busy)
;           {
;               if (@VIsual_mode == Ctrl_V)  ;; block mode
;               {
;                   oap.block_mode = true;

;                   int[] start = { oap.start_vcol };
;                   int[] end = { oap.end_vcol };
;                   getvvcol(@curwin, oap.op_start, start, null, end);
;                   oap.start_vcol = start[0];
;                   oap.end_vcol = end[0];

;                   if (!@redo_VIsual_busy)
;                   {
;                       getvvcol(@curwin, oap.op_end, start, null, end);

;                       if (start[0] < oap.start_vcol)
;                           oap.start_vcol = start[0];
;                       if (oap.end_vcol < end[0])
;                       {
;                           if (@p_sel.at(0) == (byte)'e' && 1 <= start[0] && oap.end_vcol <= start[0] - 1)
;                               oap.end_vcol = start[0] - 1;
;                           else
;                               oap.end_vcol = end[0];
;                       }
;                   }

                    ;; if '$' was used, get oap.end_vcol from longest line
;                   if (@curwin.w_curswant == MAXCOL)
;                   {
;                       @curwin.w_cursor.col = MAXCOL;
;                       oap.end_vcol = 0;
;                       for (@curwin.w_cursor.lnum = oap.op_start.lnum;
;                            @curwin.w_cursor.lnum <= oap.op_end.lnum;
;                            @curwin.w_cursor.lnum++)
;                       {
;                           getvvcol(@curwin, @curwin.w_cursor, null, null, end);
;                           if (oap.end_vcol < end[0])
;                               oap.end_vcol = end[0];
;                       }
;                   }
;                   else if (@redo_VIsual_busy)
;                       oap.end_vcol = oap.start_vcol + @redo_VIsual_vcol - 1;

                    ;; Correct oap.op_end.col and oap.op_start.col to be the
                    ;; upper-left and lower-right corner of the block area.
                    ;;
                    ;; (Actually, this does convert column positions into character positions.)

;                   @curwin.w_cursor.lnum = oap.op_end.lnum;
;                   coladvance(oap.end_vcol);
;                   COPY_pos(oap.op_end, @curwin.w_cursor);

;                   COPY_pos(@curwin.w_cursor, oap.op_start);
;                   coladvance(oap.start_vcol);
;                   COPY_pos(oap.op_start, @curwin.w_cursor);
;               }

;               if (!@redo_VIsual_busy && !gui_yank)
;               {
                    ;; Prepare to reselect and redo Visual:
                    ;; this is based on the size of the Visual text

;                   @resel_VIsual_mode = @VIsual_mode;
;                   if (@curwin.w_curswant == MAXCOL)
;                       @resel_VIsual_vcol = MAXCOL;
;                   else
;                   {
;                       if (@VIsual_mode != Ctrl_V)
;                       {
;                           int[] __ = { oap.end_vcol };
;                           getvvcol(@curwin, oap.op_end, null, null, __);
;                           oap.end_vcol = __[0];
;                       }
;                       if (@VIsual_mode == Ctrl_V || oap.line_count <= 1)
;                       {
;                           if (@VIsual_mode != Ctrl_V)
;                           {
;                               int[] __ = { oap.start_vcol };
;                               getvvcol(@curwin, oap.op_start, __, null, null);
;                               oap.start_vcol = __[0];
;                           }
;                           @resel_VIsual_vcol = oap.end_vcol - oap.start_vcol + 1;
;                       }
;                       else
;                           @resel_VIsual_vcol = oap.end_vcol;
;                   }
;                   @resel_VIsual_line_count = oap.line_count;
;               }

                ;; can't redo yank (unless 'y' is in 'cpoptions') and ":"
;               if ((vim_strbyte(@p_cpo, CPO_YANK) != null || oap.op_type != OP_YANK)
;                       && oap.op_type != OP_COLON
;                       && oap.motion_force == NUL)
;               {
                    ;; Prepare for redoing.  Only use the nchar field for "r",
                    ;; otherwise it might be the second char of the operator.

;                   if (cap.cmdchar == 'g' && (cap.@nchar == 'n' || cap.@nchar == 'N'))
;                       prep_redo(oap.regname, cap.count0,
;                               get_op_char(oap.op_type), get_extra_op_char(oap.op_type),
;                               oap.motion_force, cap.cmdchar, cap.@nchar);
;                   else if (cap.cmdchar != ':')
;                       prep_redo(oap.regname, 0L, NUL, 'v',
;                                           get_op_char(oap.op_type),
;                                           get_extra_op_char(oap.op_type),
;                                           oap.op_type == OP_REPLACE ? cap.@nchar : NUL);
;                   if (!@redo_VIsual_busy)
;                   {
;                       @redo_VIsual_mode = @resel_VIsual_mode;
;                       @redo_VIsual_vcol = @resel_VIsual_vcol;
;                       @redo_VIsual_line_count = @resel_VIsual_line_count;
;                       @redo_VIsual_count = cap.count0;
;                   }
;               }

                ;; oap.inclusive defaults to true.
                ;; If oap.op_end is on a NUL (empty line) oap.inclusive becomes false.
                ;; This makes "d}P" and "v}dP" work the same.

;               if (oap.motion_force == NUL || oap.motion_type == MLINE)
;                   oap.inclusive = true;
;               if (@VIsual_mode == 'V')
;                   oap.motion_type = MLINE;
;               else
;               {
;                   oap.motion_type = MCHAR;
;                   if (@VIsual_mode != Ctrl_V && ml_get_pos(oap.op_end).at(0) == NUL
;                           && (include_line_break || @virtual_op == FALSE))
;                   {
;                       oap.inclusive = false;
                        ;; Try to include the newline,
                        ;; unless it's an operator that works on lines only.
;                       if (@p_sel.at(0) != (byte)'o' && !op_on_lines(oap.op_type))
;                       {
;                           if (oap.op_end.lnum < @curbuf.b_ml.ml_line_count)
;                           {
;                               oap.op_end.lnum++;
;                               oap.op_end.col = 0;
;                               oap.op_end.coladd = 0;
;                               oap.line_count++;
;                           }
;                           else
;                           {
                                ;; Cannot move below the last line, make the op inclusive
                                ;; to tell the operation to include the line break.
;                               oap.inclusive = true;
;                           }
;                       }
;                   }
;               }

;               @redo_VIsual_busy = false;

                ;; Switch Visual off now, so screen updating does
                ;; not show inverted text when the screen is redrawn.
                ;; With OP_YANK and sometimes with OP_COLON and OP_FILTER there is
                ;; no screen redraw, so it is done here to remove the inverted part.

;               if (!gui_yank)
;               {
;                   @VIsual_active = false;
;                   setmouse();
;                   @mouse_dragging = 0;
;                   if (@mode_displayed)
;                       @clear_cmdline = true;   ;; unshow visual mode later
;                   else
;                       clear_showcmd();
;                   if ((oap.op_type == OP_YANK
;                               || oap.op_type == OP_COLON
;                               || oap.op_type == OP_FUNCTION
;                               || oap.op_type == OP_FILTER)
;                           && oap.motion_force == NUL)
;                   {
                        ;; make sure redrawing is correct
;                       @curwin.w_onebuf_opt.@wo_lbr = lbr_saved;
;                       redraw_curbuf_later(INVERTED);
;                   }
;               }
;           }

            ;; Include the trailing byte of a multi-byte char.
;           if (oap.inclusive)
;           {
;               int l = us_ptr2len_cc(ml_get_pos(oap.op_end));
;               if (1 < l)
;                   oap.op_end.col += l - 1;
;           }
;           @curwin.w_set_curswant = true;

            ;; oap.empty is set when start and end are the same.
            ;; The inclusive flag affects this too, unless yanking and the end is on a NUL.

;           oap.empty = (oap.motion_type == MCHAR
;                       && (!oap.inclusive || (oap.op_type == OP_YANK && gchar_pos(oap.op_end) == NUL))
;                       && eqpos(oap.op_start, oap.op_end)
;                       && !(@virtual_op != FALSE && oap.op_start.coladd != oap.op_end.coladd));

            ;; For delete, change and yank, it's an error to operate on an
            ;; empty region, when 'E' included in 'cpoptions' (Vi compatible).

;           boolean empty_region_error = (oap.empty && vim_strbyte(@p_cpo, CPO_EMPTYREGION) != null);

            ;; Force a redraw when operating on an empty Visual region,
            ;; when 'modifiable' is off or creating a fold.
;           if (oap.is_VIsual && (oap.empty || !@curbuf.@b_p_ma))
;           {
;               @curwin.w_onebuf_opt.@wo_lbr = lbr_saved;
;               redraw_curbuf_later(INVERTED);
;           }

            ;; If the end of an operator is in column one while oap.motion_type
            ;; is MCHAR and oap.inclusive is false, we put op_end after the last
            ;; character in the previous line.  If op_start is on or before the
            ;; first non-blank in the line, the operator becomes linewise
            ;; (strange, but that's the way vi does it).

;           if (       oap.motion_type == MCHAR
;                   && oap.inclusive == false
;                   && (cap.retval & CA_NO_ADJ_OP_END) == 0
;                   && oap.op_end.col == 0
;                   && (!oap.is_VIsual || @p_sel.at(0) == (byte)'o')
;                   && !oap.block_mode
;                   && 1 < oap.line_count)
;           {
;               oap.end_adjusted = true;    ;; remember that we did this
;               --oap.line_count;
;               --oap.op_end.lnum;
;               if (inindent(0))
;                   oap.motion_type = MLINE;
;               else
;               {
;                   oap.op_end.col = STRLEN(ml_get(oap.op_end.lnum));
;                   if (0 < oap.op_end.col)
;                   {
;                       --oap.op_end.col;
;                       oap.inclusive = true;
;                   }
;               }
;           }
;           else
;               oap.end_adjusted = false;

;           switch (oap.op_type)
;           {
;               case OP_LSHIFT:
;               case OP_RSHIFT:
;                   op_shift(oap, true, oap.is_VIsual ? (int)cap.count1 : 1);
;                   auto_format(false, true);
;                   break;

;               case OP_JOIN_NS:
;               case OP_JOIN:
;                   if (oap.line_count < 2)
;                       oap.line_count = 2;
;                   if (@curbuf.b_ml.ml_line_count < @curwin.w_cursor.lnum + oap.line_count - 1)
;                       beep_flush();
;                   else
;                   {
;                       do_join((int)oap.line_count, oap.op_type == OP_JOIN, true, true, true);
;                       auto_format(false, true);
;                   }
;                   break;

;               case OP_DELETE:
;                   @VIsual_reselect = false;        ;; don't reselect now
;                   if (empty_region_error)
;                   {
;                       vim_beep();
;                       cancelRedo();
;                   }
;                   else
;                   {
;                       op_delete(oap);
;                       if (oap.motion_type == MLINE && has_format_option(FO_AUTO))
;                           u_save_cursor();        ;; cursor line wasn't saved yet
;                       auto_format(false, true);
;                   }
;                   break;

;               case OP_YANK:
;                   if (empty_region_error)
;                   {
;                       if (!gui_yank)
;                       {
;                           vim_beep();
;                           cancelRedo();
;                       }
;                   }
;                   else
;                   {
;                       @curwin.w_onebuf_opt.@wo_lbr = lbr_saved;
;                       op_yank(oap, false, !gui_yank);
;                   }
;                   check_cursor_col();
;                   break;

;               case OP_CHANGE:
;                   @VIsual_reselect = false;        ;; don't reselect now
;                   if (empty_region_error)
;                   {
;                       vim_beep();
;                       cancelRedo();
;                   }
;                   else
;                   {
                        ;; This is a new edit command, not a restart.
                        ;; Need to remember it to make 'insertmode' work with mappings for Visual mode.
                        ;; But do this only once and not when typed and 'insertmode' isn't set.
;                       int restart_edit_save;
;                       if (@p_im || !@keyTyped)
;                           restart_edit_save = @restart_edit;
;                       else
;                           restart_edit_save = 0;
;                       @restart_edit = 0;
                        ;; Restore linebreak, so that when the user edits it looks as before.
;                       @curwin.w_onebuf_opt.@wo_lbr = lbr_saved;
                        ;; Reset finish_op now, don't want it set inside edit().
;                       @finish_op = false;
;                       if (op_change(oap))         ;; will call edit()
;                           cap.retval |= CA_COMMAND_BUSY;
;                       if (@restart_edit == 0)
;                           @restart_edit = restart_edit_save;
;                   }
;                   break;

;               case OP_INDENT:
;                   if (@curbuf.@b_p_lisp)
;                       op_reindent(oap, get_lisp_indent);
;                   else
;                       op_reindent(oap, get_c_indent);
;                   break;

;               case OP_FILTER:
;                   if (vim_strbyte(@p_cpo, CPO_FILTER) != null)
;                       appendToRedobuff(u8("!\r"));    ;; use any last used !cmd
;                   else
;                       @bangredo = true;            ;; do_bang() will put cmd in redo buffer
                    ;; FALLTHROUGH

;               case OP_COLON:
;                   op_colon(oap);
;                   break;

;               case OP_TILDE:
;               case OP_UPPER:
;               case OP_LOWER:
;               case OP_ROT13:
;                   if (empty_region_error)
;                   {
;                       vim_beep();
;                       cancelRedo();
;                   }
;                   else
;                       op_tilde(oap);
;                   check_cursor_col();
;                   break;

;               case OP_FORMAT:
;                   op_format(oap, false);              ;; use internal function
;                   break;

;               case OP_FORMAT2:
;                   op_format(oap, true);               ;; use internal function
;                   break;

;               case OP_FUNCTION:
;                   op_function(oap);                   ;; call 'operatorfunc'
;                   break;

;               case OP_INSERT:
;               case OP_APPEND:
;                   @VIsual_reselect = false;           ;; don't reselect now
;                   if (empty_region_error)
;                   {
;                       vim_beep();
;                       cancelRedo();
;                   }
;                   else
;                   {
                        ;; This is a new edit command, not a restart.
                        ;; Need to remember it to make 'insertmode' work with mappings for Visual mode.
                        ;; But do this only once.
;                       int restart_edit_save = @restart_edit;
;                       @restart_edit = 0;
                        ;; Restore linebreak, so that when the user edits it looks as before.
;                       @curwin.w_onebuf_opt.@wo_lbr = lbr_saved;
;                       op_insert(oap, cap.count1);
                        ;; Reset linebreak, so that formatting works correctly.
;                       @curwin.w_onebuf_opt.@wo_lbr = false;

                        ;; TODO: when inserting in several lines, should format all the lines.
;                       auto_format(false, true);

;                       if (@restart_edit == 0)
;                           @restart_edit = restart_edit_save;
;                   }
;                   break;

;               case OP_REPLACE:
;                   @VIsual_reselect = false;    ;; don't reselect now
;                   if (empty_region_error)
;                   {
;                       vim_beep();
;                       cancelRedo();
;                   }
;                   else
;                   {
                        ;; Restore linebreak, so that when the user edits it looks as before.
;                       @curwin.w_onebuf_opt.@wo_lbr = lbr_saved;
;                       op_replace(oap, cap.@nchar);
;                   }
;                   break;

;               default:
;                   clearopbeep(oap);
;                   break;
;           }

;           @virtual_op = MAYBE;

;           if (!gui_yank)
;           {
                ;; if 'sol' not set, go back to old column for some commands

;               if (!@p_sol && oap.motion_type == MLINE && !oap.end_adjusted
;                       && (oap.op_type == OP_LSHIFT
;                        || oap.op_type == OP_RSHIFT
;                        || oap.op_type == OP_DELETE))
;               {
;                   @curwin.w_onebuf_opt.@wo_lbr = false;
;                   coladvance(@curwin.w_curswant = old_col);
;               }
;           }
;           else
;           {
;               COPY_pos(@curwin.w_cursor, old_cursor);
;           }
;           oap.block_mode = false;
;           clearop(oap);
;       }

;       @curwin.w_onebuf_opt.@wo_lbr = lbr_saved;
    ))

;; Handle filter operator and visual mode ":".

(defn- #_void op_colon [#_oparg_C oap]
    (§
;       stuffcharReadbuff(':');
;       if (oap.is_VIsual)
;           stuffReadbuff(u8("'<,'>"));
;       else
;       {
            ;; Make the range look nice, so it can be repeated.

;           if (oap.op_start.lnum == @curwin.w_cursor.lnum)
;               stuffcharReadbuff('.');
;           else
;               stuffnumReadbuff(oap.op_start.lnum);
;           if (oap.op_end.lnum != oap.op_start.lnum)
;           {
;               stuffcharReadbuff(',');
;               if (oap.op_end.lnum == @curwin.w_cursor.lnum)
;                   stuffcharReadbuff('.');
;               else if (oap.op_end.lnum == @curbuf.b_ml.ml_line_count)
;                   stuffcharReadbuff('$');
;               else if (oap.op_start.lnum == @curwin.w_cursor.lnum)
;               {
;                   stuffReadbuff(u8(".+"));
;                   stuffnumReadbuff(oap.line_count - 1);
;               }
;               else
;                   stuffnumReadbuff(oap.op_end.lnum);
;           }
;       }
;       if (oap.op_type != OP_COLON)
;           stuffReadbuff(u8("!"));

        ;; do_cmdline() does the rest

    ))

;; Handle the "g@" operator: call 'operatorfunc'.

(defn- #_void op_function [#_oparg_C oap]
    (§
;       Bytes[] argv = new Bytes[1];
;       maybean save_virtual_op = @virtual_op;

;       if (@p_opfunc.at(0) == NUL)
;           emsg(u8("E774: 'operatorfunc' is empty"));
;       else
;       {
            ;; Set '[ and '] marks to text to be operated on.
;           COPY_pos(@curbuf.b_op_start, oap.op_start);
;           COPY_pos(@curbuf.b_op_end, oap.op_end);
;           if (oap.motion_type != MLINE && !oap.inclusive)
                ;; Exclude the end position.
;               decl(@curbuf.b_op_end);

;           if (oap.block_mode)
;               argv[0] = u8("block");
;           else if (oap.motion_type == MLINE)
;               argv[0] = u8("line");
;           else
;               argv[0] = u8("char");

            ;; Reset virtual_op so that 'virtualedit' can be changed in the function.
;           @virtual_op = MAYBE;

;           call_func_retnr(@p_opfunc, 1, argv, false);

;           @virtual_op = save_virtual_op;
;       }
    ))

(atom! boolean do_always)       ;; ignore 'mouse' setting next time
(atom! boolean got_click)       ;; got a click some time back
(atom! boolean in_tab_line)     ;; mouse clicked in tab line
(atom! pos_C orig_cursor    (§_pos_C))

;; Do the appropriate action for the current mouse click in the current mode.
;; Not used for Command-line mode.
;;
;; Normal Mode:
;; event         modi-  position      visual       change   action
;;               fier   cursor                     window
;; left press     -     yes         end             yes
;; left press     C     yes         end             yes     "^]" (2)
;; left press     S     yes         end             yes     "*" (2)
;; left drag      -     yes     start if moved      no
;; left relse     -     yes     start if moved      no
;; middle press   -     yes      if not active      no      put register
;; middle press   -     yes      if active          no      yank and put
;; right press    -     yes     start or extend     yes
;; right press    S     yes     no change           yes     "#" (2)
;; right drag     -     yes     extend              no
;; right relse    -     yes     extend              no
;;
;; Insert or Replace Mode:
;; event         modi-  position      visual       change   action
;;               fier   cursor                     window
;; left press     -     yes     (cannot be active)  yes
;; left press     C     yes     (cannot be active)  yes     "CTRL-O^]" (2)
;; left press     S     yes     (cannot be active)  yes     "CTRL-O*" (2)
;; left drag      -     yes     start or extend (1) no      CTRL-O (1)
;; left relse     -     yes     start or extend (1) no      CTRL-O (1)
;; middle press   -     no      (cannot be active)  no      put register
;; right press    -     yes     start or extend     yes     CTRL-O
;; right press    S     yes     (cannot be active)  yes     "CTRL-O#" (2)
;;
;; (1) only if mouse pointer moved since press
;; (2) only if click is in same buffer
;;
;; Return true if start_arrow() should be called for edit mode.

(defn- #_boolean do_mouse [#_oparg_C oap, #_int c, #_int dir, #_int count, #_int fixindent]
    ;; oap: operator argument, can be null
    ;; c: K_LEFTMOUSE, etc
    ;; dir: Direction to 'put' if necessary
    ;; fixindent: PUT_FIXINDENT if fixing indent necessary
    (§
;       boolean[] is_click = new boolean[1];    ;; if false it's a drag or release event
;       boolean[] is_drag = new boolean[1];     ;; if true it's a drag event
;       int jump_flags = 0;                     ;; flags for jump_to_mouse()

;       window_C old_curwin = @curwin;

;       boolean old_active = @VIsual_active;
;       int old_mode = @VIsual_mode;

        ;; When GUI is active, always recognize mouse events, otherwise:
        ;; - Ignore mouse event in normal mode if 'mouse' doesn't include 'n'.
        ;; - Ignore mouse event in visual mode if 'mouse' doesn't include 'v'.
        ;; - For command line and insert mode 'mouse' is checked before calling do_mouse().

;       if (@do_always)
;           @do_always = false;
;       else
;       {
;           if (@VIsual_active)
;           {
;               if (!mouse_has(MOUSE_VISUAL))
;                   return false;
;           }
;           else if (@State == NORMAL && !mouse_has(MOUSE_NORMAL))
;               return false;
;       }

;       int which_button;                   ;; MOUSE_LEFT, _MIDDLE or _RIGHT

;       for ( ; ; )
;       {
;           which_button = get_mouse_button(KEY2TERMCAP1(c), is_click, is_drag);
;           if (is_drag[0])
;           {
                ;; If the next character is the same mouse event then use that one.
                ;; Speeds up dragging the status line.
;               if (vpeekc() != NUL)
;               {
;                   int save_mouse_row = @mouse_row;
;                   int save_mouse_col = @mouse_col;

                    ;; Need to get the character, peeking doesn't get the actual one.
;                   int nc = safe_vgetc();
;                   if (c == nc)
;                       continue;
;                   vungetc(nc);
;                   @mouse_row = save_mouse_row;
;                   @mouse_col = save_mouse_col;
;               }
;           }
;           break;
;       }

        ;; Ignore drag and release events if we didn't get a click.

;       if (is_click[0])
;           @got_click = true;
;       else
;       {
;           if (!@got_click)                 ;; didn't get click, ignore
;               return false;
;           if (!is_drag[0])                   ;; release, reset got_click
;           {
;               @got_click = false;
;               if (@in_tab_line)
;               {
;                   @in_tab_line = false;
;                   return false;
;               }
;           }
;       }

        ;; CTRL right mouse button does CTRL-T

;       if (is_click[0] && (@mod_mask & MOD_MASK_CTRL) != 0 && which_button == MOUSE_RIGHT)
;       {
;           if ((@State & INSERT) != 0)
;               stuffcharReadbuff(Ctrl_O);
;           if (1 < count)
;               stuffnumReadbuff(count);
;           stuffcharReadbuff(Ctrl_T);
;           @got_click = false;              ;; ignore drag&release now
;           return false;
;       }

        ;; CTRL only works with left mouse button

;       if ((@mod_mask & MOD_MASK_CTRL) != 0 && which_button != MOUSE_LEFT)
;           return false;

        ;; When a modifier is down, ignore drag and release events, as well as
        ;; multiple clicks and the middle mouse button.
        ;; Accept shift-leftmouse drags when 'mousemodel' is "popup.*".

;       if ((@mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL | MOD_MASK_ALT | MOD_MASK_META)) != 0
;               && (!is_click[0]
;                   || (@mod_mask & MOD_MASK_MULTI_CLICK) != 0
;                   || which_button == MOUSE_MIDDLE)
;               && !((@mod_mask & (MOD_MASK_SHIFT | MOD_MASK_ALT)) != 0
;                   && mouse_model_popup()
;                   && which_button == MOUSE_LEFT)
;               && !((@mod_mask & MOD_MASK_ALT) != 0
;                   && !mouse_model_popup()
;                   && which_button == MOUSE_RIGHT)
;               )
;           return false;

        ;; If the button press was used as the movement command for an operator
        ;; (eg "d<MOUSE>"), or it is the middle button that is held down, ignore
        ;; drag/release events.

;       if (!is_click[0] && which_button == MOUSE_MIDDLE)
;           return false;

;       int regname;
;       if (oap != null)
;           regname = oap.regname;
;       else
;           regname = 0;

        ;; Middle mouse button does a 'put' of the selected text

;       if (which_button == MOUSE_MIDDLE)
;       {
;           if (@State == NORMAL)
;           {
                ;; If an operator was pending, we don't know what the user wanted
                ;; to do.  Go back to normal mode: Clear the operator and beep().

;               if (oap != null && oap.op_type != OP_NOP)
;               {
;                   clearopbeep(oap);
;                   return false;
;               }

                ;; If visual was active, yank the highlighted text and put it
                ;; before the mouse pointer position.
                ;; In Select mode replace the highlighted text with the clipboard.

;               if (@VIsual_active)
;               {
;                   if (@VIsual_select)
;                   {
;                       stuffcharReadbuff(Ctrl_G);
;                       stuffReadbuff(u8("\"+p"));
;                   }
;                   else
;                   {
;                       stuffcharReadbuff('y');
;                       stuffcharReadbuff(K_MIDDLEMOUSE);
;                   }
;                   @do_always = true;       ;; ignore 'mouse' setting next time
;                   return false;
;               }

                ;; the rest is below jump_to_mouse()

;           }

;           else if ((@State & INSERT) == 0)
;               return false;

            ;; Middle click in insert mode doesn't move the mouse, just insert the
            ;; contents of a register.  '.' register is special, can't insert that with do_put().
            ;; Also paste at the cursor if the current mode isn't in 'mouse'.

;           if ((@State & INSERT) != 0 || !mouse_has(MOUSE_NORMAL))
;           {
;               if (regname == '.')
;                   insert_reg(regname, true);
;               else
;               {
;                   if (@clip_star.available && regname == 0)
;                       regname = '*';
;                   if ((@State & REPLACE_FLAG) != 0 && !yank_register_mline(regname))
;                       insert_reg(regname, true);
;                   else
;                   {
;                       do_put(regname, BACKWARD, 1, fixindent | PUT_CURSEND);

                        ;; Repeat it with CTRL-R CTRL-O r or CTRL-R CTRL-P r.
;                       appendCharToRedobuff(Ctrl_R);
;                       appendCharToRedobuff((fixindent != 0) ? Ctrl_P : Ctrl_O);
;                       appendCharToRedobuff((regname == 0) ? '"' : regname);
;                   }
;               }
;               return false;
;           }
;       }

        ;; When dragging or button-up stay in the same window.
;       if (!is_click[0])
;           jump_flags |= MOUSE_FOCUS | MOUSE_DID_MOVE;

        ;; When 'mousemodel' is "popup" or "popup_setpos", translate mouse events:
        ;; right button up   -> pop-up menu
        ;; shift-left button -> right button
        ;; alt-left button   -> alt-right button

;       if (mouse_model_popup())
;       {
;           if (which_button == MOUSE_RIGHT && (@mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL)) == 0)
;           {
                ;; NOTE: Ignore right button down and drag mouse events.
                ;; Windows only shows the popup menu on the button up event.

;               return false;
;           }
;           if (which_button == MOUSE_LEFT && (@mod_mask & (MOD_MASK_SHIFT|MOD_MASK_ALT)) != 0)
;           {
;               which_button = MOUSE_RIGHT;
;               @mod_mask &= ~MOD_MASK_SHIFT;
;           }
;       }

;       pos_C start_visual = §_pos_C();
;       start_visual.lnum = 0;

;       pos_C end_visual = §_pos_C();

;       if ((@State & (NORMAL | INSERT)) != 0 && (@mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL)) == 0)
;       {
;           if (which_button == MOUSE_LEFT)
;           {
;               if (is_click[0])
;               {
                    ;; stop Visual mode for a left click in a window, but not when on a status line
;                   if (@VIsual_active)
;                       jump_flags |= MOUSE_MAY_STOP_VIS;
;               }
;               else if (mouse_has(MOUSE_VISUAL))
;                   jump_flags |= MOUSE_MAY_VIS;
;           }
;           else if (which_button == MOUSE_RIGHT)
;           {
;               if (is_click[0] && @VIsual_active)
;               {
                    ;; Remember the start and end of visual before moving the cursor.

;                   if (ltpos(@curwin.w_cursor, @VIsual))
;                   {
;                       COPY_pos(start_visual, @curwin.w_cursor);
;                       COPY_pos(end_visual, @VIsual);
;                   }
;                   else
;                   {
;                       COPY_pos(start_visual, @VIsual);
;                       COPY_pos(end_visual, @curwin.w_cursor);
;                   }
;               }
;               jump_flags |= MOUSE_FOCUS;
;               if (mouse_has(MOUSE_VISUAL))
;                   jump_flags |= MOUSE_MAY_VIS;
;           }
;       }

        ;; If an operator is pending, ignore all drags and releases until the next mouse click.

;       if (!is_drag[0] && oap != null && oap.op_type != OP_NOP)
;       {
;           @got_click = false;
;           oap.motion_type = MCHAR;
;       }

        ;; When releasing the button let jump_to_mouse() know.
;       if (!is_click[0] && !is_drag[0])
;           jump_flags |= MOUSE_RELEASED;

        ;; JUMP!

;       {
;           boolean[] __ = (oap != null) ? new boolean[] { oap.inclusive } : null;
;           jump_flags = jump_to_mouse(jump_flags, __, which_button);
;           if (oap != null)
;               oap.inclusive = __[0];
;       }

;       boolean moved = ((jump_flags & CURSOR_MOVED) != 0);                    ;; Has cursor moved?
;       boolean in_status_line = ((jump_flags & IN_STATUS_LINE) != 0);         ;; mouse in status line
;       boolean in_sep_line = ((jump_flags & IN_SEP_LINE) != 0);               ;; mouse in vertical separator line

        ;; When jumping to another window, clear a pending operator.
        ;; That's a bit friendlier than beeping and not jumping to that window.
;       if (@curwin != old_curwin && oap != null && oap.op_type != OP_NOP)
;           clearop(oap);

;       if ((jump_flags & IN_OTHER_WIN) != 0 && !@VIsual_active && @clip_star.available)
;       {
;           clip_modeless(which_button, is_click[0], is_drag[0]);
;           return false;
;       }

        ;; Set global flag that we are extending the Visual area with mouse dragging;
        ;; temporarily minimize 'scrolloff'.
;       if (@VIsual_active && is_drag[0] && @p_so != 0)
;       {
            ;; In the very first line, allow scrolling one line.
;           if (@mouse_row == 0)
;               @mouse_dragging = 2;
;           else
;               @mouse_dragging = 1;
;       }

        ;; When dragging the mouse above the window, scroll down.
;       if (is_drag[0] && @mouse_row < 0 && !in_status_line)
;       {
;           scroll_redraw(false, 1L);
;           @mouse_row = 0;
;       }

;       if (start_visual.lnum != 0)             ;; right click in visual mode
;       {
            ;; When ALT is pressed make Visual mode blockwise.
;           if ((@mod_mask & MOD_MASK_ALT) != 0)
;               @VIsual_mode = Ctrl_V;

            ;; In Visual-block mode, divide the area in four,
            ;; pick up the corner that is in the quarter that the cursor is in.

;           if (@VIsual_mode == Ctrl_V)
;           {
;               int[] leftcol = new int[1];
;               int[] rightcol = new int[1];
;               getvcols(@curwin, start_visual, end_visual, leftcol, rightcol);
;               if ((leftcol[0] + rightcol[0]) / 2 < @curwin.w_curswant)
;                   end_visual.col = leftcol[0];
;               else
;                   end_visual.col = rightcol[0];
;               if (@curwin.w_cursor.lnum < (start_visual.lnum + end_visual.lnum) / 2)
;                   end_visual.lnum = end_visual.lnum;
;               else
;                   end_visual.lnum = start_visual.lnum;

                ;; move VIsual to the right column
;               COPY_pos(start_visual, @curwin.w_cursor);    ;; save the cursor pos
;               COPY_pos(@curwin.w_cursor, end_visual);
;               coladvance(end_visual.col);
;               COPY_pos(@VIsual, @curwin.w_cursor);
;               COPY_pos(@curwin.w_cursor, start_visual);    ;; restore the cursor
;           }
;           else
;           {
                ;; If the click is before the start of visual, change the start.
                ;; If the click is after the end of visual, change the end.
                ;; If the click is inside the visual, change the closest side.

;               if (ltpos(@curwin.w_cursor, start_visual))
;                   COPY_pos(@VIsual, end_visual);
;               else if (ltpos(end_visual, @curwin.w_cursor))
;                   COPY_pos(@VIsual, start_visual);
;               else
;               {
                    ;; In the same line, compare column number.
;                   if (end_visual.lnum == start_visual.lnum)
;                   {
;                       if (end_visual.col - @curwin.w_cursor.col < @curwin.w_cursor.col - start_visual.col)
;                           COPY_pos(@VIsual, start_visual);
;                       else
;                           COPY_pos(@VIsual, end_visual);
;                   }
                    ;; In different lines, compare line number.
;                   else
;                   {
;                       long diff = (@curwin.w_cursor.lnum - start_visual.lnum) - (end_visual.lnum - @curwin.w_cursor.lnum);

;                       if (0 < diff)               ;; closest to end
;                           COPY_pos(@VIsual, start_visual);
;                       else if (diff < 0)          ;; closest to start
;                           COPY_pos(@VIsual, end_visual);
;                       else                        ;; in the middle line
;                       {
;                           if (@curwin.w_cursor.col < (start_visual.col + end_visual.col) / 2)
;                               COPY_pos(@VIsual, end_visual);
;                           else
;                               COPY_pos(@VIsual, start_visual);
;                       }
;                   }
;               }
;           }
;       }

        ;; If Visual mode started in insert mode, execute "CTRL-O"

;       else if ((@State & INSERT) != 0 && @VIsual_active)
;           stuffcharReadbuff(Ctrl_O);

        ;; Middle mouse click: Put text before cursor.

;       if (which_button == MOUSE_MIDDLE)
;       {
;           if (@clip_star.available && regname == 0)
;               regname = '*';
;           if (yank_register_mline(regname))
;           {
;               if (@mouse_past_bottom)
;                   dir = FORWARD;
;           }
;           else if (@mouse_past_eol)
;               dir = FORWARD;

;           int c1, c2;
;           if (fixindent != 0)
;           {
;               c1 = (dir == BACKWARD) ? '[' : ']';
;               c2 = 'p';
;           }
;           else
;           {
;               c1 = (dir == FORWARD) ? 'p' : 'P';
;               c2 = NUL;
;           }
;           prep_redo(regname, count, NUL, c1, NUL, c2, NUL);

            ;; Remember where the paste started, so in edit() insStart can be set to this position.

;           if (@restart_edit != 0)
;               COPY_pos(@where_paste_started, @curwin.w_cursor);
;           do_put(regname, dir, count, fixindent | PUT_CURSEND);
;       }

        ;; Ctrl-Mouse click jumps to the tag under the mouse pointer.

;       else if ((@mod_mask & MOD_MASK_CTRL) != 0)
;       {
;           if ((@State & INSERT) != 0)
;               stuffcharReadbuff(Ctrl_O);
;           stuffcharReadbuff(Ctrl_RSB);
;           @got_click = false;              ;; ignore drag&release now
;       }

        ;; Shift-Mouse click searches for the next occurrence of the word under the mouse pointer

;       else if ((@mod_mask & MOD_MASK_SHIFT) != 0)
;       {
;           if ((@State & INSERT) != 0 || (@VIsual_active && @VIsual_select))
;               stuffcharReadbuff(Ctrl_O);
;           if (which_button == MOUSE_LEFT)
;               stuffcharReadbuff('*');
;           else    ;; MOUSE_RIGHT
;               stuffcharReadbuff('#');
;       }

        ;; Handle double clicks, unless on status line.
;       else if (in_status_line)
;       {
;       }
;       else if (in_sep_line)
;       {
;       }
;       else if ((@mod_mask & MOD_MASK_MULTI_CLICK) != 0 && (@State & (NORMAL | INSERT)) != 0 && mouse_has(MOUSE_VISUAL))
;       {
;           if (is_click[0] || !@VIsual_active)
;           {
;               if (@VIsual_active)
;                   COPY_pos(@orig_cursor, @VIsual);
;               else
;               {
;                   check_visual_highlight();
;                   COPY_pos(@VIsual, @curwin.w_cursor);
;                   COPY_pos(@orig_cursor, @VIsual);
;                   @VIsual_active = true;
;                   @VIsual_reselect = true;
                    ;; start Select mode if 'selectmode' contains "mouse"
;                   may_start_select('o');
;                   setmouse();
;               }
;               if ((@mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)
;               {
                    ;; Double click with ALT pressed makes it blockwise.
;                   if ((@mod_mask & MOD_MASK_ALT) != 0)
;                       @VIsual_mode = Ctrl_V;
;                   else
;                       @VIsual_mode = 'v';
;               }
;               else if ((@mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_3CLICK)
;                   @VIsual_mode = 'V';
;               else if ((@mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_4CLICK)
;                   @VIsual_mode = Ctrl_V;
                ;; Make sure the clipboard gets updated.  Needed because start and
                ;; end may still be the same, and the selection needs to be owned.
;               @clip_star.vmode = NUL;
;           }

            ;; A double click selects a word or a block.

;           if ((@mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)
;           {
;               pos_C pos = null;

;               if (is_click[0])
;               {
                    ;; If the character under the cursor (skipping white space) is not a word character,
                    ;; try finding a match and select a (), {}, [], #if/#endif, etc. block.
;                   COPY_pos(end_visual, @curwin.w_cursor);
;                   while (vim_iswhite(gchar_pos(end_visual)))
;                       incp(end_visual);
;                   if (oap != null)
;                       oap.motion_type = MCHAR;
;                   if (oap != null
;                           && @VIsual_mode == 'v'
;                           && !vim_iswordc(gchar_pos(end_visual), @curbuf)
;                           && eqpos(@curwin.w_cursor, @VIsual)
;                           && (pos = findmatch(oap, NUL)) != null)
;                   {
;                       COPY_pos(@curwin.w_cursor, pos);
;                       if (oap.motion_type == MLINE)
;                           @VIsual_mode = 'V';
;                       else if (@p_sel.at(0) == (byte)'e')
;                       {
;                           if (ltpos(@curwin.w_cursor, @VIsual))
;                               @VIsual.col++;
;                           else
;                               @curwin.w_cursor.col++;
;                       }
;                   }
;               }

;               if (pos == null && (is_click[0] || is_drag[0]))
;               {
                    ;; When not found a match or when dragging: extend to include a word.
;                   if (ltpos(@curwin.w_cursor, @orig_cursor))
;                   {
;                       find_start_of_word(@curwin.w_cursor);
;                       find_end_of_word(@VIsual);
;                   }
;                   else
;                   {
;                       find_start_of_word(@VIsual);
;                       if (@p_sel.at(0) == (byte)'e' && ml_get_cursor().at(0) != NUL)
;                           @curwin.w_cursor.col += us_ptr2len_cc(ml_get_cursor());
;                       find_end_of_word(@curwin.w_cursor);
;                   }
;               }
;               @curwin.w_set_curswant = true;
;           }
;           if (is_click[0])
;               redraw_curbuf_later(INVERTED);      ;; update the inversion
;       }
;       else if (@VIsual_active && !old_active)
;       {
;           if ((@mod_mask & MOD_MASK_ALT) != 0)
;               @VIsual_mode = Ctrl_V;
;           else
;               @VIsual_mode = 'v';
;       }

        ;; If Visual mode changed show it later.
;       if ((!@VIsual_active && old_active && @mode_displayed)
;               || (@VIsual_active && @p_smd && @msg_silent == 0 && (!old_active || @VIsual_mode != old_mode)))
;           @redraw_cmdline = true;

;       return moved;
    ))

;; Move "pos" back to the start of the word it's in.

(defn- #_void find_start_of_word [#_pos_C pos]
    (§
;       Bytes line = ml_get(pos.lnum);
;       int cclass = get_mouse_class(line.plus(pos.col));

;       while (0 < pos.col)
;       {
;           int col = pos.col - 1;
;           col -= us_head_off(line, line.plus(col));
;           if (get_mouse_class(line.plus(col)) != cclass)
;               break;
;           pos.col = col;
;       }
    ))

;; Move "pos" forward to the end of the word it's in.
;; When 'selection' is "exclusive", the position is just after the word.

(defn- #_void find_end_of_word [#_pos_C pos]
    (§
;       Bytes line = ml_get(pos.lnum);
;       if (@p_sel.at(0) == (byte)'e' && 0 < pos.col)
;       {
;           --pos.col;
;           pos.col -= us_head_off(line, line.plus(pos.col));
;       }

;       int cclass = get_mouse_class(line.plus(pos.col));
;       while (line.at(pos.col) != NUL)
;       {
;           int col = pos.col + us_ptr2len_cc(line.plus(pos.col));
;           if (get_mouse_class(line.plus(col)) != cclass)
;           {
;               if (@p_sel.at(0) == (byte)'e')
;                   pos.col = col;
;               break;
;           }
;           pos.col = col;
;       }
    ))

;; Get class of a character for selection: same class means same word.
;;  0: blank
;;  1: punctuation groups
;;  2: normal word character
;; >2: multi-byte word character.

(defn- #_int get_mouse_class [#_Bytes p]
    (§
;       if (1 < us_byte2len(p.at(0), false))
;           return us_get_class(p, @curbuf);

;       if (p.at(0) == (byte)' ' || p.at(0) == (byte)'\t')
;           return 0;

;       if (us_iswordb(p.at(0), @curbuf))
;           return 2;

        ;; There are a few special cases where we want certain combinations of
        ;; characters to be considered as a single word.  These are things like
        ;; "->", "/ *", "*=", "+=", "&=", "<=", ">=", "!=" etc.  Otherwise, each
        ;; character is in its own class.

;       if (p.at(0) != NUL && vim_strbyte(u8("-+*/%<>&|^!="), p.at(0)) != null)
;           return 1;

;       return char_u(p.at(0));
    ))

(atom! boolean did_check_visual_highlight)

;; Check if highlighting for visual mode is possible, give a warning message if not.

(defn- #_void check_visual_highlight []
    (§
;       if (@full_screen)
;       {
;           if (!@did_check_visual_highlight && hl_attr(HLF_V) == 0)
;               msg(u8("Warning: terminal cannot highlight"));
;           @did_check_visual_highlight = true;
;       }
    ))

;; End Visual mode.
;; This function should ALWAYS be called to end Visual mode, except from do_pending_operator().

(defn- #_void end_visual_mode []
    (§
        ;; If we are using the clipboard, then remember what was selected in case
        ;; we need to paste it somewhere while we still own the selection.
        ;; Only do this when the clipboard is already owned.  Don't want to grab
        ;; the selection when hitting ESC.

;       if (@clip_star.available && @clip_star.owned)
;           clip_auto_select();

;       @VIsual_active = false;
;       setmouse();
;       @mouse_dragging = 0;

        ;; Save the current VIsual area for '< and '> marks, and "gv".
;       @curbuf.b_visual.vi_mode = @VIsual_mode;
;       COPY_pos(@curbuf.b_visual.vi_start, @VIsual);
;       COPY_pos(@curbuf.b_visual.vi_end, @curwin.w_cursor);
;       @curbuf.b_visual.vi_curswant = @curwin.w_curswant;
;       @curbuf.b_visual_mode_eval = @VIsual_mode;
;       if (!virtual_active())
;           @curwin.w_cursor.coladd = 0;

;       if (@mode_displayed)
;           @clear_cmdline = true;           ;; unshow visual mode later
;       else
;           clear_showcmd();

;       adjust_cursor_eol();
    ))

;; Reset VIsual_active and VIsual_reselect.

(defn- #_void reset_VIsual_and_resel []
    (§
;       if (@VIsual_active)
;       {
;           end_visual_mode();
;           redraw_curbuf_later(INVERTED);  ;; delete the inversion later
;       }
;       @VIsual_reselect = false;
    ))

;; Reset VIsual_active and VIsual_reselect if it's set.

(defn- #_void reset_VIsual []
    (§
;       if (@VIsual_active)
;       {
;           end_visual_mode();
;           redraw_curbuf_later(INVERTED);  ;; delete the inversion later
;           @VIsual_reselect = false;
;       }
    ))

;; Find the identifier under or to the right of the cursor.
;; "find_type" can have one of three values:
;; FIND_IDENT:   find an identifier (keyword)
;; FIND_STRING:  find any non-white string
;; FIND_IDENT + FIND_STRING: find any non-white string, identifier preferred.
;; FIND_EVAL:    find text useful for C program debugging
;;
;; There are three steps:
;; 1. Search forward for the start of an identifier/string.
;;    Doesn't move if already on one.
;; 2. Search backward for the start of this identifier/string.
;;    This doesn't match the real Vi but I like it a little better
;;    and it shouldn't bother anyone.
;; 3. Search forward to the end of this identifier/string.
;;    When FIND_IDENT isn't defined, we backup until a blank.
;;
;; Returns the length of the string, or zero if no string is found.
;; If a string is found, a pointer to the string is put in "*string".
;; This string is not always NUL terminated.

(defn- #_int find_ident_under_cursor [#_Bytes* string, #_int find_type]
    (§
;       return find_ident_at_pos(@curwin, @curwin.w_cursor.lnum, @curwin.w_cursor.col, string, find_type);
    ))

;; Like find_ident_under_cursor(), but for any window and any position.
;; However: Uses 'iskeyword' from the current window!.

(defn- #_int find_ident_at_pos [#_window_C wp, #_long lnum, #_int startcol, #_Bytes* string, #_int find_type]
    (§
;       Bytes p = ml_get_buf(wp.w_buffer, lnum, false);

;       int col = 0;
;       int this_class = 0;

;       int round;

        ;; if round == 0: try to find an identifier
        ;; if round == 1: try to find any non-white string

;       for (round = (find_type & FIND_IDENT) != 0 ? 0 : 1; round < 2; round++)
;       {
            ;; 1. Skip to start of identifier/string.

;           col = startcol;
;           while (p.at(col) != NUL)
;           {
;               this_class = us_get_class(p.plus(col), @curbuf);
;               if (this_class != 0 && (round == 1 || this_class != 1))
;                   break;
;               col += us_ptr2len_cc(p.plus(col));
;           }

            ;; 2. Back up to start of identifier/string.

            ;; Remember class of character under cursor.
;           this_class = us_get_class(p.plus(col), @curbuf);
;           while (0 < col && this_class != 0)
;           {
;               int prevcol = col - 1 - us_head_off(p, p.plus(col - 1));
;               int prev_class = us_get_class(p.plus(prevcol), @curbuf);
;               if (this_class != prev_class && (round == 0 || prev_class == 0 || (find_type & FIND_IDENT) != 0))
;                   break;
;               col = prevcol;
;           }

            ;; If we don't want just any old string, or we've found an identifier, stop searching.
;           if (2 < this_class)
;               this_class = 2;
;           if ((find_type & FIND_STRING) == 0 || this_class == 2)
;               break;
;       }

;       if (p.at(col) == NUL || (round == 0 && this_class != 2))
;       {
            ;; didn't find an identifier or string

;           if ((find_type & FIND_STRING) != 0)
;               emsg(u8("E348: No string under cursor"));
;           else
;               emsg(e_noident);
;           return 0;
;       }
;       p = p.plus(col);
;       string[0] = p;

        ;; 3. Find the end if the identifier/string.

;       col = 0;
        ;; Search for point of changing multibyte character class.
;       this_class = us_get_class(p, @curbuf);
;       while (p.at(col) != NUL
;           && ((round == 0 ? us_get_class(p.plus(col), @curbuf) == this_class : us_get_class(p.plus(col), @curbuf) != 0)))
;           col += us_ptr2len_cc(p.plus(col));

;       return col;
    ))

;; Prepare for redo of a normal command.

(defn- #_void prep_redo_cmd [#_cmdarg_C cap]
    (§
;       prep_redo(cap.oap.regname, cap.count0, NUL, cap.cmdchar, NUL, NUL, cap.@nchar);
    ))

;; Prepare for redo of any command.
;; Note that only the last argument can be a multi-byte char.

(defn- #_void prep_redo [#_int regname, #_long num, #_int cmd1, #_int cmd2, #_int cmd3, #_int cmd4, #_int cmd5]
    (§
;       resetRedobuff();
;       if (regname != 0)   ;; yank from specified buffer
;       {
;           appendCharToRedobuff('"');
;           appendCharToRedobuff(regname);
;       }
;       if (num != 0)
;           appendNumberToRedobuff(num);

;       if (cmd1 != NUL)
;           appendCharToRedobuff(cmd1);
;       if (cmd2 != NUL)
;           appendCharToRedobuff(cmd2);
;       if (cmd3 != NUL)
;           appendCharToRedobuff(cmd3);
;       if (cmd4 != NUL)
;           appendCharToRedobuff(cmd4);
;       if (cmd5 != NUL)
;           appendCharToRedobuff(cmd5);
    ))

;; check for operator active and clear it
;;
;; return true if operator was active

(defn- #_boolean checkclearop [#_oparg_C oap]
    (§
;       if (oap.op_type == OP_NOP)
;           return false;
;       clearopbeep(oap);
;       return true;
    ))

;; Check for operator or Visual active.  Clear active operator.
;;
;; Return true if operator or Visual was active.

(defn- #_boolean checkclearopq [#_oparg_C oap]
    (§
;       if (oap.op_type == OP_NOP && !@VIsual_active)
;           return false;
;       clearopbeep(oap);
;       return true;
    ))

(defn- #_void clearop [#_oparg_C oap]
    (§
;       oap.op_type = OP_NOP;
;       oap.regname = 0;
;       oap.motion_force = NUL;
;       oap.use_reg_one = false;
    ))

(defn- #_void clearopbeep [#_oparg_C oap]
    (§
;       clearop(oap);
;       beep_flush();
    ))

;; Remove the shift modifier from a special key.

(defn- #_void unshift_special [#_cmdarg_C cap]
    (§
;       switch (cap.cmdchar)
;       {
;           case K_S_RIGHT: cap.cmdchar = K_RIGHT; break;
;           case K_S_LEFT:  cap.cmdchar = K_LEFT; break;
;           case K_S_UP:    cap.cmdchar = K_UP; break;
;           case K_S_DOWN:  cap.cmdchar = K_DOWN; break;
;           case K_S_HOME:  cap.cmdchar = K_HOME; break;
;           case K_S_END:   cap.cmdchar = K_END; break;
;       }
;       { int[] __ = { @mod_mask }; cap.cmdchar = simplify_key(cap.cmdchar, __); @mod_mask = __[0]; }
    ))

;; Routines for displaying a partly typed command

(final int SHOWCMD_BUFLEN (+ SHOWCMD_COLS 1 30))
(final Bytes    showcmd_buf     (Bytes. SHOWCMD_BUFLEN))
(final Bytes    old_showcmd_buf (Bytes. SHOWCMD_BUFLEN))    ;; for push_showcmd()
(atom! boolean  showcmd_is_clear true)
(atom! boolean  showcmd_visual)

(defn- #_void clear_showcmd []
    (§
;       if (!@p_sc)
;           return;

;       if (@VIsual_active && !char_avail())
;       {
;           boolean cursor_bot = ltpos(@VIsual, @curwin.w_cursor);
;           long lines;
;           long top, bot;

            ;; Show the size of the Visual area.
;           if (cursor_bot)
;           {
;               top = @VIsual.lnum;
;               bot = @curwin.w_cursor.lnum;
;           }
;           else
;           {
;               top = @curwin.w_cursor.lnum;
;               bot = @VIsual.lnum;
;           }
;           lines = bot - top + 1;

;           if (@VIsual_mode == Ctrl_V)
;           {
;               Bytes saved_sbr = @p_sbr;
;               int[] leftcol = new int[1];
;               int[] rightcol = new int[1];

                ;; Make 'sbr' empty for a moment to get the correct size.
;               @p_sbr = EMPTY_OPTION;
;               getvcols(@curwin, @curwin.w_cursor, @VIsual, leftcol, rightcol);
;               @p_sbr = saved_sbr;
;               libC.sprintf(showcmd_buf, u8("%ldx%ld"), lines, (long)(rightcol[0] - leftcol[0] + 1));
;           }
;           else if (@VIsual_mode == 'V' || @VIsual.lnum != @curwin.w_cursor.lnum)
;               libC.sprintf(showcmd_buf, u8("%ld"), lines);
;           else
;           {
;               int bytes = 0;
;               int chars = 0;

;               Bytes s, e;
;               if (cursor_bot)
;               {
;                   s = ml_get_pos(@VIsual);
;                   e = ml_get_cursor();
;               }
;               else
;               {
;                   s = ml_get_cursor();
;                   e = ml_get_pos(@VIsual);
;               }
;               while ((@p_sel.at(0) != (byte)'e') ? BLE(s, e) : BLT(s, e))
;               {
;                   int l = us_ptr2len_cc(s);
;                   if (l == 0)
;                   {
;                       bytes++;
;                       chars++;
;                       break;  ;; end of line
;                   }
;                   bytes += l;
;                   chars++;
;                   s = s.plus(l);
;               }
;               if (bytes == chars)
;                   libC.sprintf(showcmd_buf, u8("%d"), chars);
;               else
;                   libC.sprintf(showcmd_buf, u8("%d-%d"), chars, bytes);
;           }
;           showcmd_buf.be(SHOWCMD_COLS, NUL);      ;; truncate
;           @showcmd_visual = true;
;       }
;       else
;       {
;           showcmd_buf.be(0, NUL);
;           @showcmd_visual = false;

            ;; Don't actually display something if there is nothing to clear.
;           if (@showcmd_is_clear)
;               return;
;       }

;       display_showcmd();
    ))

(final int* ignore_showcmd
    [
        K_IGNORE,
        K_LEFTMOUSE, K_LEFTDRAG, K_LEFTRELEASE,
        K_MIDDLEMOUSE, K_MIDDLEDRAG, K_MIDDLERELEASE,
        K_RIGHTMOUSE, K_RIGHTDRAG, K_RIGHTRELEASE,
        K_MOUSEDOWN, K_MOUSEUP, K_MOUSELEFT, K_MOUSERIGHT,
        K_X1MOUSE, K_X1DRAG, K_X1RELEASE, K_X2MOUSE, K_X2DRAG, K_X2RELEASE,
        K_CURSORHOLD,
        0
    ])

;; Add 'c' to string of shown command chars.
;; Return true if output has been written (and setcursor() has been called).

(defn- #_boolean add_to_showcmd [#_int c]
    (§
;       if (!@p_sc || @msg_silent != 0)
;           return false;

;       if (@showcmd_visual)
;       {
;           showcmd_buf.be(0, NUL);
;           @showcmd_visual = false;
;       }

        ;; Ignore keys that are scrollbar updates and mouse clicks.
;       if (is_special(c))
;           for (int i = 0; ignore_showcmd[i] != 0; i++)
;               if (ignore_showcmd[i] == c)
;                   return false;

;       Bytes p = transchar(c);
;       if (p.at(0) == (byte)' ')
;           STRCPY(p, u8("<20>"));

;       int old_len = STRLEN(showcmd_buf);
;       int extra_len = STRLEN(p);
;       int overflow = old_len + extra_len - SHOWCMD_COLS;
;       if (0 < overflow)
;           BCOPY(showcmd_buf, 0, showcmd_buf, overflow, old_len - overflow + 1);
;       STRCAT(showcmd_buf, p);

;       if (char_avail())
;           return false;

;       display_showcmd();

;       return true;
    ))

(defn- #_void add_to_showcmd_c [#_int c]
    (§
;       if (!add_to_showcmd(c))
;           setcursor();
    ))

;; Delete 'len' characters from the end of the shown command.

(defn- #_void del_from_showcmd [#_int len]
    (§
;       if (!@p_sc)
;           return;

;       int old_len = STRLEN(showcmd_buf);
;       if (old_len < len)
;           len = old_len;
;       showcmd_buf.be(old_len - len, NUL);

;       if (!char_avail())
;           display_showcmd();
    ))

;; push_showcmd() and pop_showcmd() are used when waiting for the user
;; to type something and there is a partial mapping.

(defn- #_void push_showcmd []
    (§
;       if (@p_sc)
;           STRCPY(old_showcmd_buf, showcmd_buf);
    ))

(defn- #_void pop_showcmd []
    (§
;       if (!@p_sc)
;           return;

;       STRCPY(showcmd_buf, old_showcmd_buf);

;       display_showcmd();
    ))

(defn- #_void display_showcmd []
    (§
;       cursor_off();

;       int len = STRLEN(showcmd_buf);
;       if (len == 0)
;           @showcmd_is_clear = true;
;       else
;       {
;           screen_puts(showcmd_buf, (int)@Rows - 1, @sc_col, 0);
;           @showcmd_is_clear = false;
;       }

        ;; clear the rest of an old message by outputting up to SHOWCMD_COLS spaces

;       screen_puts(u8("          ").plus(len), (int)@Rows - 1, @sc_col + len, 0);

;       setcursor();            ;; put cursor back where it belongs
    ))

(atom! window_C scr_old_curwin)
(atom! long scr_old_topline)
(atom! buffer_C scr_old_buf)
(atom! int scr_old_leftcol)

;; When "check" is false, prepare for commands that scroll the window.
;; When "check" is true, take care of scroll-binding after the window has scrolled.
;; Called from normal_cmd() and edit().

(defn- #_void do_check_scrollbind [#_boolean check]
    (§
;       if (check && @curwin.w_onebuf_opt.@wo_scb)
;       {
            ;; If a ":syncbind" command was just used, don't scroll, only reset the values.
;           if (@did_syncbind)
;               @did_syncbind = false;
;           else if (@curwin == @scr_old_curwin)
;           {
                ;; Synchronize other windows, as necessary according to 'scrollbind'.
                ;; Don't do this after an ":edit" command, except when 'diff' is set.

;               if ((@curwin.w_buffer == @scr_old_buf)
;                   && (@curwin.w_topline != @scr_old_topline || @curwin.w_leftcol != @scr_old_leftcol))
;               {
;                   check_scrollbind(@curwin.w_topline - @scr_old_topline,
;                           (long)(@curwin.w_leftcol - @scr_old_leftcol));
;               }
;           }
;           else if (vim_strchr(@p_sbo, 'j') != null) ;; jump flag set in 'scrollopt'
;           {
                ;; When switching between windows, make sure that the relative
                ;; vertical offset is valid for the new window.  The relative
                ;; offset is invalid whenever another 'scrollbind' window has
                ;; scrolled to a point that would force the current window to
                ;; scroll past the beginning or end of its buffer.  When the
                ;; resync is performed, some of the other 'scrollbind' windows may
                ;; need to jump so that the current window's relative position is
                ;; visible on-screen.

;               check_scrollbind(@curwin.w_topline - @curwin.w_scbind_pos, 0L);
;           }
;           @curwin.w_scbind_pos = @curwin.w_topline;
;       }

;       @scr_old_curwin = @curwin;
;       @scr_old_topline = @curwin.w_topline;
;       @scr_old_buf = @curwin.w_buffer;
;       @scr_old_leftcol = @curwin.w_leftcol;
    ))

;; Synchronize any windows that have "scrollbind" set,
;; based on the number of rows by which the current window has changed.

(defn- #_void check_scrollbind [#_long topline_diff, #_long leftcol_diff]
    (§
;       window_C old_curwin = @curwin;
;       buffer_C old_curbuf = @curbuf;
;       boolean old_VIsual_select = @VIsual_select;
;       boolean old_VIsual_active = @VIsual_active;
;       int tgt_leftcol = @curwin.w_leftcol;

        ;; check 'scrollopt' string for vertical and horizontal scroll options

;       boolean want_ver = (vim_strchr(@p_sbo, 'v') != null && topline_diff != 0);
;       boolean want_hor = (vim_strchr(@p_sbo, 'h') != null && (leftcol_diff != 0 || topline_diff != 0));

        ;; loop through the scrollbound windows and scroll accordingly

;       @VIsual_select = @VIsual_active = false;
;       for (@curwin = @firstwin; @curwin != null; @curwin = @curwin.w_next)
;       {
;           @curbuf = @curwin.w_buffer;
            ;; skip original window  and windows with 'noscrollbind'
;           if (@curwin != old_curwin && @curwin.w_onebuf_opt.@wo_scb)
;           {
                ;; do the vertical scroll

;               if (want_ver)
;               {
;                   @curwin.w_scbind_pos += topline_diff;
;                   long topline = @curwin.w_scbind_pos;
;                   if (topline > @curbuf.b_ml.ml_line_count)
;                       topline = @curbuf.b_ml.ml_line_count;
;                   if (topline < 1)
;                       topline = 1;

;                   long y = topline - @curwin.w_topline;
;                   if (0 < y)
;                       scrollup(y);
;                   else
;                       scrolldown(-y);

;                   redraw_later(VALID);
;                   cursor_correct();
;                   @curwin.w_redr_status = true;
;               }

                ;; do the horizontal scroll

;               if (want_hor && @curwin.w_leftcol != tgt_leftcol)
;               {
;                   @curwin.w_leftcol = tgt_leftcol;
;                   leftcol_changed();
;               }
;           }
;       }

        ;; reset current-window

;       @VIsual_select = old_VIsual_select;
;       @VIsual_active = old_VIsual_active;
;       @curwin = old_curwin;
;       @curbuf = old_curbuf;
    ))

;; Command character that's ignored.
;; Used for CTRL-Q and CTRL-S to avoid problems with terminals that use xon/xoff.

(defn- #_void nv_ignore [#_cmdarg_C cap]
    (§
;       cap.retval |= CA_COMMAND_BUSY;      ;; don't call edit() now
    ))

;; Command character that doesn't do anything, but unlike nv_ignore()
;; does start edit().  Used for "startinsert" executed while starting up.

(defn- #_void nv_nop [#_cmdarg_C _cap]
    (§
    ))

;; Command character doesn't exist.

(defn- #_void nv_error [#_cmdarg_C cap]
    (§
;       clearopbeep(cap.oap);
    ))

;; CTRL-A and CTRL-X: Add or subtract from letter or number under cursor.

(defn- #_void nv_addsub [#_cmdarg_C cap]
    (§
;       if (!checkclearopq(cap.oap) && do_addsub(cap.cmdchar, cap.count1) == true)
;           prep_redo_cmd(cap);
    ))

;; CTRL-F, CTRL-B, etc: Scroll page up or down.

(defn- #_void nv_page [#_cmdarg_C cap]
    (§
;       if (!checkclearop(cap.oap))
;       {
;           if ((@mod_mask & MOD_MASK_CTRL) == 0)
;               onepage(cap.arg, cap.count1);
;       }
    ))

;; Implementation of "gd" and "gD" command.

(defn- #_void nv_gd [#_oparg_C oap, #_int nchar, #_boolean thisblock]
    ;; thisblock: true for "1gd" and "1gD"
    (§
;       Bytes[] ptr = new Bytes[1];
;       int len = find_ident_under_cursor(ptr, FIND_IDENT);
;       if (len == 0 || find_decl(ptr[0], len, nchar == 'd', thisblock, 0) == false)
;           clearopbeep(oap);
    ))

;; Search for variable declaration of "ptr[len]".
;; When "locally" is true in the current function ("gd"), otherwise in the current file ("gD").
;; When "thisblock" is true check the {} block scope.
;; Return false when not found.

(defn- #_boolean find_decl [#_Bytes ptr, #_int len, #_boolean locally, #_boolean thisblock, #_int searchflags]
    ;; searchflags: flags passed to searchit()
    (§
;       boolean retval = true;

;       Bytes pat = new Bytes(len + 7);

        ;; Put "\V" before the pattern
        ;; to avoid that the special meaning of "." and "~" causes trouble.
;       libC.sprintf(pat, us_iswordp(ptr, @curbuf) ? u8("\\V\\<%.*s\\>") : u8("\\V%.*s"), len, ptr);
;       pos_C old_pos = §_pos_C();
;       COPY_pos(old_pos, @curwin.w_cursor);
;       boolean save_p_ws = @p_ws;
;       boolean save_p_scs = @p_scs;
;       @p_ws = false;       ;; don't wrap around end of file now
;       @p_scs = false;      ;; don't switch ignorecase off now

;       pos_C par_pos = §_pos_C();

        ;; With "gD" go to line 1.
        ;; With "gd" Search back for the start of the current function,
        ;; then go back until a blank line.  If this fails go to line 1.

;       boolean[] incll = new boolean[1];
;       if (!locally || !findpar(incll, BACKWARD, 1L, '{', false))
;       {
;           setpcmark();                    ;; set in findpar() otherwise
;           @curwin.w_cursor.lnum = 1;
;           COPY_pos(par_pos, @curwin.w_cursor);
;       }
;       else
;       {
;           COPY_pos(par_pos, @curwin.w_cursor);
;           while (1 < @curwin.w_cursor.lnum && skipwhite(ml_get_curline()).at(0) != NUL)
;               --@curwin.w_cursor.lnum;
;       }
;       @curwin.w_cursor.col = 0;

;       boolean found;
        ;; Search forward for the identifier, ignore comment lines.
;       pos_C found_pos = §_pos_C();
;       for ( ; ; )
;       {
;           int i = searchit(@curwin, @curbuf, @curwin.w_cursor, FORWARD, pat, 1L, searchflags, RE_LAST, 0, null);

;           found = (i != 0 && @curwin.w_cursor.lnum < old_pos.lnum);    ;; match after start is failure too

;           if (thisblock && found)
;           {
                ;; Check that the block the match is in doesn't end before
                ;; the position where we started the search from.
;               pos_C pos = findmatchlimit(null, '}', FM_FORWARD, (int)(old_pos.lnum - @curwin.w_cursor.lnum + 1));
;               if (pos != null && pos.lnum < old_pos.lnum)
;                   continue;
;           }

;           if (!found)
;           {
                ;; If we previously found a valid position, use it.
;               if (found_pos.lnum != 0)
;               {
;                   COPY_pos(@curwin.w_cursor, found_pos);
;                   found = true;
;               }
;               break;
;           }
;           if (0 < get_leader_len(ml_get_curline(), null, false, true))
;           {
                ;; Ignore this line, continue at start of next line.
;               @curwin.w_cursor.lnum++;
;               @curwin.w_cursor.col = 0;
;               continue;
;           }
;           if (!locally)   ;; global search: use first match found
;               break;
;           if (par_pos.lnum <= @curwin.w_cursor.lnum)
;           {
                ;; If we previously found a valid position, use it.
;               if (found_pos.lnum != 0)
;                   COPY_pos(@curwin.w_cursor, found_pos);
;               break;
;           }

            ;; For finding a local variable and the match is before the "{" search
            ;; to find a later match.  For K&R style function declarations this
            ;; skips the function header without types.
;           COPY_pos(found_pos, @curwin.w_cursor);
;       }

;       if (!found)
;       {
;           retval = false;
;           COPY_pos(@curwin.w_cursor, old_pos);
;       }
;       else
;       {
;           @curwin.w_set_curswant = true;
            ;; "n" searches forward now
;           reset_search_dir();
;       }

;       @p_ws = save_p_ws;
;       @p_scs = save_p_scs;

;       return retval;
    ))

;; Move 'dist' lines in direction 'dir',
;; counting lines by *screen* lines rather than lines in the file.
;; 'dist' must be positive.
;;
;; Return true if able to move cursor, false otherwise.

(defn- #_boolean nv_screengo [#_oparg_C oap, #_int dir, #_long dist]
    (§
;       boolean retval = true;
;       boolean atend = false;

;       int linelen = linetabsize(ml_get_curline());

;       oap.motion_type = MCHAR;
;       oap.inclusive = (@curwin.w_curswant == MAXCOL);

;       int col_off1 = curwin_col_off();                ;; margin offset for first screen line
;       int col_off2 = col_off1 - curwin_col_off2();    ;; margin offset for wrapped screen line
;       int width1 = @curwin.w_width - col_off1;         ;; text width for first screen line
;       int width2 = @curwin.w_width - col_off2;         ;; test width for wrapped screen line
;       if (width2 == 0)
;           width2 = 1;                                 ;; avoid divide by zero

;       if (@curwin.w_width != 0)
;       {
            ;; Instead of sticking at the last character of the buffer line we
            ;; try to stick in the last column of the screen.

;           if (@curwin.w_curswant == MAXCOL)
;           {
;               atend = true;
;               validate_virtcol();
;               if (width1 <= 0)
;                   @curwin.w_curswant = 0;
;               else
;               {
;                   @curwin.w_curswant = width1 - 1;
;                   if (@curwin.w_curswant < @curwin.w_virtcol)
;                       @curwin.w_curswant += ((@curwin.w_virtcol - @curwin.w_curswant - 1) / width2 + 1) * width2;
;               }
;           }
;           else
;           {
;               int n;
;               if (width1 < linelen)
;                   n = ((linelen - width1 - 1) / width2 + 1) * width2 + width1;
;               else
;                   n = width1;
;               if (@curwin.w_curswant > n + 1)
;                   @curwin.w_curswant -= ((@curwin.w_curswant - n) / width2 + 1) * width2;
;           }

;           while (0 < dist--)
;           {
;               if (dir == BACKWARD)
;               {
;                   if (width2 <= (long)@curwin.w_curswant)
                        ;; move back within line
;                       @curwin.w_curswant -= width2;
;                   else
;                   {
                        ;; to previous line
;                       if (@curwin.w_cursor.lnum == 1)
;                       {
;                           retval = false;
;                           break;
;                       }
;                       --@curwin.w_cursor.lnum;
;                       linelen = linetabsize(ml_get_curline());
;                       if (width1 < linelen)
;                           @curwin.w_curswant += (((linelen - width1 - 1) / width2) + 1) * width2;
;                   }
;               }
;               else ;; dir == FORWARD
;               {
;                   int n;
;                   if (width1 < linelen)
;                       n = ((linelen - width1 - 1) / width2 + 1) * width2 + width1;
;                   else
;                       n = width1;
;                   if (@curwin.w_curswant + width2 < n)
                        ;; move forward within line
;                       @curwin.w_curswant += width2;
;                   else
;                   {
                        ;; to next line
;                       if (@curwin.w_cursor.lnum == @curbuf.b_ml.ml_line_count)
;                       {
;                           retval = false;
;                           break;
;                       }
;                       @curwin.w_cursor.lnum++;
;                       @curwin.w_curswant %= width2;
;                       linelen = linetabsize(ml_get_curline());
;                   }
;               }
;           }
;       }

;       if (virtual_active() && atend)
;           coladvance(MAXCOL);
;       else
;           coladvance(@curwin.w_curswant);

;       if (0 < @curwin.w_cursor.col && @curwin.w_onebuf_opt.@wo_wrap)
;       {
;           int virtcol;

            ;; Check for landing on a character that got split at the end of the
            ;; last line.  We want to advance a screenline, not end up in the same
            ;; screenline or move two screenlines.

;           validate_virtcol();
;           virtcol = @curwin.w_virtcol;
;           if (virtcol > width1 && @p_sbr.at(0) != NUL)
;               virtcol -= mb_string2cells(@p_sbr, -1);

;           if (@curwin.w_curswant < virtcol
;                   && (@curwin.w_curswant < width1
;                       ? (@curwin.w_curswant > width1 / 2)
;                       : ((@curwin.w_curswant - width1) % width2 > width2 / 2)))
;               --@curwin.w_cursor.col;
;       }

;       if (atend)
;           @curwin.w_curswant = MAXCOL;     ;; stick in the last column

;       return retval;
    ))

;; Mouse scroll wheel: Default action is to scroll three lines,
;; or one page when Shift or Ctrl is used.
;; K_MOUSEUP (cap.arg == 1) or K_MOUSEDOWN (cap.arg == 0) or
;; K_MOUSELEFT (cap.arg == -1) or K_MOUSERIGHT (cap.arg == -2)

(defn- #_void nv_mousescroll [#_cmdarg_C cap]
    (§
;       window_C old_curwin = @curwin;

;       if (0 <= @mouse_row && 0 <= @mouse_col)
;       {
;           int[] row = { @mouse_row };
;           int[] col = { @mouse_col };

                ;; find the window at the pointer coordinates
;           @curwin = mouse_find_win(row, col);
;           @curbuf = @curwin.w_buffer;
;       }

;       if (cap.arg == MSCR_UP || cap.arg == MSCR_DOWN)
;       {
;           if ((@mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL)) != 0)
;           {
;               onepage((cap.arg != 0) ? FORWARD : BACKWARD, 1L);
;           }
;           else
;           {
;               cap.count1 = 3;
;               cap.count0 = 3;
;               nv_scroll_line(cap);
;           }
;       }

;       @curwin.w_redr_status = true;

;       @curwin = old_curwin;
;       @curbuf = @curwin.w_buffer;
    ))

;; Mouse clicks and drags.

(defn- #_void nv_mouse [#_cmdarg_C cap]
    (§
;       do_mouse(cap.oap, cap.cmdchar, BACKWARD, (int)cap.count1, 0);
    ))

;; Handle CTRL-E and CTRL-Y commands: scroll a line up or down.
;; cap.arg must be TRUE for CTRL-E.

(defn- #_void nv_scroll_line [#_cmdarg_C cap]
    (§
;       if (!checkclearop(cap.oap))
;           scroll_redraw(cap.arg != 0, cap.count1);
    ))

;; Scroll "count" lines up or down, and redraw.

(defn- #_void scroll_redraw [#_boolean up, #_long count]
    (§
;       long prev_topline = @curwin.w_topline;
;       long prev_lnum = @curwin.w_cursor.lnum;

;       if (up)
;           scrollup(count);
;       else
;           scrolldown(count);
;       if (@p_so != 0)
;       {
            ;; Adjust the cursor position for 'scrolloff'.  Mark w_topline as valid,
            ;; otherwise the screen jumps back at the end of the file.
;           cursor_correct();
;           check_cursor_moved(@curwin);
;           @curwin.w_valid |= VALID_TOPLINE;

            ;; If moved back to where we were, at least move the cursor, otherwise
            ;; we get stuck at one position.  Don't move the cursor up if the
            ;; first line of the buffer is already on the screen.
;           while (@curwin.w_topline == prev_topline)
;           {
;               if (up)
;               {
;                   if (prev_lnum < @curwin.w_cursor.lnum || cursor_down(1L, false) == false)
;                       break;
;               }
;               else
;               {
;                   if (@curwin.w_cursor.lnum < prev_lnum || prev_topline == 1L || cursor_up(1L, false) == false)
;                       break;
;               }
                ;; Mark w_topline as valid, otherwise the screen jumps back at the end of the file.
;               check_cursor_moved(@curwin);
;               @curwin.w_valid |= VALID_TOPLINE;
;           }
;       }
;       if (@curwin.w_cursor.lnum != prev_lnum)
;           coladvance(@curwin.w_curswant);
;       redraw_later(VALID);
    ))

;; Commands that start with "z".

(defn- #_void nv_zet [#_cmdarg_C cap]
    (§
;       int nchar = cap.@nchar;

;       dozet:
;       if (asc_isdigit(nchar))
;       {
                ;; "z123{nchar}": edit the count before obtaining {nchar}

;           if (checkclearop(cap.oap))
;               return;

;           for (long n = nchar - '0'; ; )
;           {
;               @no_mapping++;
;               @allow_keys++;   ;; no mapping for nchar, but allow key codes
;               nchar = plain_vgetc();
;               --@no_mapping;
;               --@allow_keys;

;               add_to_showcmd(nchar);

;               if (nchar == K_DEL || nchar == K_KDEL)
;                   n /= 10;
;               else if (asc_isdigit(nchar))
;                   n = n * 10 + (nchar - '0');
;               else if (nchar == CAR)
;               {
;                   win_setheight((int)n);
;                   break;
;               }
;               else if (nchar == 'l' || nchar == 'h' || nchar == K_LEFT || nchar == K_RIGHT)
;               {
;                   cap.count1 = (n != 0) ? n * cap.count1 : cap.count1;
;                   break dozet;
;               }
;               else
;               {
;                   clearopbeep(cap.oap);
;                   break;
;               }
;           }

;           cap.oap.op_type = OP_NOP;
;           return;
;       }

;       if (checkclearop(cap.oap))
;           return;

            ;; For "z+", "z<CR>", "zt", "z.", "zz", "z^", "z-", "zb":
            ;; If line number given, set cursor.

;       if (vim_strchr(u8("+\r\nt.z^-b"), nchar) != null && cap.count0 != 0 && cap.count0 != @curwin.w_cursor.lnum)
;       {
;           setpcmark();
;           if (@curbuf.b_ml.ml_line_count < cap.count0)
;               @curwin.w_cursor.lnum = @curbuf.b_ml.ml_line_count;
;           else
;               @curwin.w_cursor.lnum = cap.count0;
;           check_cursor_col();
;       }

;       switch (nchar)
;       {
;           case '+':   ;; "z+", "z<CR>" and "zt": put cursor at top of screen
;               if (cap.count0 == 0)
;               {
                        ;; No count given: put cursor at the line below screen.
;                   validate_botline(); ;; make sure w_botline is valid
;                   if (@curbuf.b_ml.ml_line_count < @curwin.w_botline)
;                       @curwin.w_cursor.lnum = @curbuf.b_ml.ml_line_count;
;                   else
;                       @curwin.w_cursor.lnum = @curwin.w_botline;
;               }
                    ;; FALLTHROUGH

;           case NL:
;           case CAR:
;           case K_KENTER:
;               beginline(BL_WHITE | BL_FIX);
                    ;; FALLTHROUGH

;           case 't':
;               scroll_cursor_top(0, true);
;               redraw_later(VALID);
;               break;

;           case '.':   ;; "z." and "zz": put cursor in middle of screen
;               beginline(BL_WHITE | BL_FIX);
                    ;; FALLTHROUGH

;           case 'z':
;               scroll_cursor_halfway(true);
;               redraw_later(VALID);
;               break;

;           case '^':   ;; "z^", "z-" and "zb": put cursor at bottom of screen
                    ;; Strange Vi behavior:
                    ;; <count>z^ finds line at top of window when <count> is at bottom of window,
                    ;; and puts that one at bottom of window.
;               if (cap.count0 != 0)
;               {
;                   scroll_cursor_bot(0, true);
;                   @curwin.w_cursor.lnum = @curwin.w_topline;
;               }
;               else if (@curwin.w_topline == 1)
;                   @curwin.w_cursor.lnum = 1;
;               else
;                   @curwin.w_cursor.lnum = @curwin.w_topline - 1;
                    ;; FALLTHROUGH

;           case '-':
;               beginline(BL_WHITE | BL_FIX);
                    ;; FALLTHROUGH

;           case 'b':
;               scroll_cursor_bot(0, true);
;               redraw_later(VALID);
;               break;

;           case 'H':   ;; "zH" - scroll screen right half-page
;               cap.count1 *= @curwin.w_width / 2;
                    ;; FALLTHROUGH

;           case 'h':   ;; "zh" - scroll screen to the right
;           case K_LEFT:
;               if (!@curwin.w_onebuf_opt.@wo_wrap)
;               {
;                   if (@curwin.w_leftcol < (int)cap.count1)
;                       @curwin.w_leftcol = 0;
;                   else
;                       @curwin.w_leftcol -= (int)cap.count1;
;                   leftcol_changed();
;               }
;               break;

;           case 'L':   ;; "zL" - scroll screen left half-page
;               cap.count1 *= @curwin.w_width / 2;
                    ;; FALLTHROUGH

;           case 'l':   ;; "zl" - scroll screen to the left
;           case K_RIGHT:
;               if (!@curwin.w_onebuf_opt.@wo_wrap)
;               {
                        ;; scroll the window left
;                   @curwin.w_leftcol += (int)cap.count1;
;                   leftcol_changed();
;               }
;               break;

;           case 's':   ;; "zs" - scroll screen, cursor at the start
;               if (!@curwin.w_onebuf_opt.@wo_wrap)
;               {
;                   int[] col = new int[1];
;                   getvcol(@curwin, @curwin.w_cursor, col, null, null);
;                   if (@p_siso < (long)col[0])
;                       col[0] -= @p_siso;
;                   else
;                       col[0] = 0;
;                   if (@curwin.w_leftcol != col[0])
;                   {
;                       @curwin.w_leftcol = col[0];
;                       redraw_later(NOT_VALID);
;                   }
;               }
;               break;

;           case 'e':   ;; "ze" - scroll screen, cursor at the end
;               if (!@curwin.w_onebuf_opt.@wo_wrap)
;               {
;                   int[] col = new int[1];
;                   getvcol(@curwin, @curwin.w_cursor, null, null, col);
;                   long n = @curwin.w_width - curwin_col_off();
;                   if ((long)col[0] + @p_siso < n)
;                       col[0] = 0;
;                   else
;                       col[0] += @p_siso - n + 1;
;                   if (@curwin.w_leftcol != col[0])
;                   {
;                       @curwin.w_leftcol = col[0];
;                       redraw_later(NOT_VALID);
;                   }
;               }
;               break;

;           default:
;               clearopbeep(cap.oap);
;               break;
;       }
    ))

;; "Q" command.

(defn- #_void nv_exmode [#_cmdarg_C cap]
    (§
            ;; Ignore 'Q' in Visual mode, just give a beep.

;       if (@VIsual_active)
;           vim_beep();
;       else if (!checkclearop(cap.oap))
;           do_exmode(false);
    ))

;; Handle a ":" command.

(defn- #_void nv_colon [#_cmdarg_C cap]
    (§
;       if (@VIsual_active)
;           nv_operator(cap);
;       else
;       {
;           if (cap.oap.op_type != OP_NOP)
;           {
                    ;; Using ":" as a movement is characterwise exclusive.
;               cap.oap.motion_type = MCHAR;
;               cap.oap.inclusive = false;
;           }
;           else if (cap.count0 != 0)
;           {
                    ;; translate "count:" into ":.,.+(count - 1)"
;               stuffcharReadbuff('.');
;               if (1 < cap.count0)
;               {
;                   stuffReadbuff(u8(",.+"));
;                   stuffnumReadbuff(cap.count0 - 1);
;               }
;           }

                ;; When typing, don't type below an old message.
;           if (@keyTyped)
;               compute_cmdrow();

;           boolean old_p_im = @p_im;

                ;; get a command line and execute it
;           boolean cmd_result = do_cmdline(null, getexline, null, (cap.oap.op_type != OP_NOP) ? DOCMD_KEEPLINE : 0);

                ;; If 'insertmode' changed, enter or exit Insert mode.
;           if (@p_im != old_p_im)
;           {
;               if (@p_im)
;                   @restart_edit = 'i';
;               else
;                   @restart_edit = 0;
;           }

;           if (cmd_result == false)
                    ;; The Ex command failed, do not execute the operator.
;               clearop(cap.oap);
;           else if (cap.oap.op_type != OP_NOP
;                   && (@curbuf.b_ml.ml_line_count < cap.oap.op_start.lnum
;                       || STRLEN(ml_get(cap.oap.op_start.lnum)) < cap.oap.op_start.col
;                       || @did_emsg))
                    ;; The start of the operator has become invalid by the Ex command.
;               clearopbeep(cap.oap);
;       }
    ))

;; Handle CTRL-G command.

(defn- #_void nv_ctrlg [#_cmdarg_C cap]
    (§
;       if (@VIsual_active)  ;; toggle Selection/Visual mode
;       {
;           @VIsual_select = !@VIsual_select;
;           showmode();
;       }
;       else if (!checkclearop(cap.oap))
                ;; print full name if count given
;           fileinfo((int)cap.count0, true);
    ))

;; Handle CTRL-H <Backspace> command.

(defn- #_void nv_ctrlh [#_cmdarg_C cap]
    (§
;       if (@VIsual_active && @VIsual_select)
;       {
;           cap.cmdchar = 'x';  ;; BS key behaves like 'x' in Select mode
;           v_visop(cap);
;       }
;       else
;           nv_left(cap);
    ))

;; CTRL-L: clear screen and redraw.

(defn- #_void nv_clear [#_cmdarg_C cap]
    (§
;       if (!checkclearop(cap.oap))
;       {
;           redraw_later(CLEAR);
;       }
    ))

;; CTRL-O: In Select mode: switch to Visual mode for one command.
;; Otherwise: Go to older pcmark.

(defn- #_void nv_ctrlo [#_cmdarg_C cap]
    (§
;       if (@VIsual_active && @VIsual_select)
;       {
;           @VIsual_select = false;
;           showmode();
;           @restart_VIsual_select = 2;      ;; restart Select mode later
;       }
;       else
;       {
;           cap.count1 = -cap.count1;
;           nv_pcmark(cap);
;       }
    ))

;; CTRL-^ command, short for ":e #"

(defn- #_void nv_hat [#_cmdarg_C cap]
    (§
;       if (!checkclearopq(cap.oap))
;           buflist_getfile((int)cap.count0, 0, GETF_SETMARK|GETF_ALT, false);
    ))

;; "Z" commands.

(defn- #_void nv_Zet [#_cmdarg_C cap]
    (§
;       if (!checkclearopq(cap.oap))
;       {
;           switch (cap.@nchar)
;           {
                                ;; "ZZ": equivalent to ":x".
;               case 'Z':   do_cmdline_cmd(u8("x"));
;                           break;

                                ;; "ZQ": equivalent to ":q!" (Elvis compatible).
;               case 'Q':   do_cmdline_cmd(u8("q!"));
;                           break;

;               default:    clearopbeep(cap.oap);
;           }
;       }
    ))

;; Call nv_ident() as if "c1" was used, with "c2" as next character.

(defn- #_void do_nv_ident [#_int c1, #_int c2]
    (§
;       oparg_C oa = §_oparg_C();
;       cmdarg_C ca = §_cmdarg_C();

;       ca.oap = oa;
;       ca.cmdchar = c1;
;       ca.@nchar = c2;
;       nv_ident(ca);
    ))

;; Handle the commands that use the word under the cursor.
;; [g] CTRL-]   :ta to current identifier
;; [g] 'K'      run program for current identifier
;; [g] '*'      / to current identifier or string
;; [g] '#'      ? to current identifier or string
;;  g  ']'      :tselect for current identifier

(defn- #_void nv_ident [#_cmdarg_C cap]
    (§
;       int cmdchar = cap.cmdchar;

;       boolean g_cmd = (cmdchar == 'g');
;       if (g_cmd)                          ;; "g*", "g#", "g]" and "gCTRL-]"
;           cmdchar = cap.@nchar;

;       if (cmdchar == char_u(POUND))       ;; the pound sign, '#' for English keyboards
;           cmdchar = '#';

;       Bytes[] ident = { null };
;       int[] n = { 0 };

            ;; The "]", "CTRL-]" and "K" commands accept an argument in Visual mode.

;       if (cmdchar == ']' || cmdchar == Ctrl_RSB || cmdchar == 'K')
;       {
;           if (@VIsual_active && get_visual_text(cap, ident, n) == false)
;               return;
;           if (checkclearopq(cap.oap))
;               return;
;       }

;       if (ident[0] == null)
;       {
;           int type = (cmdchar == '*' || cmdchar == '#') ? FIND_IDENT|FIND_STRING : FIND_IDENT;
;           n[0] = find_ident_under_cursor(ident, type);
;           if (n[0] == 0)
;           {
;               clearop(cap.oap);
;               return;
;           }
;       }

            ;; Allocate buffer to put the command in.
            ;; Inserting backslashes can double the length of the word.
            ;; "p_kp" / "curbuf.b_p_kp" could be added and some numbers.

;       Bytes kp = (@curbuf.@b_p_kp.at(0) == NUL) ? @p_kp : @curbuf.@b_p_kp;    ;; value of 'keywordprg'

;       Bytes buf = new Bytes(n[0] * 2 + 30 + STRLEN(kp));
;       buf.be(0, NUL);

;       boolean tag_cmd = false;

;       switch (cmdchar)
;       {
;           case '*':
;           case '#':
;           {
                    ;; Put cursor at start of word, makes search skip the word under the cursor.
                    ;; Call setpcmark() first, so "*``" puts the cursor back where it was.

;               setpcmark();
;               @curwin.w_cursor.col = BDIFF(ident[0], ml_get_curline());

;               if (!g_cmd && us_iswordp(ident[0], @curbuf))
;                   STRCPY(buf, u8("\\<"));
;               @no_smartcase = true;        ;; don't use 'smartcase' now
;               break;
;           }

;           case 'K':
;           {
                    ;; An external command will probably use an argument starting
                    ;; with "-" as an option.  To avoid trouble we skip the "-".

;               for ( ; 0 < n[0] && ident[0].at(0) == (byte)'-'; --n[0])
;                   ident[0] = ident[0].plus(1);
;               if (n[0] == 0)
;               {
;                   emsg(e_noident);        ;; found dashes only
;                   return;
;               }

                    ;; When a count is given, turn it into a range.  Is this really what we want?
;               if (cap.count0 != 0)
;                   libC.sprintf(buf, u8(".,.+%ld"), cap.count0 - 1);

;               if (kp.at(0) != (byte)':')
;                   STRCAT(buf, u8("!"));
;               STRCAT(buf, (kp.at(0) != (byte)':') ? kp : kp.plus(1));
;               STRCAT(buf, u8(" "));
;               break;
;           }

;           case ']':
;           {
;               tag_cmd = true;
;               STRCPY(buf, u8("ts "));
;               break;
;           }

;           default:
;           {
;               tag_cmd = true;
;               if (g_cmd)
;                   STRCPY(buf, u8("tj "));
;               else
;                   libC.sprintf(buf, u8("%ldta "), cap.count0);
;               break;
;           }
;       }

            ;; Now grab the chars in the identifier

;       Bytes aux;
;       if (cmdchar == '*')
;           aux = @p_magic ? u8("/.*~[^$\\") : u8("/^$\\");
;       else if (cmdchar == '#')
;           aux = @p_magic ? u8("/?.*~[^$\\") : u8("/?^$\\");
;       else if (tag_cmd)
;           aux = u8("\\|\"\n[");
;       else
;           aux = u8("\\|\"\n*?[");

;       Bytes p = buf.plus(STRLEN(buf));
;       while (0 < n[0]--)
;       {
                ;; put a backslash before \ and some others
;           if (vim_strchr(aux, ident[0].at(0)) != null)
;               (p = p.plus(1)).be(-1, (byte)'\\');

                ;; When current byte is part of multibyte character, copy all bytes of the character.
;           for (int i = 0, len = us_ptr2len_cc(ident[0]) - 1; i < len && 1 <= n[0]; ++i, --n[0])
;               (p = p.plus(1)).be(-1, (ident[0] = ident[0].plus(1)).at(-1));

;           (p = p.plus(1)).be(-1, (ident[0] = ident[0].plus(1)).at(-1));
;       }
;       p.be(0, NUL);

            ;; Execute the command.

;       if (cmdchar == '*' || cmdchar == '#')
;       {
;           if (!g_cmd && us_iswordp(us_prevptr(ml_get_curline(), ident[0]), @curbuf))
;               STRCAT(buf, u8("\\>"));
                ;; put pattern in search history
;           init_history();
;           add_to_history(HIST_SEARCH, buf, true, NUL);
;           normal_search(cap, (cmdchar == '*') ? (byte)'/' : (byte)'?', buf, 0);
;       }
;       else
;           do_cmdline_cmd(buf);
    ))

;; Get visually selected text, within one line only.
;; Returns false if more than one line selected.

(defn- #_boolean get_visual_text [#_cmdarg_C cap, #_Bytes* pp, #_int* lenp]
    ;; pp: return: start of selected text
    ;; lenp: return: length of selected text
    (§
;       if (@VIsual_mode != 'V')
;           unadjust_for_sel();
;       if (@VIsual.lnum != @curwin.w_cursor.lnum)
;       {
;           if (cap != null)
;               clearopbeep(cap.oap);
;           return false;
;       }
;       if (@VIsual_mode == 'V')
;       {
;           pp[0] = ml_get_curline();
;           lenp[0] = STRLEN(pp[0]);
;       }
;       else
;       {
;           if (ltpos(@curwin.w_cursor, @VIsual))
;           {
;               pp[0] = ml_get_pos(@curwin.w_cursor);
;               lenp[0] = @VIsual.col - @curwin.w_cursor.col + 1;
;           }
;           else
;           {
;               pp[0] = ml_get_pos(@VIsual);
;               lenp[0] = @curwin.w_cursor.col - @VIsual.col + 1;
;           }

            ;; Correct the length to include the whole last character.
;           lenp[0] += us_ptr2len_cc(pp[0].plus(lenp[0] - 1)) - 1;
;       }
;       reset_VIsual_and_resel();
;       return true;
    ))

;; Handle scrolling command 'H', 'L' and 'M'.

(defn- #_void nv_scroll [#_cmdarg_C cap]
    (§
;       cap.oap.motion_type = MLINE;
;       setpcmark();

;       if (cap.cmdchar == 'L')
;       {
;           validate_botline();         ;; make sure curwin.w_botline is valid
;           @curwin.w_cursor.lnum = @curwin.w_botline - 1;
;           if (@curwin.w_cursor.lnum <= cap.count1 - 1)
;               @curwin.w_cursor.lnum = 1;
;           else
;           {
;               @curwin.w_cursor.lnum -= cap.count1 - 1;
;           }
;       }
;       else
;       {
;           long n;
;           if (cap.cmdchar == 'M')
;           {
;               validate_botline();     ;; make sure w_empty_rows is valid

;               int half = (@curwin.w_height - @curwin.w_empty_rows + 1) / 2;
;               int used = 0;
;               for (n = 0; @curwin.w_topline + n < @curbuf.b_ml.ml_line_count; n++)
;               {
;                   used += plines(@curwin.w_topline + n);
;                   if (half <= used)
;                       break;
;               }
;               if (0 < n && @curwin.w_height < used)
;                   --n;
;           }
;           else ;; (cap.cmdchar == 'H')
;           {
;               n = cap.count1 - 1;
;           }
;           @curwin.w_cursor.lnum = @curwin.w_topline + n;
;           if (@curwin.w_cursor.lnum > @curbuf.b_ml.ml_line_count)
;               @curwin.w_cursor.lnum = @curbuf.b_ml.ml_line_count;
;       }

;       cursor_correct();   ;; correct for 'so'
;       beginline(BL_SOL | BL_FIX);
    ))

;; Cursor right commands.

(defn- #_void nv_right [#_cmdarg_C cap]
    (§
;       if ((@mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL)) != 0)
;       {
                ;; <C-Right> and <S-Right> move a word or WORD right
;           if ((@mod_mask & MOD_MASK_CTRL) != 0)
;               cap.arg = TRUE;
;           nv_wordcmd(cap);
;           return;
;       }

;       cap.oap.motion_type = MCHAR;
;       cap.oap.inclusive = false;
;       boolean past_line = (@VIsual_active && @p_sel.at(0) != (byte)'o');

            ;; In virtual edit mode, there's no such thing as "past_line",
            ;; as lines are (theoretically) infinitely long.

;       if (virtual_active())
;           past_line = false;

;       for (long n = cap.count1; 0 < n; --n)
;       {
;           if ((!past_line && oneright() == false) || (past_line && ml_get_cursor().at(0) == NUL))
;           {
                    ;;    <Space> wraps to next line if 'whichwrap' has 's'.
                    ;;        'l' wraps to next line if 'whichwrap' has 'l'.
                    ;; CURS_RIGHT wraps to next line if 'whichwrap' has '>'.

;               if (((cap.cmdchar == ' ' && vim_strchr(@p_ww, 's') != null)
;                   || (cap.cmdchar == 'l' && vim_strchr(@p_ww, 'l') != null)
;                   || (cap.cmdchar == K_RIGHT && vim_strchr(@p_ww, '>') != null))
;                       && @curwin.w_cursor.lnum < @curbuf.b_ml.ml_line_count)
;               {
                        ;; When deleting we also count the NL as a character.
                        ;; Set cap.oap.inclusive when last char in the line is
                        ;; included, move to next line after that
;                   if (cap.oap.op_type != OP_NOP
;                           && !cap.oap.inclusive
;                           && !lineempty(@curwin.w_cursor.lnum))
;                       cap.oap.inclusive = true;
;                   else
;                   {
;                       @curwin.w_cursor.lnum++;
;                       @curwin.w_cursor.col = 0;
;                       @curwin.w_cursor.coladd = 0;
;                       @curwin.w_set_curswant = true;
;                       cap.oap.inclusive = false;
;                   }
;                   continue;
;               }
;               if (cap.oap.op_type == OP_NOP)
;               {
                        ;; Only beep and flush if not moved at all.
;                   if (n == cap.count1)
;                       beep_flush();
;               }
;               else
;               {
;                   if (!lineempty(@curwin.w_cursor.lnum))
;                       cap.oap.inclusive = true;
;               }
;               break;
;           }
;           else if (past_line)
;           {
;               @curwin.w_set_curswant = true;
;               if (virtual_active())
;                   oneright();
;               else
;                   @curwin.w_cursor.col += us_ptr2len_cc(ml_get_cursor());
;           }
;       }
    ))

;; Cursor left commands.
;;
;; Returns true when operator end should not be adjusted.

(defn- #_void nv_left [#_cmdarg_C cap]
    (§
;       if ((@mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL)) != 0)
;       {
                ;; <C-Left> and <S-Left> move a word or WORD left
;           if ((@mod_mask & MOD_MASK_CTRL) != 0)
;               cap.arg = 1;
;           nv_bck_word(cap);
;           return;
;       }

;       cap.oap.motion_type = MCHAR;
;       cap.oap.inclusive = false;

;       for (long n = cap.count1; 0 < n; --n)
;       {
;           if (oneleft() == false)
;           {
                    ;; <BS> and <Del> wrap to previous line if 'whichwrap' has 'b'.
                    ;;           'h' wraps to previous line if 'whichwrap' has 'h'.
                    ;;     CURS_LEFT wraps to previous line if 'whichwrap' has '<'.

;               if ((((cap.cmdchar == K_BS || cap.cmdchar == Ctrl_H) && vim_strchr(@p_ww, 'b') != null)
;                   || (cap.cmdchar == 'h' && vim_strchr(@p_ww, 'h') != null)
;                   || (cap.cmdchar == K_LEFT && vim_strchr(@p_ww, '<') != null))
;                       && 1 < @curwin.w_cursor.lnum)
;               {
;                   --@curwin.w_cursor.lnum;
;                   coladvance(MAXCOL);
;                   @curwin.w_set_curswant = true;

                        ;; When the NL before the first char has to be deleted we
                        ;; put the cursor on the NUL after the previous line.
                        ;; This is a very special case, be careful!
                        ;; Don't adjust op_end now, otherwise it won't work.
;                   if ((cap.oap.op_type == OP_DELETE || cap.oap.op_type == OP_CHANGE)
;                           && !lineempty(@curwin.w_cursor.lnum))
;                   {
;                       Bytes cp = ml_get_cursor();

;                       if (cp.at(0) != NUL)
;                           @curwin.w_cursor.col += us_ptr2len_cc(cp);
;                       cap.retval |= CA_NO_ADJ_OP_END;
;                   }
;                   continue;
;               }
                    ;; Only beep and flush if not moved at all.
;               else if (cap.oap.op_type == OP_NOP && n == cap.count1)
;                   beep_flush();
;               break;
;           }
;       }
    ))

;; Cursor up commands.
;; cap.arg is TRUE for "-": Move cursor to first non-blank.

(defn- #_void nv_up [#_cmdarg_C cap]
    (§
;       if ((@mod_mask & MOD_MASK_SHIFT) != 0)
;       {
                ;; <S-Up> is page up
;           cap.arg = BACKWARD;
;           nv_page(cap);
;       }
;       else
;       {
;           cap.oap.motion_type = MLINE;
;           if (cursor_up(cap.count1, cap.oap.op_type == OP_NOP) == false)
;               clearopbeep(cap.oap);
;           else if (cap.arg != 0)
;               beginline(BL_WHITE | BL_FIX);
;       }
    ))

;; Cursor down commands.
;; cap.arg is TRUE for CR and "+": Move cursor to first non-blank.

(defn- #_void nv_down [#_cmdarg_C cap]
    (§
;       if ((@mod_mask & MOD_MASK_SHIFT) != 0)
;       {
                ;; <S-Down> is page down
;           cap.arg = FORWARD;
;           nv_page(cap);
;       }
;       else
;       {
                ;; In the cmdline window a <CR> executes the command.
;           if (@cmdwin_type != 0 && cap.cmdchar == CAR)
;               @cmdwin_result = CAR;
;           else
;           {
;               cap.oap.motion_type = MLINE;
;               if (cursor_down(cap.count1, cap.oap.op_type == OP_NOP) == false)
;                   clearopbeep(cap.oap);
;               else if (cap.arg != 0)
;                   beginline(BL_WHITE | BL_FIX);
;           }
;       }
    ))

;; <End> command: to end of current line or last line.

(defn- #_void nv_end [#_cmdarg_C cap]
    (§
;       if (cap.arg != 0 || (@mod_mask & MOD_MASK_CTRL) != 0)    ;; CTRL-END = goto last line
;       {
;           cap.arg = TRUE;
;           nv_goto(cap);
;           cap.count1 = 1;             ;; to end of current line
;       }
;       nv_dollar(cap);
    ))

;; Handle the "$" command.

(defn- #_void nv_dollar [#_cmdarg_C cap]
    (§
;       cap.oap.motion_type = MCHAR;
;       cap.oap.inclusive = true;
            ;; In virtual mode when off the edge of a line and an operator
            ;; is pending (whew!) keep the cursor where it is.
            ;; Otherwise, send it to the end of the line.
;       if (!virtual_active() || gchar_cursor() != NUL || cap.oap.op_type == OP_NOP)
;           @curwin.w_curswant = MAXCOL;     ;; so we stay at the end
;       if (cursor_down(cap.count1 - 1, cap.oap.op_type == OP_NOP) == false)
;           clearopbeep(cap.oap);
    ))

;; Implementation of '?' and '/' commands.
;; If cap.arg is TRUE, don't set PC mark.

(defn- #_void nv_search [#_cmdarg_C cap]
    (§
;       oparg_C oap = cap.oap;

;       if (cap.cmdchar == '?' && cap.oap.op_type == OP_ROT13)
;       {
                ;; Translate "g??" to "g?g?".
;           cap.cmdchar = 'g';
;           cap.@nchar = '?';
;           nv_operator(cap);
;           return;
;       }

;       cap.searchbuf = getcmdline(cap.cmdchar, cap.count1, 0);

;       if (cap.searchbuf == null)
;       {
;           clearop(oap);
;           return;
;       }

;       normal_search(cap, (byte)cap.cmdchar, cap.searchbuf, (cap.arg != 0) ? 0 : SEARCH_MARK);
    ))

;; Handle "N" and "n" commands.
;; cap.arg is SEARCH_REV for "N", 0 for "n".

(defn- #_void nv_next [#_cmdarg_C cap]
    (§
;       pos_C old = §_pos_C();
;       COPY_pos(old, @curwin.w_cursor);
;       int i = normal_search(cap, NUL, null, SEARCH_MARK | cap.arg);

;       if (i == 1 && eqpos(old, @curwin.w_cursor))
;       {
                ;; Avoid getting stuck on the current cursor position, which can
                ;; happen when an offset is given and the cursor is on the last char
                ;; in the buffer: Repeat with count + 1.
;           cap.count1 += 1;
;           normal_search(cap, NUL, null, SEARCH_MARK | cap.arg);
;           cap.count1 -= 1;
;       }
    ))

;; Search for "pat" in direction "dirc" ('/' or '?', 0 for repeat).
;; Uses only cap.count1 and cap.oap from "cap".
;; Return 0 for failure, 1 for found, 2 for found and line offset added.

(defn- #_int normal_search [#_cmdarg_C cap, #_byte dirc, #_Bytes pat, #_int opt]
    ;; opt: extra flags for do_search()
    (§
;       cap.oap.motion_type = MCHAR;
;       cap.oap.inclusive = false;
;       cap.oap.use_reg_one = true;
;       @curwin.w_set_curswant = true;

;       int i = do_search(cap.oap, dirc, pat, cap.count1, opt | SEARCH_OPT | SEARCH_ECHO | SEARCH_MSG, null);
;       if (i == 0)
;           clearop(cap.oap);
;       else
;       {
;           if (i == 2)
;               cap.oap.motion_type = MLINE;
;           @curwin.w_cursor.coladd = 0;
;       }

        ;; "/$" will put the cursor after the end of the line, may need to correct that here
;       check_cursor();
;       return i;
    ))

;; Character search commands.
;; cap.arg is BACKWARD for 'F' and 'T', FORWARD for 'f' and 't', TRUE for ',' and FALSE for ';'.
;; cap.nchar is NUL for ',' and ';' (repeat the search).

(defn- #_void nv_csearch [#_cmdarg_C cap]
    (§
;       boolean t_cmd = (cap.cmdchar == 't' || cap.cmdchar == 'T');

;       cap.oap.motion_type = MCHAR;
;       if (is_special(cap.@nchar) || searchc(cap, t_cmd) == false)
;           clearopbeep(cap.oap);
;       else
;       {
;           @curwin.w_set_curswant = true;
                ;; Include a Tab for "tx" and for "dfx".
;           if (gchar_cursor() == TAB && virtual_active() && cap.arg == FORWARD && (t_cmd || cap.oap.op_type != OP_NOP))
;           {
;               int[] scol = new int[1];
;               int[] ecol = new int[1];

;               getvcol(@curwin, @curwin.w_cursor, scol, null, ecol);
;               @curwin.w_cursor.coladd = ecol[0] - scol[0];
;           }
;           else
;               @curwin.w_cursor.coladd = 0;
;           adjust_for_sel(cap);
;       }
    ))

;; "[" and "]" commands.
;; cap.arg is BACKWARD for "[" and FORWARD for "]".

(defn- #_void nv_brackets [#_cmdarg_C cap]
    (§
;       cap.oap.motion_type = MCHAR;
;       cap.oap.inclusive = false;
;       pos_C old_pos = §_pos_C();
;       COPY_pos(old_pos, @curwin.w_cursor);     ;; cursor position before command
;       @curwin.w_cursor.coladd = 0;             ;; TODO: don't do this for an error

;       pos_C prev_pos = §_pos_C();

            ;; "[{", "[(", "]}" or "])": go to Nth unclosed '{', '(', '}' or ')'
            ;; "[#", "]#": go to start/end of Nth innermost #if..#endif construct.
            ;; "[/", "[*", "]/", "]*": go to Nth comment start/end.
            ;; "[m" or "]m" search for prev/next start of (Java) method.
            ;; "[M" or "]M" search for prev/next end of (Java) method.

;       if ((cap.cmdchar == '[' && vim_strchr(u8("{(*/#mM"), cap.@nchar) != null)
;        || (cap.cmdchar == ']' && vim_strchr(u8("})*/#mM"), cap.@nchar) != null))
;       {
;           if (cap.@nchar == '*')
;               cap.@nchar = '/';

;           int findc;
;           long n;
;           if (cap.@nchar == 'm' || cap.@nchar == 'M')
;           {
;               if (cap.cmdchar == '[')
;                   findc = '{';
;               else
;                   findc = '}';
;               n = 9999;
;           }
;           else
;           {
;               findc = cap.@nchar;
;               n = cap.count1;
;           }

;           pos_C pos = null;
;           prev_pos.lnum = 0;
;           pos_C new_pos = §_pos_C();

;           for ( ; 0 < n; --n)
;           {
;               pos = findmatchlimit(cap.oap, findc, (cap.cmdchar == '[') ? FM_BACKWARD : FM_FORWARD, 0);
;               if (pos == null)
;               {
;                   if (new_pos.lnum == 0) ;; nothing found
;                   {
;                       if (cap.@nchar != 'm' && cap.@nchar != 'M')
;                           clearopbeep(cap.oap);
;                   }
;                   else
;                       pos = new_pos;      ;; use last one found
;                   break;
;               }
;               COPY_pos(prev_pos, new_pos);
;               COPY_pos(@curwin.w_cursor, pos);
;               COPY_pos(new_pos, pos);
;           }
;           COPY_pos(@curwin.w_cursor, old_pos);

                ;; Handle "[m", "]m", "[M" and "[M".  The findmatchlimit() only
                ;; brought us to the match for "[m" and "]M" when inside a method.
                ;; Try finding the '{' or '}' we want to be at.
                ;; Also repeat for the given count.

;           if (cap.@nchar == 'm' || cap.@nchar == 'M')
;           {
                    ;; norm is true for "]M" and "[m"
;               boolean norm = ((findc == '{') == (cap.@nchar == 'm'));

;               n = cap.count1;
                    ;; found a match: we were inside a method
;               if (prev_pos.lnum != 0)
;               {
;                   pos = prev_pos;
;                   COPY_pos(@curwin.w_cursor, prev_pos);
;                   if (norm)
;                       --n;
;               }
;               else
;                   pos = null;
;               for ( ; 0 < n; --n)
;               {
;                   for ( ; ; )
;                   {
;                       if ((findc == '{' ? dec_cursor() : inc_cursor()) < 0)
;                       {
                                ;; if not found anything, that's an error
;                           if (pos == null)
;                               clearopbeep(cap.oap);
;                           n = 0;
;                           break;
;                       }
;                       int c = gchar_cursor();
;                       if (c == '{' || c == '}')
;                       {
                                ;; Must have found end/start of class: use it.
                                ;; Or found the place to be at.
;                           if ((c == findc && norm) || (n == 1 && !norm))
;                           {
;                               COPY_pos(new_pos, @curwin.w_cursor);
;                               pos = new_pos;
;                               n = 0;
;                           }
                                ;; If no match found at all, we started outside of the class
                                ;; and we're inside now.  Just go on.
;                           else if (new_pos.lnum == 0)
;                           {
;                               COPY_pos(new_pos, @curwin.w_cursor);
;                               pos = new_pos;
;                           }
                                ;; found start/end of other method: go to match
;                           else if ((pos = findmatchlimit(cap.oap, findc,
;                               (cap.cmdchar == '[') ? FM_BACKWARD : FM_FORWARD, 0)) == null)
;                               n = 0;
;                           else
;                               COPY_pos(@curwin.w_cursor, pos);
;                           break;
;                       }
;                   }
;               }
;               COPY_pos(@curwin.w_cursor, old_pos);
;               if (pos == null && new_pos.lnum != 0)
;                   clearopbeep(cap.oap);
;           }
;           if (pos != null)
;           {
;               setpcmark();
;               COPY_pos(@curwin.w_cursor, pos);
;               @curwin.w_set_curswant = true;
;           }
;       }

            ;; "[[", "[]", "]]" and "][": move to start or end of function

;       else if (cap.@nchar == '[' || cap.@nchar == ']')
;       {
;           int flag;
;           if (cap.@nchar == cap.cmdchar)   ;; "]]" or "[["
;               flag = '{';
;           else
;               flag = '}';                 ;; "][" or "[]"

;           @curwin.w_set_curswant = true;

                ;; Imitate strange Vi behaviour: When using "]]" with an operator we also stop at '}'.

;           boolean b;
;           { boolean[] __ = { cap.oap.inclusive }; b = findpar(__, cap.arg, cap.count1, flag, (cap.oap.op_type != OP_NOP && cap.arg == FORWARD && flag == '{')); cap.oap.inclusive = __[0]; }
;           if (!b)
;               clearopbeep(cap.oap);
;           else
;           {
;               if (cap.oap.op_type == OP_NOP)
;                   beginline(BL_WHITE | BL_FIX);
;           }
;       }

            ;; "[p", "[P", "]P" and "]p": put with indent adjustment

;       else if (cap.@nchar == 'p' || cap.@nchar == 'P')
;       {
;           if (!checkclearop(cap.oap))
;           {
;               int dir = (cap.cmdchar == ']' && cap.@nchar == 'p') ? FORWARD : BACKWARD;
;               int regname = cap.oap.regname;
;               boolean was_visual = @VIsual_active;
;               long line_count = @curbuf.b_ml.ml_line_count;

;               pos_C start = §_pos_C();
;               pos_C end = §_pos_C();
;               if (@VIsual_active)
;               {
;                   COPY_pos(start, ltoreq(@VIsual, @curwin.w_cursor) ? @VIsual : @curwin.w_cursor);
;                   COPY_pos(end, eqpos(start, @VIsual) ? @curwin.w_cursor : @VIsual);
;                   COPY_pos(@curwin.w_cursor, (dir == BACKWARD) ? start : end);
;               }

;               regname = adjust_clip_reg(regname);
;               prep_redo_cmd(cap);

;               do_put(regname, dir, (int)cap.count1, PUT_FIXINDENT);

;               if (was_visual)
;               {
;                   COPY_pos(@VIsual, start);
;                   COPY_pos(@curwin.w_cursor, end);
;                   if (dir == BACKWARD)
;                   {
                            ;; adjust lines
;                       @VIsual.lnum += @curbuf.b_ml.ml_line_count - line_count;
;                       @curwin.w_cursor.lnum += @curbuf.b_ml.ml_line_count - line_count;
;                   }

;                   @VIsual_active = true;
;                   if (@VIsual_mode == 'V')
;                   {
                            ;; delete visually selected lines
;                       cap.cmdchar = 'd';
;                       cap.@nchar = NUL;
;                       cap.oap.regname = regname;
;                       nv_operator(cap);
;                       do_pending_operator(cap, 0, false);
;                   }
;                   if (@VIsual_active)
;                   {
;                       end_visual_mode();
;                       redraw_later(SOME_VALID);
;                   }
;               }
;           }
;       }

            ;; "['", "[`", "]'" and "]`": jump to next mark

;       else if (cap.@nchar == '\'' || cap.@nchar == '`')
;       {
;           pos_C pos = @curwin.w_cursor;
;           for (long n = cap.count1; 0 < n; --n)
;           {
;               COPY_pos(prev_pos, pos);
;               pos = getnextmark(pos, (cap.cmdchar == '[') ? BACKWARD : FORWARD, cap.@nchar == '\'');
;               if (pos == null)
;                   break;
;           }
;           if (pos == null)
;               pos = prev_pos;
;           nv_cursormark(cap, cap.@nchar == '\'', pos);
;       }

            ;; [ or ] followed by a middle mouse click: put selected text with indent adjustment.
            ;; Any other button just does as usual.

;       else if (K_RIGHTRELEASE <= cap.@nchar && cap.@nchar <= K_LEFTMOUSE)
;       {
;           do_mouse(cap.oap, cap.@nchar, (cap.cmdchar == ']') ? FORWARD : BACKWARD, (int)cap.count1, PUT_FIXINDENT);
;       }

            ;; Not a valid cap.nchar.
;       else
;           clearopbeep(cap.oap);
    ))

;; Handle Normal mode "%" command.

(defn- #_void nv_percent [#_cmdarg_C cap]
    (§
;       cap.oap.inclusive = true;
;       if (cap.count0 != 0)                ;; {cnt}% : goto {cnt} percentage in file
;       {
;           if (100 < cap.count0)
;               clearopbeep(cap.oap);
;           else
;           {
;               cap.oap.motion_type = MLINE;
;               setpcmark();
                    ;; Round up, so CTRL-G will give same value.
                    ;; Watch out for a large line count, the line number must not go negative!
;               if (1000000 < @curbuf.b_ml.ml_line_count)
;                   @curwin.w_cursor.lnum = (@curbuf.b_ml.ml_line_count + 99L) / 100L * cap.count0;
;               else
;                   @curwin.w_cursor.lnum = (@curbuf.b_ml.ml_line_count * cap.count0 + 99L) / 100L;
;               if (@curwin.w_cursor.lnum > @curbuf.b_ml.ml_line_count)
;                   @curwin.w_cursor.lnum = @curbuf.b_ml.ml_line_count;
;               beginline(BL_SOL | BL_FIX);
;           }
;       }
;       else                            ;; "%" : go to matching paren
;       {
;           cap.oap.motion_type = MCHAR;
;           cap.oap.use_reg_one = true;

;           pos_C pos = findmatch(cap.oap, NUL);
;           if (pos == null)
;               clearopbeep(cap.oap);
;           else
;           {
;               setpcmark();
;               COPY_pos(@curwin.w_cursor, pos);
;               @curwin.w_set_curswant = true;
;               @curwin.w_cursor.coladd = 0;
;               adjust_for_sel(cap);
;           }
;       }
    ))

;; Handle "(" and ")" commands.
;; cap.arg is BACKWARD for "(" and FORWARD for ")".

(defn- #_void nv_brace [#_cmdarg_C cap]
    (§
;       cap.oap.motion_type = MCHAR;
;       cap.oap.use_reg_one = true;
            ;; The motion used to be inclusive for "(", but that is not what Vi does.
;       cap.oap.inclusive = false;
;       @curwin.w_set_curswant = true;

;       if (findsent(cap.arg, cap.count1) == false)
;           clearopbeep(cap.oap);
;       else
;       {
                ;; Don't leave the cursor on the NUL past end of line.
;           adjust_cursor(cap.oap);
;           @curwin.w_cursor.coladd = 0;
;       }
    ))

;; "m" command: Mark a position.

(defn- #_void nv_mark [#_cmdarg_C cap]
    (§
;       if (!checkclearop(cap.oap))
;       {
;           if (setmark(cap.@nchar) == false)
;               clearopbeep(cap.oap);
;       }
    ))

;; "{" and "}" commands.
;; cmd.arg is BACKWARD for "{" and FORWARD for "}".

(defn- #_void nv_findpar [#_cmdarg_C cap]
    (§
;       cap.oap.motion_type = MCHAR;
;       cap.oap.inclusive = false;
;       cap.oap.use_reg_one = true;
;       @curwin.w_set_curswant = true;
;       boolean b;
;       { boolean[] __ = { cap.oap.inclusive }; b = findpar(__, cap.arg, cap.count1, NUL, false); cap.oap.inclusive = __[0]; }
;       if (!b)
;           clearopbeep(cap.oap);
;       else
;           @curwin.w_cursor.coladd = 0;
    ))

;; "u" command: Undo or make lower case.

(defn- #_void nv_undo [#_cmdarg_C cap]
    (§
;       if (cap.oap.op_type == OP_LOWER || @VIsual_active)
;       {
                ;; translate "<Visual>u" to "<Visual>gu" and "guu" to "gugu"
;           cap.cmdchar = 'g';
;           cap.@nchar = 'u';
;           nv_operator(cap);
;       }
;       else
;           nv_kundo(cap);
    ))

;; <Undo> command.

(defn- #_void nv_kundo [#_cmdarg_C cap]
    (§
;       if (!checkclearopq(cap.oap))
;       {
;           u_undo((int)cap.count1);
;           @curwin.w_set_curswant = true;
;       }
    ))

;; Handle the "r" command.

(defn- #_void nv_replace [#_cmdarg_C cap]
    (§
;       if (checkclearop(cap.oap))
;           return;

            ;; get another character
;       int had_ctrl_v;
;       if (cap.@nchar == Ctrl_V)
;       {
;           had_ctrl_v = Ctrl_V;
;           cap.@nchar = get_literal();
                ;; Don't redo a multibyte character with CTRL-V.
;           if (DEL < cap.@nchar)
;               had_ctrl_v = NUL;
;       }
;       else
;           had_ctrl_v = NUL;

            ;; Abort if the character is a special key.
;       if (is_special(cap.@nchar))
;       {
;           clearopbeep(cap.oap);
;           return;
;       }

            ;; Visual mode "r".
;       if (@VIsual_active)
;       {
;           if (@got_int)
;               reset_VIsual();
;           if (had_ctrl_v != NUL)
;           {
;               if (cap.@nchar == '\r')
;                   cap.@nchar = -1;
;               else if (cap.@nchar == '\n')
;                   cap.@nchar = -2;
;           }
;           nv_operator(cap);
;           return;
;       }

            ;; Break tabs, etc.
;       if (virtual_active())
;       {
;           if (!u_save_cursor())
;               return;
;           if (gchar_cursor() == NUL)
;           {
                    ;; Add extra space and put the cursor on the first one.
;               coladvance_force((int)(getviscol() + cap.count1));
;               @curwin.w_cursor.col -= cap.count1;
;           }
;           else if (gchar_cursor() == TAB)
;               coladvance_force(getviscol());
;       }

            ;; Abort if not enough characters to replace.
;       Bytes ptr = ml_get_cursor();
;       if (STRLEN(ptr) < cap.count1 || us_charlen(ptr) < cap.count1)
;       {
;           clearopbeep(cap.oap);
;           return;
;       }

            ;; Replacing with a TAB is done by edit() when it is complicated because
            ;; 'expandtab' or 'smarttab' is set.  CTRL-V TAB inserts a literal TAB.
            ;; Other characters are done below to avoid problems with things like
            ;; CTRL-V 048 (for edit() this would be R CTRL-V 0 ESC).

;       if (had_ctrl_v != Ctrl_V && cap.@nchar == '\t' && (@curbuf.@b_p_et || @p_sta))
;       {
;           stuffnumReadbuff(cap.count1);
;           stuffcharReadbuff('R');
;           stuffcharReadbuff('\t');
;           stuffcharReadbuff(ESC);
;           return;
;       }

            ;; save line for undo
;       if (!u_save_cursor())
;           return;

;       if (had_ctrl_v != Ctrl_V && (cap.@nchar == '\r' || cap.@nchar == '\n'))
;       {
                ;; Replace character(s) by a single newline.
                ;; Strange vi behaviour: Only one newline is inserted.
                ;; Delete the characters here.
                ;; Insert the newline with an insert command, takes care of
                ;; autoindent.  The insert command depends on being on the last
                ;; character of a line or not.

;           del_chars((int)cap.count1, false);      ;; delete the characters
;           stuffcharReadbuff('\r');
;           stuffcharReadbuff(ESC);

                ;; Give 'r' to edit(), to get the redo command right.
;           invoke_edit(cap, true, 'r', false);
;       }
;       else
;       {
;           prep_redo(cap.oap.regname, cap.count1, NUL, 'r', NUL, had_ctrl_v, cap.@nchar);

;           COPY_pos(@curbuf.b_op_start, @curwin.w_cursor);

;           {
;               int old_State = @State;

;               if (cap.ncharC1 != 0)
;                   appendCharToRedobuff(cap.ncharC1);
;               if (cap.ncharC2 != 0)
;                   appendCharToRedobuff(cap.ncharC2);

                    ;; This is slow, but it handles replacing a single-byte with a
                    ;; multi-byte and the other way around.  Also handles adding
                    ;; composing characters for utf-8.
;               for (long n = cap.count1; 0 < n; --n)
;               {
;                   @State = REPLACE;
;                   if (cap.@nchar == Ctrl_E || cap.@nchar == Ctrl_Y)
;                   {
;                       int c = ins_copychar(@curwin.w_cursor.lnum + (cap.@nchar == Ctrl_Y ? -1 : 1));
;                       if (c != NUL)
;                           ins_char(c);
;                       else
                                ;; will be decremented further down
;                           @curwin.w_cursor.col++;
;                   }
;                   else
;                       ins_char(cap.@nchar);
;                   @State = old_State;
;                   if (cap.ncharC1 != 0)
;                       ins_char(cap.ncharC1);
;                   if (cap.ncharC2 != 0)
;                       ins_char(cap.ncharC2);
;               }
;           }

;           --@curwin.w_cursor.col;      ;; cursor on the last replaced char

                ;; If the character on the left of the current cursor
                ;; is a multi-byte character, move two characters left.
;           mb_adjust_pos(@curbuf, @curwin.w_cursor);
;           COPY_pos(@curbuf.b_op_end, @curwin.w_cursor);
;           @curwin.w_set_curswant = true;
;           set_last_insert(cap.@nchar);
;       }
    ))

;; 'o': Exchange start and end of Visual area.
;; 'O': same, but in block mode exchange left and right corners.

(defn- #_void v_swap_corners [#_int cmdchar]
    (§
;       if (cmdchar == 'O' && @VIsual_mode == Ctrl_V)
;       {
;           pos_C old_cursor = §_pos_C();
;           COPY_pos(old_cursor, @curwin.w_cursor);
;           int[] left = new int[1];
;           int[] right = new int[1];
;           getvcols(@curwin, old_cursor, @VIsual, left, right);
;           @curwin.w_cursor.lnum = @VIsual.lnum;
;           coladvance(left[0]);
;           COPY_pos(@VIsual, @curwin.w_cursor);

;           @curwin.w_cursor.lnum = old_cursor.lnum;
;           @curwin.w_curswant = right[0];
            ;; 'selection "exclusive" and cursor at right-bottom corner: move it right one column
;           if (@VIsual.lnum <= old_cursor.lnum && @p_sel.at(0) == (byte)'e')
;               @curwin.w_curswant++;
;           coladvance(@curwin.w_curswant);
;           if (@curwin.w_cursor.col == old_cursor.col
;                   && (!virtual_active() || @curwin.w_cursor.coladd == old_cursor.coladd))
;           {
;               @curwin.w_cursor.lnum = @VIsual.lnum;
;               if (old_cursor.lnum <= @VIsual.lnum && @p_sel.at(0) == (byte)'e')
;                   right[0]++;
;               coladvance(right[0]);
;               COPY_pos(@VIsual, @curwin.w_cursor);

;               @curwin.w_cursor.lnum = old_cursor.lnum;
;               coladvance(left[0]);
;               @curwin.w_curswant = left[0];
;           }
;       }
;       else
;       {
;           pos_C old_cursor = §_pos_C();
;           COPY_pos(old_cursor, @curwin.w_cursor);
;           COPY_pos(@curwin.w_cursor, @VIsual);
;           COPY_pos(@VIsual, old_cursor);
;           @curwin.w_set_curswant = true;
;       }
    ))

;; "R" (cap.arg is FALSE) and "gR" (cap.arg is TRUE).

(defn- #_void nv_Replace [#_cmdarg_C cap]
    (§
;       if (@VIsual_active)          ;; "R" is replace lines
;       {
;           cap.cmdchar = 'c';
;           cap.@nchar = NUL;
;           @VIsual_mode_orig = @VIsual_mode; ;; remember original area for gv
;           @VIsual_mode = 'V';
;           nv_operator(cap);
;       }
;       else if (!checkclearopq(cap.oap))
;       {
;           if (!@curbuf.@b_p_ma)
;               emsg(e_modifiable);
;           else
;           {
;               if (virtual_active())
;                   coladvance(getviscol());
;               invoke_edit(cap, false, (cap.arg != 0) ? 'V' : 'R', false);
;           }
;       }
    ))

;; "gr".

(defn- #_void nv_vreplace [#_cmdarg_C cap]
    (§
;       if (@VIsual_active)
;       {
;           cap.cmdchar = 'r';
;           cap.@nchar = cap.@extra_char;
;           nv_replace(cap);        ;; Do same as "r" in Visual mode for now
;       }
;       else if (!checkclearopq(cap.oap))
;       {
;           if (!@curbuf.@b_p_ma)
;               emsg(e_modifiable);
;           else
;           {
;               if (cap.@extra_char == Ctrl_V)       ;; get another character
;                   cap.@extra_char = get_literal();
;               stuffcharReadbuff(cap.@extra_char);
;               stuffcharReadbuff(ESC);
;               if (virtual_active())
;                   coladvance(getviscol());
;               invoke_edit(cap, true, 'v', false);
;           }
;       }
    ))

;; Swap case for "~" command, when it does not work like an operator.

(defn- #_void n_swapchar [#_cmdarg_C cap]
    (§
;       if (checkclearopq(cap.oap))
;           return;

;       if (lineempty(@curwin.w_cursor.lnum) && vim_strchr(@p_ww, '~') == null)
;       {
;           clearopbeep(cap.oap);
;           return;
;       }

;       prep_redo_cmd(cap);

;       if (!u_save_cursor())
;           return;

;       boolean did_change = false;

;       pos_C startpos = §_pos_C();
;       COPY_pos(startpos, @curwin.w_cursor);

;       for (long n = cap.count1; 0 < n; --n)
;       {
;           did_change |= swapchar(cap.oap.op_type, @curwin.w_cursor);
;           inc_cursor();
;           if (gchar_cursor() == NUL)
;           {
;               if (vim_strchr(@p_ww, '~') != null && @curwin.w_cursor.lnum < @curbuf.b_ml.ml_line_count)
;               {
;                   @curwin.w_cursor.lnum++;
;                   @curwin.w_cursor.col = 0;
;                   if (1 < n)
;                   {
;                       if (u_savesub(@curwin.w_cursor.lnum) == false)
;                           break;
;                       u_clearline();
;                   }
;               }
;               else
;                   break;
;           }
;       }

;       check_cursor();
;       @curwin.w_set_curswant = true;

;       if (did_change)
;       {
;           changed_lines(startpos.lnum, startpos.col, @curwin.w_cursor.lnum + 1, 0L);
;           COPY_pos(@curbuf.b_op_start, startpos);
;           COPY_pos(@curbuf.b_op_end, @curwin.w_cursor);
;           if (0 < @curbuf.b_op_end.col)
;               --@curbuf.b_op_end.col;
;       }
    ))

;; Move cursor to mark.

(defn- #_void nv_cursormark [#_cmdarg_C cap, #_boolean flag, #_pos_C pos]
    (§
;       if (check_mark(pos) == false)
;           clearop(cap.oap);
;       else
;       {
;           if (cap.cmdchar == '\'' || cap.cmdchar == '`' || cap.cmdchar == '[' || cap.cmdchar == ']')
;               setpcmark();
;           COPY_pos(@curwin.w_cursor, pos);
;           if (flag)
;               beginline(BL_WHITE | BL_FIX);
;           else
;               check_cursor();
;       }
;       cap.oap.motion_type = flag ? MLINE : MCHAR;
;       if (cap.cmdchar == '`')
;           cap.oap.use_reg_one = true;
;       cap.oap.inclusive = false;              ;; ignored if not MCHAR
;       @curwin.w_set_curswant = true;
    ))

(final Bytes visop_trans (u8 "YyDdCcxdXdAAIIrr"))

;; Handle commands that are operators in Visual mode.

(defn- #_void v_visop [#_cmdarg_C cap]
    (§
        ;; Uppercase means linewise, except in block mode,
        ;; then "D" deletes, and "C" replaces till EOL.
;       if (asc_isupper(cap.cmdchar))
;       {
;           if (@VIsual_mode != Ctrl_V)
;           {
;               @VIsual_mode_orig = @VIsual_mode;
;               @VIsual_mode = 'V';
;           }
;           else if (cap.cmdchar == 'C' || cap.cmdchar == 'D')
;               @curwin.w_curswant = MAXCOL;
;       }
;       cap.cmdchar = vim_strchr(visop_trans, cap.cmdchar).at(1);
;       nv_operator(cap);
    ))

;; "s" and "S" commands.

(defn- #_void nv_subst [#_cmdarg_C cap]
    (§
;       if (@VIsual_active)  ;; "vs" and "vS" are the same as "vc"
;       {
;           if (cap.cmdchar == 'S')
;           {
;               @VIsual_mode_orig = @VIsual_mode;
;               @VIsual_mode = 'V';
;           }
;           cap.cmdchar = 'c';
;           nv_operator(cap);
;       }
;       else
;           nv_optrans(cap);
    ))

;; Abbreviated commands.

(defn- #_void nv_abbrev [#_cmdarg_C cap]
    (§
;       if (cap.cmdchar == K_DEL || cap.cmdchar == K_KDEL)
;           cap.cmdchar = 'x';          ;; DEL key behaves like 'x'

            ;; in Visual mode these commands are operators
;       if (@VIsual_active)
;           v_visop(cap);
;       else
;           nv_optrans(cap);
    ))

(final Bytes* #_"[/*8*/]" optrans_ar
    [
        (u8 "dl"), (u8 "dh"),
        (u8 "d$"), (u8 "c$"),
        (u8 "cl"), (u8 "cc"),
        (u8 "yy"), (u8 ":s\r")
    ])
(final Bytes optrans_str (u8 "xXDCsSY&"))

;; Translate a command into another command.

(defn- #_void nv_optrans [#_cmdarg_C cap]
    (§
;       if (!checkclearopq(cap.oap))
;       {
                ;; In Vi "2D" doesn't delete the next line.
                ;; Can't translate it either, because "2." should also not use the count.
;           if (cap.cmdchar == 'D' && vim_strbyte(@p_cpo, CPO_HASH) != null)
;           {
;               COPY_pos(cap.oap.op_start, @curwin.w_cursor);
;               cap.oap.op_type = OP_DELETE;
;               cap.count1 = 1;
;               nv_dollar(cap);
;               @finish_op = true;
;               resetRedobuff();
;               appendCharToRedobuff('D');
;           }
;           else
;           {
;               if (cap.count0 != 0)
;                   stuffnumReadbuff(cap.count0);
;               stuffReadbuff(optrans_ar[BDIFF(vim_strchr(optrans_str, cap.cmdchar), optrans_str)]);
;           }
;       }
;       cap.opcount = 0;
    ))

;; "'" and "`" commands.  Also for "g'" and "g`".
;; cap.arg is TRUE for "'" and "g'".

(defn- #_void nv_gomark [#_cmdarg_C cap]
    (§
;       int c;
;       if (cap.cmdchar == 'g')
;           c = cap.@extra_char;
;       else
;           c = cap.@nchar;

;       pos_C pos = getmark(c, (cap.oap.op_type == OP_NOP));
;       if (pos == NOPOS)   ;; jumped to other file
;       {
;           if (cap.arg != 0)
;           {
;               check_cursor_lnum();
;               beginline(BL_WHITE | BL_FIX);
;           }
;           else
;               check_cursor();
;       }
;       else
;           nv_cursormark(cap, cap.arg != 0, pos);

            ;; May need to clear the coladd that a mark includes.
;       if (!virtual_active())
;           @curwin.w_cursor.coladd = 0;
    ))

;; Handle CTRL-O, CTRL-I, "g;" and "g," commands.

(defn- #_void nv_pcmark [#_cmdarg_C cap]
    (§
;       pos_C pos;

;       if (!checkclearopq(cap.oap))
;       {
;           if (cap.cmdchar == 'g')
;               pos = movechangelist((int)cap.count1);
;           else
;               pos = movemark((int)cap.count1);
;           if (pos == NOPOS)           ;; jump to other file
;           {
;               @curwin.w_set_curswant = true;
;               check_cursor();
;           }
;           else if (pos != null)               ;; can jump
;               nv_cursormark(cap, false, pos);
;           else if (cap.cmdchar == 'g')
;           {
;               if (@curbuf.b_changelistlen == 0)
;                   emsg(u8("E664: changelist is empty"));
;               else if (cap.count1 < 0)
;                   emsg(u8("E662: At start of changelist"));
;               else
;                   emsg(u8("E663: At end of changelist"));
;           }
;           else
;               clearopbeep(cap.oap);
;       }
    ))

;; Handle '"' command.

(defn- #_void nv_regname [#_cmdarg_C cap]
    (§
;       if (checkclearop(cap.oap))
;           return;
;       if (cap.@nchar == '=')
;           cap.@nchar = get_expr_register();
;       if (cap.@nchar != NUL && valid_yank_reg(cap.@nchar, false))
;       {
;           cap.oap.regname = cap.@nchar;
;           cap.opcount = cap.count0;       ;; remember count before '"'
;       }
;       else
;           clearopbeep(cap.oap);
    ))

;; Handle "v", "V" and "CTRL-V" commands.
;; Also for "gh", "gH" and "g^H" commands: Always start Select mode, cap.arg is TRUE.
;; Handle CTRL-Q just like CTRL-V.

(defn- #_void nv_visual [#_cmdarg_C cap]
    (§
;       if (cap.cmdchar == Ctrl_Q)
;           cap.cmdchar = Ctrl_V;

            ;; 'v', 'V' and CTRL-V can be used while an operator is pending to make it
            ;; characterwise, linewise, or blockwise.
;       if (cap.oap.op_type != OP_NOP)
;       {
;           cap.oap.motion_force = cap.cmdchar;
;           @finish_op = false;      ;; operator doesn't finish now but later
;           return;
;       }

;       @VIsual_select = (cap.arg != 0);
;       if (@VIsual_active)      ;; change Visual mode
;       {
;           if (@VIsual_mode == cap.cmdchar)     ;; stop visual mode
;               end_visual_mode();
;           else                                ;; toggle char/block mode
;           {                                   ;;     or char/line mode
;               @VIsual_mode = cap.cmdchar;
;               showmode();
;           }
;           redraw_curbuf_later(INVERTED);      ;; update the inversion
;       }
;       else                    ;; start Visual mode
;       {
;           check_visual_highlight();
;           if (0 < cap.count0 && @resel_VIsual_mode != NUL)
;           {
                    ;; use previously selected part
;               COPY_pos(@VIsual, @curwin.w_cursor);

;               @VIsual_active = true;
;               @VIsual_reselect = true;
;               if (cap.arg == 0)
                        ;; start Select mode when 'selectmode' contains "cmd"
;                   may_start_select('c');
;               setmouse();
;               if (@p_smd && @msg_silent == 0)
;                   @redraw_cmdline = true;      ;; show visual mode later

                    ;; For V and ^V, we multiply the number of lines even if there was only one.

;               if (@resel_VIsual_mode != 'v' || 1 < @resel_VIsual_line_count)
;               {
;                   @curwin.w_cursor.lnum += @resel_VIsual_line_count * cap.count0 - 1;
;                   if (@curwin.w_cursor.lnum > @curbuf.b_ml.ml_line_count)
;                       @curwin.w_cursor.lnum = @curbuf.b_ml.ml_line_count;
;               }
;               @VIsual_mode = @resel_VIsual_mode;
;               if (@VIsual_mode == 'v')
;               {
;                   if (@resel_VIsual_line_count <= 1)
;                   {
;                       validate_virtcol();
;                       @curwin.w_curswant = @curwin.w_virtcol + @resel_VIsual_vcol * (int)cap.count0 - 1;
;                   }
;                   else
;                       @curwin.w_curswant = @resel_VIsual_vcol;
;                   coladvance(@curwin.w_curswant);
;               }
;               if (@resel_VIsual_vcol == MAXCOL)
;               {
;                   @curwin.w_curswant = MAXCOL;
;                   coladvance(MAXCOL);
;               }
;               else if (@VIsual_mode == Ctrl_V)
;               {
;                   validate_virtcol();
;                   @curwin.w_curswant = @curwin.w_virtcol + @resel_VIsual_vcol * (int)cap.count0 - 1;
;                   coladvance(@curwin.w_curswant);
;               }
;               else
;                   @curwin.w_set_curswant = true;
;               redraw_curbuf_later(INVERTED);      ;; show the inversion
;           }
;           else
;           {
;               if (cap.arg == 0)
                        ;; start Select mode when 'selectmode' contains "cmd"
;                   may_start_select('c');
;               n_start_visual_mode(cap.cmdchar);
;               if (@VIsual_mode != 'V' && @p_sel.at(0) == (byte)'e')
;                   cap.count1++;   ;; include one more char
;               if (0 < cap.count0 && 0 < --cap.count1)
;               {
                        ;; With a count select that many characters or lines.
;                   if (@VIsual_mode == 'v' || @VIsual_mode == Ctrl_V)
;                       nv_right(cap);
;                   else if (@VIsual_mode == 'V')
;                       nv_down(cap);
;               }
;           }
;       }
    ))

;; Start selection for Shift-movement keys.

(defn- #_void start_selection []
    (§
        ;; if 'selectmode' contains "key", start Select mode
;       may_start_select('k');
;       n_start_visual_mode('v');
    ))

;; Start Select mode, if "c" is in 'selectmode' and not in a mapping or menu.

(defn- #_void may_start_select [#_int c]
    (§
;       @VIsual_select = (stuff_empty() && typebuf_typed() && vim_strchr(@p_slm, c) != null);
    ))

;; Start Visual mode "c".
;; Should set VIsual_select before calling this.

(defn- #_void n_start_visual_mode [#_int c]
    (§
        ;; Check for redraw before changing the state.
;       conceal_check_cursor_line();

;       @VIsual_mode = c;
;       @VIsual_active = true;
;       @VIsual_reselect = true;
        ;; Corner case: the 0 position in a tab may change when going into
        ;; virtualedit.  Recalculate curwin.w_cursor to avoid bad hilighting.

;       if (c == Ctrl_V && (@ve_flags & VE_BLOCK) != 0 && gchar_cursor() == TAB)
;       {
;           validate_virtcol();
;           coladvance(@curwin.w_virtcol);
;       }
;       COPY_pos(@VIsual, @curwin.w_cursor);

;       setmouse();
        ;; Check for redraw after changing the state.
;       conceal_check_cursor_line();

;       if (@p_smd && @msg_silent == 0)
;           @redraw_cmdline = true;  ;; show visual mode later
        ;; Make sure the clipboard gets updated.  Needed because start and
        ;; end may still be the same, and the selection needs to be owned.
;       @clip_star.vmode = NUL;

        ;; Only need to redraw this line, unless still need to redraw
        ;; an old Visual area (when 'lazyredraw' is set).
;       if (@curwin.w_redr_type < INVERTED)
;       {
;           @curwin.w_old_cursor_lnum = @curwin.w_cursor.lnum;
;           @curwin.w_old_visual_lnum = @curwin.w_cursor.lnum;
;       }
    ))

;; CTRL-W: Window commands

(defn- #_void nv_window [#_cmdarg_C cap]
    (§
;       if (!checkclearop(cap.oap))
;           do_window(cap.@nchar, cap.count0, NUL);
    ))

;; CTRL-Z: Suspend

(defn- #_void nv_suspend [#_cmdarg_C cap]
    (§
;       clearop(cap.oap);
;       if (@VIsual_active)
;           end_visual_mode();              ;; stop Visual mode
;       do_cmdline_cmd(u8("st"));
    ))

;; Commands starting with "g".

(defn- #_void nv_g_cmd [#_cmdarg_C cap]
    (§
;       oparg_C oap = cap.oap;
;       boolean flag = false;

;       switch (cap.@nchar)
;       {
                ;; "gR": Enter virtual replace mode.

;           case 'R':
;               cap.arg = TRUE;
;               nv_Replace(cap);
;               break;

;           case 'r':
;               nv_vreplace(cap);
;               break;

;           case '&':
;               do_cmdline_cmd(u8("%s//~/&"));
;               break;

                ;; "gv": Reselect the previous Visual area.
                ;;       If Visual already active, exchange previous and current Visual area.

;           case 'v':
;               if (checkclearop(oap))
;                   break;

;               if (@curbuf.b_visual.vi_start.lnum == 0
;                       || @curbuf.b_ml.ml_line_count < @curbuf.b_visual.vi_start.lnum
;                       || @curbuf.b_visual.vi_end.lnum == 0)
;                   beep_flush();
;               else
;               {
                        ;; set w_cursor to the start of the Visual area, tpos to the end
;                   pos_C tpos = §_pos_C();
;                   if (@VIsual_active)
;                   {
;                       int i = @VIsual_mode;
;                       @VIsual_mode = @curbuf.b_visual.vi_mode;
;                       @curbuf.b_visual.vi_mode = i;
;                       @curbuf.b_visual_mode_eval = i;
;                       i = @curwin.w_curswant;
;                       @curwin.w_curswant = @curbuf.b_visual.vi_curswant;
;                       @curbuf.b_visual.vi_curswant = i;

;                       COPY_pos(tpos, @curbuf.b_visual.vi_end);
;                       COPY_pos(@curbuf.b_visual.vi_end, @curwin.w_cursor);
;                       COPY_pos(@curwin.w_cursor, @curbuf.b_visual.vi_start);
;                       COPY_pos(@curbuf.b_visual.vi_start, @VIsual);
;                   }
;                   else
;                   {
;                       @VIsual_mode = @curbuf.b_visual.vi_mode;
;                       @curwin.w_curswant = @curbuf.b_visual.vi_curswant;
;                       COPY_pos(tpos, @curbuf.b_visual.vi_end);
;                       COPY_pos(@curwin.w_cursor, @curbuf.b_visual.vi_start);
;                   }

;                   @VIsual_active = true;
;                   @VIsual_reselect = true;

                        ;; Set Visual to the start and w_cursor to the end of the Visual area.
                        ;; Make sure they are on an existing character.
;                   check_cursor();
;                   COPY_pos(@VIsual, @curwin.w_cursor);
;                   COPY_pos(@curwin.w_cursor, tpos);
;                   check_cursor();
;                   update_topline();

                        ;; When called from normal "g" command: start Select mode when 'selectmode'
                        ;; contains "cmd".  When called for K_SELECT, always start Select mode.

;                   if (cap.arg != 0)
;                       @VIsual_select = true;
;                   else
;                       may_start_select('c');
;                   setmouse();
                        ;; Make sure the clipboard gets updated.  Needed because start and
                        ;; end are still the same, and the selection needs to be owned.
;                   @clip_star.vmode = NUL;
;                   redraw_curbuf_later(INVERTED);
;                   showmode();
;               }
;               break;

                ;; "gV": Don't reselect the previous Visual area after a Select mode mapping of menu.

;           case 'V':
;               @VIsual_reselect = false;
;               break;

                ;; "gh":  start Select mode.
                ;; "gH":  start Select line mode.
                ;; "g^H": start Select block mode.

;           case K_BS:
;               cap.@nchar = Ctrl_H;
                    ;; FALLTHROUGH

;           case 'h':
;           case 'H':
;           case Ctrl_H:
;               cap.cmdchar = cap.@nchar + ('v' - 'h');
;               cap.arg = TRUE;
;               nv_visual(cap);
;               break;

                ;; "gn", "gN" visually select next/previous search match
                ;; "gn" selects next match
                ;; "gN" selects previous match

;           case 'N':
;           case 'n':
;               if (!current_search(cap.count1, cap.@nchar == 'n'))
;                   clearopbeep(oap);
;               break;

                ;; "gj" and "gk" two new funny movement keys -- up and down
                ;; movement based on *screen* line rather than *file* line.

;           case 'j':
;           case K_DOWN:
;           {
;               boolean i;

                    ;; with 'nowrap' it works just like the normal "j" command;
                    ;; also when in a closed fold
;               if (!@curwin.w_onebuf_opt.@wo_wrap)
;               {
;                   oap.motion_type = MLINE;
;                   i = cursor_down(cap.count1, oap.op_type == OP_NOP);
;               }
;               else
;                   i = nv_screengo(oap, FORWARD, cap.count1);
;               if (i == false)
;                   clearopbeep(oap);
;               break;
;           }

;           case 'k':
;           case K_UP:
;           {
;               boolean i;

                    ;; with 'nowrap' it works just like the normal "k" command;
                    ;; also when in a closed fold
;               if (!@curwin.w_onebuf_opt.@wo_wrap)
;               {
;                   oap.motion_type = MLINE;
;                   i = cursor_up(cap.count1, oap.op_type == OP_NOP);
;               }
;               else
;                   i = nv_screengo(oap, BACKWARD, cap.count1);
;               if (i == false)
;                   clearopbeep(oap);
;               break;
;           }

                ;; "gJ": join two lines without inserting a space.

;           case 'J':
;               nv_join(cap);
;               break;

                ;; "g0", "g^" and "g$": Like "0", "^" and "$" but for screen lines.
                ;; "gm": middle of "g0" and "g$".

;           case '^':
;               flag = true;
                    ;; FALLTHROUGH

;           case '0':
;           case 'm':
;           case K_HOME:
;           case K_KHOME:
;           {
;               int i;

;               oap.motion_type = MCHAR;
;               oap.inclusive = false;
;               if (@curwin.w_onebuf_opt.@wo_wrap && @curwin.w_width != 0)
;               {
;                   int width1 = @curwin.w_width - curwin_col_off();
;                   int width2 = width1 + curwin_col_off2();

;                   validate_virtcol();
;                   i = 0;
;                   if (width1 <= @curwin.w_virtcol && 0 < width2)
;                       i = (@curwin.w_virtcol - width1) / width2 * width2 + width1;
;               }
;               else
;                   i = @curwin.w_leftcol;
                    ;; Go to the middle of the screen line.  When 'number' or 'relativenumber' is on
                    ;; and lines are wrapping the middle can be more to the left.
;               if (cap.@nchar == 'm')
;                   i += (@curwin.w_width - curwin_col_off()
;                           + ((@curwin.w_onebuf_opt.@wo_wrap && 0 < i) ? curwin_col_off2() : 0)) / 2;
;               coladvance(i);
;               if (flag)
;               {
;                   do
;                   {
;                       i = gchar_cursor();
;                   } while (vim_iswhite(i) && oneright() == true);
;               }
;               @curwin.w_set_curswant = true;
;               break;
;           }

;           case '_':
                    ;; "g_": to the last non-blank character in the line or <count> lines downward.
;               cap.oap.motion_type = MCHAR;
;               cap.oap.inclusive = true;
;               @curwin.w_curswant = MAXCOL;
;               if (cursor_down(cap.count1 - 1, cap.oap.op_type == OP_NOP) == false)
;                   clearopbeep(cap.oap);
;               else
;               {
;                   Bytes ptr = ml_get_curline();

                        ;; In Visual mode we may end up after the line.
;                   if (0 < @curwin.w_cursor.col && ptr.at(@curwin.w_cursor.col) == NUL)
;                       --@curwin.w_cursor.col;

                        ;; Decrease the cursor column until it's on a non-blank.
;                   while (0 < @curwin.w_cursor.col && vim_iswhite(ptr.at(@curwin.w_cursor.col)))
;                       --@curwin.w_cursor.col;
;                   @curwin.w_set_curswant = true;
;                   adjust_for_sel(cap);
;               }
;               break;

;           case '$':
;           case K_END:
;           case K_KEND:
;           {
;               int col_off = curwin_col_off();

;               oap.motion_type = MCHAR;
;               oap.inclusive = true;
;               if (@curwin.w_onebuf_opt.@wo_wrap && @curwin.w_width != 0)
;               {
;                   @curwin.w_curswant = MAXCOL; ;; so we stay at the end
;                   if (cap.count1 == 1)
;                   {
;                       int width1 = @curwin.w_width - col_off;
;                       int width2 = width1 + curwin_col_off2();

;                       validate_virtcol();
;                       int i = width1 - 1;
;                       if (width1 <= @curwin.w_virtcol)
;                           i += ((@curwin.w_virtcol - width1) / width2 + 1) * width2;
;                       coladvance(i);

                            ;; Make sure we stick in this column.
;                       validate_virtcol();
;                       @curwin.w_curswant = @curwin.w_virtcol;
;                       @curwin.w_set_curswant = false;
;                       if (0 < @curwin.w_cursor.col && @curwin.w_onebuf_opt.@wo_wrap)
;                       {
                                ;; Check for landing on a character that got split at the end of the line.
                                ;; We do not want to advance to the next screen line.

;                           if (i < @curwin.w_virtcol)
;                               --@curwin.w_cursor.col;
;                       }
;                   }
;                   else if (nv_screengo(oap, FORWARD, cap.count1 - 1) == false)
;                       clearopbeep(oap);
;               }
;               else
;               {
;                   int i = @curwin.w_leftcol + @curwin.w_width - col_off - 1;
;                   coladvance(i);

                        ;; Make sure we stick in this column.
;                   validate_virtcol();
;                   @curwin.w_curswant = @curwin.w_virtcol;
;                   @curwin.w_set_curswant = false;
;               }
;               break;
;           }

                ;; "g*" and "g#", like "*" and "#" but without using "\<" and "\>"

;           case '*':
;           case '#':
;           case 163: // case char_u(POUND):        ;; pound sign (sometimes equal to '#')
;           case Ctrl_RSB:                          ;; :tag or :tselect for current identifier
;           case ']':                               ;; :tselect for current identifier
;               nv_ident(cap);
;               break;

                ;; ge and gE: go back to end of word

;           case 'e':
;           case 'E':
;               oap.motion_type = MCHAR;
;               @curwin.w_set_curswant = true;
;               oap.inclusive = true;
;               if (bckend_word(cap.count1, cap.@nchar == 'E', false) == false)
;                   clearopbeep(oap);
;               break;

                ;; "g CTRL-G": display info about cursor position.

;           case Ctrl_G:
;               cursor_pos_info();
;               break;

                ;; "gi": start Insert at the last position.

;           case 'i':
;               if (@curbuf.b_last_insert.lnum != 0)
;               {
;                   COPY_pos(@curwin.w_cursor, @curbuf.b_last_insert);
;                   check_cursor_lnum();
;                   int i = STRLEN(ml_get_curline());
;                   if (i < @curwin.w_cursor.col)
;                   {
;                       if (virtual_active())
;                           @curwin.w_cursor.coladd += @curwin.w_cursor.col - i;
;                       @curwin.w_cursor.col = i;
;                   }
;               }
;               cap.cmdchar = 'i';
;               nv_edit(cap);
;               break;

                ;; "gI": Start insert in column 1.

;           case 'I':
;               beginline(0);
;               if (!checkclearopq(oap))
;                   invoke_edit(cap, false, 'g', false);
;               break;

                ;; "g'm" and "g`m": jump to mark without setting pcmark.

;           case '\'':
;               cap.arg = TRUE;
                    ;; FALLTHROUGH

;           case '`':
;               nv_gomark(cap);
;               break;

                ;; "gs": Goto sleep.

;           case 's':
;               do_sleep(cap.count1 * 1000L);
;               break;

                ;; "ga": Display the ascii value of the character under the cursor.
                ;;       It is displayed in decimal, hex, and octal.

;           case 'a':
;               ex_ascii(null);
;               break;

                ;; "g8": Display the bytes used for the UTF-8 character under the cursor.
                ;;       It is displayed in hex.
                ;; "8g8" finds illegal byte sequence.

;           case '8':
;               if (cap.count0 == 8)
;                   utf_find_illegal();
;               else
;                   show_utf8();
;               break;

;           case '<':
;               show_sb_text();
;               break;

                ;; "gg": Goto the first line in file.
                ;;       With a count it goes to that line number like for "G".

;           case 'g':
;               cap.arg = FALSE;
;               nv_goto(cap);
;               break;

                ;; Two-character operators:
                ;;  "gq"    Format text.
                ;;  "gw"    Format text and keep cursor position.
                ;;  "g~"    Toggle the case of the text.
                ;;  "gu"    Change text to lower case.
                ;;  "gU"    Change text to upper case.
                ;;  "g?"    rot13 encoding
                ;;  "g@"    call 'operatorfunc'

;           case 'q':
;           case 'w':
;               COPY_pos(oap.cursor_start, @curwin.w_cursor);
                    ;; FALLTHROUGH

;           case '~':
;           case 'u':
;           case 'U':
;           case '?':
;           case '@':
;               nv_operator(cap);
;               break;

                ;; "gd": Find first occurrence of pattern under the cursor in the current function;
                ;; "gD": idem, but in the current file.

;           case 'd':
;           case 'D':
;               nv_gd(oap, cap.@nchar, cap.count0 == 1);
;               break;

                ;; g<*Mouse> : <C-*mouse>

;           case K_MIDDLEMOUSE:
;           case K_MIDDLEDRAG:
;           case K_MIDDLERELEASE:
;           case K_LEFTMOUSE:
;           case K_LEFTDRAG:
;           case K_LEFTRELEASE:
;           case K_RIGHTMOUSE:
;           case K_RIGHTDRAG:
;           case K_RIGHTRELEASE:
;           case K_X1MOUSE:
;           case K_X1DRAG:
;           case K_X1RELEASE:
;           case K_X2MOUSE:
;           case K_X2DRAG:
;           case K_X2RELEASE:
;               @mod_mask = MOD_MASK_CTRL;
;               do_mouse(oap, cap.@nchar, BACKWARD, (int)cap.count1, 0);
;               break;

;           case K_IGNORE:
;               break;

                ;; "gP" and "gp": same as "P" and "p" but leave cursor just after new text.

;           case 'p':
;           case 'P':
;               nv_put(cap);
;               break;

                ;; "go": goto byte count from start of buffer
;           case 'o':
;               goto_byte(cap.count0);
;               break;

                ;; "gQ": improved Ex mode
;           case 'Q':
;               if (text_locked())
;               {
;                   clearopbeep(cap.oap);
;                   text_locked_msg();
;                   break;
;               }

;               if (!checkclearopq(oap))
;                   do_exmode(true);
;               break;

;           case ',':
;               nv_pcmark(cap);
;               break;

;           case ';':
;               cap.count1 = -cap.count1;
;               nv_pcmark(cap);
;               break;

                ;; "g+" and "g-": undo or redo along the timeline.

;           case '+':
;           case '-':
;               if (!checkclearopq(oap))
;                   undo_time(cap.@nchar == '-' ? -cap.count1 : cap.count1, false, false, false);
;               break;

;           default:
;               clearopbeep(oap);
;               break;
;       }
    ))

;; Handle "o" and "O" commands.

(defn- #_void n_opencmd [#_cmdarg_C cap]
    (§
;       long oldline = @curwin.w_cursor.lnum;

;       if (!checkclearopq(cap.oap))
;       {
;           if (u_save(@curwin.w_cursor.lnum - (cap.cmdchar == 'O' ? 1 : 0),
;                      @curwin.w_cursor.lnum + (cap.cmdchar == 'o' ? 1 : 0))
;                   && open_line(cap.cmdchar == 'O' ? BACKWARD : FORWARD,
;                       has_format_option(FO_OPEN_COMS) ? OPENLINE_DO_COM : 0, 0))
;           {
;               if (0 < @curwin.w_onebuf_opt.@wo_cole && oldline != @curwin.w_cursor.lnum)
;                   update_single_line(@curwin, oldline);
                ;; When '#' is in 'cpoptions' ignore the count.
;               if (vim_strbyte(@p_cpo, CPO_HASH) != null)
;                   cap.count1 = 1;
;               invoke_edit(cap, false, cap.cmdchar, true);
;           }
;       }
    ))

;; "." command: redo last change.

(defn- #_void nv_dot [#_cmdarg_C cap]
    (§
;       if (!checkclearopq(cap.oap))
;       {
                ;; If "restart_edit" is true, the last but one command is repeated
                ;; instead of the last command (inserting text).  This is used for
                ;; CTRL-O <.> in insert mode.

;           if (!start_redo(cap.count0, @restart_edit != 0 && !@arrow_used))
;               clearopbeep(cap.oap);
;       }
    ))

;; CTRL-R: undo undo

(defn- #_void nv_redo [#_cmdarg_C cap]
    (§
;       if (!checkclearopq(cap.oap))
;       {
;           u_redo((int)cap.count1);
;           @curwin.w_set_curswant = true;
;       }
    ))

;; Handle "U" command.

(defn- #_void nv_Undo [#_cmdarg_C cap]
    (§
            ;; In Visual mode and typing "gUU" triggers an operator.
;       if (cap.oap.op_type == OP_UPPER || @VIsual_active)
;       {
                ;; translate "gUU" to "gUgU"
;           cap.cmdchar = 'g';
;           cap.@nchar = 'U';
;           nv_operator(cap);
;       }
;       else if (!checkclearopq(cap.oap))
;       {
;           u_undoline();
;           @curwin.w_set_curswant = true;
;       }
    ))

;; '~' command: If tilde is not an operator and Visual is off: swap case of a single character.

(defn- #_void nv_tilde [#_cmdarg_C cap]
    (§
;       if (!@p_to && !@VIsual_active && cap.oap.op_type != OP_TILDE)
;           n_swapchar(cap);
;       else
;           nv_operator(cap);
    ))

;; Handle an operator command.
;; The actual work is done by do_pending_operator().

(defn- #_void nv_operator [#_cmdarg_C cap]
    (§
;       int op_type = get_op_type(cap.cmdchar, cap.@nchar);

;       if (op_type == cap.oap.op_type)     ;; double operator works on lines
;           nv_lineop(cap);
;       else if (!checkclearop(cap.oap))
;       {
;           COPY_pos(cap.oap.op_start, @curwin.w_cursor);
;           cap.oap.op_type = op_type;
;       }
    ))

;; Handle linewise operator "dd", "yy", etc.
;;
;; "_" is is a strange motion command that helps make operators more logical.
;; It is actually implemented, but not documented in the real Vi.  This motion
;; command actually refers to "the current line".  Commands like "dd" and "yy"
;; are really an alternate form of "d_" and "y_".  It does accept a count, so
;; "d3_" works to delete 3 lines.

(defn- #_void nv_lineop [#_cmdarg_C cap]
    (§
;       cap.oap.motion_type = MLINE;
;       if (cursor_down(cap.count1 - 1L, cap.oap.op_type == OP_NOP) == false)
;           clearopbeep(cap.oap);
;       else if (  (cap.oap.op_type == OP_DELETE    ;; only with linewise motions
;                   && cap.oap.motion_force != 'v'
;                   && cap.oap.motion_force != Ctrl_V)
;               || cap.oap.op_type == OP_LSHIFT
;               || cap.oap.op_type == OP_RSHIFT)
;           beginline(BL_SOL | BL_FIX);
;       else if (cap.oap.op_type != OP_YANK)        ;; 'Y' does not move cursor
;           beginline(BL_WHITE | BL_FIX);
    ))

;; <Home> command.

(defn- #_void nv_home [#_cmdarg_C cap]
    (§
            ;; CTRL-HOME is like "gg"
;       if ((@mod_mask & MOD_MASK_CTRL) != 0)
;           nv_goto(cap);
;       else
;       {
;           cap.count0 = 1;
;           nv_pipe(cap);
;       }
;       @ins_at_eol = false;     ;; Don't move cursor past eol
                                    ;; (only necessary in a one-character line).
    ))

;; "|" command.

(defn- #_void nv_pipe [#_cmdarg_C cap]
    (§
;       cap.oap.motion_type = MCHAR;
;       cap.oap.inclusive = false;
;       beginline(0);
;       if (0 < cap.count0)
;       {
;           coladvance((int)(cap.count0 - 1));
;           @curwin.w_curswant = (int)(cap.count0 - 1);
;       }
;       else
;           @curwin.w_curswant = 0;
            ;; Keep curswant at the column where we wanted to go,
            ;; not where we ended; differs if line is too short.
;       @curwin.w_set_curswant = false;
    ))

;; Handle back-word command "b" and "B".
;; cap.arg is 1 for "B"

(defn- #_void nv_bck_word [#_cmdarg_C cap]
    (§
;       cap.oap.motion_type = MCHAR;
;       cap.oap.inclusive = false;
;       @curwin.w_set_curswant = true;
;       if (bck_word(cap.count1, cap.arg != 0, false) == false)
;           clearopbeep(cap.oap);
    ))

;; Handle word motion commands "e", "E", "w" and "W".
;; cap.arg is TRUE for "E" and "W".

(defn- #_void nv_wordcmd [#_cmdarg_C cap]
    (§
;       pos_C startpos = §_pos_C();
;       COPY_pos(startpos, @curwin.w_cursor);

            ;; Set inclusive for the "E" and "e" command.

;       boolean word_end = (cap.cmdchar == 'e' || cap.cmdchar == 'E');
;       cap.oap.inclusive = word_end;

;       boolean flag = false;

            ;; "cw" and "cW" are a special case.

;       if (!word_end && cap.oap.op_type == OP_CHANGE)
;       {
;           int n = gchar_cursor();
;           if (n != NUL)                   ;; not an empty line
;           {
;               if (vim_iswhite(n))
;               {
                        ;; Reproduce a funny Vi behaviour: "cw" on a blank only
                        ;; changes one character, not all blanks until the start of
                        ;; the next word.  Only do this when the 'w' flag is included
                        ;; in 'cpoptions'.

;                   if (cap.count1 == 1 && vim_strbyte(@p_cpo, CPO_CW) != null)
;                   {
;                       cap.oap.inclusive = true;
;                       cap.oap.motion_type = MCHAR;
;                       return;
;                   }
;               }
;               else
;               {
                        ;; This is a little strange.  To match what the real Vi does,
                        ;; we effectively map 'cw' to 'ce', and 'cW' to 'cE', provided
                        ;; that we are not on a space or a TAB.  This seems impolite
                        ;; at first, but it's really more what we mean when we say 'cw'.
                        ;; Another strangeness: When standing on the end of a word
                        ;; "ce" will change until the end of the next word, but "cw"
                        ;; will change only one character! This is done by setting flag.

;                   cap.oap.inclusive = true;
;                   word_end = true;
;                   flag = true;
;               }
;           }
;       }

;       cap.oap.motion_type = MCHAR;
;       @curwin.w_set_curswant = true;
;       boolean n;
;       if (word_end)
;           n = end_word(cap.count1, cap.arg != 0, flag, false);
;       else
;           n = fwd_word(cap.count1, cap.arg != 0, cap.oap.op_type != OP_NOP);

            ;; Don't leave the cursor on the NUL past the end of line.
            ;; Unless we didn't move it forward.
;       if (ltpos(startpos, @curwin.w_cursor))
;           adjust_cursor(cap.oap);

;       if (n == false && cap.oap.op_type == OP_NOP)
;           clearopbeep(cap.oap);
;       else
;           adjust_for_sel(cap);
    ))

;; Used after a movement command: if the cursor ends up on the NUL after the end of the line,
;; may move it back to the last character and make the motion inclusive.

(defn- #_void adjust_cursor [#_oparg_C oap]
    (§
        ;; The cursor cannot remain on the NUL when:
        ;; - the column is > 0
        ;; - not in Visual mode or 'selection' is "o"
        ;; - 'virtualedit' is not "all" and not "onemore".

;       if (0 < @curwin.w_cursor.col && gchar_cursor() == NUL
;                   && (!@VIsual_active || @p_sel.at(0) == (byte)'o')
;                   && !virtual_active() && (@ve_flags & VE_ONEMORE) == 0)
;       {
;           --@curwin.w_cursor.col;
            ;; prevent cursor from moving on the trail byte
;           mb_adjust_pos(@curbuf, @curwin.w_cursor);
;           oap.inclusive = true;
;       }
    ))

;; "0" and "^" commands.
;; cap.arg is the argument for beginline().

(defn- #_void nv_beginline [#_cmdarg_C cap]
    (§
;       cap.oap.motion_type = MCHAR;
;       cap.oap.inclusive = false;
;       beginline(cap.arg);
;       @ins_at_eol = false;     ;; Don't move cursor past eol
                                    ;; (only necessary in a one-character line).
    ))

;; In exclusive Visual mode, may include the last character.

(defn- #_void adjust_for_sel [#_cmdarg_C cap]
    (§
;       if (@VIsual_active && cap.oap.inclusive && @p_sel.at(0) == (byte)'e'
;               && gchar_cursor() != NUL && ltpos(@VIsual, @curwin.w_cursor))
;       {
;           inc_cursor();
;           cap.oap.inclusive = false;
;       }
    ))

;; Exclude last character at end of Visual area for 'selection' == "exclusive".
;; Should check VIsual_mode before calling this.
;; Returns true when backed up to the previous line.

(defn- #_boolean unadjust_for_sel []
    (§
;       if (@p_sel.at(0) == (byte)'e' && !eqpos(@VIsual, @curwin.w_cursor))
;       {
;           pos_C pp;
;           if (ltpos(@VIsual, @curwin.w_cursor))
;               pp = @curwin.w_cursor;
;           else
;               pp = @VIsual;
;           if (0 < pp.coladd)
;               --pp.coladd;
;           else if (0 < pp.col)
;           {
;               --pp.col;
;               mb_adjust_pos(@curbuf, pp);
;           }
;           else if (1 < pp.lnum)
;           {
;               --pp.lnum;
;               pp.col = STRLEN(ml_get(pp.lnum));
;               return true;
;           }
;       }
;       return false;
    ))

;; SELECT key in Normal or Visual mode: end of Select mode mapping.

(defn- #_void nv_select [#_cmdarg_C cap]
    (§
;       if (@VIsual_active)
;           @VIsual_select = true;
;       else if (@VIsual_reselect)
;       {
;           cap.@nchar = 'v';        ;; fake "gv" command
;           cap.arg = TRUE;
;           nv_g_cmd(cap);
;       }
    ))

;; "G", "gg", CTRL-END, CTRL-HOME.
;; cap.arg is TRUE for "G".

(defn- #_void nv_goto [#_cmdarg_C cap]
    (§
;       long lnum;
;       if (cap.arg != 0)
;           lnum = @curbuf.b_ml.ml_line_count;
;       else
;           lnum = 1L;

;       cap.oap.motion_type = MLINE;
;       setpcmark();

            ;; When a count is given, use it instead of the default lnum.
;       if (cap.count0 != 0)
;           lnum = cap.count0;
;       if (lnum < 1L)
;           lnum = 1L;
;       else if (@curbuf.b_ml.ml_line_count < lnum)
;           lnum = @curbuf.b_ml.ml_line_count;
;       @curwin.w_cursor.lnum = lnum;
;       beginline(BL_SOL | BL_FIX);
    ))

;; CTRL-\ in Normal mode.

(defn- #_void nv_normal [#_cmdarg_C cap]
    (§
;       if (cap.@nchar == Ctrl_N || cap.@nchar == Ctrl_G)
;       {
;           clearop(cap.oap);
;           if (@restart_edit != 0 && @mode_displayed)
;               @clear_cmdline = true;               ;; unshow mode later
;           @restart_edit = 0;
;           if (@cmdwin_type != 0)
;               @cmdwin_result = Ctrl_C;
;           if (@VIsual_active)
;           {
;               end_visual_mode();          ;; stop Visual
;               redraw_curbuf_later(INVERTED);
;           }
                ;; CTRL-\ CTRL-G restarts Insert mode when 'insertmode' is set.
;           if (cap.@nchar == Ctrl_G && @p_im)
;               @restart_edit = 'a';
;       }
;       else
;           clearopbeep(cap.oap);
    ))

;; ESC in Normal mode: beep, but don't flush buffers.
;; Don't even beep if we are canceling a command.

(defn- #_void nv_esc [#_cmdarg_C cap]
    (§
;       boolean no_reason = (cap.oap.op_type == OP_NOP
;                   && cap.opcount == 0
;                   && cap.count0 == 0
;                   && cap.oap.regname == 0
;                   && !@p_im);

;       if (cap.arg != 0)                   ;; true for CTRL-C
;       {
;           if (@restart_edit == 0 && @cmdwin_type == 0 && !@VIsual_active && no_reason)
;               msg(u8("Type  :quit<Enter>  to exit Vim"));

                ;; Don't reset "restart_edit" when 'insertmode' is set,
                ;; it won't be set again below when halfway a mapping.
;           if (!@p_im)
;               @restart_edit = 0;
;           if (@cmdwin_type != 0)
;           {
;               @cmdwin_result = K_IGNORE;
;               @got_int = false;            ;; don't stop executing autocommands et al.
;               return;
;           }
;       }

;       if (@VIsual_active)
;       {
;           end_visual_mode();              ;; stop Visual
;           check_cursor_col();             ;; make sure cursor is not beyond EOL
;           @curwin.w_set_curswant = true;
;           redraw_curbuf_later(INVERTED);
;       }
;       else if (no_reason)
;           vim_beep();
;       clearop(cap.oap);

            ;; A CTRL-C is often used at the start of a menu.
            ;; When 'insertmode' is set, return to Insert mode afterwards.
;       if (@restart_edit == 0 && goto_im() && @ex_normal_busy == 0)
;           @restart_edit = 'a';
    ))

;; Handle "A", "a", "I", "i" and <Insert> commands.

(defn- #_void nv_edit [#_cmdarg_C cap]
    (§
            ;; <Insert> is equal to "i"
;       if (cap.cmdchar == K_INS || cap.cmdchar == K_KINS)
;           cap.cmdchar = 'i';

            ;; in Visual mode "A" and "I" are an operator
;       if (@VIsual_active && (cap.cmdchar == 'A' || cap.cmdchar == 'I'))
;           v_visop(cap);

            ;; in Visual mode and after an operator "a" and "i" are for text objects
;       else if ((cap.cmdchar == 'a' || cap.cmdchar == 'i')
;               && (cap.oap.op_type != OP_NOP || @VIsual_active))
;       {
;           nv_object(cap);
;       }
;       else if (!@curbuf.@b_p_ma && !@p_im)
;       {
                ;; Only give this error when 'insertmode' is off.
;           emsg(e_modifiable);
;           clearop(cap.oap);
;       }
;       else if (!checkclearopq(cap.oap))
;       {
;           switch (cap.cmdchar)
;           {
;               case 'A':   ;; "A"ppend after the line
;                   @curwin.w_set_curswant = true;
;                   if (@ve_flags == VE_ALL)
;                   {
;                       int save_State = @State;

                            ;; Pretend Insert mode here to allow the cursor
                            ;; on the character past the end of the line.
;                       @State = INSERT;
;                       coladvance(MAXCOL);
;                       @State = save_State;
;                   }
;                   else
;                       @curwin.w_cursor.col += STRLEN(ml_get_cursor());
;                   break;

;               case 'I':   ;; "I"nsert before the first non-blank
;                   if (vim_strbyte(@p_cpo, CPO_INSEND) == null)
;                       beginline(BL_WHITE);
;                   else
;                       beginline(BL_WHITE|BL_FIX);
;                   break;

;               case 'a':   ;; "a"ppend is like "i"nsert on the next character
                        ;; Increment coladd when in virtual space, increment the
                        ;; column otherwise, also to append after an unprintable char.
;                   if (virtual_active()
;                           && (0 < @curwin.w_cursor.coladd
;                               || ml_get_cursor().at(0) == NUL
;                               || ml_get_cursor().at(0) == TAB))
;                       @curwin.w_cursor.coladd++;
;                   else if (ml_get_cursor().at(0) != NUL)
;                       inc_cursor();
;                   break;
;           }

;           if (@curwin.w_cursor.coladd != 0 && cap.cmdchar != 'A')
;           {
;               int save_State = @State;

                    ;; Pretend Insert mode here to allow the cursor
                    ;; on the character past the end of the line.
;               @State = INSERT;
;               coladvance(getviscol());
;               @State = save_State;
;           }

;           invoke_edit(cap, false, cap.cmdchar, false);
;       }
    ))

;; Invoke edit() and take care of "restart_edit" and the return value.

(defn- #_void invoke_edit [#_cmdarg_C cap, #_boolean repl, #_int cmd, #_boolean startln]
    ;; repl: "r" or "gr" command
    (§
;       int restart_edit_save = 0;

        ;; Complicated: when the user types "a<C-O>a", we don't want to do Insert mode recursively.
        ;; But when doing "a<C-O>." or "a<C-O>rx", we do allow it.
;       if (repl || !stuff_empty())
;           restart_edit_save = @restart_edit;
;       else
;           restart_edit_save = 0;

        ;; Always reset "restart_edit", this is not a restarted edit.
;       @restart_edit = 0;

;       if (edit(cmd, startln, cap.count1))
;           cap.retval |= CA_COMMAND_BUSY;

;       if (@restart_edit == 0)
;           @restart_edit = restart_edit_save;
    ))

;; "a" or "i" while an operator is pending or in Visual mode: object motion.

(defn- #_void nv_object [#_cmdarg_C cap]
    (§
;       boolean include;
;       if (cap.cmdchar == 'i')
;           include = false;    ;; "ix" = inner object: exclude white space
;       else
;           include = true;     ;; "ax" = an object: include white space

        ;; Make sure (), [], {} and <> are in 'matchpairs'.
;       Bytes mps_save = @curbuf.@b_p_mps;
;       @curbuf.@b_p_mps = u8("(:),{:},[:],<:>");

;       boolean flag;
;       switch (cap.@nchar)
;       {
;           case 'w': ;; "aw" = a word
;                   flag = current_word(cap.oap, cap.count1, include, false);
;                   break;
;           case 'W': ;; "aW" = a WORD
;                   flag = current_word(cap.oap, cap.count1, include, true);
;                   break;
;           case 'b': ;; "ab" = a braces block
;           case '(':
;           case ')':
;                   flag = current_block(cap.oap, cap.count1, include, '(', ')');
;                   break;
;           case 'B': ;; "aB" = a Brackets block
;           case '{':
;           case '}':
;                   flag = current_block(cap.oap, cap.count1, include, '{', '}');
;                   break;
;           case '[': ;; "a[" = a [] block
;           case ']':
;                   flag = current_block(cap.oap, cap.count1, include, '[', ']');
;                   break;
;           case '<': ;; "a<" = a <> block
;           case '>':
;                   flag = current_block(cap.oap, cap.count1, include, '<', '>');
;                   break;
;           case 'p': ;; "ap" = a paragraph
;                   flag = current_par(cap.oap, cap.count1, include, 'p');
;                   break;
;           case 's': ;; "as" = a sentence
;                   flag = current_sent(cap.oap, cap.count1, include);
;                   break;
;           case '"': ;; "a"" = a double quoted string
;           case '\'': ;; "a'" = a single quoted string
;           case '`': ;; "a`" = a backtick quoted string
;                   flag = current_quote(cap.oap, cap.count1, include, cap.@nchar);
;                   break;
;           default:
;                   flag = false;
;                   break;
;       }

;       @curbuf.@b_p_mps = mps_save;
;       if (flag == false)
;           clearopbeep(cap.oap);
;       adjust_cursor_col();
;       @curwin.w_set_curswant = true;
    ))

;; "q" command: Start/stop recording.
;; "q:", "q/", "q?": edit command-line in command-line window.

(defn- #_void nv_record [#_cmdarg_C cap]
    (§
;       if (cap.oap.op_type == OP_FORMAT)
;       {
                ;; "gqq" is the same as "gqgq": format line
;           cap.cmdchar = 'g';
;           cap.@nchar = 'q';
;           nv_operator(cap);
;       }
;       else if (!checkclearop(cap.oap))
;       {
;           if (cap.@nchar == ':' || cap.@nchar == '/' || cap.@nchar == '?')
;           {
;               stuffcharReadbuff(cap.@nchar);
;               stuffcharReadbuff(K_CMDWIN);
;           }
;           else
                    ;; (stop) recording into a named register, unless executing a register
;               if (!@execReg && do_record(cap.@nchar) == false)
;                   clearopbeep(cap.oap);
;       }
    ))

;; Handle the "@r" command.

(defn- #_void nv_at [#_cmdarg_C cap]
    (§
;       if (checkclearop(cap.oap))
;           return;
;       if (cap.@nchar == '=')
;       {
;           if (get_expr_register() == NUL)
;               return;
;       }
;       while (0 < cap.count1-- && !@got_int)
;       {
;           if (do_execreg(cap.@nchar, false, false, false) == false)
;           {
;               clearopbeep(cap.oap);
;               break;
;           }
;           line_breakcheck();
;       }
    ))

;; Handle the CTRL-U and CTRL-D commands.

(defn- #_void nv_halfpage [#_cmdarg_C cap]
    (§
;       if ((cap.cmdchar == Ctrl_U && @curwin.w_cursor.lnum == 1)
;               || (cap.cmdchar == Ctrl_D && @curwin.w_cursor.lnum == @curbuf.b_ml.ml_line_count))
;           clearopbeep(cap.oap);
;       else if (!checkclearop(cap.oap))
;           halfpage(cap.cmdchar == Ctrl_D, cap.count0);
    ))

;; Handle "J" or "gJ" command.

(defn- #_void nv_join [#_cmdarg_C cap]
    (§
;       if (@VIsual_active)  ;; join the visual lines
;           nv_operator(cap);
;       else if (!checkclearop(cap.oap))
;       {
;           if (cap.count0 <= 1)
;               cap.count0 = 2;         ;; default for join is two lines!
;           if (@curbuf.b_ml.ml_line_count < @curwin.w_cursor.lnum + cap.count0 - 1)
;               clearopbeep(cap.oap);   ;; beyond last line
;           else
;           {
;               prep_redo(cap.oap.regname, cap.count0, NUL, cap.cmdchar, NUL, NUL, cap.@nchar);
;               do_join((int)cap.count0, cap.@nchar == NUL, true, true, true);
;           }
;       }
    ))

;; "P", "gP", "p" and "gp" commands.

(defn- #_void nv_put [#_cmdarg_C cap]
    (§
;       int regname = 0;
;       boolean empty = false;
;       boolean was_visual = false;
;       int flags = 0;

;       if (cap.oap.op_type != OP_NOP)
;       {
;           clearopbeep(cap.oap);
;       }
;       else
;       {
;           int dir = (cap.cmdchar == 'P' || (cap.cmdchar == 'g' && cap.@nchar == 'P')) ? BACKWARD : FORWARD;
;           prep_redo_cmd(cap);
;           if (cap.cmdchar == 'g')
;               flags |= PUT_CURSEND;

;           yankreg_C reg1 = null, reg2 = null;

;           if (@VIsual_active)
;           {
                    ;; Putting in Visual mode: The put text replaces the selected
                    ;; text.  First delete the selected text, then put the new text.
                    ;; Need to save and restore the registers that the delete
                    ;; overwrites if the old contents is being put.

;               was_visual = true;
;               regname = cap.oap.regname;
;               regname = adjust_clip_reg(regname);
;               if (regname == 0 || regname == '"' || asc_isdigit(regname) || regname == '-'
;                       || (@clip_unnamed != 0 && (regname == '*' || regname == '+')))
;               {
                        ;; The delete is going to overwrite the register we want to put, save it first.
;                   reg1 = get_register(regname, true);
;               }

                    ;; Now delete the selected text.
;               cap.cmdchar = 'd';
;               cap.@nchar = NUL;
;               cap.oap.regname = NUL;
;               nv_operator(cap);
;               do_pending_operator(cap, 0, false);
;               empty = ((@curbuf.b_ml.ml_flags & ML_EMPTY) != 0);

                    ;; delete PUT_LINE_BACKWARD;
;               cap.oap.regname = regname;

;               if (reg1 != null)
;               {
                        ;; Delete probably changed the register we want to put, save it first.
                        ;; Then put back what was there before the delete.
;                   reg2 = get_register(regname, false);
;                   put_register(regname, reg1);
;               }

                    ;; When deleted a linewise Visual area,
                    ;; put the register as lines to avoid it joined with the next line.
                    ;; When deletion was characterwise, split a line when putting lines.
;               if (@VIsual_mode == 'V')
;                   flags |= PUT_LINE;
;               else if (@VIsual_mode == 'v')
;                   flags |= PUT_LINE_SPLIT;
;               if (@VIsual_mode == Ctrl_V && dir == FORWARD)
;                   flags |= PUT_LINE_FORWARD;
;               dir = BACKWARD;
;               if ((@VIsual_mode != 'V' && @curwin.w_cursor.col < @curbuf.b_op_start.col)
;               || (@VIsual_mode == 'V' && @curwin.w_cursor.lnum < @curbuf.b_op_start.lnum))
                        ;; cursor is at the end of the line or end of file, put forward.
;                   dir = FORWARD;
                    ;; May have been reset in do_put().
;               @VIsual_active = true;
;           }

;           do_put(cap.oap.regname, dir, (int)cap.count1, flags);

                ;; If a register was saved, put it back now.
;           if (reg2 != null)
;               put_register(regname, reg2);

                ;; What to reselect with "gv"?
                ;; Selecting the just put text seems to be the most useful, since the original was removed.
;           if (was_visual)
;           {
;               COPY_pos(@curbuf.b_visual.vi_start, @curbuf.b_op_start);
;               COPY_pos(@curbuf.b_visual.vi_end, @curbuf.b_op_end);
;           }

                ;; When all lines were selected and deleted do_put() leaves
                ;; an empty line that needs to be deleted now.
;           if (empty && ml_get(@curbuf.b_ml.ml_line_count).at(0) == NUL)
;           {
;               ml_delete(@curbuf.b_ml.ml_line_count, true);

                    ;; If the cursor was in that line, move it to the end of the last line.
;               if (@curwin.w_cursor.lnum > @curbuf.b_ml.ml_line_count)
;               {
;                   @curwin.w_cursor.lnum = @curbuf.b_ml.ml_line_count;
;                   coladvance(MAXCOL);
;               }
;           }
;           auto_format(false, true);
;       }
    ))

;; "o" and "O" commands.

(defn- #_void nv_open [#_cmdarg_C cap]
    (§
;       if (@VIsual_active)  ;; switch start and end of visual
;           v_swap_corners(cap.cmdchar);
;       else
;           n_opencmd(cap);
    ))

(defn- #_void nv_drop [#_cmdarg_C _cap]
    (§
;       do_put('~', BACKWARD, 1, PUT_CURSEND);
    ))

;; Trigger CursorHold event.
;; When waiting for a character for 'updatetime' K_CURSORHOLD is put in the
;; input buffer.  "did_cursorhold" is set to avoid retriggering.

(defn- #_void nv_cursorhold [#_cmdarg_C cap]
    (§
;       @did_cursorhold = true;
;       cap.retval |= CA_COMMAND_BUSY;  ;; don't call edit() now
    ))

;; This table contains one entry for every Normal or Visual mode command.
;; The order doesn't matter, init_normal_cmds() will create a sorted index.
;; It is faster when all keys from zero to '~' are present.

(final nv_cmd_C* nv_cmds
    [
        (->nv_cmd_C NUL,              nv_error,       0,                      0               ),
        (->nv_cmd_C Ctrl_A,           nv_addsub,      0,                      0               ),
        (->nv_cmd_C Ctrl_B,           nv_page,        NV_STS,                 BACKWARD        ),
        (->nv_cmd_C Ctrl_C,           nv_esc,         0,                      TRUE            ),
        (->nv_cmd_C Ctrl_D,           nv_halfpage,    0,                      0               ),
        (->nv_cmd_C Ctrl_E,           nv_scroll_line, 0,                      TRUE            ),
        (->nv_cmd_C Ctrl_F,           nv_page,        NV_STS,                 FORWARD         ),
        (->nv_cmd_C Ctrl_G,           nv_ctrlg,       0,                      0               ),
        (->nv_cmd_C Ctrl_H,           nv_ctrlh,       0,                      0               ),
        (->nv_cmd_C Ctrl_I,           nv_pcmark,      0,                      0               ),
        (->nv_cmd_C NL,               nv_down,        0,                      FALSE           ),
        (->nv_cmd_C Ctrl_K,           nv_error,       0,                      0               ),
        (->nv_cmd_C Ctrl_L,           nv_clear,       0,                      0               ),
        (->nv_cmd_C Ctrl_M,           nv_down,        0,                      TRUE            ),
        (->nv_cmd_C Ctrl_N,           nv_down,        NV_STS,                 FALSE           ),
        (->nv_cmd_C Ctrl_O,           nv_ctrlo,       0,                      0               ),
        (->nv_cmd_C Ctrl_P,           nv_up,          NV_STS,                 FALSE           ),
        (->nv_cmd_C Ctrl_Q,           nv_visual,      0,                      FALSE           ),
        (->nv_cmd_C Ctrl_R,           nv_redo,        0,                      0               ),
        (->nv_cmd_C Ctrl_S,           nv_ignore,      0,                      0               ),
        (->nv_cmd_C Ctrl_T,           nv_error,       0,                      0               ),
        (->nv_cmd_C Ctrl_U,           nv_halfpage,    0,                      0               ),
        (->nv_cmd_C Ctrl_V,           nv_visual,      0,                      FALSE           ),
        (->nv_cmd_C (int \V),         nv_visual,      0,                      FALSE           ),
        (->nv_cmd_C (int \v),         nv_visual,      0,                      FALSE           ),
        (->nv_cmd_C Ctrl_W,           nv_window,      0,                      0               ),
        (->nv_cmd_C Ctrl_X,           nv_addsub,      0,                      0               ),
        (->nv_cmd_C Ctrl_Y,           nv_scroll_line, 0,                      FALSE           ),
        (->nv_cmd_C Ctrl_Z,           nv_suspend,     0,                      0               ),
        (->nv_cmd_C ESC,              nv_esc,         0,                      FALSE           ),
        (->nv_cmd_C Ctrl_BSL,         nv_normal,      NV_NCH_ALW,             0               ),
        (->nv_cmd_C Ctrl_RSB,         nv_ident,       NV_NCW,                 0               ),
        (->nv_cmd_C Ctrl_HAT,         nv_hat,         NV_NCW,                 0               ),
        (->nv_cmd_C Ctrl__,           nv_error,       0,                      0               ),
        (->nv_cmd_C (int \space),     nv_right,       0,                      0               ),
        (->nv_cmd_C (int \!),         nv_operator,    0,                      0               ),
        (->nv_cmd_C (int \"),         nv_regname,  (| NV_NCH_NOP NV_KEEPREG), 0               ),
        (->nv_cmd_C (int \#),         nv_ident,       0,                      0               ),
        (->nv_cmd_C (int \$),         nv_dollar,      0,                      0               ),
        (->nv_cmd_C (int \%),         nv_percent,     0,                      0               ),
        (->nv_cmd_C (int \&),         nv_optrans,     0,                      0               ),
        (->nv_cmd_C (int \'),         nv_gomark,      NV_NCH_ALW,             TRUE            ),
        (->nv_cmd_C (int \(),         nv_brace,       0,                      BACKWARD        ),
        (->nv_cmd_C (int \)),         nv_brace,       0,                      FORWARD         ),
        (->nv_cmd_C (int \*),         nv_ident,       0,                      0               ),
        (->nv_cmd_C (int \+),         nv_down,        0,                      TRUE            ),
        (->nv_cmd_C (int \,),         nv_csearch,     0,                      TRUE            ),
        (->nv_cmd_C (int \-),         nv_up,          0,                      TRUE            ),
        (->nv_cmd_C (int \.),         nv_dot,         NV_KEEPREG,             0               ),
        (->nv_cmd_C (int \/),         nv_search,      0,                      FALSE           ),
        (->nv_cmd_C (int \0),         nv_beginline,   0,                      0               ),
        (->nv_cmd_C (int \1),         nv_ignore,      0,                      0               ),
        (->nv_cmd_C (int \2),         nv_ignore,      0,                      0               ),
        (->nv_cmd_C (int \3),         nv_ignore,      0,                      0               ),
        (->nv_cmd_C (int \4),         nv_ignore,      0,                      0               ),
        (->nv_cmd_C (int \5),         nv_ignore,      0,                      0               ),
        (->nv_cmd_C (int \6),         nv_ignore,      0,                      0               ),
        (->nv_cmd_C (int \7),         nv_ignore,      0,                      0               ),
        (->nv_cmd_C (int \8),         nv_ignore,      0,                      0               ),
        (->nv_cmd_C (int \9),         nv_ignore,      0,                      0               ),
        (->nv_cmd_C (int \:),         nv_colon,       0,                      0               ),
        (->nv_cmd_C (int \;),         nv_csearch,     0,                      FALSE           ),
        (->nv_cmd_C (int \<),         nv_operator,    NV_RL,                  0               ),
        (->nv_cmd_C (int \=),         nv_operator,    0,                      0               ),
        (->nv_cmd_C (int \>),         nv_operator,    NV_RL,                  0               ),
        (->nv_cmd_C (int \?),         nv_search,      0,                      FALSE           ),
        (->nv_cmd_C (int \@),         nv_at,          NV_NCH_NOP,             FALSE           ),
        (->nv_cmd_C (int \A),         nv_edit,        0,                      0               ),
        (->nv_cmd_C (int \B),         nv_bck_word,    0,                      1               ),
        (->nv_cmd_C (int \C),         nv_abbrev,      NV_KEEPREG,             0               ),
        (->nv_cmd_C (int \D),         nv_abbrev,      NV_KEEPREG,             0               ),
        (->nv_cmd_C (int \E),         nv_wordcmd,     0,                      TRUE            ),
        (->nv_cmd_C (int \F),         nv_csearch,  (| NV_NCH_ALW NV_LANG),    BACKWARD        ),
        (->nv_cmd_C (int \G),         nv_goto,        0,                      TRUE            ),
        (->nv_cmd_C (int \H),         nv_scroll,      0,                      0               ),
        (->nv_cmd_C (int \I),         nv_edit,        0,                      0               ),
        (->nv_cmd_C (int \J),         nv_join,        0,                      0               ),
        (->nv_cmd_C (int \K),         nv_ident,       0,                      0               ),
        (->nv_cmd_C (int \L),         nv_scroll,      0,                      0               ),
        (->nv_cmd_C (int \M),         nv_scroll,      0,                      0               ),
        (->nv_cmd_C (int \N),         nv_next,        0,                      SEARCH_REV      ),
        (->nv_cmd_C (int \O),         nv_open,        0,                      0               ),
        (->nv_cmd_C (int \P),         nv_put,         0,                      0               ),
        (->nv_cmd_C (int \Q),         nv_exmode,      NV_NCW,                 0               ),
        (->nv_cmd_C (int \R),         nv_Replace,     0,                      FALSE           ),
        (->nv_cmd_C (int \S),         nv_subst,       NV_KEEPREG,             0               ),
        (->nv_cmd_C (int \T),         nv_csearch,  (| NV_NCH_ALW NV_LANG),    BACKWARD        ),
        (->nv_cmd_C (int \U),         nv_Undo,        0,                      0               ),
        (->nv_cmd_C (int \W),         nv_wordcmd,     0,                      TRUE            ),
        (->nv_cmd_C (int \X),         nv_abbrev,      NV_KEEPREG,             0               ),
        (->nv_cmd_C (int \Y),         nv_abbrev,      NV_KEEPREG,             0               ),
        (->nv_cmd_C (int \Z),         nv_Zet,      (| NV_NCH_NOP NV_NCW),     0               ),
        (->nv_cmd_C (int \[),         nv_brackets,    NV_NCH_ALW,             BACKWARD        ),
        (->nv_cmd_C (int \\),         nv_error,       0,                      0               ),
        (->nv_cmd_C (int \]),         nv_brackets,    NV_NCH_ALW,             FORWARD         ),
        (->nv_cmd_C (int \^),         nv_beginline,   0,                   (| BL_WHITE BL_FIX)),
        (->nv_cmd_C (int \_),         nv_lineop,      0,                      0               ),
        (->nv_cmd_C (int \`),         nv_gomark,      NV_NCH_ALW,             FALSE           ),
        (->nv_cmd_C (int \a),         nv_edit,        NV_NCH,                 0               ),
        (->nv_cmd_C (int \b),         nv_bck_word,    0,                      0               ),
        (->nv_cmd_C (int \c),         nv_operator,    0,                      0               ),
        (->nv_cmd_C (int \d),         nv_operator,    0,                      0               ),
        (->nv_cmd_C (int \e),         nv_wordcmd,     0,                      FALSE           ),
        (->nv_cmd_C (int \f),         nv_csearch,  (| NV_NCH_ALW NV_LANG),    FORWARD         ),
        (->nv_cmd_C (int \g),         nv_g_cmd,       NV_NCH_ALW,             FALSE           ),
        (->nv_cmd_C (int \h),         nv_left,        NV_RL,                  0               ),
        (->nv_cmd_C (int \i),         nv_edit,        NV_NCH,                 0               ),
        (->nv_cmd_C (int \j),         nv_down,        0,                      FALSE           ),
        (->nv_cmd_C (int \k),         nv_up,          0,                      FALSE           ),
        (->nv_cmd_C (int \l),         nv_right,       NV_RL,                  0               ),
        (->nv_cmd_C (int \m),         nv_mark,        NV_NCH_NOP,             0               ),
        (->nv_cmd_C (int \n),         nv_next,        0,                      0               ),
        (->nv_cmd_C (int \o),         nv_open,        0,                      0               ),
        (->nv_cmd_C (int \p),         nv_put,         0,                      0               ),
        (->nv_cmd_C (int \q),         nv_record,      NV_NCH,                 0               ),
        (->nv_cmd_C (int \r),         nv_replace,  (| NV_NCH_NOP NV_LANG),    0               ),
        (->nv_cmd_C (int \s),         nv_subst,       NV_KEEPREG,             0               ),
        (->nv_cmd_C (int \t),         nv_csearch,  (| NV_NCH_ALW NV_LANG),    FORWARD         ),
        (->nv_cmd_C (int \u),         nv_undo,        0,                      0               ),
        (->nv_cmd_C (int \w),         nv_wordcmd,     0,                      FALSE           ),
        (->nv_cmd_C (int \x),         nv_abbrev,      NV_KEEPREG,             0               ),
        (->nv_cmd_C (int \y),         nv_operator,    0,                      0               ),
        (->nv_cmd_C (int \z),         nv_zet,         NV_NCH_ALW,             0               ),
        (->nv_cmd_C (int \{),         nv_findpar,     0,                      BACKWARD        ),
        (->nv_cmd_C (int \|),         nv_pipe,        0,                      0               ),
        (->nv_cmd_C (int \}),         nv_findpar,     0,                      FORWARD         ),
        (->nv_cmd_C (int \~),         nv_tilde,       0,                      0               ),

        ;; pound sign
;       new nv_cmd_C(char_u(POUND),    nv_ident,       0,                     0               ),
        (->nv_cmd_C K_MOUSEUP,        nv_mousescroll, 0,                      MSCR_UP         ),
        (->nv_cmd_C K_MOUSEDOWN,      nv_mousescroll, 0,                      MSCR_DOWN       ),
        (->nv_cmd_C K_MOUSELEFT,      nv_mousescroll, 0,                      MSCR_LEFT       ),
        (->nv_cmd_C K_MOUSERIGHT,     nv_mousescroll, 0,                      MSCR_RIGHT      ),
        (->nv_cmd_C K_LEFTMOUSE,      nv_mouse,       0,                      0               ),
        (->nv_cmd_C K_LEFTMOUSE_NM,   nv_mouse,       0,                      0               ),
        (->nv_cmd_C K_LEFTDRAG,       nv_mouse,       0,                      0               ),
        (->nv_cmd_C K_LEFTRELEASE,    nv_mouse,       0,                      0               ),
        (->nv_cmd_C K_LEFTRELEASE_NM, nv_mouse,       0,                      0               ),
        (->nv_cmd_C K_MIDDLEMOUSE,    nv_mouse,       0,                      0               ),
        (->nv_cmd_C K_MIDDLEDRAG,     nv_mouse,       0,                      0               ),
        (->nv_cmd_C K_MIDDLERELEASE,  nv_mouse,       0,                      0               ),
        (->nv_cmd_C K_RIGHTMOUSE,     nv_mouse,       0,                      0               ),
        (->nv_cmd_C K_RIGHTDRAG,      nv_mouse,       0,                      0               ),
        (->nv_cmd_C K_RIGHTRELEASE,   nv_mouse,       0,                      0               ),
        (->nv_cmd_C K_X1MOUSE,        nv_mouse,       0,                      0               ),
        (->nv_cmd_C K_X1DRAG,         nv_mouse,       0,                      0               ),
        (->nv_cmd_C K_X1RELEASE,      nv_mouse,       0,                      0               ),
        (->nv_cmd_C K_X2MOUSE,        nv_mouse,       0,                      0               ),
        (->nv_cmd_C K_X2DRAG,         nv_mouse,       0,                      0               ),
        (->nv_cmd_C K_X2RELEASE,      nv_mouse,       0,                      0               ),
        (->nv_cmd_C K_IGNORE,         nv_ignore,      NV_KEEPREG,             0               ),
        (->nv_cmd_C K_NOP,            nv_nop,         0,                      0               ),
        (->nv_cmd_C K_INS,            nv_edit,        0,                      0               ),
        (->nv_cmd_C K_KINS,           nv_edit,        0,                      0               ),
        (->nv_cmd_C K_BS,             nv_ctrlh,       0,                      0               ),
        (->nv_cmd_C K_UP,             nv_up,       (| NV_SSS NV_STS),         FALSE           ),
        (->nv_cmd_C K_S_UP,           nv_page,        NV_SS,                  BACKWARD        ),
        (->nv_cmd_C K_DOWN,           nv_down,     (| NV_SSS NV_STS),         FALSE           ),
        (->nv_cmd_C K_S_DOWN,         nv_page,        NV_SS,                  FORWARD         ),
        (->nv_cmd_C K_LEFT,           nv_left,     (| NV_SSS NV_STS NV_RL),   0               ),
        (->nv_cmd_C K_S_LEFT,         nv_bck_word, (| NV_SS NV_RL),           0               ),
        (->nv_cmd_C K_C_LEFT,         nv_bck_word, (| NV_SSS NV_RL NV_STS),   1               ),
        (->nv_cmd_C K_RIGHT,          nv_right,    (| NV_SSS NV_STS NV_RL),   0               ),
        (->nv_cmd_C K_S_RIGHT,        nv_wordcmd,  (| NV_SS NV_RL),           FALSE           ),
        (->nv_cmd_C K_C_RIGHT,        nv_wordcmd,  (| NV_SSS NV_RL NV_STS),   TRUE            ),
        (->nv_cmd_C K_PAGEUP,         nv_page,     (| NV_SSS NV_STS),         BACKWARD        ),
        (->nv_cmd_C K_KPAGEUP,        nv_page,     (| NV_SSS NV_STS),         BACKWARD        ),
        (->nv_cmd_C K_PAGEDOWN,       nv_page,     (| NV_SSS NV_STS),         FORWARD         ),
        (->nv_cmd_C K_KPAGEDOWN,      nv_page,     (| NV_SSS NV_STS),         FORWARD         ),
        (->nv_cmd_C K_END,            nv_end,      (| NV_SSS NV_STS),         FALSE           ),
        (->nv_cmd_C K_KEND,           nv_end,      (| NV_SSS NV_STS),         FALSE           ),
        (->nv_cmd_C K_S_END,          nv_end,         NV_SS,                  FALSE           ),
        (->nv_cmd_C K_C_END,          nv_end,      (| NV_SSS NV_STS),         TRUE            ),
        (->nv_cmd_C K_HOME,           nv_home,     (| NV_SSS NV_STS),         0               ),
        (->nv_cmd_C K_KHOME,          nv_home,     (| NV_SSS NV_STS),         0               ),
        (->nv_cmd_C K_S_HOME,         nv_home,        NV_SS,                  0               ),
        (->nv_cmd_C K_C_HOME,         nv_goto,     (| NV_SSS NV_STS),         FALSE           ),
        (->nv_cmd_C K_DEL,            nv_abbrev,      0,                      0               ),
        (->nv_cmd_C K_KDEL,           nv_abbrev,      0,                      0               ),
        (->nv_cmd_C K_UNDO,           nv_kundo,       0,                      0               ),
        (->nv_cmd_C K_SELECT,         nv_select,      0,                      0               ),
        (->nv_cmd_C K_DROP,           nv_drop,        NV_STS,                 0               ),
        (->nv_cmd_C K_CURSORHOLD,     nv_cursorhold,  NV_KEEPREG,             0               ),
    ])

;; Sorted index of commands in nv_cmds[].
; %%    (final Short* nv_cmd_idx    (count nv_cmds))

;; The highest index for which
;; nv_cmds[idx].cmd_char == nv_cmd_idx[nv_cmds[idx].cmd_char].

(atom! int nv_max_linear)

;; ops.c: implementation of op_shift, op_delete, op_tilde, op_change, op_yank, do_put and do_join

;; Number of registers.
;;      0 = unnamed register, for normal yanks and puts
;;   1..9 = registers '1' to '9', for deletes
;; 10..35 = registers 'a' to 'z'
;;     36 = delete register '-'
;;     37 = Selection register '*'.  Only if FEAT_CLIPBOARD defined
;;     38 = Clipboard register '+'.  Only if FEAT_CLIPBOARD and FEAT_X11 defined

;; Symbolic names for some registers.

(final int DELETION_REGISTER       36)
(final int STAR_REGISTER           37)
(final int PLUS_REGISTER           STAR_REGISTER)           ;; there is only one
(final int TILDE_REGISTER          (inc PLUS_REGISTER))

(final int NUM_REGISTERS           (inc TILDE_REGISTER))

;; Each yank register is an array of pointers to lines.

(class! #_final yankreg_C
    [
        (field Bytes*       y_array)            ;; pointer to array of line pointers
        (field int          y_size)             ;; number of lines in "y_array"
        (field byte         y_type)             ;; MLINE, MCHAR or MBLOCK
        (field int          y_width)            ;; only set if y_type == MBLOCK
    ])

(defn- #_void COPY_yankreg [#_yankreg_C y1, #_yankreg_C y0]
    (§
;       y1.y_array = y0.y_array;
;       y1.y_size = y0.y_size;
;       y1.y_type = y0.y_type;
;       y1.y_width = y0.y_width;
    ))

(defn- #_yankreg_C* ARRAY_yankreg [#_int n]
    (vec (repeatedly n §_yankreg_C)))

(final yankreg_C*   y_regs    (ARRAY_yankreg NUM_REGISTERS))

(atom! yankreg_C    y_current)      ;; ptr to current yankreg
(atom! boolean      y_append)       ;; true when appending
(atom! yankreg_C    y_previous)     ;; ptr to last written yankreg

;; structure used by block_prep, op_delete and op_yank for blockwise operators
;; also op_change, op_shift, op_insert, op_replace

(class! #_final block_def_C
    [
        (field int          startspaces)        ;; 'extra' cols before first char
        (field int          endspaces)          ;; 'extra' cols after last char
        (field int          textlen)            ;; chars in block
        (field Bytes        textstart)          ;; pointer to 1st char (partially) in block
        (field int          textcol)            ;; index of chars (partially) in block
        (field int          start_vcol)         ;; start col of 1st char wholly inside block
        (field int          end_vcol)           ;; start col of 1st char wholly after block
        (field boolean      is_short)           ;; true if line is too short to fit in block
        (field boolean      is_MAX)             ;; true if curswant == MAXCOL when starting
        (field boolean      is_oneChar)         ;; true if block within one character
        (field int          pre_whitesp)        ;; screen cols of ws before block
        (field int          pre_whitesp_c)      ;; chars of ws before block
        (field int          end_char_vcols)     ;; number of vcols of post-block char
        (field int          start_char_vcols)   ;; number of vcols of pre-block char
    ])

;; The names of operators.
;; IMPORTANT: Index must correspond with defines in vim.h!!!
;; The third field indicates whether the operator always works on lines.

(final byte** #_"[/*3*/]" opchars
    [
        [ NUL, NUL, FALSE ],    ;; OP_NOP
        [ \d,  NUL, FALSE ],    ;; OP_DELETE
        [ \y,  NUL, FALSE ],    ;; OP_YANK
        [ \c,  NUL, FALSE ],    ;; OP_CHANGE
        [ \<,  NUL, TRUE  ],    ;; OP_LSHIFT
        [ \>,  NUL, TRUE  ],    ;; OP_RSHIFT
        [ \!,  NUL, TRUE  ],    ;; OP_FILTER
        [ \g,  \~,  FALSE ],    ;; OP_TILDE
        [ \=,  NUL, TRUE  ],    ;; OP_INDENT
        [ \g,  \q,  TRUE  ],    ;; OP_FORMAT
        [ \:,  NUL, TRUE  ],    ;; OP_COLON
        [ \g,  \U,  FALSE ],    ;; OP_UPPER
        [ \g,  \u,  FALSE ],    ;; OP_LOWER
        [ \J,  NUL, TRUE  ],    ;; DO_JOIN
        [ \g,  \J,  TRUE  ],    ;; DO_JOIN_NS
        [ \g,  \?,  FALSE ],    ;; OP_ROT13
        [ \r,  NUL, FALSE ],    ;; OP_REPLACE
        [ \I,  NUL, FALSE ],    ;; OP_INSERT
        [ \A,  NUL, FALSE ],    ;; OP_APPEND
        [ \g,  \w,  TRUE  ],    ;; OP_FORMAT2
        [ \g,  \@,  FALSE ],    ;; OP_FUNCTION
    ])

;; Translate a command name into an operator type.
;; Must only be called with a valid operator name!

(defn- #_int get_op_type [#_int char1, #_int char2]
    (§
;       if (char1 == 'r')           ;; ignore second character
;           return OP_REPLACE;
;       if (char1 == '~')           ;; when tilde is an operator
;           return OP_TILDE;

;       int i;
;       for (i = 0; ; i++)
;           if (opchars[i][0] == char1 && opchars[i][1] == char2)
;               break;
;       return i;
    ))

;; Return true if operator "op" always works on whole lines.

(defn- #_boolean op_on_lines [#_int op]
    (§
;       return (opchars[op][2] != FALSE);
    ))

;; Get first operator command character.
;; Returns 'g' or 'z' if there is another command character.

(defn- #_int get_op_char [#_int optype]
    (§
;       return opchars[optype][0];
    ))

;; Get second operator command character.

(defn- #_int get_extra_op_char [#_int optype]
    (§
;       return opchars[optype][1];
    ))

;; op_shift - handle a shift operation

(defn- #_void op_shift [#_oparg_C oap, #_boolean curs_top, #_int amount]
    (§
;       int block_col = 0;

;       if (!u_save(oap.op_start.lnum - 1, oap.op_end.lnum + 1))
;           return;

;       if (oap.block_mode)
;           block_col = @curwin.w_cursor.col;

;       for (long n = oap.line_count; 0 <= --n; @curwin.w_cursor.lnum++)
;       {
;           byte c0 = ml_get_curline().at(0);
;           if (c0 == NUL)                      ;; empty line
;               @curwin.w_cursor.col = 0;
;           else if (oap.block_mode)
;               shift_block(oap, amount);
;           else if (c0 != '#' || !preprocs_left())
;           {
                ;; Move the line right if it doesn't start with '#',
                ;; 'smartindent' isn't set or 'cindent' isn't set or '#' isn't in 'cino'.
;               shift_line(oap.op_type == OP_LSHIFT, @p_sr, amount, false);
;           }
;       }

;       changed_lines(oap.op_start.lnum, 0, oap.op_end.lnum + 1, 0L);

;       if (oap.block_mode)
;       {
;           @curwin.w_cursor.lnum = oap.op_start.lnum;
;           @curwin.w_cursor.col = block_col;
;       }
;       else if (curs_top)      ;; put cursor on first line, for ">>"
;       {
;           @curwin.w_cursor.lnum = oap.op_start.lnum;
;           beginline(BL_SOL | BL_FIX);     ;; shift_line() may have set cursor.col
;       }
;       else
;           --@curwin.w_cursor.lnum;         ;; put cursor on last line, for ":>"

;       if (@p_report < oap.line_count)
;       {
;           Bytes s = (oap.op_type == OP_RSHIFT) ? u8(">") : u8("<");
;           if (oap.line_count == 1)
;           {
;               if (amount == 1)
;                   libC.sprintf(@ioBuff, u8("1 line %sed 1 time"), s);
;               else
;                   libC.sprintf(@ioBuff, u8("1 line %sed %d times"), s, amount);
;           }
;           else
;           {
;               if (amount == 1)
;                   libC.sprintf(@ioBuff, u8("%ld lines %sed 1 time"), oap.line_count, s);
;               else
;                   libC.sprintf(@ioBuff, u8("%ld lines %sed %d times"), oap.line_count, s, amount);
;           }
;           msg(@ioBuff);
;       }

        ;; Set "'[" and "']" marks.

;       COPY_pos(@curbuf.b_op_start, oap.op_start);
;       @curbuf.b_op_end.lnum = oap.op_end.lnum;
;       @curbuf.b_op_end.col = STRLEN(ml_get(oap.op_end.lnum));
;       if (0 < @curbuf.b_op_end.col)
;           --@curbuf.b_op_end.col;
    ))

;; shift the current line one shiftwidth left (if left != 0) or right
;; leaves cursor on first blank in the line

(defn- #_void shift_line [#_boolean left, #_boolean round, #_int amount, #_boolean call_changed_bytes]
    ;; call_changed_bytes: call changed_bytes()
    (§
;       int q_sw = (int)get_sw_value(@curbuf);

;       int count = get_indent();       ;; get current indent

;       if (round)                      ;; round off indent
;       {
;           int i = count / q_sw;       ;; number of "p_sw" rounded down
;           int j = count % q_sw;       ;; extra spaces
;           if (j != 0 && left)         ;; first remove extra spaces
;               --amount;
;           if (left)
;           {
;               i -= amount;
;               if (i < 0)
;                   i = 0;
;           }
;           else
;               i += amount;
;           count = i * q_sw;
;       }
;       else                            ;; original vi indent
;       {
;           if (left)
;           {
;               count -= q_sw * amount;
;               if (count < 0)
;                   count = 0;
;           }
;           else
;               count += q_sw * amount;
;       }

        ;; Set new indent.
;       if ((@State & VREPLACE_FLAG) != 0)
;           change_indent(INDENT_SET, count, false, NUL, call_changed_bytes);
;       else
;           set_indent(count, call_changed_bytes ? SIN_CHANGED : 0);
    ))

;; Shift one line of the current block one shiftwidth right or left.
;; Leaves cursor on first character in block.

(defn- #_void shift_block [#_oparg_C oap, #_int amount]
    (§
;       boolean left = (oap.op_type == OP_LSHIFT);

;       int oldcol = @curwin.w_cursor.col;
;       int q_sw = (int)get_sw_value(@curbuf);
;       int q_ts = (int)@curbuf.@b_p_ts;

;       boolean old_p_ri = @p_ri;
;       @p_ri = false;                   ;; don't want revins in indent

;       int oldstate = @State;
;       @State = INSERT;             ;; don't want REPLACE for State

;       block_def_C bd = §_block_def_C();
;       block_prep(oap, bd, @curwin.w_cursor.lnum, true);
;       if (bd.is_short)
;           return;

        ;; total is number of screen columns to be inserted/removed
;       int total = amount * q_sw;
;       Bytes oldp = ml_get_curline();
;       Bytes newp;

;       if (!left)
;       {
            ;;  1. Get start vcol
            ;;  2. Total ws vcols
            ;;  3. Divvy into TABs & spp
            ;;  4. Construct new string

;           total += bd.pre_whitesp;    ;; all virtual WS upto & incl a split TAB
;           int ws_vcol = bd.start_vcol - bd.pre_whitesp;
;           if (bd.startspaces != 0)
;               bd.textstart = bd.textstart.plus(us_ptr2len_cc(bd.textstart));
;           while (vim_iswhite(bd.textstart.at(0)))
;           {
                ;; TODO: is passing bd.textstart for start of the line OK?
;               int incr;
;               { Bytes[] __ = { bd.textstart }; incr = lbr_chartabsize_adv(bd.textstart, __, bd.start_vcol); bd.textstart = __[0]; }
;               total += incr;
;               bd.start_vcol += incr;
;           }
            ;; OK, now total=all the VWS reqd, and textstart
            ;; points at the 1st non-ws char in the block.
;           int i = 0, j = total;
;           if (!@curbuf.@b_p_et)
;               i = ((ws_vcol % q_ts) + total) / q_ts; ;; number of tabs
;           if (i != 0)
;               j = ((ws_vcol % q_ts) + total) % q_ts; ;; number of spp
            ;; if we're splitting a TAB, allow for it
;           bd.textcol -= bd.pre_whitesp_c - ((bd.startspaces != 0) ? 1 : 0);
;           int len = STRLEN(bd.textstart) + 1;
;           newp = new Bytes(bd.textcol + i + j + len);

;           BCOPY(newp, oldp, bd.textcol);
;           copy_chars(newp.plus(bd.textcol), i, TAB);
;           copy_spaces(newp.plus(bd.textcol + i), j);
;           BCOPY(newp, bd.textcol + i + j, bd.textstart, 0, len);
;       }
;       else ;; left
;       {
            ;; Firstly, let's find the first non-whitespace character that is
            ;; displayed after the block's start column and the character's column
            ;; number.  Also, let's calculate the width of all the whitespace
            ;; characters that are displayed in the block and precede the searched
            ;; non-whitespace character.

            ;; If "bd.startspaces" is set, "bd.textstart" points to the character,
            ;; the part of which is displayed at the block's beginning.  Let's start
            ;; searching from the next character.
;           Bytes[] non_white = { bd.textstart };
;           if (bd.startspaces != 0)
;               non_white[0] = non_white[0].plus(us_ptr2len_cc(non_white[0]));

            ;; The character's column is in "bd.start_vcol".
;           int non_white_col = bd.start_vcol;

;           while (vim_iswhite(non_white[0].at(0)))
;           {
;               int incr = lbr_chartabsize_adv(bd.textstart, non_white, non_white_col);
;               non_white_col += incr;
;           }

;           int block_space_width = non_white_col - oap.start_vcol;
            ;; We will shift by "total" or "block_space_width", whichever is less.
;           int shift_amount = (block_space_width < total) ? block_space_width : total;

            ;; The column to which we will shift the text.
;           int destination_col = non_white_col - shift_amount;

            ;; Now let's find out how much of the beginning
            ;; of the line we can reuse without modification.

            ;; end of the part of the line which is copied verbatim
;           Bytes verbatim_copy_end = bd.textstart;
            ;; the (displayed) width of this part of line
;           int verbatim_copy_width = bd.start_vcol;

            ;; If "bd.startspaces" is set, "bd.textstart" points to the character preceding the block.
            ;; We have to subtract its width to obtain its column number.
;           if (bd.startspaces != 0)
;               verbatim_copy_width -= bd.start_char_vcols;
;           while (verbatim_copy_width < destination_col)
;           {
;               Bytes line = verbatim_copy_end;

                ;; TODO: is passing "verbatim_copy_end" for start of the line OK?
;               int incr = lbr_chartabsize(line, verbatim_copy_end, verbatim_copy_width);
;               if (destination_col < verbatim_copy_width + incr)
;                   break;
;               verbatim_copy_width += incr;
;               verbatim_copy_end = verbatim_copy_end.plus(us_ptr2len_cc(verbatim_copy_end));
;           }

            ;; If "destination_col" is different from the width of the initial
            ;; part of the line that will be copied, it means we encountered a tab
            ;; character, which we will have to partly replace with spaces.
;           int fill = destination_col - verbatim_copy_width;

            ;; The replacement line will consist of:
            ;; - the beginning of the original line up to "verbatim_copy_end",
            ;; - "fill" number of spaces,
            ;; - the rest of the line, pointed to by "non_white".

            ;; the length of the line after the block shift
;           int diff = BDIFF(verbatim_copy_end, oldp);
;           int new_line_len = diff + fill + STRLEN(non_white[0]) + 1;

;           newp = new Bytes(new_line_len);

;           BCOPY(newp, oldp, diff);
;           copy_spaces(newp.plus(diff), fill);
;           BCOPY(newp, diff + fill, non_white[0], 0, STRLEN(non_white[0]) + 1);
;       }

        ;; replace the line
;       ml_replace(@curwin.w_cursor.lnum, newp, false);
;       changed_bytes(@curwin.w_cursor.lnum, bd.textcol);
;       @State = oldstate;
;       @curwin.w_cursor.col = oldcol;
;       @p_ri = old_p_ri;
    ))

;; Insert string "s" (b_insert ? before : after) block.
;; Caller must prepare for undo.

(defn- #_void block_insert [#_oparg_C oap, #_Bytes s, #_boolean b_insert, #_block_def_C bdp]
    (§
;       int count = 0;                                  ;; extra spaces to replace a cut TAB
;       int spaces = 0;                                 ;; non-zero if cutting a TAB

;       int oldstate = @State;
;       @State = INSERT;                                 ;; don't want REPLACE for State

;       int s_len = STRLEN(s);

;       for (long lnum = oap.op_start.lnum + 1; lnum <= oap.op_end.lnum; lnum++)
;       {
;           block_prep(oap, bdp, lnum, true);
;           if (bdp.is_short && b_insert)
;               continue;                               ;; OP_INSERT, line ends before block start

;           Bytes oldp = ml_get(lnum);

;           int q_ts;
;           int offset;
;           if (b_insert)
;           {
;               q_ts = bdp.start_char_vcols;
;               spaces = bdp.startspaces;
;               if (spaces != 0)
;                   count = q_ts - 1;                   ;; we're cutting a TAB
;               offset = bdp.textcol;
;           }
;           else                                        ;; append
;           {
;               q_ts = bdp.end_char_vcols;
;               if (!bdp.is_short)                      ;; spaces = padding after block
;               {
;                   spaces = (bdp.endspaces != 0) ? q_ts - bdp.endspaces : 0;
;                   if (spaces != 0)
;                       count = q_ts - 1;               ;; we're cutting a TAB
;                   offset = bdp.textcol + bdp.textlen - ((spaces != 0) ? 1 : 0);
;               }
;               else                                    ;; spaces = padding to block edge
;               {
                    ;; if $ used, just append to EOL (ie spaces==0)
;                   if (!bdp.is_MAX)
;                       spaces = (oap.end_vcol - bdp.end_vcol) + 1;
;                   count = spaces;
;                   offset = bdp.textcol + bdp.textlen;
;               }
;           }

;           if (0 < spaces)
;           {
;               int off;

                ;; Avoid starting halfway a multi-byte character.
;               if (b_insert)
;               {
;                   off = us_head_off(oldp, oldp.plus(offset + spaces));
;               }
;               else
;               {
;                   off = us_off_next(oldp, oldp.plus(offset));
;                   offset += off;
;               }
;               spaces -= off;
;               count -= off;
;           }

;           Bytes newp = new Bytes(STRLEN(oldp) + s_len + count + 1);

            ;; copy up to shifted part
;           BCOPY(newp, oldp, offset);
;           oldp = oldp.plus(offset);

            ;; insert pre-padding
;           copy_spaces(newp.plus(offset), spaces);

            ;; copy the new text
;           BCOPY(newp, offset + spaces, s, 0, s_len);
;           offset += s_len;

;           if (0 < spaces && !bdp.is_short)
;           {
                ;; insert post-padding
;               copy_spaces(newp.plus(offset + spaces), q_ts - spaces);
                ;; We're splitting a TAB, don't copy it.
;               oldp = oldp.plus(1);
                ;; We allowed for that TAB, remember this now.
;               count++;
;           }

;           if (0 < spaces)
;               offset += count;
;           BCOPY(newp, offset, oldp, 0, STRLEN(oldp) + 1);

;           ml_replace(lnum, newp, false);

;           if (lnum == oap.op_end.lnum)
;           {
                ;; Set "']" mark to the end of the block instead of the end of the insert in the first line.
;               @curbuf.b_op_end.lnum = oap.op_end.lnum;
;               @curbuf.b_op_end.col = offset;
;           }
;       }

;       changed_lines(oap.op_start.lnum + 1, 0, oap.op_end.lnum + 1, 0L);

;       @State = oldstate;
    ))

;; op_reindent - handle reindenting a block of lines.

(defn- #_void op_reindent [#_oparg_C oap, #_getindent_F getindent]
    (§
;       long first_changed = 0;
;       long last_changed = 0;
;       long start_lnum = @curwin.w_cursor.lnum;

        ;; Don't even try when 'modifiable' is off.
;       if (!@curbuf.@b_p_ma)
;       {
;           emsg(e_modifiable);
;           return;
;       }

;       long i;
;       for (i = oap.line_count; 0 <= --i && !@got_int; )
;       {
            ;; It's a slow thing to do, so give feedback,
            ;; so there's no worry that the computer's just hung.

;           if (1 < i
;                   && (i % 50 == 0 || i == oap.line_count - 1)
;                   && @p_report < oap.line_count)
;               smsg(u8("%ld lines to indent... "), i);

            ;; Be vi-compatible: for lisp indenting the first line is not indented,
            ;; unless there is only one line.

;           if (i != oap.line_count - 1 || oap.line_count == 1 || getindent != get_lisp_indent)
;           {
;               int count = 0;
;               Bytes l = skipwhite(ml_get_curline());
;               if (l.at(0) != NUL)                     ;; empty or blank line
;                   count = getindent();            ;; get the indent for this line

;               if (set_indent(count, SIN_UNDO))
;               {
                    ;; did change the indent, call changed_lines() later
;                   if (first_changed == 0)
;                       first_changed = @curwin.w_cursor.lnum;
;                   last_changed = @curwin.w_cursor.lnum;
;               }
;           }
;           @curwin.w_cursor.lnum++;
;           @curwin.w_cursor.col = 0;            ;; make sure it's valid
;       }

        ;; put cursor on first non-blank of indented line
;       @curwin.w_cursor.lnum = start_lnum;
;       beginline(BL_SOL | BL_FIX);

        ;; Mark changed lines so that they will be redrawn.
        ;; When Visual highlighting was present, need to continue until the last line.
        ;; When there is no change still need to remove the Visual highlighting.
;       if (last_changed != 0)
;           changed_lines(first_changed, 0,
;                   oap.is_VIsual ? start_lnum + oap.line_count : last_changed + 1, 0L);
;       else if (oap.is_VIsual)
;           redraw_curbuf_later(INVERTED);

;       if (@p_report < oap.line_count)
;       {
;           i = oap.line_count - (i + 1);
;           if (i == 1)
;               msg(u8("1 line indented "));
;           else
;               smsg(u8("%ld lines indented "), i);
;       }
        ;; set '[ and '] marks
;       COPY_pos(@curbuf.b_op_start, oap.op_start);
;       COPY_pos(@curbuf.b_op_end, oap.op_end);
    ))

;; Keep the last expression line here, for repeating.

(atom! Bytes expr_line)

;; Get an expression for the "\"=expr1" or "CTRL-R =expr1"
;; Returns '=' when OK, NUL otherwise.

(defn- #_int get_expr_register []
    (§
;       Bytes new_line = getcmdline('=', 0L, 0);
;       if (new_line == null)
;           return NUL;

;       if (new_line.at(0) == NUL)
        ; ;; use previous line
;       else
;           set_expr_line(new_line);

;       return '=';
    ))

;; Set the expression for the '=' register.
;; Argument must be an allocated string.

(defn- #_void set_expr_line [#_Bytes new_line]
    (§
;       @expr_line = new_line;
    ))

(atom! int __nested)

;; Get the result of the '=' register expression.
;; Returns a pointer to allocated memory, or null for failure.

(defn- #_Bytes get_expr_line []
    (§
;       if (@expr_line == null)
;           return null;

        ;; Make a copy of the expression, because evaluating it may cause it to be changed.
;       Bytes expr_copy = STRDUP(@expr_line);

        ;; When we are invoked recursively limit the evaluation to 10 levels.
        ;; Then return the string as-is.
;       if (10 <= @__nested)
;           return expr_copy;

;       @__nested++;
;       Bytes rv = eval_to_string(expr_copy, null, true);
;       --@__nested;
;       return rv;
    ))

;; Get the '=' register expression itself, without evaluating it.

(defn- #_Bytes get_expr_line_src []
    (§
;       if (@expr_line == null)
;           return null;

;       return STRDUP(@expr_line);
    ))

;; Check if 'regname' is a valid name of a yank register.
;; Note: There is no check for 0 (default register), caller should do this

(defn- #_boolean valid_yank_reg [#_int regname, #_boolean writing]
    ;; writing: if true check for writable registers
    (§
;       if ((0 < regname && asc_isalnum(regname))
;               || (!writing && vim_strchr(u8("/.%:="), regname) != null)
;               || regname == '#'
;               || regname == '"'
;               || regname == '-'
;               || regname == '_'
;               || regname == '*'
;               || regname == '+'
;               || (!writing && regname == '~'))
;           return true;

;       return false;
    ))

;; Set y_current and y_append, according to the value of "regname".
;; Cannot handle the '_' register.
;; Must only be called with a valid register name!
;;
;; If regname is 0 and writing, use register 0.
;; If regname is 0 and reading, use previous register.

(defn- #_void get_yank_register [#_int regname, #_boolean writing]
    (§
;       @y_append = false;

;       if ((regname == 0 || regname == '"') && !writing && @y_previous != null)
;       {
;           @y_current = @y_previous;
;           return;
;       }

;       int i = regname;
;       if (asc_isdigit(i))
;           i -= '0';
;       else if (asc_islower(i))
;           i = charOrdLow(i) + 10;
;       else if (asc_isupper(i))
;       {
;           i = charOrdUp(i) + 10;
;           @y_append = true;
;       }
;       else if (regname == '-')
;           i = DELETION_REGISTER;
        ;; When selection is not available, use register 0 instead of '*'.
;       else if (@clip_star.available && regname == '*')
;           i = STAR_REGISTER;
        ;; When clipboard is not available, use register 0 instead of '+'.
;       else if (@clip_plus.available && regname == '+')
;           i = PLUS_REGISTER;
;       else if (!writing && regname == '~')
;           i = TILDE_REGISTER;
;       else                ;; not 0-9, a-z, A-Z or '-': use register 0
;           i = 0;

;       @y_current = y_regs[i];

;       if (writing)        ;; remember the register we write into for do_put()
;           @y_previous = @y_current;
    ))

;; When "regname" is a clipboard register, obtain the selection.
;; If it's not available return zero, otherwise return "regname".

(defn- #_int may_get_selection [#_int regname]
    (§
;       if (regname == '*')
;       {
;           if (!@clip_star.available)
;               regname = 0;
;           else
;               clip_get_selection(@clip_star);
;       }
;       else if (regname == '+')
;       {
;           if (!@clip_plus.available)
;               regname = 0;
;           else
;               clip_get_selection(@clip_plus);
;       }
;       return regname;
    ))

;; Obtain the contents of a "normal" register.  The register is made empty.
;; The returned pointer has allocated memory, use put_register() later.

(defn- #_yankreg_C get_register [#_int name, #_boolean copy]
    ;; copy: make a copy, if false make register empty.
    (§
        ;; When Visual area changed, may have to update selection.  Obtain the selection too.
;       if (name == '*' && @clip_star.available)
;       {
;           if (clip_isautosel_star())
;               clip_update_selection(@clip_star);
;           may_get_selection(name);
;       }
;       if (name == '+' && @clip_plus.available)
;       {
;           if (clip_isautosel_plus())
;               clip_update_selection(@clip_plus);
;           may_get_selection(name);
;       }

;       get_yank_register(name, false);

;       yankreg_C reg = §_yankreg_C();

;       COPY_yankreg(reg, @y_current);
;       if (copy)
;       {
            ;; If we run out of memory some or all of the lines are empty.
;           if (reg.y_size == 0)
;               reg.y_array = null;
;           else
;           {
;               reg.y_array = new Bytes[reg.y_size];

;               for (int i = 0; i < reg.y_size; i++)
;                   reg.y_array[i] = STRDUP(@y_current.y_array[i]);
;           }
;       }
;       else
;           @y_current.y_array = null;

;       return reg;
    ))

;; Put "reg" into register "name".  Free any previous contents and "reg".

(defn- #_void put_register [#_int name, #_yankreg_C reg]
    (§
;       get_yank_register(name, false);
;       @y_current.y_array = null;
;       COPY_yankreg(@y_current, reg);

        ;; Send text written to clipboard register to the clipboard.
;       may_set_selection();
    ))

;; return true if the current yank register has type MLINE

(defn- #_boolean yank_register_mline [#_int regname]
    (§
;       if (regname != 0 && !valid_yank_reg(regname, false))
;           return false;
;       if (regname == '_')         ;; black hole is always empty
;           return false;
;       get_yank_register(regname, false);
;       return (@y_current.y_type == MLINE);
    ))

(atom! int rec__regname)

;; Start or stop recording into a yank register.
;;
;; Return false for failure, true otherwise.

(defn- #_boolean do_record [#_int c]
    (§
;       boolean retval;

;       if (@Recording == false)         ;; start recording
;       {
            ;; registers 0-9, a-z and " are allowed
;           if (c < 0 || (!asc_isalnum(c) && c != '"'))
;               retval = false;
;           else
;           {
;               @Recording = true;
;               showmode();
;               @rec__regname = c;
;               retval = true;
;           }
;       }
;       else                            ;; stop recording
;       {
            ;; Get the recorded key hits.
            ;; KB_SPECIAL and CSI will be escaped, this needs to be removed again to put it in a register.
            ;; exec_reg then adds the escaping back later.

;           @Recording = false;
;           msg(u8(""));
;           Bytes p = get_recorded();
;           if (p == null)
;               retval = false;
;           else
;           {
                ;; Remove escaping for CSI and KB_SPECIAL in multi-byte chars.
;               vim_unescape_csi(p);

                ;; We don't want to change the default register here,
                ;; so save and restore the current register name.

;               yankreg_C old_y_previous = @y_previous;
;               yankreg_C old_y_current = @y_current;

;               retval = stuff_yank(@rec__regname, p);

;               @y_previous = old_y_previous;
;               @y_current = old_y_current;
;           }
;       }

;       return retval;
    ))

;; Stuff string "p" into yank register "regname" as a single line (append if uppercase).
;; "p" must have been alloced.
;;
;; return false for failure, true otherwise

(defn- #_boolean stuff_yank [#_int regname, #_Bytes p]
    (§
        ;; check for read-only register
;       if (regname != 0 && !valid_yank_reg(regname, true))
;           return false;
;       if (regname == '_')             ;; black hole: don't do anything
;           return true;

;       get_yank_register(regname, true);

;       if (@y_append && @y_current.y_array != null)
;       {
;           Bytes[] a = @y_current.y_array;
;           int i = @y_current.y_size - 1;

;           Bytes lp = new Bytes(STRLEN(a[i]) + STRLEN(p) + 1);
;           STRCPY(lp, a[i]);
;           STRCAT(lp, p);
;           a[i] = lp;
;       }
;       else
;       {
;           @y_current.y_array = new Bytes[1];
;           @y_current.y_array[0] = p;
;           @y_current.y_size = 1;
;           @y_current.y_type = MCHAR;   ;; used to be MLINE, why?
;       }

;       return true;
    ))

(atom! int execreg_lastc NUL)

;; execute a yank register: copy it into the stuff buffer
;;
;; return false for failure, true otherwise

(defn- #_boolean do_execreg [#_int regname, #_boolean colon, #_boolean addcr, #_boolean silent]
    ;; colon: insert ':' before each line
    ;; addcr: always add '\n' to end of line
    ;; silent: set "silent" flag in typeahead buffer
    (§
;       boolean retval = true;

;       if (regname == '@')                 ;; repeat previous one
;       {
;           if (@execreg_lastc == NUL)
;           {
;               emsg(u8("E748: No previously used register"));
;               return false;
;           }
;           regname = @execreg_lastc;
;       }
                                            ;; check for valid regname
;       if (regname == '%' || regname == '#' || !valid_yank_reg(regname, false))
;       {
;           emsg_invreg(regname);
;           return false;
;       }
;       @execreg_lastc = regname;

;       regname = may_get_selection(regname);

;       if (regname == '_')                 ;; black hole: don't stuff anything
;           return true;

;       if (regname == ':')                 ;; use last command line
;       {
;           if (@last_cmdline == null)
;           {
;               emsg(e_nolastcmd);
;               return false;
;           }
;           @new_last_cmdline = null;        ;; don't keep the cmdline containing @:
            ;; Escape all control characters with a CTRL-V.
;           Bytes p = vim_strsave_escaped_ext(@last_cmdline, u8("\001\002\003\004\005\006\007\010\011\012\013\014\015\016\017\020\021\022\023\024\025\026\027\030\031\032\033\034\035\036\037"), Ctrl_V);

            ;; When in Visual mode "'<,'>" will be prepended to the command.
            ;; Remove it when it's already there.
;           if (@VIsual_active && STRNCMP(p, u8("'<,'>"), 5) == 0)
;               retval = put_in_typebuf(p.plus(5), true, true, silent);
;           else
;               retval = put_in_typebuf(p, true, true, silent);
;       }
;       else if (regname == '=')
;       {
;           Bytes p = get_expr_line();
;           if (p == null)
;               return false;

;           retval = put_in_typebuf(p, true, colon, silent);
;       }
;       else if (regname == '.')            ;; use last inserted text
;       {
;           Bytes p = get_last_insert_save();
;           if (p == null)
;           {
;               emsg(e_noinstext);
;               return false;
;           }
;           retval = put_in_typebuf(p, false, colon, silent);
;       }
;       else
;       {
;           get_yank_register(regname, false);
;           if (@y_current.y_array == null)
;               return false;

            ;; Disallow remaping for ":@r".
;           int remap = colon ? REMAP_NONE : REMAP_YES;

            ;; Insert lines into typeahead buffer, from last one to first one.

;           put_reedit_in_typebuf(silent);

;           for (int i = @y_current.y_size; 0 <= --i; )
;           {
                ;; insert NL between lines and after last line if type is MLINE
;               if (@y_current.y_type == MLINE || i < @y_current.y_size - 1 || addcr)
;                   if (!ins_typebuf(u8("\n"), remap, 0, true, silent))
;                       return false;

;               Bytes escaped = vim_strsave_escape_csi(@y_current.y_array[i]);

;               retval = ins_typebuf(escaped, remap, 0, true, silent);

;               if (!retval)
;                   return false;

;               if (colon && !ins_typebuf(u8(":"), remap, 0, true, silent))
;                   return false;
;           }
;           @execReg = true;         ;; disable the 'q' command
;       }

;       return retval;
    ))

;; If "restart_edit" is not zero, put it in the typeahead buffer, so that it's
;; used only after other typeahead has been processed.

(defn- #_void put_reedit_in_typebuf [#_boolean silent]
    (§
;       Bytes buf = new Bytes(3);

;       if (@restart_edit != NUL)
;       {
;           if (@restart_edit == 'V')
;           {
;               buf.be(0, (byte)'g');
;               buf.be(1, (byte)'R');
;               buf.be(2, NUL);
;           }
;           else
;           {
;               buf.be(0, (@restart_edit == 'I') ? (byte)'i' : @restart_edit);
;               buf.be(1, NUL);
;           }
;           if (ins_typebuf(buf, REMAP_NONE, 0, true, silent))
;               @restart_edit = NUL;
;       }
    ))

;; Insert register contents "s" into the typeahead buffer, so that it will be executed again.
;; When "esc" is true it is to be taken literally: escape CSI characters and no remapping.

(defn- #_boolean put_in_typebuf [#_Bytes s, #_boolean esc, #_boolean colon, #_boolean silent]
    ;; colon: add ':' before the line
    (§
;       boolean retval = true;

;       put_reedit_in_typebuf(silent);

;       if (colon)
;           retval = ins_typebuf(u8("\n"), REMAP_NONE, 0, true, silent);
;       if (retval)
;       {
;           Bytes p = (esc) ? vim_strsave_escape_csi(s) : s;

;           if (p == null)
;               retval = false;
;           else
;               retval = ins_typebuf(p, esc ? REMAP_NONE : REMAP_YES, 0, true, silent);
;       }
;       if (colon && retval)
;           retval = ins_typebuf(u8(":"), REMAP_NONE, 0, true, silent);

;       return retval;
    ))

;; Insert a yank register: copy it into the Read buffer.
;; Used by CTRL-R command and middle mouse button in insert mode.
;;
;; return false for failure, true otherwise

(defn- #_boolean insert_reg [#_int regname, #_boolean literally]
    ;; literally: insert literally, not as if typed
    (§
;       boolean retval = true;

        ;; It is possible to get into an endless loop by having CTRL-R a in
        ;; register a and then, in insert mode, doing CTRL-R a.
        ;; If you hit CTRL-C, the loop will be broken here.

;       ui_breakcheck();
;       if (@got_int)
;           return false;

        ;; check for valid regname
;       if (regname != NUL && !valid_yank_reg(regname, false))
;           return false;

;       regname = may_get_selection(regname);

;       Bytes[] arg = new Bytes[1];
;       boolean[] allocated = new boolean[1];

;       if (regname == '.')                 ;; insert last inserted text
;           retval = stuff_inserted(NUL, 1L, true);
;       else if (get_spec_reg(regname, arg, allocated, true))
;       {
;           if (arg[0] == null)
;               return false;
;           stuffescaped(arg[0], literally);
;       }
;       else                                ;; name or number register
;       {
;           get_yank_register(regname, false);
;           if (@y_current.y_array == null)
;               retval = false;
;           else
;           {
;               for (int i = 0; i < @y_current.y_size; i++)
;               {
;                   stuffescaped(@y_current.y_array[i], literally);

                    ;; Insert a newline between lines and after last line if y_type is MLINE.

;                   if (@y_current.y_type == MLINE || i < @y_current.y_size - 1)
;                       stuffcharReadbuff('\n');
;               }
;           }
;       }

;       return retval;
    ))

;; Stuff a string into the typeahead buffer, such that edit() will insert it
;; literally ("literally" true) or interpret is as typed characters.

(defn- #_void stuffescaped [#_Bytes _arg, #_boolean literally]
    (§
;       Bytes[] arg = { _arg };
;       while (arg[0].at(0) != NUL)
;       {
            ;; Stuff a sequence of normal ASCII characters, that's fast.
            ;; Also stuff KB_SPECIAL to get the effect of a special key when "literally" is true.
;           Bytes start = arg[0];
;           while ((' ' <= arg[0].at(0) && arg[0].at(0) < DEL) || (arg[0].at(0) == KB_SPECIAL && !literally))
;               arg[0] = arg[0].plus(1);
;           if (BLT(start, arg[0]))
;               stuffReadbuffLen(start, BDIFF(arg[0], start));

            ;; stuff a single special character
;           if (arg[0].at(0) != NUL)
;           {
;               int c = us_ptr2char_adv(arg, false);
;               if (literally && ((c < ' ' && c != TAB) || c == DEL))
;                   stuffcharReadbuff(Ctrl_V);
;               stuffcharReadbuff(c);
;           }
;       }
    ))

;; If "regname" is a special register, return true and store a pointer to its value in "argp".

(defn- #_boolean get_spec_reg [#_int regname, #_Bytes* argp, #_boolean* allocated, #_boolean errmsg]
    ;; allocated: return: true when value was allocated
    ;; errmsg: give error message when failing
    (§
;       argp[0] = null;
;       allocated[0] = false;

;       switch (regname)
;       {
;           case '%':                                       ;; file name
;           case '#':                                       ;; alternate file name
;               argp[0] = null;
;               return false;

;           case '=':                                       ;; result of expression
;               argp[0] = get_expr_line();
;               allocated[0] = true;
;               return true;

;           case ':':                                       ;; last command line
;               if (@last_cmdline == null && errmsg)
;                   emsg(e_nolastcmd);
;               argp[0] = @last_cmdline;
;               return true;

;           case '/':                                       ;; last search-pattern
;               if (last_search_pat() == null && errmsg)
;                   emsg(e_noprevre);
;               argp[0] = last_search_pat();
;               return true;

;           case '.':                                       ;; last inserted text
;               argp[0] = get_last_insert_save();
;               allocated[0] = true;
;               if (argp[0] == null && errmsg)
;                   emsg(e_noinstext);
;               return true;

;           case Ctrl_W:                                    ;; word under cursor
;           case Ctrl_A:                                    ;; WORD (mnemonic All) under cursor
;           {
;               if (!errmsg)
;                   return false;
;               int cnt = find_ident_under_cursor(argp, regname == Ctrl_W ? (FIND_IDENT|FIND_STRING) : FIND_STRING);
;               argp[0] = (cnt != 0) ? STRNDUP(argp[0], cnt) : null;
;               allocated[0] = true;
;               return true;
;           }

;           case '_':               ;; black hole: always empty
;               argp[0] = u8("");
;               return true;
;       }

;       return false;
    ))

;; Paste a yank register into the command line.
;; Only for non-special registers.
;; Used by CTRL-R command in command-line mode
;; insert_reg() can't be used here, because special characters from the
;; register contents will be interpreted as commands.
;;
;; return false for failure, true otherwise

(defn- #_boolean cmdline_paste_reg [#_int regname, #_boolean literally, #_boolean remcr]
    ;; literally: Insert text literally instead of "as typed"
    ;; remcr: don't add trailing CR
    (§
;       get_yank_register(regname, false);
;       if (@y_current.y_array == null)
;           return false;

;       for (int i = 0; i < @y_current.y_size; i++)
;       {
;           cmdline_paste_str(@y_current.y_array[i], literally);

            ;; Insert ^M between lines and after last line if type is MLINE.
            ;; Don't do this when "remcr" is true and the next line is empty.
;           if (@y_current.y_type == MLINE
;                   || (i < @y_current.y_size - 1
;                       && !(remcr
;                           && i == @y_current.y_size - 2
;                           && @y_current.y_array[i + 1].at(0) == NUL)))
;               cmdline_paste_str(u8("\r"), literally);

            ;; Check for CTRL-C in case someone tries to paste
            ;; a few thousand lines and gets bored.
;           ui_breakcheck();
;           if (@got_int)
;               return false;
;       }

;       return true;
    ))

;; Adjust the register name "reg" for the clipboard being used always and the clipboard being available.

(defn- #_int adjust_clip_reg [#_int reg]
    (§
        ;; If no reg. specified, and "unnamed" or "unnamedplus" is in 'clipboard',
        ;; use '*' or '+' reg, respectively.  "unnamedplus" prevails.
;       if (reg == 0 && (@clip_unnamed != 0 || @clip_unnamed_saved != 0))
;       {
;           if (@clip_unnamed != 0)
;               reg = ((@clip_unnamed & CLIP_UNNAMED_PLUS) != 0 && @clip_plus.available) ? '+' : '*';
;           else
;               reg = ((@clip_unnamed_saved & CLIP_UNNAMED_PLUS) != 0 && @clip_plus.available) ? '+' : '*';
;       }
;       if (!@clip_star.available && reg == '*')
;           reg = 0;
;       if (!@clip_plus.available && reg == '+')
;           reg = 0;

;       return reg;
    ))

;; Handle a delete operation.
;;
;; Return false if undo failed, true otherwise.

(defn- #_boolean op_delete [#_oparg_C oap]
    (§
;       long old_lcount = @curbuf.b_ml.ml_line_count;
;       boolean did_yank = false;
;       int orig_regname = oap.regname;

;       if ((@curbuf.b_ml.ml_flags & ML_EMPTY) != 0) ;; nothing to do
;           return true;

        ;; Nothing to delete, return here.  Do prepare undo, for op_change().
;       if (oap.empty)
;           return u_save_cursor();

;       if (!@curbuf.@b_p_ma)
;       {
;           emsg(e_modifiable);
;           return false;
;       }

;       oap.regname = adjust_clip_reg(oap.regname);

;       mb_adjust_opend(oap);

        ;; Imitate the strange Vi behaviour: If the delete spans more than one
        ;; line and motion_type == MCHAR and the result is a blank line, make the
        ;; delete linewise.  Don't do this for the change command or Visual mode.

;       if (       oap.motion_type == MCHAR
;               && !oap.is_VIsual
;               && !oap.block_mode
;               && 1 < oap.line_count
;               && oap.motion_force == NUL
;               && oap.op_type == OP_DELETE)
;       {
;           Bytes ptr = ml_get(oap.op_end.lnum).plus(oap.op_end.col);
;           if (ptr.at(0) != NUL && oap.inclusive)
;               ptr = ptr.plus(1);
;           ptr = skipwhite(ptr);
;           if (ptr.at(0) == NUL && inindent(0))
;               oap.motion_type = MLINE;
;       }

;       setmarks:
;       {
            ;; Check for trying to delete (e.g. "D") in an empty line.
            ;; Note: For the change operator it is ok.

;           if (oap.motion_type == MCHAR
;                   && oap.line_count == 1
;                   && oap.op_type == OP_DELETE
;                   && ml_get(oap.op_start.lnum).at(0) == NUL)
;           {
                ;; It's an error to operate on an empty region,
                ;; when 'E' included in 'cpoptions' (Vi compatible).

;               if (@virtual_op != FALSE)
                    ;; Virtual editing: nothing gets deleted,
                    ;; but we set the '[ and '] marks as if it happened.
;                   break setmarks;
;               if (vim_strbyte(@p_cpo, CPO_EMPTYREGION) != null)
;                   beep_flush();
;               return true;
;           }

            ;; Do a yank of whatever we're about to delete.
            ;; If a yank register was specified, put the deleted text into that register.
            ;; For the black hole register '_' don't yank anything.

;           if (oap.regname != '_')
;           {
;               if (oap.regname != 0)
;               {
                    ;; check for read-only register
;                   if (!valid_yank_reg(oap.regname, true))
;                   {
;                       beep_flush();
;                       return true;
;                   }
;                   get_yank_register(oap.regname, true);       ;; yank into specif'd reg.
;                   if (op_yank(oap, true, false) == true)      ;; yank without message
;                       did_yank = true;
;               }

                ;; Put deleted text into register 1 and shift number registers if the
                ;; delete contains a line break, or when a regname has been specified.
                ;; Use the register name from before adjust_clip_reg() may have changed it.

;               if (orig_regname != 0 || oap.motion_type == MLINE || 1 < oap.line_count || oap.use_reg_one)
;               {
;                   @y_current = y_regs[9];
;                   @y_current.y_array = null;               ;; free register nine
;                   for (int n = 9; 1 < n; --n)
;                       COPY_yankreg(y_regs[n], y_regs[n - 1]);
;                   @y_previous = @y_current = y_regs[1];
;                   y_regs[1].y_array = null;               ;; set register one to empty
;                   if (op_yank(oap, true, false) == true)
;                       did_yank = true;
;               }

                ;; Yank into small delete register when no named register specified
                ;; and the delete is within one line.
;               if ((((@clip_unnamed & CLIP_UNNAMED) != 0 && oap.regname == '*')
;                   || ((@clip_unnamed & CLIP_UNNAMED_PLUS) != 0 && oap.regname == '+')
;                   || oap.regname == 0)
;                       && oap.motion_type != MLINE && oap.line_count == 1)
;               {
;                   oap.regname = '-';
;                   get_yank_register(oap.regname, true);
;                   if (op_yank(oap, true, false) == true)
;                       did_yank = true;
;                   oap.regname = 0;
;               }

                ;; If there's too much stuff to fit in the yank register, then get a
                ;; confirmation before doing the delete.  This is crude, but simple.
                ;; And it avoids doing a delete of something we can't put back if we want.

;               if (!did_yank)
;               {
;                   int msg_silent_save = @msg_silent;

;                   @msg_silent = 0;     ;; must display the prompt
;                   int n = ask_yesno(u8("cannot yank; delete anyway"), true);
;                   @msg_silent = msg_silent_save;
;                   if (n != 'y')
;                   {
;                       emsg(e_abort);
;                       return false;
;                   }
;               }
;           }

            ;; block mode delete

;           if (oap.block_mode)
;           {
;               if (!u_save(oap.op_start.lnum - 1, oap.op_end.lnum + 1))
;                   return false;

;               block_def_C bd = §_block_def_C();
;               for (long lnum = @curwin.w_cursor.lnum; lnum <= oap.op_end.lnum; lnum++)
;               {
;                   block_prep(oap, bd, lnum, true);
;                   if (bd.textlen == 0)    ;; nothing to delete
;                       continue;

                    ;; Adjust cursor position for tab replaced by spaces and 'lbr'.
;                   if (lnum == @curwin.w_cursor.lnum)
;                   {
;                       @curwin.w_cursor.col = bd.textcol + bd.startspaces;
;                       @curwin.w_cursor.coladd = 0;
;                   }

                    ;; n == number of chars deleted
                    ;; If we delete a TAB, it may be replaced by several characters.
                    ;; Thus the number of characters may increase!

;                   int n = bd.textlen - bd.startspaces - bd.endspaces;
;                   Bytes oldp = ml_get(lnum);
;                   Bytes newp = new Bytes(STRLEN(oldp) + 1 - n);

                    ;; copy up to deleted part
;                   BCOPY(newp, oldp, bd.textcol);
                    ;; insert spaces
;                   copy_spaces(newp.plus(bd.textcol), bd.startspaces + bd.endspaces);
                    ;; copy the part after the deleted part
;                   oldp = oldp.plus(bd.textcol + bd.textlen);
;                   BCOPY(newp, bd.textcol + bd.startspaces + bd.endspaces, oldp, 0, STRLEN(oldp) + 1);
                    ;; replace the line
;                   ml_replace(lnum, newp, false);
;               }

;               check_cursor_col();
;               changed_lines(@curwin.w_cursor.lnum, @curwin.w_cursor.col, oap.op_end.lnum + 1, 0L);
;               oap.line_count = 0;     ;; no lines deleted
;           }
;           else if (oap.motion_type == MLINE)
;           {
;               if (oap.op_type == OP_CHANGE)
;               {
                    ;; Delete the lines except the first one.  Temporarily move the
                    ;; cursor to the next line.  Save the current line number, if the
                    ;; last line is deleted it may be changed.

;                   if (1 < oap.line_count)
;                   {
;                       long lnum = @curwin.w_cursor.lnum;
;                       @curwin.w_cursor.lnum++;
;                       del_lines(oap.line_count - 1, true);
;                       @curwin.w_cursor.lnum = lnum;
;                   }
;                   if (!u_save_cursor())
;                       return false;
;                   if (@curbuf.@b_p_ai)                  ;; don't delete indent
;                   {
;                       beginline(BL_WHITE);            ;; cursor on first non-white
;                       @did_ai = true;                  ;; delete the indent when ESC hit
;                       @ai_col = @curwin.w_cursor.col;
;                   }
;                   else
;                       beginline(0);                   ;; cursor in column 0
;                   truncate_line(false);               ;; delete the rest of the line
                                                        ;; leave cursor past last char in line
;                   if (1 < oap.line_count)
;                       u_clearline();                  ;; "U" command not possible after "2cc"
;               }
;               else
;               {
;                   del_lines(oap.line_count, true);
;                   beginline(BL_WHITE | BL_FIX);
;                   u_clearline();                      ;; "U" command not possible after "dd"
;               }
;           }
;           else
;           {
;               if (@virtual_op != FALSE)
;               {
;                   int endcol = 0;

                    ;; For virtualedit: break the tabs that are partly included.
;                   if (gchar_pos(oap.op_start) == '\t')
;                   {
;                       if (!u_save_cursor())       ;; save first line for undo
;                           return false;
;                       if (oap.line_count == 1)
;                           endcol = getviscol2(oap.op_end.col, oap.op_end.coladd);
;                       coladvance_force(getviscol2(oap.op_start.col, oap.op_start.coladd));
;                       COPY_pos(oap.op_start, @curwin.w_cursor);
;                       if (oap.line_count == 1)
;                       {
;                           coladvance(endcol);
;                           oap.op_end.col = @curwin.w_cursor.col;
;                           oap.op_end.coladd = @curwin.w_cursor.coladd;
;                           COPY_pos(@curwin.w_cursor, oap.op_start);
;                       }
;                   }

                    ;; Break a tab only when it's included in the area.
;                   if (gchar_pos(oap.op_end) == '\t' && oap.op_end.coladd < (oap.inclusive ? 1 : 0))
;                   {
                        ;; save last line for undo
;                       if (!u_save(oap.op_end.lnum - 1, oap.op_end.lnum + 1))
;                           return false;
;                       COPY_pos(@curwin.w_cursor, oap.op_end);
;                       coladvance_force(getviscol2(oap.op_end.col, oap.op_end.coladd));
;                       COPY_pos(oap.op_end, @curwin.w_cursor);
;                       COPY_pos(@curwin.w_cursor, oap.op_start);
;                   }
;               }

;               if (oap.line_count == 1)            ;; delete characters within one line
;               {
;                   if (!u_save_cursor())           ;; save line for undo
;                       return false;

                    ;; if 'cpoptions' contains '$', display '$' at end of change
;                   if (vim_strbyte(@p_cpo, CPO_DOLLAR) != null
;                           && oap.op_type == OP_CHANGE
;                           && oap.op_end.lnum == @curwin.w_cursor.lnum
;                           && !oap.is_VIsual)
;                       display_dollar(oap.op_end.col - (!oap.inclusive ? 1 : 0));

;                   int n = oap.op_end.col - oap.op_start.col + 1 - (!oap.inclusive ? 1 : 0);

;                   if (@virtual_op != FALSE)
;                   {
                        ;; fix up things for virtualedit-delete:
                        ;; break the tabs which are going to get in our way

;                       Bytes curline = ml_get_curline();
;                       int len = STRLEN(curline);

;                       if (oap.op_end.coladd != 0
;                               && len - 1 <= oap.op_end.col
;                               && !(oap.op_start.coladd != 0 && len - 1 <= oap.op_end.col))
;                           n++;
                        ;; Delete at least one char (e.g, when on a control char).
;                       if (n == 0 && oap.op_start.coladd != oap.op_end.coladd)
;                           n = 1;

                        ;; When deleted a char in the line, reset coladd.
;                       if (gchar_cursor() != NUL)
;                           @curwin.w_cursor.coladd = 0;
;                   }
;                   if (oap.op_type == OP_DELETE
;                           && oap.inclusive
;                           && oap.op_end.lnum == @curbuf.b_ml.ml_line_count
;                           && STRLEN(ml_get(oap.op_end.lnum)) < n)
;                   {
                        ;; Special case: gH<Del> deletes the last line.
;                       del_lines(1L, false);
;                   }
;                   else
;                   {
;                       del_bytes(n, @virtual_op == FALSE, oap.op_type == OP_DELETE && !oap.is_VIsual);
;                   }
;               }
;               else                                    ;; delete characters between lines
;               {
                    ;; save deleted and changed lines for undo
;                   if (!u_save(@curwin.w_cursor.lnum - 1, @curwin.w_cursor.lnum + oap.line_count))
;                       return false;

;                   boolean delete_last_line = (oap.op_end.lnum == @curbuf.b_ml.ml_line_count);
;                   truncate_line(true);                ;; delete from cursor to end of line

;                   pos_C curpos = §_pos_C();
;                   COPY_pos(curpos, @curwin.w_cursor);

;                   @curwin.w_cursor.lnum++;
;                   del_lines(oap.line_count - 2, false);

;                   if (delete_last_line)
;                       oap.op_end.lnum = @curbuf.b_ml.ml_line_count;

;                   int n = (oap.op_end.col + 1 - (!oap.inclusive ? 1 : 0));
;                   if (oap.inclusive && delete_last_line && STRLEN(ml_get(oap.op_end.lnum)) < n)
;                   {
                        ;; Special case: gH<Del> deletes the last line.
;                       del_lines(1L, false);
;                       COPY_pos(@curwin.w_cursor, curpos);
;                       if (@curwin.w_cursor.lnum > @curbuf.b_ml.ml_line_count)
;                           @curwin.w_cursor.lnum = @curbuf.b_ml.ml_line_count;
;                   }
;                   else
;                   {
                        ;; delete from start of line until op_end
;                       @curwin.w_cursor.col = 0;
;                       del_bytes(n, @virtual_op == FALSE, oap.op_type == OP_DELETE && !oap.is_VIsual);
;                       COPY_pos(@curwin.w_cursor, curpos);
;                   }
;                   if (@curwin.w_cursor.lnum < @curbuf.b_ml.ml_line_count)
;                       do_join(2, false, false, false, false);
;               }
;           }

;           msgmore(@curbuf.b_ml.ml_line_count - old_lcount);
;       }

;       if (oap.block_mode)
;       {
;           @curbuf.b_op_end.lnum = oap.op_end.lnum;
;           @curbuf.b_op_end.col = oap.op_start.col;
;       }
;       else
;           COPY_pos(@curbuf.b_op_end, oap.op_start);
;       COPY_pos(@curbuf.b_op_start, oap.op_start);

;       return true;
    ))

;; Adjust end of operating area for ending on a multi-byte character.
;; Used for deletion.

(defn- #_void mb_adjust_opend [#_oparg_C oap]
    (§
;       if (oap.inclusive)
;       {
;           Bytes p = ml_get(oap.op_end.lnum);
;           oap.op_end.col += us_tail_off(p, p.plus(oap.op_end.col));
;       }
    ))

;; Replace a whole area with one character.

(defn- #_boolean op_replace [#_oparg_C oap, #_int c]
    (§
;       Bytes after_p = null;
;       boolean had_ctrl_v_cr = (c == -1 || c == -2);

;       if ((@curbuf.b_ml.ml_flags & ML_EMPTY) != 0 || oap.empty)
;           return true;            ;; nothing to do

;       if (had_ctrl_v_cr)
;           c = (c == -1) ? '\r' : '\n';

;       mb_adjust_opend(oap);

;       if (!u_save(oap.op_start.lnum - 1, oap.op_end.lnum + 1))
;           return false;

        ;; block mode replace

;       if (oap.block_mode)
;       {
;           block_def_C bd = §_block_def_C();

;           bd.is_MAX = (@curwin.w_curswant == MAXCOL);
;           for ( ; @curwin.w_cursor.lnum <= oap.op_end.lnum; @curwin.w_cursor.lnum++)
;           {
;               @curwin.w_cursor.col = 0;    ;; make sure cursor position is valid
;               block_prep(oap, bd, @curwin.w_cursor.lnum, true);
;               if (bd.textlen == 0 && (@virtual_op == FALSE || bd.is_MAX))
;                   continue;               ;; nothing to replace

                ;; n == number of extra chars required
                ;; If we split a TAB, it may be replaced by several characters.
                ;; Thus the number of characters may increase!

                ;; If the range starts in virtual space,
                ;; count the initial coladd offset as part of "startspaces".
;               int n;
;               if (@virtual_op != FALSE && bd.is_short && bd.textstart.at(0) == NUL)
;               {
;                   pos_C vpos = §_pos_C();

;                   vpos.lnum = @curwin.w_cursor.lnum;
;                   getvpos(vpos, oap.start_vcol);
;                   bd.startspaces += vpos.coladd;
;                   n = bd.startspaces;
;               }
;               else
                    ;; allow for pre spaces
;                   n = (bd.startspaces != 0) ? bd.start_char_vcols - 1 : 0;

                ;; allow for post spp
;               n += (bd.endspaces != 0 && !bd.is_oneChar && 0 < bd.end_char_vcols)
;                       ? bd.end_char_vcols - 1 : 0;
                ;; Figure out how many characters to replace.
;               int numc = oap.end_vcol - oap.start_vcol + 1;
;               if (bd.is_short && (@virtual_op == FALSE || bd.is_MAX))
;                   numc -= (oap.end_vcol - bd.end_vcol) + 1;

                ;; A double-wide character can be replaced only up to half the times.
;               if (1 < utf_char2cells(c))
;               {
;                   if ((numc & 1) != 0 && !bd.is_short)
;                   {
;                       bd.endspaces++;
;                       n++;
;                   }
;                   numc = numc / 2;
;               }

                ;; Compute bytes needed, move character count to num_chars.
;               int num_chars = numc;
;               numc *= utf_char2len(c);
                ;; oldlen includes textlen, so don't double count
;               n += numc - bd.textlen;

;               Bytes oldp = ml_get_curline();
;               int oldlen = STRLEN(oldp);
;               Bytes newp = new Bytes(oldlen + 1 + n);

                ;; copy up to deleted part
;               BCOPY(newp, oldp, bd.textcol);
;               oldp = oldp.plus(bd.textcol + bd.textlen);
                ;; insert pre-spaces
;               copy_spaces(newp.plus(bd.textcol), bd.startspaces);
                ;; insert replacement chars CHECK FOR ALLOCATED SPACE
                ;; -1/-2 is used for entering CR literally.
;               if (had_ctrl_v_cr || (c != '\r' && c != '\n'))
;               {
;                   n = STRLEN(newp);
;                   while (0 <= --num_chars)
;                       n += utf_char2bytes(c, newp.plus(n));

;                   if (!bd.is_short)
;                   {
                        ;; insert post-spaces
;                       copy_spaces(newp.plus(STRLEN(newp)), bd.endspaces);
                        ;; copy the part after the changed part
;                       BCOPY(newp, STRLEN(newp), oldp, 0, STRLEN(oldp) + 1);
;                   }
;               }
;               else
;               {
                    ;; Replacing with \r or \n means splitting the line.
;                   after_p = new Bytes(oldlen + 1 + n - STRLEN(newp));
;                   BCOPY(after_p, oldp, STRLEN(oldp) + 1);
;               }
                ;; replace the line
;               ml_replace(@curwin.w_cursor.lnum, newp, false);
;               if (after_p != null)
;               {
;                   ml_append(@curwin.w_cursor.lnum++, after_p, 0, false);
;                   appended_lines_mark(@curwin.w_cursor.lnum, 1L);
;                   oap.op_end.lnum++;
;               }
;           }
;       }
;       else
;       {
            ;; MCHAR and MLINE motion replace.

;           if (oap.motion_type == MLINE)
;           {
;               oap.op_start.col = 0;
;               @curwin.w_cursor.col = 0;
;               oap.op_end.col = STRLEN(ml_get(oap.op_end.lnum));
;               if (oap.op_end.col != 0)
;                   --oap.op_end.col;
;           }
;           else if (!oap.inclusive)
;               decp(oap.op_end);

;           while (ltoreq(@curwin.w_cursor, oap.op_end))
;           {
;               int n = gchar_cursor();
;               if (n != NUL)
;               {
;                   if (1 < utf_char2len(c) || 1 < utf_char2len(n))
;                   {
                        ;; This is slow, but it handles replacing a single-byte
                        ;; with a multi-byte and the other way around.
;                       if (@curwin.w_cursor.lnum == oap.op_end.lnum)
;                           oap.op_end.col += utf_char2len(c) - utf_char2len(n);
;                       n = @State;
;                       @State = REPLACE;
;                       ins_char(c);
;                       @State = n;
                        ;; Backup to the replaced character.
;                       dec_cursor();
;                   }
;                   else
;                   {
;                       if (n == TAB)
;                       {
;                           int end_vcol = 0;

;                           if (@curwin.w_cursor.lnum == oap.op_end.lnum)
;                           {
                                ;; oap.op_end has to be recalculated when the tab breaks
;                               end_vcol = getviscol2(oap.op_end.col, oap.op_end.coladd);
;                           }
;                           coladvance_force(getviscol());
;                           if (@curwin.w_cursor.lnum == oap.op_end.lnum)
;                               getvpos(oap.op_end, end_vcol);
;                       }
;                       ml_get_buf(@curbuf, @curwin.w_cursor.lnum, true).be(@curwin.w_cursor.col, c);
;                   }
;               }
;               else if (@virtual_op != FALSE && @curwin.w_cursor.lnum == oap.op_end.lnum)
;               {
;                   int virtcols = oap.op_end.coladd;

;                   if (@curwin.w_cursor.lnum == oap.op_start.lnum
;                           && oap.op_start.col == oap.op_end.col && oap.op_start.coladd != 0)
;                       virtcols -= oap.op_start.coladd;

                    ;; 'oap.op_end' has been trimmed, so it's effectively inclusive;
                    ;; as a result, an extra +1 must be counted, so we don't trample the NUL byte.
;                   coladvance_force(getviscol2(oap.op_end.col, oap.op_end.coladd) + 1);
;                   @curwin.w_cursor.col -= (virtcols + 1);
;                   for ( ; 0 <= virtcols; virtcols--)
;                   {
;                       ml_get_buf(@curbuf, @curwin.w_cursor.lnum, true).be(@curwin.w_cursor.col, c);
;                       if (incp(@curwin.w_cursor) == -1)
;                           break;
;                   }
;               }

                ;; Advance to next character, stop at the end of the file.
;               if (inc_cursor() == -1)
;                   break;
;           }
;       }

;       COPY_pos(@curwin.w_cursor, oap.op_start);
;       check_cursor();
;       changed_lines(oap.op_start.lnum, oap.op_start.col, oap.op_end.lnum + 1, 0L);

        ;; Set "'[" and "']" marks.
;       COPY_pos(@curbuf.b_op_start, oap.op_start);
;       COPY_pos(@curbuf.b_op_end, oap.op_end);

;       return true;
    ))

;; Handle the (non-standard vi) tilde operator.  Also for "gu", "gU" and "g?".

(defn- #_void op_tilde [#_oparg_C oap]
    (§
;       boolean did_change = false;

;       if (!u_save(oap.op_start.lnum - 1, oap.op_end.lnum + 1))
;           return;

;       pos_C pos = §_pos_C();
;       COPY_pos(pos, oap.op_start);

;       if (oap.block_mode)                     ;; Visual block mode
;       {
;           for ( ; pos.lnum <= oap.op_end.lnum; pos.lnum++)
;           {
;               block_def_C bd = §_block_def_C();
;               block_prep(oap, bd, pos.lnum, false);
;               pos.col = bd.textcol;
;               boolean one_change = swapchars(oap.op_type, pos, bd.textlen);
;               did_change |= one_change;
;           }
;           if (did_change)
;               changed_lines(oap.op_start.lnum, 0, oap.op_end.lnum + 1, 0L);
;       }
;       else                                    ;; not block mode
;       {
;           if (oap.motion_type == MLINE)
;           {
;               oap.op_start.col = 0;
;               pos.col = 0;
;               oap.op_end.col = STRLEN(ml_get(oap.op_end.lnum));
;               if (oap.op_end.col != 0)
;                   --oap.op_end.col;
;           }
;           else if (!oap.inclusive)
;               decp(oap.op_end);

;           if (pos.lnum == oap.op_end.lnum)
;               did_change = swapchars(oap.op_type, pos, oap.op_end.col - pos.col + 1);
;           else
;               for ( ; ; )
;               {
;                   did_change |= swapchars(oap.op_type, pos,
;                                   (pos.lnum == oap.op_end.lnum) ? oap.op_end.col + 1 : STRLEN(ml_get_pos(pos)));
;                   if (ltoreq(oap.op_end, pos) || incp(pos) == -1)
;                       break;
;               }

;           if (did_change)
;           {
;               changed_lines(oap.op_start.lnum, oap.op_start.col, oap.op_end.lnum + 1, 0L);
;           }
;       }

;       if (!did_change && oap.is_VIsual)
            ;; No change: need to remove the Visual selection.
;           redraw_curbuf_later(INVERTED);

        ;; Set '[ and '] marks.

;       COPY_pos(@curbuf.b_op_start, oap.op_start);
;       COPY_pos(@curbuf.b_op_end, oap.op_end);

;       if (@p_report < oap.line_count)
;       {
;           if (oap.line_count == 1)
;               msg(u8("1 line changed"));
;           else
;               smsg(u8("%ld lines changed"), oap.line_count);
;       }
    ))

;; Invoke swapchar() on "length" bytes at position "pos".
;; "pos" is advanced to just after the changed characters.
;; "length" is rounded up to include the whole last multi-byte character.
;; Also works correctly when the number of bytes changes.
;; Returns true if some character was changed.

(defn- #_boolean swapchars [#_int op_type, #_pos_C pos, #_int length]
    (§
;       boolean did_change = false;

;       for (int todo = length; 0 < todo; --todo)
;       {
;           int len = us_ptr2len_cc(ml_get_pos(pos));

            ;; we're counting bytes, not characters
;           if (0 < len)
;               todo -= len - 1;

;           did_change |= swapchar(op_type, pos);
;           if (incp(pos) == -1)     ;; at end of file
;               break;
;       }

;       return did_change;
    ))

;; If op_type == OP_UPPER: make uppercase,
;; if op_type == OP_LOWER: make lowercase,
;; if op_type == OP_ROT13: do rot13 encoding,
;; else swap case of character at 'pos'
;; returns true when something actually changed.

(defn- #_boolean swapchar [#_int op_type, #_pos_C pos]
    (§
;       int c = gchar_pos(pos);

        ;; Only do rot13 encoding for ASCII characters.
;       if (0x80 <= c && op_type == OP_ROT13)
;           return false;

;       if (op_type == OP_UPPER && c == 0xdf)
;       {
;           pos_C sp = §_pos_C();
;           COPY_pos(sp, @curwin.w_cursor);

            ;; Special handling of German sharp s: change to "SS".
;           COPY_pos(@curwin.w_cursor, pos);
;           del_char(false);
;           ins_char('S');
;           ins_char('S');
;           COPY_pos(@curwin.w_cursor, sp);
;           incp(pos);
;       }

;       int nc = c;
;       if (utf_islower(c))
;       {
;           if (op_type == OP_ROT13)
;               nc = rot13(c, 'a');
;           else if (op_type != OP_LOWER)
;               nc = utf_toupper(c);
;       }
;       else if (utf_isupper(c))
;       {
;           if (op_type == OP_ROT13)
;               nc = rot13(c, 'A');
;           else if (op_type != OP_UPPER)
;               nc = utf_tolower(c);
;       }
;       if (nc != c)
;       {
;           if (0x80 <= c || 0x80 <= nc)
;           {
;               pos_C sp = §_pos_C();
;               COPY_pos(sp, @curwin.w_cursor);

;               COPY_pos(@curwin.w_cursor, pos);
                ;; don't use del_char(), it also removes composing chars
;               del_bytes(us_ptr2len(ml_get_cursor()), false, false);
;               ins_char(nc);
;               COPY_pos(@curwin.w_cursor, sp);
;           }
;           else
;               ml_get_buf(@curbuf, pos.lnum, true).be(pos.col, nc);
;           return true;
;       }
;       return false;
    ))

;; op_insert - Insert and append operators for Visual mode.

(defn- #_void op_insert [#_oparg_C oap, #_long count1]
    (§
;       int pre_textlen = 0;

        ;; edit() changes this - record it for OP_APPEND
;       block_def_C bd = §_block_def_C();
;       bd.is_MAX = (@curwin.w_curswant == MAXCOL);

        ;; vis block is still marked.  Get rid of it now.
;       @curwin.w_cursor.lnum = oap.op_start.lnum;
;       update_screen(INVERTED);

;       if (oap.block_mode)
;       {
            ;; When 'virtualedit' is used, need to insert the extra spaces before doing block_prep().
            ;; When only "block" is used, virtual edit is already disabled,
            ;; but still need it when calling coladvance_force().
;           if (0 < @curwin.w_cursor.coladd)
;           {
;               int old_ve_flags = @ve_flags;

;               @ve_flags = VE_ALL;
;               if (!u_save_cursor())
;                   return;

;               coladvance_force(oap.op_type == OP_APPEND ? oap.end_vcol + 1 : getviscol());
;               if (oap.op_type == OP_APPEND)
;                   --@curwin.w_cursor.col;
;               @ve_flags = old_ve_flags;
;           }
            ;; Get the info about the block before entering the text.
;           block_prep(oap, bd, oap.op_start.lnum, true);
;           Bytes firstline = ml_get(oap.op_start.lnum).plus(bd.textcol);
;           if (oap.op_type == OP_APPEND)
;               firstline = firstline.plus(bd.textlen);
;           pre_textlen = STRLEN(firstline);
;       }

;       if (oap.op_type == OP_APPEND)
;       {
;           if (oap.block_mode && @curwin.w_cursor.coladd == 0)
;           {
                ;; Move the cursor to the character right of the block.
;               @curwin.w_set_curswant = true;
;               while (ml_get_cursor().at(0) != NUL && @curwin.w_cursor.col < bd.textcol + bd.textlen)
;                   @curwin.w_cursor.col++;
;               if (bd.is_short && !bd.is_MAX)
;               {
                    ;; First line was too short, make it longer and adjust the values in "bd".
;                   if (!u_save_cursor())
;                       return;

;                   for (int i = 0; i < bd.endspaces; i++)
;                       ins_char(' ');
;                   bd.textlen += bd.endspaces;
;               }
;           }
;           else
;           {
;               COPY_pos(@curwin.w_cursor, oap.op_end);
;               check_cursor_col();

                ;; Works just like an 'i'nsert on the next character.
;               if (!lineempty(@curwin.w_cursor.lnum) && oap.start_vcol != oap.end_vcol)
;                   inc_cursor();
;           }
;       }

;       pos_C t1 = §_pos_C();
;       COPY_pos(t1, oap.op_start);

;       edit(NUL, false, count1);

        ;; When a tab was inserted, and the characters in front of the tab
        ;; have been converted to a tab as well, the column of the cursor
        ;; might have actually been reduced, so need to adjust here.
;       if (t1.lnum == @curbuf.b_op_start_orig.lnum && ltpos(@curbuf.b_op_start_orig, t1))
;           COPY_pos(oap.op_start, @curbuf.b_op_start_orig);

        ;; If user has moved off this line, we don't know what to do, so do nothing.
        ;; Also don't repeat the insert when Insert mode ended with CTRL-C.
;       if (@curwin.w_cursor.lnum != oap.op_start.lnum || @got_int)
;           return;

;       if (oap.block_mode)
;       {
;           block_def_C bd2 = §_block_def_C();

            ;; The user may have moved the cursor before inserting something,
            ;; try to adjust the block for that.
;           if (oap.op_start.lnum == @curbuf.b_op_start_orig.lnum && !bd.is_MAX)
;           {
;               if (oap.op_type == OP_INSERT && oap.op_start.col + oap.op_start.coladd != @curbuf.b_op_start_orig.col + @curbuf.b_op_start_orig.coladd)
;               {
;                   int t = getviscol2(@curbuf.b_op_start_orig.col, @curbuf.b_op_start_orig.coladd);
;                   oap.op_start.col = @curbuf.b_op_start_orig.col;
;                   pre_textlen -= t - oap.start_vcol;
;                   oap.start_vcol = t;
;               }
;               else if (oap.op_type == OP_APPEND && @curbuf.b_op_start_orig.col + @curbuf.b_op_start_orig.coladd <= oap.op_end.col + oap.op_end.coladd)
;               {
;                   int t = getviscol2(@curbuf.b_op_start_orig.col, @curbuf.b_op_start_orig.coladd);
;                   oap.op_start.col = @curbuf.b_op_start_orig.col;
                    ;; reset pre_textlen to the value of OP_INSERT
;                   pre_textlen += bd.textlen;
;                   pre_textlen -= t - oap.start_vcol;
;                   oap.start_vcol = t;
;                   oap.op_type = OP_INSERT;
;               }
;           }

            ;; Spaces and tabs in the indent may have changed to other spaces and tabs.
            ;; Get the starting column again and correct the length.
            ;; Don't do this when "$" used, end-of-line will have changed.

;           block_prep(oap, bd2, oap.op_start.lnum, true);
;           if (!bd.is_MAX || bd2.textlen < bd.textlen)
;           {
;               if (oap.op_type == OP_APPEND)
;               {
;                   pre_textlen += bd2.textlen - bd.textlen;
;                   if (bd2.endspaces != 0)
;                       --bd2.textlen;
;               }
;               bd.textcol = bd2.textcol;
;               bd.textlen = bd2.textlen;
;           }

            ;; Subsequent calls to ml_get() flush the firstline data
            ;; - take a copy of the required string.

;           Bytes firstline = ml_get(oap.op_start.lnum).plus(bd.textcol);
;           if (oap.op_type == OP_APPEND)
;               firstline = firstline.plus(bd.textlen);

;           int ins_len;
;           if (0 <= pre_textlen && 0 < (ins_len = STRLEN(firstline) - pre_textlen))
;           {
;               Bytes ins_text = STRNDUP(firstline, ins_len);

                ;; block handled here
;               if (u_save(oap.op_start.lnum, oap.op_end.lnum + 1))
;                   block_insert(oap, ins_text, (oap.op_type == OP_INSERT), bd);

;               @curwin.w_cursor.col = oap.op_start.col;
;               check_cursor();
;           }
;       }
    ))

;; op_change - handle a change operation
;;
;; return true if edit() returns because of a CTRL-O command

(defn- #_boolean op_change [#_oparg_C oap]
    (§
;       int pre_textlen = 0;
;       int pre_indent = 0;

;       int l = oap.op_start.col;
;       if (oap.motion_type == MLINE)
;       {
;           l = 0;
;           if (!@p_paste && @curbuf.@b_p_si && !@curbuf.@b_p_cin)
;               @can_si = true;      ;; It's like opening a new line, do si
;       }

        ;; First delete the text in the region.  In an empty buffer only need to save for undo.
;       if ((@curbuf.b_ml.ml_flags & ML_EMPTY) != 0)
;       {
;           if (!u_save_cursor())
;               return false;
;       }
;       else if (op_delete(oap) == false)
;           return false;

;       if ((@curwin.w_cursor.col < l) && !lineempty(@curwin.w_cursor.lnum) && @virtual_op == FALSE)
;           inc_cursor();

;       block_def_C bd = §_block_def_C();
        ;; check for still on same line (<CR> in inserted text meaningless); skip blank lines too
;       if (oap.block_mode)
;       {
            ;; Add spaces before getting the current line length.
;           if (@virtual_op != FALSE && (0 < @curwin.w_cursor.coladd || gchar_cursor() == NUL))
;               coladvance_force(getviscol());
;           Bytes firstline = ml_get(oap.op_start.lnum);
;           pre_textlen = STRLEN(firstline);
;           pre_indent = BDIFF(skipwhite(firstline), firstline);
;           bd.textcol = @curwin.w_cursor.col;
;       }

;       if (oap.motion_type == MLINE)
;           fix_indent();

;       boolean retval = edit(NUL, false, 1);

        ;; In Visual block mode, handle copying the new text to all lines of the block.
        ;; Don't repeat the insert when Insert mode ended with CTRL-C.

;       if (oap.block_mode && oap.op_start.lnum != oap.op_end.lnum && !@got_int)
;       {
            ;; Auto-indenting may have changed the indent.  If the cursor was past
            ;; the indent, exclude that indent change from the inserted text.
;           Bytes firstline = ml_get(oap.op_start.lnum);
;           if (pre_indent < bd.textcol)
;           {
;               int new_indent = BDIFF(skipwhite(firstline), firstline);

;               pre_textlen += new_indent - pre_indent;
;               bd.textcol += new_indent - pre_indent;
;           }

;           int ins_len = STRLEN(firstline) - pre_textlen;
;           if (0 < ins_len)
;           {
                ;; Subsequent calls to ml_get() flush the "firstline" data
                ;; -- take a copy of the inserted text.
;               Bytes ins_text = STRNDUP(firstline.plus(bd.textcol), ins_len);

;               for (long linenr = oap.op_start.lnum + 1; linenr <= oap.op_end.lnum; linenr++)
;               {
;                   block_prep(oap, bd, linenr, true);
;                   if (!bd.is_short || @virtual_op != FALSE)
;                   {
;                       pos_C vpos = §_pos_C();

                        ;; If the block starts in virtual space, count the
                        ;; initial coladd offset as part of "startspaces".
;                       if (bd.is_short)
;                       {
;                           vpos.lnum = linenr;
;                           getvpos(vpos, oap.start_vcol);
;                       }
;                       else
;                           vpos.coladd = 0;
;                       Bytes oldp = ml_get(linenr);
;                       Bytes newp = new Bytes(STRLEN(oldp) + vpos.coladd + ins_len + 1);

                        ;; copy up to block start
;                       BCOPY(newp, oldp, bd.textcol);
;                       int offset = bd.textcol;
;                       copy_spaces(newp.plus(offset), vpos.coladd);
;                       offset += vpos.coladd;
;                       BCOPY(newp, offset, ins_text, 0, ins_len);
;                       offset += ins_len;
;                       oldp = oldp.plus(bd.textcol);
;                       BCOPY(newp, offset, oldp, 0, STRLEN(oldp) + 1);
;                       ml_replace(linenr, newp, false);
;                   }
;               }
;               check_cursor();

;               changed_lines(oap.op_start.lnum + 1, 0, oap.op_end.lnum + 1, 0L);
;           }
;       }

;       return retval;
    ))

;; set all the yank registers to empty (called from main())

(defn- #_void init_yank []
    (§
;       for (int i = 0; i < NUM_REGISTERS; i++)
;           y_regs[i].y_array = null;
    ))

;; Yank the text between "oap.op_start" and "oap.op_end" into a yank register.
;; If we are to append (uppercase register), we first yank into a new yank
;; register and then concatenate the old and the new one (so we keep the old
;; one in case of out-of-memory).
;;
;; Return false for failure, true otherwise.

(defn- #_boolean op_yank [#_oparg_C oap, #_boolean deleting, #_boolean mess]
    (§
;       byte yanktype = oap.motion_type;
;       int yanklines = (int)oap.line_count;
;       long yankendlnum = oap.op_end.lnum;

                                                        ;; check for read-only register
;       if (oap.regname != 0 && !valid_yank_reg(oap.regname, true))
;       {
;           beep_flush();
;           return false;
;       }
;       if (oap.regname == '_')                         ;; black hole: nothing to do
;           return true;

;       if (!@clip_star.available && oap.regname == '*')
;           oap.regname = 0;
;       else if (!@clip_plus.available && oap.regname == '+')
;           oap.regname = 0;

;       if (!deleting)                                  ;; op_delete() already set y_current
;           get_yank_register(oap.regname, true);

;       yankreg_C curr = @y_current;                     ;; copy of y_current
;       yankreg_C newreg = §_yankreg_C();             ;; new yank register when appending
;       if (@y_append && @y_current.y_array != null)      ;; append to existing contents
;           @y_current = newreg;
;       else
;           @y_current.y_array = null;                   ;; free previously yanked lines

        ;; If the cursor was in column 1 before and after the movement,
        ;; and the operator is not inclusive, the yank is always linewise.

;       if (       oap.motion_type == MCHAR
;               && oap.op_start.col == 0
;               && !oap.inclusive
;               && (!oap.is_VIsual || @p_sel.at(0) == (byte)'o')
;               && !oap.block_mode
;               && oap.op_end.col == 0
;               && 1 < yanklines)
;       {
;           yanktype = MLINE;
;           --yankendlnum;
;           --yanklines;
;       }

;       @y_current.y_size = yanklines;
;       @y_current.y_type = yanktype;                    ;; set the yank register type
;       @y_current.y_width = 0;
;       @y_current.y_array = new Bytes[yanklines];

;       int y_idx = 0;                                 ;; index in y_array[]
;       long lnum = oap.op_start.lnum;                  ;; current line number

;       if (oap.block_mode)
;       {
            ;; Visual block mode.
;           @y_current.y_type = MBLOCK;                  ;; set the yank register type
;           @y_current.y_width = oap.end_vcol - oap.start_vcol;

;           if (@curwin.w_curswant == MAXCOL && 0 < @y_current.y_width)
;               @y_current.y_width--;
;       }

;       fail:
;       {
;           block_def_C bd = §_block_def_C();

;           for ( ; lnum <= yankendlnum; lnum++, y_idx++)
;           {
;               switch (@y_current.y_type)
;               {
;                   case MBLOCK:
;                       block_prep(oap, bd, lnum, false);
;                       if (yank_copy_line(bd, y_idx) == false)
;                           break fail;
;                       break;

;                   case MLINE:
;                       if ((@y_current.y_array[y_idx] = STRDUP(ml_get(lnum))) == null)
;                           break fail;
;                       break;

;                   case MCHAR:
;                   {
;                       int startcol = 0, endcol = MAXCOL;
;                       boolean is_oneChar = false;
;                       Bytes p = ml_get(lnum);
;                       bd.startspaces = 0;
;                       bd.endspaces = 0;

;                       if (lnum == oap.op_start.lnum)
;                       {
;                           startcol = oap.op_start.col;
;                           if (@virtual_op != FALSE)
;                           {
;                               int[] cs = new int[1];
;                               int[] ce = new int[1];
;                               getvcol(@curwin, oap.op_start, cs, null, ce);
;                               if (ce[0] != cs[0] && 0 < oap.op_start.coladd)
;                               {
                                    ;; Part of a tab selected -- but don't double-count it.
;                                   bd.startspaces = (ce[0] - cs[0] + 1) - oap.op_start.coladd;
;                                   startcol++;
;                               }
;                           }
;                       }

;                       if (lnum == oap.op_end.lnum)
;                       {
;                           endcol = oap.op_end.col;
;                           if (@virtual_op != FALSE)
;                           {
;                               int[] cs = new int[1];
;                               int[] ce = new int[1];
;                               getvcol(@curwin, oap.op_end, cs, null, ce);
;                               if (p.at(endcol) == NUL || (cs[0] + oap.op_end.coladd < ce[0]
                                            ;; Don't add space for double-wide char;
                                            ;; endcol will be on last byte of multi-byte char.
;                                           && us_head_off(p, p.plus(endcol)) == 0))
;                               {
;                                   if (oap.op_start.lnum == oap.op_end.lnum && oap.op_start.col == oap.op_end.col)
;                                   {
                                        ;; Special case: inside a single char.
;                                       is_oneChar = true;
;                                       bd.startspaces = oap.op_end.coladd - oap.op_start.coladd + (oap.inclusive ? 1 : 0);
;                                       endcol = startcol;
;                                   }
;                                   else
;                                   {
;                                       bd.endspaces = oap.op_end.coladd + (oap.inclusive ? 1 : 0);
;                                       endcol -= (oap.inclusive ? 1 : 0);
;                                   }
;                               }
;                           }
;                       }
;                       if (endcol == MAXCOL)
;                           endcol = STRLEN(p);
;                       if (endcol < startcol || is_oneChar)
;                           bd.textlen = 0;
;                       else
;                           bd.textlen = endcol - startcol + (oap.inclusive ? 1 : 0);
;                       bd.textstart = p.plus(startcol);
;                       if (yank_copy_line(bd, y_idx) == false)
;                           break fail;
;                       break;
;                   }
;               }
;           }

;           if (curr != @y_current)      ;; append the new block to the old block
;           {
;               Bytes[] new_ptr = new Bytes[curr.y_size + @y_current.y_size];

;               int j;
;               for (j = 0; j < curr.y_size; j++)
;                   new_ptr[j] = curr.y_array[j];
;               curr.y_array = new_ptr;

;               if (yanktype == MLINE)  ;; MLINE overrides MCHAR and MBLOCK
;                   curr.y_type = MLINE;

                ;; Concatenate the last line of the old block with the first line of the new block,
                ;; unless being Vi compatible.
;               if (curr.y_type == MCHAR && vim_strbyte(@p_cpo, CPO_REGAPPEND) == null)
;               {
;                   Bytes p = new Bytes(STRLEN(curr.y_array[curr.y_size - 1]) + STRLEN(@y_current.y_array[0]) + 1);

;                   STRCPY(p, curr.y_array[--j]);
;                   STRCAT(p, @y_current.y_array[0]);
;                   @y_current.y_array[0] = null;
;                   curr.y_array[j++] = p;
;                   y_idx = 1;
;               }
;               else
;                   y_idx = 0;
;               while (y_idx < @y_current.y_size)
;                   curr.y_array[j++] = @y_current.y_array[y_idx++];
;               curr.y_size = j;
;               @y_current.y_array = null;
;               @y_current = curr;
;           }

;           if (@curwin.w_onebuf_opt.@wo_rnu)
;               redraw_later(SOME_VALID);       ;; cursor moved to start

;           if (mess)                   ;; Display message about yank?
;           {
;               if (yanktype == MCHAR && !oap.block_mode && yanklines == 1)
;                   yanklines = 0;
                ;; Some versions of Vi use ">=" here, some don't...
;               if (@p_report < yanklines)
;               {
                    ;; redisplay now, so message is not deleted
;                   update_topline_redraw();
;                   if (yanklines == 1)
;                   {
;                       if (oap.block_mode)
;                           msg(u8("block of 1 line yanked"));
;                       else
;                           msg(u8("1 line yanked"));
;                   }
;                   else if (oap.block_mode)
;                       smsg(u8("block of %ld lines yanked"), yanklines);
;                   else
;                       smsg(u8("%ld lines yanked"), yanklines);
;               }
;           }

            ;; Set "'[" and "']" marks.

;           COPY_pos(@curbuf.b_op_start, oap.op_start);
;           COPY_pos(@curbuf.b_op_end, oap.op_end);
;           if (yanktype == MLINE && !oap.block_mode)
;           {
;               @curbuf.b_op_start.col = 0;
;               @curbuf.b_op_end.col = MAXCOL;
;           }

            ;; If we were yanking to the '*' register, send result to clipboard.
            ;; If no register was specified, and "unnamed" in 'clipboard',
            ;; make a copy to the '*' register.

;           if (@clip_star.available
;                   && (curr == y_regs[STAR_REGISTER]
;                       || (!deleting && oap.regname == 0
;                       && ((@clip_unnamed | @clip_unnamed_saved) & CLIP_UNNAMED) != 0)))
;           {
;               if (curr != y_regs[STAR_REGISTER])
                    ;; Copy the text from register 0 to the clipboard register.
;                   copy_yank_reg(y_regs[STAR_REGISTER]);

;               clip_own_selection(@clip_star);
;               clip_gen_set_selection(@clip_star);
;           }

;           return true;
;       }

;       @y_current.y_array = null;
;       @y_current = curr;

;       return false;
    ))

(defn- #_boolean yank_copy_line [#_block_def_C bd, #_int y_idx]
    (§
;       Bytes pnew = new Bytes(bd.startspaces + bd.endspaces + bd.textlen + 1);

;       @y_current.y_array[y_idx] = pnew;
;       copy_spaces(pnew, bd.startspaces);
;       pnew = pnew.plus(bd.startspaces);
;       BCOPY(pnew, bd.textstart, bd.textlen);
;       pnew = pnew.plus(bd.textlen);
;       copy_spaces(pnew, bd.endspaces);
;       pnew = pnew.plus(bd.endspaces);
;       pnew.be(0, NUL);

;       return true;
    ))

;; Make a copy of the y_current register to register "reg".

(defn- #_void copy_yank_reg [#_yankreg_C reg]
    (§
;       yankreg_C curr = @y_current;

;       @y_current = reg;
;       COPY_yankreg(@y_current, curr);
;       @y_current.y_array = new Bytes[@y_current.y_size];

;       for (int i = 0; i < @y_current.y_size; i++)
;       {
;           Bytes s = STRDUP(curr.y_array[i]);
;           if (s == null)
;           {
;               @y_current.y_array = null;
;               @y_current.y_size = 0;
;               break;
;           }
;           @y_current.y_array[i] = s;
;       }

;       @y_current = curr;
    ))

;; Put contents of register "regname" into the text.
;; Caller must check "regname" to be valid!
;; "flags": PUT_FIXINDENT       make indent look nice
;;          PUT_CURSEND         leave cursor after end of new text
;;          PUT_LINE            force linewise put (":put")

(defn- #_void do_put [#_int regname, #_int dir, #_int count, #_int flags]
    ;; dir: BACKWARD for 'P', FORWARD for 'p'
    (§
;       int totlen = 0;
;       int y_width = 0;
;       int incr = 0;
;       long nr_lines = 0;
;       int orig_indent = 0;
;       int indent_diff = 0;
;       boolean first_indent = true;
;       int lendiff = 0;

        ;; Adjust register name for "unnamed" in 'clipboard'.
;       regname = adjust_clip_reg(regname);
;       may_get_selection(regname);

;       if ((flags & PUT_FIXINDENT) != 0)
;           orig_indent = get_indent();

;       COPY_pos(@curbuf.b_op_start, @curwin.w_cursor);   ;; default for '[ mark
;       COPY_pos(@curbuf.b_op_end, @curwin.w_cursor);     ;; default for '] mark

        ;; Using inserted text works differently, because the register includes
        ;; special characters (newlines, etc.).

;       if (regname == '.')
;       {
;           stuff_inserted((dir == FORWARD) ? (count == -1 ? 'o' : 'a') : (count == -1 ? 'O' : 'i'), count, false);
            ;; Putting the text is done later, so can't really move the cursor
            ;; to the next character.  Use "l" to simulate it.
;           if ((flags & PUT_CURSEND) != 0 && gchar_cursor() != NUL)
;               stuffcharReadbuff('l');
;           return;
;       }

        ;; For special registers '%' (file name), '#' (alternate file name) and
        ;; ':' (last command line), etc. we have to create a fake yank register.

;       Bytes[] insert_string = { null };
;       boolean[] allocated = { false };
;       if (get_spec_reg(regname, insert_string, allocated, true))
;       {
;           if (insert_string[0] == null)
;               return;
;       }

        ;; Autocommands may be executed when saving lines for undo,
        ;; which may make "y_array" invalid.  Start undo now to avoid that.
;       u_save(@curwin.w_cursor.lnum, @curwin.w_cursor.lnum + 1);

;       int y_type;
;       int y_size;
;       Bytes[] y_array = null;

;       if (insert_string[0] != null)
;       {
;           y_type = MCHAR;
;           if (regname == '=')
;           {
                ;; For the = register we need to split the string at NL characters.
                ;; Loop twice: count the number of lines and save them.
;               for ( ; ; )
;               {
;                   y_size = 0;
;                   for (Bytes p = insert_string[0]; p != null; )
;                   {
;                       if (y_array != null)
;                           y_array[y_size] = p;
;                       y_size++;
;                       p = vim_strchr(p, '\n');
;                       if (p != null)
;                       {
;                           if (y_array != null)
;                               p.be(0, NUL);
;                           p = p.plus(1);
                            ;; A trailing '\n' makes the register linewise.
;                           if (p.at(0) == NUL)
;                           {
;                               y_type = MLINE;
;                               break;
;                           }
;                       }
;                   }
;                   if (y_array != null)
;                       break;
;                   y_array = new Bytes[y_size];
;               }
;           }
;           else
;           {
;               y_size = 1;         ;; use fake one-line yank register
;               y_array = new Bytes[] { insert_string[0] };
;           }
;       }
;       else
;       {
;           get_yank_register(regname, false);

;           y_type = @y_current.y_type;
;           y_width = @y_current.y_width;
;           y_size = @y_current.y_size;
;           y_array = @y_current.y_array;
;       }

;       theend:
;       {
;           if (y_type == MLINE)
;           {
;               if ((flags & PUT_LINE_SPLIT) != 0)
;               {
                    ;; "p" or "P" in Visual mode: split the lines to put the text in between.
;                   if (!u_save_cursor())
;                       break theend;

;                   Bytes p = STRDUP(ml_get_cursor());
;                   ml_append(@curwin.w_cursor.lnum, p, 0, false);
;                   p = STRNDUP(ml_get_curline(), @curwin.w_cursor.col);
;                   ml_replace(@curwin.w_cursor.lnum, p, false);
;                   nr_lines++;
;                   dir = FORWARD;
;               }
;               if ((flags & PUT_LINE_FORWARD) != 0)
;               {
                    ;; Must be "p" for a Visual block, put lines below the block.
;                   COPY_pos(@curwin.w_cursor, @curbuf.b_visual.vi_end);
;                   dir = FORWARD;
;               }
;               COPY_pos(@curbuf.b_op_start, @curwin.w_cursor);   ;; default for '[ mark
;               COPY_pos(@curbuf.b_op_end, @curwin.w_cursor);     ;; default for '] mark
;           }

;           if ((flags & PUT_LINE) != 0)        ;; :put command or "p" in Visual line mode.
;               y_type = MLINE;

;           if (y_size == 0 || y_array == null)
;           {
;               emsg2(u8("E353: Nothing in register %s"), (regname == 0) ? u8("\"") : transchar(regname));
;               break theend;
;           }

;           long lnum;
;           if (y_type == MBLOCK)
;           {
;               lnum = @curwin.w_cursor.lnum + y_size + 1;
;               if (lnum > @curbuf.b_ml.ml_line_count)
;                   lnum = @curbuf.b_ml.ml_line_count + 1;
;               if (!u_save(@curwin.w_cursor.lnum - 1, lnum))
;                   break theend;
;           }
;           else if (y_type == MLINE)
;           {
;               lnum = @curwin.w_cursor.lnum;
;               if (dir == FORWARD)
;                   lnum++;
                ;; In an empty buffer the empty line is going to be replaced,
                ;; include it in the saved lines.
;               if (bufempty() ? !u_save(0, 2) : !u_save(lnum - 1, lnum))
;                   break theend;
;           }
;           else if (!u_save_cursor())
;               break theend;

;           int yanklen = STRLEN(y_array[0]);

;           if (@ve_flags == VE_ALL && y_type == MCHAR)
;           {
;               if (gchar_cursor() == TAB)
;               {
                    ;; Don't need to insert spaces when "p" on the last position
                    ;; of a tab or "P" on the first position.
;                   if (dir == FORWARD
;                           ? @curwin.w_cursor.coladd < @curbuf.@b_p_ts - 1 : 0 < @curwin.w_cursor.coladd)
;                       coladvance_force(getviscol());
;                   else
;                       @curwin.w_cursor.coladd = 0;
;               }
;               else if (0 < @curwin.w_cursor.coladd || gchar_cursor() == NUL)
;                   coladvance_force(getviscol() + (dir == FORWARD ? 1 : 0));
;           }

;           lnum = @curwin.w_cursor.lnum;
;           int[] col = { @curwin.w_cursor.col };

            ;; Block mode

;           if (y_type == MBLOCK)
;           {
;               block_def_C bd = §_block_def_C();
;               int c = gchar_cursor();
;               int[] endcol2 = { 0 };

;               if (dir == FORWARD && c != NUL)
;               {
;                   if (@ve_flags == VE_ALL)
;                       getvcol(@curwin, @curwin.w_cursor, col, null, endcol2);
;                   else
;                       getvcol(@curwin, @curwin.w_cursor, null, null, col);

                    ;; move to start of next multi-byte character
;                   @curwin.w_cursor.col += us_ptr2len_cc(ml_get_cursor());

;                   col[0]++;
;               }
;               else
;                   getvcol(@curwin, @curwin.w_cursor, col, null, endcol2);

;               col[0] += @curwin.w_cursor.coladd;
;               if (@ve_flags == VE_ALL && (0 < @curwin.w_cursor.coladd || endcol2[0] == @curwin.w_cursor.col))
;               {
;                   if (dir == FORWARD && c == NUL)
;                       col[0]++;
;                   if (dir != FORWARD && c != NUL)
;                       @curwin.w_cursor.col++;
;                   if (c == TAB)
;                   {
;                       if (dir == BACKWARD && 0 < @curwin.w_cursor.col)
;                           @curwin.w_cursor.col--;
;                       if (dir == FORWARD && col[0] - 1 == endcol2[0])
;                           @curwin.w_cursor.col++;
;                   }
;               }
;               @curwin.w_cursor.coladd = 0;
;               bd.textcol = 0;
;               for (int i = 0; i < y_size; i++)
;               {
;                   bd.startspaces = 0;
;                   bd.endspaces = 0;
;                   int vcol = 0;
;                   int delcount = 0;

                    ;; add a new line
;                   if (@curbuf.b_ml.ml_line_count < @curwin.w_cursor.lnum)
;                   {
;                       if (!ml_append(@curbuf.b_ml.ml_line_count, u8(""), 1, false))
;                           break;
;                       nr_lines++;
;                   }
                    ;; get the old line and advance to the position to insert at
;                   Bytes oldp = ml_get_curline();
;                   int oldlen = STRLEN(oldp);
;                   Bytes[] pp = new Bytes[1];
;                   for (pp[0] = oldp; vcol < col[0] && pp[0].at(0) != NUL; )
;                   {
                        ;; Count a tab for what it's worth (if list mode not on).
;                       incr = lbr_chartabsize_adv(oldp, pp, vcol);
;                       vcol += incr;
;                   }
;                   bd.textcol = BDIFF(pp[0], oldp);

;                   boolean shortline = (vcol < col[0]) || (vcol == col[0] && pp[0].at(0) == NUL);

;                   if (vcol < col[0]) ;; line too short, padd with spaces
;                       bd.startspaces = col[0] - vcol;
;                   else if (col[0] < vcol)
;                   {
;                       bd.endspaces = vcol - col[0];
;                       bd.startspaces = incr - bd.endspaces;
;                       --bd.textcol;
;                       delcount = 1;
;                       bd.textcol -= us_head_off(oldp, oldp.plus(bd.textcol));
;                       if (oldp.at(bd.textcol) != TAB)
;                       {
                            ;; Only a Tab can be split into spaces.
                            ;; Other characters will have to be moved to after the block,
                            ;; causing misalignment.
;                           delcount = 0;
;                           bd.endspaces = 0;
;                       }
;                   }

;                   yanklen = STRLEN(y_array[i]);

                    ;; calculate number of spaces required to fill right side of block
;                   int spaces = y_width + 1;
;                   for (int j = 0; j < yanklen; j++)
;                       spaces -= lbr_chartabsize(null, y_array[i].plus(j), 0);
;                   if (spaces < 0)
;                       spaces = 0;

                    ;; insert the new text
;                   totlen = count * (yanklen + spaces) + bd.startspaces + bd.endspaces;
;                   Bytes newp = new Bytes(totlen + oldlen + 1);

                    ;; copy part up to cursor to new line
;                   Bytes p = newp;
;                   BCOPY(p, oldp, bd.textcol);
;                   p = p.plus(bd.textcol);
                    ;; may insert some spaces before the new text
;                   copy_spaces(p, bd.startspaces);
;                   p = p.plus(bd.startspaces);
                    ;; insert the new text
;                   for (int j = 0; j < count; j++)
;                   {
;                       BCOPY(p, y_array[i], yanklen);
;                       p = p.plus(yanklen);

                        ;; insert block's trailing spaces only if there's text behind
;                       if ((j < count - 1 || !shortline) && spaces != 0)
;                       {
;                           copy_spaces(p, spaces);
;                           p = p.plus(spaces);
;                       }
;                   }
                    ;; may insert some spaces after the new text
;                   copy_spaces(p, bd.endspaces);
;                   p = p.plus(bd.endspaces);
                    ;; move the text after the cursor to the end of the line.
;                   BCOPY(p, 0, oldp, bd.textcol + delcount, oldlen - bd.textcol - delcount + 1);
;                   ml_replace(@curwin.w_cursor.lnum, newp, false);

;                   @curwin.w_cursor.lnum++;
;                   if (i == 0)
;                       @curwin.w_cursor.col += bd.startspaces;
;               }

;               changed_lines(lnum, 0, @curwin.w_cursor.lnum, nr_lines);

                ;; Set '[ mark.
;               COPY_pos(@curbuf.b_op_start, @curwin.w_cursor);
;               @curbuf.b_op_start.lnum = lnum;

                ;; Adjust '] mark.
;               @curbuf.b_op_end.lnum = @curwin.w_cursor.lnum - 1;
;               @curbuf.b_op_end.col = bd.textcol + totlen - 1;
;               @curbuf.b_op_end.coladd = 0;
;               if ((flags & PUT_CURSEND) != 0)
;               {
;                   COPY_pos(@curwin.w_cursor, @curbuf.b_op_end);
;                   @curwin.w_cursor.col++;

                    ;; in Insert mode we might be after the NUL, correct for that
;                   int len = STRLEN(ml_get_curline());
;                   if (@curwin.w_cursor.col > len)
;                       @curwin.w_cursor.col = len;
;               }
;               else
;                   @curwin.w_cursor.lnum = lnum;
;           }
;           else
;           {
                ;; Character or Line mode

;               if (y_type == MCHAR)
;               {
                    ;; if type is MCHAR, FORWARD is the same as BACKWARD on the next char
;                   if (dir == FORWARD && gchar_cursor() != NUL)
;                   {
;                       int bytelen = us_ptr2len_cc(ml_get_cursor());

                        ;; put it on the next of the multi-byte character.
;                       col[0] += bytelen;
;                       if (yanklen != 0)
;                       {
;                           @curwin.w_cursor.col += bytelen;
;                           @curbuf.b_op_end.col += bytelen;
;                       }
;                   }
;                   COPY_pos(@curbuf.b_op_start, @curwin.w_cursor);
;               }

                ;; Line mode: BACKWARD is the same as FORWARD on the previous line

;               else if (dir == BACKWARD)
;                   --lnum;

;               pos_C new_cursor = §_pos_C();
;               COPY_pos(new_cursor, @curwin.w_cursor);

                ;; simple case: insert into current line

;               if (y_type == MCHAR && y_size == 1)
;               {
;                   do
;                   {
;                       totlen = count * yanklen;
;                       if (0 < totlen)
;                       {
;                           Bytes oldp = ml_get(lnum);
;                           Bytes newp = new Bytes(STRLEN(oldp) + totlen + 1);

;                           BCOPY(newp, oldp, col[0]);
;                           Bytes p = newp.plus(col[0]);
;                           for (long i = 0; i < count; i++)
;                           {
;                               BCOPY(p, y_array[0], yanklen);
;                               p = p.plus(yanklen);
;                           }
;                           BCOPY(p, 0, oldp, col[0], STRLEN(oldp, col[0]) + 1);
;                           ml_replace(lnum, newp, false);
                            ;; Place cursor on last putted char.
;                           if (lnum == @curwin.w_cursor.lnum)
;                           {
                                ;; make sure curwin.w_virtcol is updated
;                               changed_cline_bef_curs();
;                               @curwin.w_cursor.col += totlen - 1;
;                           }
;                       }
;                       if (@VIsual_active)
;                           lnum++;
;                   } while (@VIsual_active && lnum <= @curbuf.b_visual.vi_end.lnum);

;                   if (@VIsual_active) ;; reset lnum to the last visual line
;                       lnum--;

;                   COPY_pos(@curbuf.b_op_end, @curwin.w_cursor);
                    ;; For "CTRL-O p" in Insert mode, put cursor after last char.
;                   if (totlen != 0 && (@restart_edit != 0 || (flags & PUT_CURSEND) != 0))
;                       @curwin.w_cursor.col++;
;                   changed_bytes(lnum, col[0]);
;               }
;               else
;               {
                    ;; Insert at least one line.  When y_type is MCHAR, break the first line in two.

;                   error:
;                   for (long cnt = 1; cnt <= count; cnt++)
;                   {
;                       int i = 0;
;                       if (y_type == MCHAR)
;                       {
                            ;; Split the current line in two at the insert position.
                            ;; First insert y_array[size - 1] in front of second line.
                            ;; Then append y_array[0] to first line.

;                           lnum = new_cursor.lnum;
;                           Bytes p = ml_get(lnum).plus(col[0]);
;                           totlen = STRLEN(y_array[y_size - 1]);
;                           Bytes newp = new Bytes(STRLEN(p) + totlen + 1);
;                           STRCPY(newp, y_array[y_size - 1]);
;                           STRCAT(newp, p);
                            ;; insert second line
;                           ml_append(lnum, newp, 0, false);

;                           Bytes oldp = ml_get(lnum);
;                           newp = new Bytes(col[0] + yanklen + 1);
                            ;; copy first part of line
;                           BCOPY(newp, oldp, col[0]);
                            ;; append to first line
;                           BCOPY(newp, col[0], y_array[0], 0, yanklen + 1);
;                           ml_replace(lnum, newp, false);

;                           @curwin.w_cursor.lnum = lnum;
;                           i = 1;
;                       }

;                       for ( ; i < y_size; i++)
;                       {
;                           if ((y_type != MCHAR || i < y_size - 1) && !ml_append(lnum, y_array[i], 0, false))
;                               break error;
;                           lnum++;
;                           nr_lines++;
;                           if ((flags & PUT_FIXINDENT) != 0)
;                           {
;                               pos_C old_pos = §_pos_C();
;                               COPY_pos(old_pos, @curwin.w_cursor);
;                               @curwin.w_cursor.lnum = lnum;
;                               Bytes p = ml_get(lnum);
;                               if (cnt == count && i == y_size - 1)
;                                   lendiff = STRLEN(p);
;                               int indent;
;                               if (p.at(0) == (byte)'#' && preprocs_left())
;                                   indent = 0;     ;; leave # lines at start
;                               else if (p.at(0) == NUL)
;                                   indent = 0;     ;; ignore empty lines
;                               else if (first_indent)
;                               {
;                                   indent_diff = orig_indent - get_indent();
;                                   indent = orig_indent;
;                                   first_indent = false;
;                               }
;                               else if ((indent = get_indent() + indent_diff) < 0)
;                                   indent = 0;
;                               set_indent(indent, 0);
;                               COPY_pos(@curwin.w_cursor, old_pos);
                                ;; remember how many chars were removed
;                               if (cnt == count && i == y_size - 1)
;                                   lendiff -= STRLEN(ml_get(lnum));
;                           }
;                       }
;                   }

                    ;; Adjust marks.
;                   if (y_type == MLINE)
;                   {
;                       @curbuf.b_op_start.col = 0;
;                       if (dir == FORWARD)
;                           @curbuf.b_op_start.lnum++;
;                   }
;                   mark_adjust(@curbuf.b_op_start.lnum + (y_type == MCHAR ? 1 : 0), MAXLNUM, nr_lines, 0L);

                    ;; note changed text for displaying and folding
;                   if (y_type == MCHAR)
;                       changed_lines(@curwin.w_cursor.lnum, col[0], @curwin.w_cursor.lnum + 1, nr_lines);
;                   else
;                       changed_lines(@curbuf.b_op_start.lnum, 0, @curbuf.b_op_start.lnum, nr_lines);

                    ;; put '] mark at last inserted character
;                   @curbuf.b_op_end.lnum = lnum;
                    ;; correct length for change in indent
;                   col[0] = STRLEN(y_array[y_size - 1]) - lendiff;
;                   if (1 < col[0])
;                       @curbuf.b_op_end.col = col[0] - 1;
;                   else
;                       @curbuf.b_op_end.col = 0;

;                   if ((flags & PUT_CURSLINE) != 0)
;                   {
                        ;; ":put": put cursor on last inserted line
;                       @curwin.w_cursor.lnum = lnum;
;                       beginline(BL_WHITE | BL_FIX);
;                   }
;                   else if ((flags & PUT_CURSEND) != 0)
;                   {
                        ;; put cursor after inserted text
;                       if (y_type == MLINE)
;                       {
;                           if (@curbuf.b_ml.ml_line_count <= lnum)
;                               @curwin.w_cursor.lnum = @curbuf.b_ml.ml_line_count;
;                           else
;                               @curwin.w_cursor.lnum = lnum + 1;
;                           @curwin.w_cursor.col = 0;
;                       }
;                       else
;                       {
;                           @curwin.w_cursor.lnum = lnum;
;                           @curwin.w_cursor.col = col[0];
;                       }
;                   }
;                   else if (y_type == MLINE)
;                   {
                        ;; put cursor on first non-blank in first inserted line
;                       @curwin.w_cursor.col = 0;
;                       if (dir == FORWARD)
;                           @curwin.w_cursor.lnum++;
;                       beginline(BL_WHITE | BL_FIX);
;                   }
;                   else        ;; put cursor on first inserted character
;                       COPY_pos(@curwin.w_cursor, new_cursor);
;               }
;           }

;           msgmore(nr_lines);
;           @curwin.w_set_curswant = true;
;       }

;       @VIsual_active = false;

        ;; If the cursor is past the end of the line put it at the end.
;       adjust_cursor_eol();
    ))

;; When the cursor is on the NUL past the end of the line
;; and it should not be there, move it left.

(defn- #_void adjust_cursor_eol []
    (§
;       if (0 < @curwin.w_cursor.col
;               && gchar_cursor() == NUL
;               && (@ve_flags & VE_ONEMORE) == 0
;               && @restart_edit == 0 && (@State & INSERT) == 0)
;       {
            ;; Put the cursor on the last character in the line.
;           dec_cursor();

;           if (@ve_flags == VE_ALL)
;           {
;               int[] scol = new int[1];
;               int[] ecol = new int[1];

                ;; Coladd is set to the width of the last character.
;               getvcol(@curwin, @curwin.w_cursor, scol, null, ecol);
;               @curwin.w_cursor.coladd = ecol[0] - scol[0] + 1;
;           }
;       }
    ))

;; Return true if lines starting with '#' should be left aligned.

(defn- #_boolean preprocs_left []
    (§
;       return (@curbuf.@b_p_si && !@curbuf.@b_p_cin)
;           || (@curbuf.@b_p_cin && in_cinkeys('#', ' ', true) && @curbuf.b_ind_hash_comment == 0);
    ))

;; Return the character name of the register with the given number.
(defn- #_int get_register_name [#_int num]
    (§
;       if (num == -1)
;           return '"';
;       else if (num < 10)
;           return num + '0';
;       else if (num == DELETION_REGISTER)
;           return '-';
;       else if (num == STAR_REGISTER)
;           return '*';
;       else if (num == PLUS_REGISTER)
;           return '+';
;       else
;           return num + 'a' - 10;
    ))

;; ":dis" and ":registers": Display the contents of the yank registers.

(defn- #_void ex_display [#_exarg_C eap]
    (§
;       Bytes arg = eap.arg;
;       if (arg != null && arg.at(0) == NUL)
;           arg = null;
;       int attr = hl_attr(HLF_8);

            ;; Highlight title.
;       msg_puts_title(u8("\n--- Registers ---"));

;       for (int i = -1; i < NUM_REGISTERS && !@got_int; i++)
;       {
;           int name = get_register_name(i);
;           if (arg != null && vim_strchr(arg, name) == null)
;               continue;       ;; did not ask for this register

                ;; Adjust register name for "unnamed" in 'clipboard'.
                ;; When it's a clipboard register, fill it with the current contents of the clipboard.
;           name = adjust_clip_reg(name);
;           may_get_selection(name);

;           yankreg_C yb;
;           if (i == -1)
;           {
;               if (@y_previous != null)
;                   yb = @y_previous;
;               else
;                   yb = y_regs[0];
;           }
;           else
;               yb = y_regs[i];

;           if (yb.y_array != null)
;           {
;               msg_putchar('\n');
;               msg_putchar('"');
;               msg_putchar(name);
;               msg_puts(u8("   "));

;               int n = (int)@Columns - 6;
;               for (int j = 0; j < yb.y_size && 1 < n; j++)
;               {
;                   if (j != 0)
;                   {
;                       msg_puts_attr(u8("^J"), attr);
;                       n -= 2;
;                   }

;                   for (Bytes p = yb.y_array[j]; p.at(0) != NUL && 0 <= (n -= mb_ptr2cells(p)); p = p.plus(1))
;                   {
;                       int clen = us_ptr2len_cc(p);
;                       msg_outtrans_len(p, clen);
;                       p = p.plus(clen - 1);
;                   }
;               }
;               if (1 < n && yb.y_type == MLINE)
;                   msg_puts_attr(u8("^J"), attr);
;               out_flush();                    ;; show one line at a time
;           }
;           ui_breakcheck();
;       }

            ;; display last inserted text

;       Bytes p = get_last_insert();
;       if (p != null && (arg == null || vim_strchr(arg, '.') != null) && !@got_int)
;       {
;           msg_puts(u8("\n\".   "));
;           dis_msg(p, true);
;       }

            ;; display last command line

;       if (@last_cmdline != null && (arg == null || vim_strchr(arg, ':') != null) && !@got_int)
;       {
;           msg_puts(u8("\n\":   "));
;           dis_msg(@last_cmdline, false);
;       }

            ;; display last search pattern

;       p = last_search_pat();
;       if (p != null && (arg == null || vim_strchr(arg, '/') != null) && !@got_int)
;       {
;           msg_puts(u8("\n\"/   "));
;           dis_msg(p, false);
;       }

            ;; display last used expression

;       if (@expr_line != null && (arg == null || vim_strchr(arg, '=') != null) && !@got_int)
;       {
;           msg_puts(u8("\n\"=   "));
;           dis_msg(@expr_line, false);
;       }
    ))

;; display a string for do_dis()
;; truncate at end of screen line

(defn- #_void dis_msg [#_Bytes p, #_boolean skip_esc]
    ;; skip_esc: if true, ignore trailing ESC
    (§
;       int n = (int)@Columns - 6;
;       while (p.at(0) != NUL && !(p.at(0) == ESC && skip_esc && p.at(1) == NUL) && 0 <= (n -= mb_ptr2cells(p)))
;       {
;           int len = us_ptr2len_cc(p);
;           if (1 < len)
;           {
;               msg_outtrans_len(p, len);
;               p = p.plus(len);
;           }
;           else
;           {
;               msg_outtrans_len(p, 1);
;               p = p.plus(1);
;           }
;       }
;       ui_breakcheck();
    ))

;; If "process" is true and the line begins with a comment leader (possibly
;; after some white space), return a pointer to the text after it.  Put a boolean
;; value indicating whether the line ends with an unclosed comment in "is_comment".
;; line - line to be processed,
;; process - if false, will only check whether the line ends with an unclosed comment,
;; include_space - whether to also skip space following the comment leader,
;; is_comment - will indicate whether the current line ends with an unclosed comment.

(defn- #_Bytes skip_comment [#_Bytes line, #_boolean process, #_boolean include_space, #_boolean* is_comment]
    (§
;       Bytes[] flags = { null };
;       int leader_offset = get_last_leader_offset(line, flags);

;       is_comment[0] = false;
;       if (leader_offset != -1)
;       {
            ;; Let's check whether the line ends with an unclosed comment.
            ;; If the last comment leader has COM_END in flags, there's no comment.

;           while (flags[0].at(0) != NUL)
;           {
;               if (flags[0].at(0) == COM_END || flags[0].at(0) == (byte)':')
;                   break;
;               flags[0] = flags[0].plus(1);
;           }
;           if (flags[0].at(0) != COM_END)
;               is_comment[0] = true;
;       }

;       if (process == false)
;           return line;

;       int lead_len = get_leader_len(line, flags, false, include_space);
;       if (lead_len == 0)
;           return line;

        ;; Find:
        ;; - COM_END,
        ;; - colon,
        ;; whichever comes first.

;       while (flags[0].at(0) != NUL)
;       {
;           if (flags[0].at(0) == COM_END || flags[0].at(0) == (byte)':')
;               break;
;           flags[0] = flags[0].plus(1);
;       }

        ;; If we found a colon, it means that we are not processing a line
        ;; starting with a closing part of a three-part comment.  That's good,
        ;; because we don't want to remove those as this would be annoying.

;       if (flags[0].at(0) == (byte)':' || flags[0].at(0) == NUL)
;           line = line.plus(lead_len);

;       return line;
    ))

;; Join 'count' lines (minimal 2) at cursor position.
;; When "save_undo" is true save lines for undo first.
;; Set "use_formatoptions" to false when e.g. processing backspace and comment
;; leaders should not be removed.
;; When setmark is true, sets the '[ and '] mark, else, the caller is expected
;; to set those marks.
;;
;; return false for failure, true otherwise

(defn- #_boolean do_join [#_int count, #_boolean insert_space, #_boolean save_undo, #_boolean use_formatoptions, #_boolean setmark]
    (§
;       boolean retval = true;

;       Bytes curr = null;
;       Bytes curr_start = null;
;       int endcurr1 = NUL;
;       int endcurr2 = NUL;
;       int currsize = 0;               ;; size of the current line
;       int sumsize = 0;                ;; size of the long new line
;       int col = 0;

;       boolean remove_comments = (use_formatoptions == true) && has_format_option(FO_REMOVE_COMS);

;       if (save_undo && !u_save(@curwin.w_cursor.lnum - 1, @curwin.w_cursor.lnum + count))
;           return false;

        ;; Allocate an array to store the number of spaces inserted before each line.
        ;; We will use it to pre-compute the length of the new line and the
        ;; proper placement of each original line in the new one.
;       int[] spaces = new int[count];

;       int[] comments = null;
;       if (remove_comments)
;           comments = new int[count];

        ;; Don't move anything, just compute the final line length
        ;; and setup the array of space strings lengths.

;       for (int t = 0; t < count; t++)
;       {
;           curr = curr_start = ml_get(@curwin.w_cursor.lnum + t);
;           if (t == 0 && setmark)
;           {
                ;; Set the '[ mark.
;               @curwin.w_buffer.b_op_start.lnum = @curwin.w_cursor.lnum;
;               @curwin.w_buffer.b_op_start.col  = STRLEN(curr);
;           }
;           if (remove_comments)
;           {
;               boolean[] prev_was_comment = new boolean[1];

                ;; We don't want to remove the comment leader if the previous line is not a comment.
;               if (0 < t && prev_was_comment[0])
;               {
;                   Bytes new_curr = skip_comment(curr, true, insert_space, prev_was_comment);
;                   comments[t] = BDIFF(new_curr, curr);
;                   curr = new_curr;
;               }
;               else
;                   curr = skip_comment(curr, false, insert_space, prev_was_comment);
;           }

;           if (insert_space && 0 < t)
;           {
;               curr = skipwhite(curr);
;               if (curr.at(0) != (byte)')' && currsize != 0 && endcurr1 != TAB
;                       && (!has_format_option(FO_MBYTE_JOIN)
;                           || (us_ptr2char(curr) < 0x100 && endcurr1 < 0x100))
;                       && (!has_format_option(FO_MBYTE_JOIN2)
;                           || us_ptr2char(curr) < 0x100 || endcurr1 < 0x100))
;               {
                    ;; don't add a space if the line is ending in a space
;                   if (endcurr1 == ' ')
;                       endcurr1 = endcurr2;
;                   else
;                       ++spaces[t];
                    ;; extra space when 'joinspaces' set and line ends in '.'
;                   if (@p_js
;                           && (endcurr1 == '.'
;                               || (vim_strbyte(@p_cpo, CPO_JOINSP) == null
;                                   && (endcurr1 == '?' || endcurr1 == '!'))))
;                       ++spaces[t];
;               }
;           }
;           currsize = STRLEN(curr);
;           sumsize += currsize + spaces[t];
;           endcurr1 = endcurr2 = NUL;
;           if (insert_space && 0 < currsize)
;           {
;               Bytes cend = curr.plus(currsize);
;               cend = cend.minus(us_ptr_back(curr, cend));
;               endcurr1 = us_ptr2char(cend);
;               if (BLT(curr, cend))
;               {
;                   cend = cend.minus(us_ptr_back(curr, cend));
;                   endcurr2 = us_ptr2char(cend);
;               }
;           }
;           line_breakcheck();
;           if (@got_int)
;               return false;
;       }

        ;; store the column position before last line
;       col = sumsize - currsize - spaces[count - 1];

        ;; allocate the space for the new line
;       Bytes newp = new Bytes(sumsize + 1);
;       Bytes cend = newp.plus(sumsize);
;       cend.be(0, NUL);

        ;; Move affected lines to the new long one.
        ;;
        ;; Move marks from each deleted line to the joined line, adjusting the
        ;; column.  This is not Vi compatible, but Vi deletes the marks, thus that
        ;; should not really be a problem.

;       for (int t = count - 1; ; --t)
;       {
;           cend = cend.minus(currsize);
;           BCOPY(cend, curr, currsize);
;           if (0 < spaces[t])
;           {
;               cend = cend.minus(spaces[t]);
;               copy_spaces(cend, spaces[t]);
;           }
;           mark_col_adjust(@curwin.w_cursor.lnum + t, 0, (long)-t,
;                            (long)(BDIFF(cend, newp) + spaces[t] - BDIFF(curr, curr_start)));
;           if (t == 0)
;               break;
;           curr = curr_start = ml_get(@curwin.w_cursor.lnum + t - 1);
;           if (remove_comments)
;               curr = curr.plus(comments[t - 1]);
;           if (insert_space && 1 < t)
;               curr = skipwhite(curr);
;           currsize = STRLEN(curr);
;       }
;       ml_replace(@curwin.w_cursor.lnum, newp, false);

;       if (setmark)
;       {
            ;; Set the '] mark.
;           @curwin.w_buffer.b_op_end.lnum = @curwin.w_cursor.lnum;
;           @curwin.w_buffer.b_op_end.col  = STRLEN(newp);
;       }

        ;; Only report the change in the first line here,
        ;; del_lines() will report the deleted line.
;       changed_lines(@curwin.w_cursor.lnum, currsize, @curwin.w_cursor.lnum + 1, 0L);

        ;; Delete following lines.  To do this we move the cursor there
        ;; briefly, and then move it back.  After del_lines() the cursor may
        ;; have moved up (last line deleted), so the current lnum is kept in t.

;       long t = @curwin.w_cursor.lnum;
;       @curwin.w_cursor.lnum++;
;       del_lines(count - 1, false);
;       @curwin.w_cursor.lnum = t;

        ;; Set the cursor column:
        ;; Vi compatible: use the column of the first join
        ;; vim:           use the column of the last join

;       @curwin.w_cursor.col = (vim_strbyte(@p_cpo, CPO_JOINCOL) != null) ? currsize : col;
;       check_cursor_col();

;       @curwin.w_cursor.coladd = 0;
;       @curwin.w_set_curswant = true;

;       return retval;
    ))

;; Return true if the two comment leaders given are the same.
;; "lnum" is the first line.  White-space is ignored.
;; Note that the whole of 'leader1' must match 'leader2_len' characters from 'leader2'.

(defn- #_boolean same_leader [#_long lnum, #_int leader1_len, #_Bytes leader1_flags, #_int leader2_len, #_Bytes leader2_flags]
    (§
;       int idx1 = 0, idx2 = 0;

;       if (leader1_len == 0)
;           return (leader2_len == 0);

        ;; If first leader has 'f' flag, the lines can be joined only
        ;; if the second line does not have a leader.
        ;; If first leader has 'e' flag, the lines can never be joined.
        ;; If first leader has 's' flag, the lines can only be joined
        ;; if there is some text after it and the second line has the 'm' flag.

;       if (leader1_flags != null)
;       {
;           for (Bytes p = leader1_flags; p.at(0) != NUL && p.at(0) != (byte)':'; p = p.plus(1))
;           {
;               if (p.at(0) == COM_FIRST)
;                   return (leader2_len == 0);
;               if (p.at(0) == COM_END)
;                   return false;
;               if (p.at(0) == COM_START)
;               {
;                   if (ml_get(lnum).at(leader1_len) == NUL)
;                       return false;
;                   if (leader2_flags == null || leader2_len == 0)
;                       return false;
;                   for (p = leader2_flags; p.at(0) != NUL && p.at(0) != (byte)':'; p = p.plus(1))
;                       if (p.at(0) == COM_MIDDLE)
;                           return true;

;                   return false;
;               }
;           }
;       }

        ;; Get current line and next line, compare the leaders.
        ;; The first line has to be saved, only one line can be locked at a time.

;       Bytes line1 = STRDUP(ml_get(lnum));

;       for (idx1 = 0; vim_iswhite(line1.at(idx1)); ++idx1)
        ;
;       Bytes line2 = ml_get(lnum + 1);
;       for (idx2 = 0; idx2 < leader2_len; ++idx2)
;       {
;           if (!vim_iswhite(line2.at(idx2)))
;           {
;               if (line1.at(idx1++) != line2.at(idx2))
;                   break;
;           }
;           else
;               while (vim_iswhite(line1.at(idx1)))
;                   idx1++;
;       }

;       return (idx2 == leader2_len && idx1 == leader1_len);
    ))

;; Implementation of the format operator 'gq'.

(defn- #_void op_format [#_oparg_C oap, #_boolean keep_cursor]
    ;; keep_cursor: keep cursor on same text char
    (§
;       long old_line_count = @curbuf.b_ml.ml_line_count;

        ;; Place the cursor where the "gq" or "gw" command was given, so that "u" can put it back there.
;       COPY_pos(@curwin.w_cursor, oap.cursor_start);

;       if (!u_save(oap.op_start.lnum - 1, oap.op_end.lnum + 1))
;           return;
;       COPY_pos(@curwin.w_cursor, oap.op_start);

;       if (oap.is_VIsual)
            ;; When there is no change: need to remove the Visual selection.
;           redraw_curbuf_later(INVERTED);

        ;; Set '[ mark at the start of the formatted area.
;       COPY_pos(@curbuf.b_op_start, oap.op_start);

        ;; For "gw" remember the cursor position and put it back below (adjusted for joined and split lines).
;       if (keep_cursor)
;           COPY_pos(@saved_cursor, oap.cursor_start);

;       format_lines(oap.line_count, keep_cursor);

        ;; Leave the cursor at the first non-blank of the last formatted line.
        ;; If the cursor was moved one line back (e.g. with "Q}") go to the next line,
        ;; so "." will do the next lines.

;       if (oap.end_adjusted && @curwin.w_cursor.lnum < @curbuf.b_ml.ml_line_count)
;           @curwin.w_cursor.lnum++;
;       beginline(BL_WHITE | BL_FIX);
;       old_line_count = @curbuf.b_ml.ml_line_count - old_line_count;
;       msgmore(old_line_count);

        ;; put '] mark on the end of the formatted area
;       COPY_pos(@curbuf.b_op_end, @curwin.w_cursor);

;       if (keep_cursor)
;       {
;           COPY_pos(@curwin.w_cursor, @saved_cursor);
;           @saved_cursor.lnum = 0;
;       }

;       if (oap.is_VIsual)
;       {
;           for (window_C wp = @firstwin; wp != null; wp = wp.w_next)
;           {
;               if (wp.w_old_cursor_lnum != 0)
;               {
                    ;; When lines have been inserted or deleted,
                    ;; adjust the end of the Visual area to be redrawn.
;                   if (wp.w_old_visual_lnum < wp.w_old_cursor_lnum)
;                       wp.w_old_cursor_lnum += old_line_count;
;                   else
;                       wp.w_old_visual_lnum += old_line_count;
;               }
;           }
;       }
    ))

;; Format "line_count" lines, starting at the cursor position.
;; When "line_count" is negative, format until the end of the paragraph.
;; Lines after the cursor line are saved for undo, caller must have saved the first line.

(defn- #_void format_lines [#_long line_count, #_boolean avoid_fex]
    ;; avoid_fex: don't use 'formatexpr'
    (§
;       boolean prev_is_end_par = false;        ;; prev. line not part of parag.
;       boolean next_is_start_par = false;
;       boolean do_comments_list = false;               ;; format comments with 'n' or '2'
;       boolean advance = true;
;       int second_indent = -1;                 ;; indent for second line (comment aware)
;       boolean first_par_line = true;
;       boolean need_set_indent = true;         ;; set indent of next paragraph
;       boolean force_format = false;

;       int old_State = @State;

        ;; length of a line to force formatting: 3 * 'tw'
;       int max_len = comp_textwidth(true) * 3;

        ;; check for 'q', '2' and '1' in 'formatoptions'
;       boolean do_comments = has_format_option(FO_Q_COMS);         ;; format comments
;       boolean do_second_indent = has_format_option(FO_Q_SECOND);
;       boolean do_number_indent = has_format_option(FO_Q_NUMBER);
;       boolean do_trail_white = has_format_option(FO_WHITE_PAR);

        ;; Get info about the previous and current line.

;       boolean is_not_par = true;                      ;; current line not part of parag.
;       int[] leader_len = { 0 };                       ;; leader len of current line
;       Bytes[] leader_flags = { null };                ;; flags for leader of current line
;       if (1 < @curwin.w_cursor.lnum)
;           is_not_par = fmt_check_par(@curwin.w_cursor.lnum - 1, leader_len, leader_flags, do_comments);

;       boolean next_is_not_par;                        ;; next line not part of paragraph
;       int[] next_leader_len = new int[1];             ;; leader len of next line
;       Bytes[] next_leader_flags = new Bytes[1];       ;; flags for leader of next line
;       next_is_not_par = fmt_check_par(@curwin.w_cursor.lnum, next_leader_len, next_leader_flags, do_comments);

;       boolean is_end_par = (is_not_par || next_is_not_par);       ;; at end of paragraph
;       if (!is_end_par && do_trail_white)
;           is_end_par = !ends_in_white(@curwin.w_cursor.lnum - 1);

;       --@curwin.w_cursor.lnum;
;       for (long count = line_count; count != 0 && !@got_int; --count)
;       {
            ;; Advance to next paragraph.

;           if (advance)
;           {
;               @curwin.w_cursor.lnum++;
;               prev_is_end_par = is_end_par;
;               is_not_par = next_is_not_par;
;               leader_len[0] = next_leader_len[0];
;               leader_flags[0] = next_leader_flags[0];
;           }

            ;; The last line to be formatted.

;           if (count == 1 || @curwin.w_cursor.lnum == @curbuf.b_ml.ml_line_count)
;           {
;               next_is_not_par = true;
;               next_leader_len[0] = 0;
;               next_leader_flags[0] = null;
;           }
;           else
;           {
;               next_is_not_par = fmt_check_par(@curwin.w_cursor.lnum + 1,
;                                       next_leader_len, next_leader_flags, do_comments);
;               if (do_number_indent)
;                   next_is_start_par = (0 < get_number_indent(@curwin.w_cursor.lnum + 1));
;           }
;           advance = true;
;           is_end_par = (is_not_par || next_is_not_par || next_is_start_par);
;           if (!is_end_par && do_trail_white)
;               is_end_par = !ends_in_white(@curwin.w_cursor.lnum);

            ;; Skip lines that are not in a paragraph.

;           if (is_not_par)
;           {
;               if (line_count < 0)
;                   break;
;           }
;           else
;           {
                ;; For the first line of a paragraph, check indent of second line.
                ;; Don't do this for comments and empty lines.

;               if (first_par_line
;                       && (do_second_indent || do_number_indent)
;                       && prev_is_end_par
;                       && @curwin.w_cursor.lnum < @curbuf.b_ml.ml_line_count)
;               {
;                   if (do_second_indent && !lineempty(@curwin.w_cursor.lnum + 1))
;                   {
;                       if (leader_len[0] == 0 && next_leader_len[0] == 0)
;                       {
                            ;; no comment found
;                           second_indent = get_indent_lnum(@curwin.w_cursor.lnum + 1);
;                       }
;                       else
;                       {
;                           second_indent = next_leader_len[0];
;                           do_comments_list = true;
;                       }
;                   }
;                   else if (do_number_indent)
;                   {
;                       if (leader_len[0] == 0 && next_leader_len[0] == 0)
;                       {
                            ;; no comment found
;                           second_indent = get_number_indent(@curwin.w_cursor.lnum);
;                       }
;                       else
;                       {
                            ;; get_number_indent() is now "comment aware"...
;                           second_indent = get_number_indent(@curwin.w_cursor.lnum);
;                           do_comments_list = true;
;                       }
;                   }
;               }

                ;; When the comment leader changes, it's the end of the paragraph.

;               if (@curbuf.b_ml.ml_line_count <= @curwin.w_cursor.lnum
;                       || !same_leader(@curwin.w_cursor.lnum, leader_len[0], leader_flags[0],
;                                                       next_leader_len[0], next_leader_flags[0]))
;                   is_end_par = true;

                ;; If we have got to the end of a paragraph, or the line is getting long, format it.

;               if (is_end_par || force_format)
;               {
;                   if (need_set_indent)
                        ;; Replace indent in first line with minimal number of tabs and spaces,
                        ;; according to current options.
;                       set_indent(get_indent(), SIN_CHANGED);

                    ;; put cursor on last non-space
;                   @State = NORMAL; ;; don't go past end-of-line
;                   coladvance(MAXCOL);
;                   while (@curwin.w_cursor.col != 0 && vim_isspace(gchar_cursor()))
;                       dec_cursor();

                    ;; do the formatting, without 'showmode'
;                   @State = INSERT; ;; for open_line()
;                   boolean smd_save = @p_smd;
;                   @p_smd = false;
;                   insertchar(NUL, INSCHAR_FORMAT
;                           + (do_comments ? INSCHAR_DO_COM : 0)
;                           + (do_comments && do_comments_list ? INSCHAR_COM_LIST : 0)
;                           + (avoid_fex ? INSCHAR_NO_FEX : 0), second_indent);
;                   @State = old_State;
;                   @p_smd = smd_save;
;                   second_indent = -1;
                    ;; at end of par.: need to set indent of next par.
;                   need_set_indent = is_end_par;
;                   if (is_end_par)
;                   {
                        ;; When called with a negative line count,
                        ;; break at the end of the paragraph.
;                       if (line_count < 0)
;                           break;
;                       first_par_line = true;
;                   }
;                   force_format = false;
;               }

                ;; When still in same paragraph, join the lines together.
                ;; But first delete the leader from the second line.

;               if (!is_end_par)
;               {
;                   advance = false;
;                   @curwin.w_cursor.lnum++;
;                   @curwin.w_cursor.col = 0;
;                   if (line_count < 0 && !u_save_cursor())
;                       break;
;                   if (0 < next_leader_len[0])
;                   {
;                       del_bytes(next_leader_len[0], false, false);
;                       mark_col_adjust(@curwin.w_cursor.lnum, 0, 0L, (long)-next_leader_len[0]);
;                   }
;                   else if (0 < second_indent)     ;; the "leader" for FO_Q_SECOND
;                   {
;                       Bytes p = ml_get_curline();
;                       int indent = BDIFF(skipwhite(p), p);

;                       if (0 < indent)
;                       {
;                           del_bytes(indent, false, false);
;                           mark_col_adjust(@curwin.w_cursor.lnum, 0, 0L, (long)-indent);
;                       }
;                   }
;                   --@curwin.w_cursor.lnum;
;                   if (do_join(2, true, false, false, false) == false)
;                   {
;                       beep_flush();
;                       break;
;                   }
;                   first_par_line = false;
                    ;; If the line is getting long, format it next time.
;                   force_format = (max_len < STRLEN(ml_get_curline()));
;               }
;           }
;           line_breakcheck();
;       }
    ))

;; Return true if line "lnum" ends in a white character.

(defn- #_boolean ends_in_white [#_long lnum]
    (§
;       Bytes s = ml_get(lnum);
;       if (s.at(0) == NUL)
;           return false;

;       return vim_iswhite(s.at(STRLEN(s) - 1));
    ))

;; Blank lines, and lines containing only the comment leader, are left untouched
;; by the formatting.  The function returns true in this case.
;; It also returns true when a line starts with the end of a comment ('e' in comment flags),
;; so that this line is skipped, and not joined to the previous line.
;; A new paragraph starts after a blank line, or when the comment leader changes.

(defn- #_boolean fmt_check_par [#_long lnum, #_int* leader_len, #_Bytes* leader_flags, #_boolean do_comments]
    (§
;       Bytes flags = null;
;       Bytes ptr = ml_get(lnum);
;       if (do_comments)
;           leader_len[0] = get_leader_len(ptr, leader_flags, false, true);
;       else
;           leader_len[0] = 0;

;       if (0 < leader_len[0])
;       {
            ;; Search for 'e' flag in comment leader flags.

;           flags = leader_flags[0];
;           while (flags.at(0) != NUL && flags.at(0) != (byte)':' && flags.at(0) != COM_END)
;               flags = flags.plus(1);
;       }

;       return (skipwhite(ptr.plus(leader_len[0])).at(0) == NUL
;                   || (0 < leader_len[0] && flags.at(0) == COM_END)
;                   || startPS(lnum, NUL, false));
    ))

;; Return true when a paragraph starts in line "lnum".
;; Return false when the previous line is in the same paragraph.
;; Used for auto-formatting.

(defn- #_boolean paragraph_start [#_long lnum]
    (§
;       if (lnum <= 1)
;           return true;                ;; start of the file

;       Bytes p = ml_get(lnum - 1);
;       if (p.at(0) == NUL)
;           return true;                ;; after empty line

;       boolean do_comments = has_format_option(FO_Q_COMS);     ;; format comments

;       int[] leader_len = { 0 };               ;; leader len of current line
;       Bytes[] leader_flags = { null };        ;; flags for leader of current line

;       if (fmt_check_par(lnum - 1, leader_len, leader_flags, do_comments))
;           return true;                ;; after non-paragraph line

;       int[] next_leader_len = new int[1];         ;; leader len of next line
;       Bytes[] next_leader_flags = new Bytes[1];   ;; flags for leader of next line

;       if (fmt_check_par(lnum, next_leader_len, next_leader_flags, do_comments))
;           return true;                ;; "lnum" is not a paragraph line

;       if (has_format_option(FO_WHITE_PAR) && !ends_in_white(lnum - 1))
;           return true;                ;; missing trailing space in previous line.

;       if (has_format_option(FO_Q_NUMBER) && (0 < get_number_indent(lnum)))
;           return true;                ;; numbered item starts in "lnum".

;       if (!same_leader(lnum - 1, leader_len[0], leader_flags[0], next_leader_len[0], next_leader_flags[0]))
;           return true;                ;; change of comment leader.

;       return false;
    ))

;; prepare a few things for block mode yank/delete/tilde
;;
;; for delete:
;; - textlen includes the first/last char to be (partly) deleted
;; - start/endspaces is the number of columns that are taken by the
;;   first/last deleted char minus the number of columns that have to be deleted.
;; for yank and tilde:
;; - textlen includes the first/last char to be wholly yanked
;; - start/endspaces is the number of columns of the first/last yanked char
;;   that are to be yanked.

(defn- #_void block_prep [#_oparg_C oap, #_block_def_C bdp, #_long lnum, #_boolean is_del]
    (§
;       int incr = 0;

;       bdp.startspaces = 0;
;       bdp.endspaces = 0;
;       bdp.textlen = 0;
;       bdp.start_vcol = 0;
;       bdp.end_vcol = 0;
;       bdp.is_short = false;
;       bdp.is_oneChar = false;
;       bdp.pre_whitesp = 0;
;       bdp.pre_whitesp_c = 0;
;       bdp.end_char_vcols = 0;
;       bdp.start_char_vcols = 0;

;       Bytes line = ml_get(lnum);

;       Bytes pstart = line;
;       Bytes prev_pstart = line;

;       while (bdp.start_vcol < oap.start_vcol && pstart.at(0) != NUL)
;       {
            ;; Count a tab for what it's worth (if list mode not on).
;           incr = lbr_chartabsize(line, pstart, bdp.start_vcol);
;           bdp.start_vcol += incr;
;           if (vim_iswhite(pstart.at(0)))
;           {
;               bdp.pre_whitesp += incr;
;               bdp.pre_whitesp_c++;
;           }
;           else
;           {
;               bdp.pre_whitesp = 0;
;               bdp.pre_whitesp_c = 0;
;           }
;           prev_pstart = pstart;
;           pstart = pstart.plus(us_ptr2len_cc(pstart));
;       }

;       bdp.start_char_vcols = incr;

;       if (bdp.start_vcol < oap.start_vcol)        ;; line too short
;       {
;           bdp.end_vcol = bdp.start_vcol;
;           bdp.is_short = true;
;           if (!is_del || oap.op_type == OP_APPEND)
;               bdp.endspaces = oap.end_vcol - oap.start_vcol + 1;
;       }
;       else
;       {
            ;; notice: this converts partly selected Multibyte characters to spaces, too.
;           bdp.startspaces = bdp.start_vcol - oap.start_vcol;
;           if (is_del && bdp.startspaces != 0)
;               bdp.startspaces = bdp.start_char_vcols - bdp.startspaces;
;           Bytes[] pend = { pstart };
;           bdp.end_vcol = bdp.start_vcol;
;           if (oap.end_vcol < bdp.end_vcol)        ;; it's all in one character
;           {
;               bdp.is_oneChar = true;
;               if (oap.op_type == OP_INSERT)
;                   bdp.endspaces = bdp.start_char_vcols - bdp.startspaces;
;               else if (oap.op_type == OP_APPEND)
;               {
;                   bdp.startspaces += oap.end_vcol - oap.start_vcol + 1;
;                   bdp.endspaces = bdp.start_char_vcols - bdp.startspaces;
;               }
;               else
;               {
;                   bdp.startspaces = oap.end_vcol - oap.start_vcol + 1;
;                   if (is_del && oap.op_type != OP_LSHIFT)
;                   {
                        ;; just putting the sum of those two into
                        ;; bdp.startspaces doesn't work for Visual replace,
                        ;; so we have to split the tab in two
;                       bdp.startspaces = bdp.start_char_vcols - (bdp.start_vcol - oap.start_vcol);
;                       bdp.endspaces = bdp.end_vcol - oap.end_vcol - 1;
;                   }
;               }
;           }
;           else
;           {
;               Bytes prev_pend = pend[0];
;               while (bdp.end_vcol <= oap.end_vcol && pend[0].at(0) != NUL)
;               {
                    ;; Count a tab for what it's worth (if list mode not on).
;                   prev_pend = pend[0];
;                   incr = lbr_chartabsize_adv(line, pend, bdp.end_vcol);
;                   bdp.end_vcol += incr;
;               }
;               if (bdp.end_vcol <= oap.end_vcol
;                       && (!is_del
;                           || oap.op_type == OP_APPEND
;                           || oap.op_type == OP_REPLACE)) ;; line too short
;               {
;                   bdp.is_short = true;
                    ;; Alternative: include spaces to fill up the block.
                    ;; Disadvantage: can lead to trailing spaces when
                    ;; the line is short where the text is put.
                    ;; if (!is_del || oap.op_type == OP_APPEND)
;                   if (oap.op_type == OP_APPEND || @virtual_op != FALSE)
;                       bdp.endspaces = oap.end_vcol - bdp.end_vcol + (oap.inclusive ? 1 : 0);
;                   else
;                       bdp.endspaces = 0; ;; replace doesn't add characters
;               }
;               else if (oap.end_vcol < bdp.end_vcol)
;               {
;                   bdp.endspaces = bdp.end_vcol - oap.end_vcol - 1;
;                   if (!is_del && bdp.endspaces != 0)
;                   {
;                       bdp.endspaces = incr - bdp.endspaces;
;                       if (BNE(pend[0], pstart))
;                           pend[0] = prev_pend;
;                   }
;               }
;           }
;           bdp.end_char_vcols = incr;
;           if (is_del && bdp.startspaces != 0)
;               pstart = prev_pstart;
;           bdp.textlen = BDIFF(pend[0], pstart);
;       }

;       bdp.textcol = BDIFF(pstart, line);
;       bdp.textstart = pstart;
    ))

(defn- #_void reverse_line [#_Bytes s]
    (§
;       int i = STRLEN(s) - 1;
;       if (i <= 0)
;           return;

;       @curwin.w_cursor.col = i - @curwin.w_cursor.col;
;       for (int j = 0; j < i; j++, i--)
;       {
;           byte c = s.at(i);
;           s.be(i, s.at(j));
;           s.be(j, c);
;       }
    ))

(atom! boolean hexupper)                                ;; 0xABC

;; add or subtract 'Prenum1' from a number in a line
;; 'command' is CTRL-A for add, CTRL-X for subtract
;;
;; return false for failure, true otherwise

(defn- #_boolean do_addsub [#_int command, #_long Prenum1]
    (§
;       boolean dohex = (vim_strchr(@curbuf.@b_p_nf, 'x') != null);   ;; "heX"
;       boolean dooct = (vim_strchr(@curbuf.@b_p_nf, 'o') != null);   ;; "Octal"
;       boolean doalp = (vim_strchr(@curbuf.@b_p_nf, 'p') != null);   ;; "alPha"

;       Bytes ptr = ml_get_curline();
;       if (@curwin.w_onebuf_opt.@wo_rl)
;           reverse_line(ptr);

        ;; First check if we are on a hexadecimal number, after the "0x".

;       int col = @curwin.w_cursor.col;
;       if (dohex)
;           while (0 < col && asc_isxdigit(ptr.at(col)))
;               --col;
;       if (dohex
;               && 0 < col
;               && (ptr.at(col) == (byte)'X' || ptr.at(col) == (byte)'x')
;               && ptr.at(col - 1) == (byte)'0'
;               && asc_isxdigit(ptr.at(col + 1)))
;       {
            ;; Found hexadecimal number, move to its start.

;           --col;
;       }
;       else
;       {
            ;; Search forward and then backward to find the start of number.

;           col = @curwin.w_cursor.col;

;           while (ptr.at(col) != NUL
;                   && !asc_isdigit(ptr.at(col))
;                   && !(doalp && asc_isalpha(ptr.at(col))))
;               col++;

;           while (0 < col
;                   && asc_isdigit(ptr.at(col - 1))
;                   && !(doalp && asc_isalpha(ptr.at(col))))
;               --col;
;       }

        ;; If a number was found, and saving for undo works, replace the number.

;       int firstdigit = ptr.at(col);
;       if (@curwin.w_onebuf_opt.@wo_rl)
;           reverse_line(ptr);
;       if ((!asc_isdigit(firstdigit) && !(doalp && asc_isalpha(firstdigit))) || !u_save_cursor())
;       {
;           beep_flush();
;           return false;
;       }

        ;; get 'ptr' again, because u_save() may have changed it
;       ptr = ml_get_curline();
;       if (@curwin.w_onebuf_opt.@wo_rl)
;           reverse_line(ptr);

;       if (doalp && asc_isalpha(firstdigit))
;       {
            ;; decrement or increment alphabetic character
;           if (command == Ctrl_X)
;           {
;               if (charOrd(firstdigit) < Prenum1)
;               {
;                   if (asc_isupper(firstdigit))
;                       firstdigit = 'A';
;                   else
;                       firstdigit = 'a';
;               }
;               else
;                   firstdigit -= Prenum1;
;           }
;           else
;           {
;               if (26 - charOrd(firstdigit) - 1 < Prenum1)
;               {
;                   if (asc_isupper(firstdigit))
;                       firstdigit = 'Z';
;                   else
;                       firstdigit = 'z';
;               }
;               else
;                   firstdigit += Prenum1;
;           }
;           @curwin.w_cursor.col = col;
;           del_char(false);
;           ins_char(firstdigit);
;       }
;       else
;       {
;           boolean negative = false;
;           if (0 < col && ptr.at(col - 1) == (byte)'-')        ;; negative number
;           {
;               --col;
;               negative = true;
;           }

;           int[] hex = new int[1];                             ;; 'X' or 'x': hex; '0': octal
;           int[] length = { 0 };                               ;; character length of the number
;           long[] n = new long[1];
            ;; get the number value (unsigned)
;           vim_str2nr(ptr.plus(col), hex, length, dooct ? TRUE : FALSE, dohex ? TRUE : FALSE, n);
;           if (n[0] < 0)
;               n[0] = -n[0];

            ;; ignore leading '-' for hex and octal numbers
;           if (hex[0] != 0 && negative)
;           {
;               col++;
;               --length[0];
;               negative = false;
;           }

            ;; add or subtract
;           boolean subtract = false;
;           if (command == Ctrl_X)
;               subtract ^= true;
;           if (negative)
;               subtract ^= true;

;           long oldn = n[0];
;           if (subtract)
;               n[0] -= Prenum1;
;           else
;               n[0] += Prenum1;

;           final long roof = 0x7fffffffffffffffL;
;           n[0] &= roof;

            ;; handle wraparound for decimal numbers
;           if (hex[0] == 0)
;           {
;               if (subtract)
;               {
;                   if (oldn < n[0])
;                   {
;                       n[0] = 1 + (n[0] ^ roof);
;                       negative ^= true;
;                   }
;               }
;               else ;; add
;               {
;                   if (n[0] < oldn)
;                   {
;                       n[0] = (n[0] ^ roof);
;                       negative ^= true;
;                   }
;               }
;               if (n[0] == 0)
;                   negative = false;
;           }

            ;; Delete the old number.

;           @curwin.w_cursor.col = col;
;           int todel = length[0];
;           int c = gchar_cursor();

            ;; Don't include the '-' in the length, only the length of the part
            ;; after it is kept the same.

;           if (c == '-')
;               --length[0];
;           while (0 < todel--)
;           {
;               if (c < 0x100 && asc_isalpha(c))
;               {
;                   if (asc_isupper(c))
;                       @hexupper = true;
;                   else
;                       @hexupper = false;
;               }
                ;; del_char() will mark line needing displaying
;               del_char(false);
;               c = gchar_cursor();
;           }

            ;; Prepare the leading characters in buf1[].
            ;; When there are many leading zeros it could be very long.
            ;; Allocate a bit too much.

;           Bytes buf1 = new Bytes(length[0] + NUMBUFLEN);

;           ptr = buf1;
;           if (negative)
;           {
;               (ptr = ptr.plus(1)).be(-1, (byte)'-');
;           }
;           if (hex[0] != 0)
;           {
;               (ptr = ptr.plus(1)).be(-1, (byte)'0');
;               --length[0];
;           }
;           if (hex[0] == 'x' || hex[0] == 'X')
;           {
;               (ptr = ptr.plus(1)).be(-1, hex[0]);
;               --length[0];
;           }

            ;; Put the number characters in buf2[].

;           Bytes buf2 = new Bytes(NUMBUFLEN);
;           if (hex[0] == 0)
;               libC.sprintf(buf2, u8("%ld"), n[0]);
;           else if (hex[0] == '0')
;               libC.sprintf(buf2, u8("%lo"), n[0]);
;           else if (hex[0] != 0 && @hexupper)
;               libC.sprintf(buf2, u8("%lX"), n[0]);
;           else
;               libC.sprintf(buf2, u8("%lx"), n[0]);
;           length[0] -= STRLEN(buf2);

            ;; Adjust number of zeros to the new number of digits,
            ;; so the total length of the number remains the same.
            ;; Don't do this when the result may look like an octal number.

;           if (firstdigit == '0' && !(dooct && hex[0] == 0))
;               while (0 < length[0]--)
;                   (ptr = ptr.plus(1)).be(-1, (byte)'0');
;           ptr.be(0, NUL);
;           STRCAT(buf1, buf2);
;           ins_str(buf1);          ;; insert the new number
;       }

;       --@curwin.w_cursor.col;
;       @curwin.w_set_curswant = true;
;       ptr = ml_get_buf(@curbuf, @curwin.w_cursor.lnum, true);
;       if (@curwin.w_onebuf_opt.@wo_rl)
;           reverse_line(ptr);
;       return true;
    ))

;; SELECTION / PRIMARY ('*')
;;
;; Text selection stuff that uses the GUI selection register '*'.  When using a
;; GUI this may be text from another window, otherwise it is the last text we
;; had highlighted with VIsual mode.  With mouse support, clicking the middle
;; button performs the paste, otherwise you will need to do <"*p>. "
;; If not under X, it is synonymous with the clipboard register '+'.
;;
;; X CLIPBOARD ('+')
;;
;; Text selection stuff that uses the GUI clipboard register '+'.
;; Under X, this matches the standard cut/paste buffer CLIPBOARD selection.
;; It will be used for unnamed cut/pasting is 'clipboard' contains "unnamed",
;; otherwise you will need to do <"+p>. "
;; If not under X, it is synonymous with the selection register '*'.

;; Routine to export any final X selection we had to the environment
;; so that the text is still available after vim has exited.  X selections
;; only exist while the owning application exists, so we write to the
;; permanent (while X runs) store CUT_BUFFER0.
;; Dump the CLIPBOARD selection if we own it (it's logically the more
;; 'permanent' of the two), otherwise the PRIMARY one.
;; For now, use a hard-coded sanity limit of 1Mb of data.

(defn- #_void clip_free_selection [#_clipboard_C cbd]
    (§
;       yankreg_C y_ptr = @y_current;

;       if (cbd == @clip_plus)
;           @y_current = y_regs[PLUS_REGISTER];
;       else
;           @y_current = y_regs[STAR_REGISTER];

;       @y_current.y_array = null;
;       @y_current.y_size = 0;

;       @y_current = y_ptr;
    ))

;; Get the selected text and put it in the gui selection register '*' or '+'.

(defn- #_void clip_get_selection [#_clipboard_C cbd]
    (§
;       if (cbd.owned)
;       {
;           if ((cbd == @clip_plus && y_regs[PLUS_REGISTER].y_array != null)
;            || (cbd == @clip_star && y_regs[STAR_REGISTER].y_array != null))
;               return;

            ;; get the text between clip_star.cbd_start & clip_star.cbd_end
;           yankreg_C old_y_previous = @y_previous;
;           yankreg_C old_y_current = @y_current;
;           pos_C old_cursor = §_pos_C();
;           COPY_pos(old_cursor, @curwin.w_cursor);

;           int old_curswant = @curwin.w_curswant;
;           boolean old_set_curswant = @curwin.w_set_curswant;
;           pos_C old_op_start = §_pos_C();
;           COPY_pos(old_op_start, @curbuf.b_op_start);
;           pos_C old_op_end = §_pos_C();
;           COPY_pos(old_op_end, @curbuf.b_op_end);
;           pos_C old_visual = §_pos_C();
;           COPY_pos(old_visual, @VIsual);
;           int old_visual_mode = @VIsual_mode;

;           oparg_C oa = §_oparg_C();
;           oa.regname = (cbd == @clip_plus) ? '+' : '*';
;           oa.op_type = OP_YANK;

;           cmdarg_C ca = §_cmdarg_C();
;           ca.oap = oa;
;           ca.cmdchar = 'y';
;           ca.count1 = 1;
;           ca.retval = CA_NO_ADJ_OP_END;

;           do_pending_operator(ca, 0, true);

;           @y_previous = old_y_previous;
;           @y_current = old_y_current;
;           COPY_pos(@curwin.w_cursor, old_cursor);

;           changed_cline_bef_curs();               ;; need to update w_virtcol et al

;           @curwin.w_curswant = old_curswant;
;           @curwin.w_set_curswant = old_set_curswant;
;           COPY_pos(@curbuf.b_op_start, old_op_start);
;           COPY_pos(@curbuf.b_op_end, old_op_end);
;           COPY_pos(@VIsual, old_visual);
;           @VIsual_mode = old_visual_mode;
;       }
;       else
;       {
;           clip_free_selection(cbd);

            ;; Try to get selected text from another window.
;           clip_gen_request_selection(cbd);
;       }
    ))

;; Convert from the GUI selection string into the '*'/'+' register.

(defn- #_void clip_yank_selection [#_byte type, #_Bytes str, #_int len, #_clipboard_C cbd]
    (§
;       yankreg_C y_ptr;

;       if (cbd == @clip_plus)
;           y_ptr = y_regs[PLUS_REGISTER];
;       else
;           y_ptr = y_regs[STAR_REGISTER];

;       clip_free_selection(cbd);

;       str_to_reg(y_ptr, type, str, len, 0, false);
    ))

;; If we have written to a clipboard register, send the text to the clipboard.

(defn- #_void may_set_selection []
    (§
;       if (@y_current == y_regs[STAR_REGISTER] && @clip_star.available)
;       {
;           clip_own_selection(@clip_star);
;           clip_gen_set_selection(@clip_star);
;       }
;       else if (@y_current == y_regs[PLUS_REGISTER] && @clip_plus.available)
;       {
;           clip_own_selection(@clip_plus);
;           clip_gen_set_selection(@clip_plus);
;       }
    ))

;; Replace the contents of the '~' register with str.

(defn- #_void dnd_yank_drag_data [#_Bytes str, #_int len]
    (§
;       yankreg_C curr = @y_current;
;       @y_current = y_regs[TILDE_REGISTER];
;       @y_current.y_array = null;
;       str_to_reg(@y_current, MCHAR, str, len, 0, false);
;       @y_current = curr;
    ))

;; Return the type of a register.
;; Used for getregtype()
;; Returns MAUTO for error.

(defn- #_byte get_reg_type [#_int regname, #_long* reglen]
    (§
;       switch (regname)
;       {
;           case '%':               ;; file name
;           case '#':               ;; alternate file name
;           case '=':               ;; expression
;           case ':':               ;; last command line
;           case '/':               ;; last search-pattern
;           case '.':               ;; last inserted text
;           case Ctrl_W:            ;; word under cursor
;           case Ctrl_A:            ;; WORD (mnemonic All) under cursor
;           case '_':               ;; black hole: always empty
;               return MCHAR;
;       }

;       regname = may_get_selection(regname);

;       if (regname != NUL && !valid_yank_reg(regname, false))
;           return MAUTO;

;       get_yank_register(regname, false);

;       if (@y_current.y_array != null)
;       {
;           if (reglen != null && @y_current.y_type == MBLOCK)
;               reglen[0] = @y_current.y_width;
;           return @y_current.y_type;
;       }

;       return MAUTO;
    ))

;; Return the contents of a register as a single allocated string.
;; Used for "@r" in expressions and for getreg().
;; Returns null for error.
;; Flags:
;;      GREG_NO_EXPR    Do not allow expression register
;;      GREG_EXPR_SRC   For the expression register: return expression itself,
;;                      not the result of its evaluation.

(defn- #_Bytes get_reg_contents [#_int regname, #_int flags]
    (§
        ;; Don't allow using an expression register inside an expression.
;       if (regname == '=')
;       {
;           if ((flags & GREG_NO_EXPR) != 0)
;               return null;
;           if ((flags & GREG_EXPR_SRC) != 0)
;               return get_expr_line_src();

;           return get_expr_line();
;       }

;       if (regname == '@')     ;; "@@" is used for unnamed register
;           regname = '"';

        ;; check for valid regname
;       if (regname != NUL && !valid_yank_reg(regname, false))
;           return null;

;       regname = may_get_selection(regname);

;       Bytes[] ret = new Bytes[1];
;       boolean[] allocated = new boolean[1];
;       if (get_spec_reg(regname, ret, allocated, false))
;       {
;           if (ret[0] == null)
;               return null;

;           return allocated[0] ? ret[0] : STRDUP(ret[0]);
;       }

;       get_yank_register(regname, false);
;       if (@y_current.y_array == null)
;           return null;

        ;; Compute length of resulting string.

;       int len = 0;
;       for (int i = 0; i < @y_current.y_size; i++)
;       {
;           len += STRLEN(@y_current.y_array[i]);

            ;; Insert a newline between lines and after last line if y_type is MLINE.

;           if (@y_current.y_type == MLINE || i < @y_current.y_size - 1)
;               len++;
;       }

;       Bytes retval = new Bytes(len + 1);

        ;; Copy the lines of the yank register into the string.

;       len = 0;
;       for (int i = 0; i < @y_current.y_size; i++)
;       {
;           STRCPY(retval.plus(len), @y_current.y_array[i]);
;           len += STRLEN(retval, len);

            ;; Insert a NL between lines and after the last line if y_type is MLINE.

;           if (@y_current.y_type == MLINE || i < @y_current.y_size - 1)
;               retval.be(len++, (byte)'\n');
;       }
;       retval.be(len, NUL);

;       return retval;
    ))

;; Put a string into a register.  When the register is not empty, the string is appended.

(defn- #_void str_to_reg [#_yankreg_C y_ptr, #_byte yank_type, #_Object str, #_int len, #_int blocklen, #_boolean str_list]
    ;; y_ptr: pointer to yank register
    ;; yank_type: MCHAR, MLINE, MBLOCK, MAUTO
    ;; str: string to put in register
    ;; len: length of string
    ;; blocklen: width of Visual block
    ;; str_list: true if str is Bytes[]
    (§
;       int extraline = 0;                      ;; extra line at the end
;       boolean append = false;                 ;; append to last line in register

;       if (y_ptr.y_array == null)              ;; null means empty register
;           y_ptr.y_size = 0;

;       byte type;                              ;; MCHAR, MLINE or MBLOCK
;       if (yank_type == MAUTO)
;           type = (str_list || (0 < len && (((Bytes)str).at(len - 1) == NL || ((Bytes)str).at(len - 1) == CAR))) ? MLINE : MCHAR;
;       else
;           type = yank_type;

        ;; Count the number of lines within the string.

;       int newlines = 0;                       ;; number of lines added
;       if (str_list)
;       {
;           Bytes[] pp = (Bytes[])str;

;           for (int i = 0; pp[i] != null; i++)
;               newlines++;
;       }
;       else
;       {
;           Bytes p = (Bytes)str;

;           for (int i = 0; i < len; i++)
;               if (p.at(i) == (byte)'\n')
;                   newlines++;
;           if (type == MCHAR || len == 0 || p.at(len - 1) != (byte)'\n')
;           {
;               extraline = 1;
;               newlines++;                     ;; count extra newline at the end
;           }
;           if (0 < y_ptr.y_size && y_ptr.y_type == MCHAR)
;           {
;               append = true;
;               --newlines;                     ;; uncount newline when appending first line
;           }
;       }

        ;; Allocate an array to hold the pointers to the new register lines.
        ;; If the register was not empty, move the existing lines to the new array.

;       Bytes[] pp = new Bytes[y_ptr.y_size + newlines];

;       int lnum;
;       for (lnum = 0; lnum < y_ptr.y_size; lnum++)
;           pp[lnum] = y_ptr.y_array[lnum];
;       y_ptr.y_array = pp;
;       int maxlen = 0;

        ;; Find the end of each line and save it into the array.

;       if (str_list)
;       {
;           Bytes[] qq = (Bytes[])str;

;           for (int i = 0; qq[i] != null; i++, lnum++)
;           {
;               int n = STRLEN(qq[i]);
;               pp[lnum] = STRNDUP(qq[i], n);
;               if (maxlen < n)
;                   maxlen = n;
;           }
;       }
;       else
;       {
;           Bytes p = (Bytes)str;

;           for (int start = 0, i; start < len + extraline; start += i + 1)
;           {
;               for (i = start; i < len; i++)   ;; find the end of the line
;                   if (p.at(i) == (byte)'\n')
;                       break;
;               i -= start;                     ;; i is now length of line
;               if (maxlen < i)
;                   maxlen = i;
;               int extra = 0;
;               if (append)
;               {
;                   --lnum;
;                   extra = STRLEN(y_ptr.y_array[lnum]);
;               }

;               Bytes s = new Bytes(i + extra + 1);

;               if (extra != 0)
;                   BCOPY(s, y_ptr.y_array[lnum], extra);
;               if (append)
;                   y_ptr.y_array[lnum] = null;
;               if (i != 0)
;                   BCOPY(s, extra, p, start, i);
;               extra += i;
;               s.be(extra, NUL);
;               y_ptr.y_array[lnum++] = s;
;               while (0 <= --extra)
;               {
;                   if (s.at(0) == NUL)
;                       s.be(0, (byte)'\n');        ;; replace NUL with newline
;                   s = s.plus(1);
;               }
;               append = false;                     ;; only first line is appended
;           }
;       }
;       y_ptr.y_type = type;
;       y_ptr.y_size = lnum;
;       if (type == MBLOCK)
;           y_ptr.y_width = (blocklen < 0) ? maxlen - 1 : blocklen;
;       else
;           y_ptr.y_width = 0;
    ))

;; Count the number of bytes, characters and "words" in a line.
;;
;; "Words" are counted by looking for boundaries between non-space and
;; space characters.  (it seems to produce results that match 'wc'.)
;;
;; Return value is byte count; word count for the line is added to "*wc".
;; Char count is added to "*cc".
;;
;; The function will only examine the first "limit" characters in the
;; line, stopping if it encounters an end-of-line (NUL byte).  In that
;; case, eol_size will be added to the character count to account for
;; the size of the EOL character.

(defn- #_int line_count_info [#_Bytes line, #_int* wc, #_int* cc, #_int limit, #_int eol_size]
    (§
;       int i;

;       int words = 0;
;       int chars = 0;
;       boolean is_word = false;

;       for (i = 0; i < limit && line.at(i) != NUL; )
;       {
;           if (is_word)
;           {
;               if (vim_isspace(line.at(i)))
;               {
;                   words++;
;                   is_word = false;
;               }
;           }
;           else if (!vim_isspace(line.at(i)))
;               is_word = true;
;           chars++;
;           i += us_ptr2len_cc(line.plus(i));
;       }

;       if (is_word)
;           words++;
;       wc[0] += words;

        ;; Add eol_size if the end of line was reached before hitting limit.
;       if (i < limit && line.at(i) == NUL)
;       {
;           i += eol_size;
;           chars += eol_size;
;       }
;       cc[0] += chars;

;       return i;
    ))

;; Give some info about the position of the cursor (for "g CTRL-G").
;; In Visual mode, give some info about the selected region.  (In this case,
;; the *_count_cursor variables store running totals for the selection.)

(defn- #_void cursor_pos_info []
    (§
        ;; Compute the length of the file in characters.

;       if ((@curbuf.b_ml.ml_flags & ML_EMPTY) != 0)
;       {
;           msg(no_lines_msg);
;           return;
;       }

;       Bytes buf1 = new Bytes(50);
;       Bytes buf2 = new Bytes(40);
;       int byte_count = 0;
;       int byte_count_cursor = 0;
;       int[] char_count = { 0 };
;       int[] char_count_cursor = { 0 };
;       int[] word_count = { 0 };
;       int[] word_count_cursor = { 0 };
;       int last_check = 100000;
;       long line_count_selected = 0;

;       pos_C min_pos = §_pos_C();
;       pos_C max_pos = §_pos_C();
;       oparg_C oparg = §_oparg_C();

;       int eol_size = 1;

;       if (@VIsual_active)
;       {
;           if (ltpos(@VIsual, @curwin.w_cursor))
;           {
;               COPY_pos(min_pos, @VIsual);
;               COPY_pos(max_pos, @curwin.w_cursor);
;           }
;           else
;           {
;               COPY_pos(min_pos, @curwin.w_cursor);
;               COPY_pos(max_pos, @VIsual);
;           }
;           if (@p_sel.at(0) == (byte)'e' && 0 < max_pos.col)
;               --max_pos.col;

;           if (@VIsual_mode == Ctrl_V)
;           {
;               Bytes saved_sbr = @p_sbr;

                ;; Make 'sbr' empty for a moment to get the correct size.
;               @p_sbr = EMPTY_OPTION;
;               oparg.is_VIsual = true;
;               oparg.block_mode = true;
;               oparg.op_type = OP_NOP;
;               {
;                   int[] scol = { oparg.start_vcol };
;                   int[] ecol = { oparg.end_vcol };
;                   getvcols(@curwin, min_pos, max_pos, scol, ecol);
;                   oparg.start_vcol = scol[0];
;                   oparg.end_vcol = ecol[0];
;               }
;               @p_sbr = saved_sbr;
;               if (@curwin.w_curswant == MAXCOL)
;                   oparg.end_vcol = MAXCOL;
                ;; Swap the start, end vcol if needed.
;               if (oparg.end_vcol < oparg.start_vcol)
;               {
;                   oparg.end_vcol += oparg.start_vcol;
;                   oparg.start_vcol = oparg.end_vcol - oparg.start_vcol;
;                   oparg.end_vcol -= oparg.start_vcol;
;               }
;           }

;           line_count_selected = max_pos.lnum - min_pos.lnum + 1;
;       }

;       for (long lnum = 1; lnum <= @curbuf.b_ml.ml_line_count; lnum++)
;       {
            ;; Check for a CTRL-C every 100000 characters.
;           if (last_check < byte_count)
;           {
;               ui_breakcheck();
;               if (@got_int)
;                   return;
;               last_check = byte_count + 100000;
;           }

            ;; Do extra processing for VIsual mode.
;           if (@VIsual_active && min_pos.lnum <= lnum && lnum <= max_pos.lnum)
;           {
;               Bytes s = null;
;               int len = 0;

;               switch (@VIsual_mode)
;               {
;                   case Ctrl_V:
;                   {
;                       @virtual_op = virtual_active() ? TRUE : FALSE;
;                       block_def_C bd = §_block_def_C();
;                       block_prep(oparg, bd, lnum, false);
;                       @virtual_op = MAYBE;
;                       s = bd.textstart;
;                       len = bd.textlen;
;                       break;
;                   }

;                   case 'V':
;                   {
;                       s = ml_get(lnum);
;                       len = MAXCOL;
;                       break;
;                   }

;                   case 'v':
;                   {
;                       int start_col = (lnum == min_pos.lnum) ? min_pos.col : 0;
;                       int end_col = (lnum == max_pos.lnum) ? max_pos.col - start_col + 1 : MAXCOL;

;                       s = ml_get(lnum).plus(start_col);
;                       len = end_col;
;                       break;
;                   }
;               }

;               if (s != null)
;                   byte_count_cursor += line_count_info(s, word_count_cursor, char_count_cursor, len, eol_size);
;           }
;           else
;           {
                ;; In non-visual mode, check for the line the cursor is on.
;               if (lnum == @curwin.w_cursor.lnum)
;               {
;                   word_count_cursor[0] += word_count[0];
;                   char_count_cursor[0] += char_count[0];
;                   byte_count_cursor = byte_count +
;                       line_count_info(ml_get(lnum), word_count_cursor, char_count_cursor, @curwin.w_cursor.col + 1, eol_size);
;               }
;           }

            ;; Add to the running totals.
;           byte_count += line_count_info(ml_get(lnum), word_count, char_count, MAXCOL, eol_size);
;       }

;       if (@VIsual_active)
;       {
;           if (@VIsual_mode == Ctrl_V && @curwin.w_curswant < MAXCOL)
;           {
;               {
;                   int[] _1 = { min_pos.col };
;                   int[] _2 = { max_pos.col };
;                   getvcols(@curwin, min_pos, max_pos, _1, _2);
;                   min_pos.col = _1[0];
;                   max_pos.col = _2[0];
;               }
;               vim_snprintf(buf1, buf1.size(), u8("%ld Cols; "), oparg.end_vcol - oparg.start_vcol + 1);
;           }
;           else
;               buf1.be(0, NUL);

;           if (char_count_cursor[0] == byte_count_cursor && char_count[0] == byte_count)
;               vim_snprintf(@ioBuff, IOSIZE,
;                       u8("Selected %s%ld of %ld Lines; %ld of %ld Words; %ld of %ld Bytes"),
;                       buf1, line_count_selected, @curbuf.b_ml.ml_line_count,
;                       word_count_cursor[0], word_count[0],
;                       byte_count_cursor, byte_count);
;           else
;               vim_snprintf(@ioBuff, IOSIZE,
;                       u8("Selected %s%ld of %ld Lines; %ld of %ld Words; %ld of %ld Chars; %ld of %ld Bytes"),
;                       buf1, line_count_selected, @curbuf.b_ml.ml_line_count,
;                       word_count_cursor[0], word_count[0],
;                       char_count_cursor[0], char_count[0],
;                       byte_count_cursor, byte_count);
;       }
;       else
;       {
;           Bytes p = ml_get_curline();
;           validate_virtcol();
;           col_print(buf1, buf1.size(), @curwin.w_cursor.col + 1, @curwin.w_virtcol + 1);
;           col_print(buf2, buf2.size(), STRLEN(p), linetabsize(p));

;           if (char_count_cursor[0] == byte_count_cursor && char_count[0] == byte_count)
;               vim_snprintf(@ioBuff, IOSIZE,
;                   u8("Col %s of %s; Line %ld of %ld; Word %ld of %ld; Byte %ld of %ld"),
;                   buf1, buf2,
;                   @curwin.w_cursor.lnum, @curbuf.b_ml.ml_line_count,
;                   word_count_cursor[0], word_count[0],
;                   byte_count_cursor, byte_count);
;           else
;               vim_snprintf(@ioBuff, IOSIZE,
;                   u8("Col %s of %s; Line %ld of %ld; Word %ld of %ld; Char %ld of %ld; Byte %ld of %ld"),
;                   buf1, buf2,
;                   @curwin.w_cursor.lnum, @curbuf.b_ml.ml_line_count,
;                   word_count_cursor[0], word_count[0],
;                   char_count_cursor[0], char_count[0],
;                   byte_count_cursor, byte_count);
;       }

        ;; Don't shorten this message, the user asked for it.
;       Bytes p = @p_shm;
;       @p_shm = u8("");
;       msg(@ioBuff);
;       @p_shm = p;
    ))

;; mark.c: functions for setting marks and jumping to them ----------------------------------------

;; If a named file mark's lnum is non-zero, it is valid.
;; If a named file mark's fnum is non-zero, it is for an existing buffer,
;; otherwise it is from .viminfo and namedfm[n].fname is the file name.
;; There are marks 'A - 'Z (set by user) and '0 to '9 (set when writing viminfo).

(final int EXTRA_MARKS 10)                                              ;; marks 0-9
(final xfmark_C*    namedfm    (ARRAY_xfmark (+ NMARKS EXTRA_MARKS)))   ;; marks with file nr

;; Set named mark "c" at current cursor position.
;; Returns true on success, false if bad name given.

(defn- #_boolean setmark [#_int c]
    (§
;       return setmark_pos(c, @curwin.w_cursor, @curbuf.b_fnum);
    ))

;; Set named mark "c" to position "pos".
;; When "c" is upper case use file "fnum".
;; Returns true on success, false if bad name given.

(defn- #_boolean setmark_pos [#_int c, #_pos_C pos, #_int fnum]
    (§
        ;; Check for a special key (may cause islower() to crash).
;       if (c < 0)
;           return false;

;       if (c == '\'' || c == '`')
;       {
;           if (pos == @curwin.w_cursor)
;           {
;               setpcmark();
                ;; keep it even when the cursor doesn't move
;               COPY_pos(@curwin.w_prev_pcmark, @curwin.w_pcmark);
;           }
;           else
;               COPY_pos(@curwin.w_pcmark, pos);
;           return true;
;       }

;       if (c == '"')
;       {
;           COPY_pos(@curbuf.b_last_cursor, pos);
;           return true;
;       }

        ;; Allow setting '[ and '] for an autocommand that simulates reading a file.
;       if (c == '[')
;       {
;           COPY_pos(@curbuf.b_op_start, pos);
;           return true;
;       }
;       if (c == ']')
;       {
;           COPY_pos(@curbuf.b_op_end, pos);
;           return true;
;       }

;       if (c == '<' || c == '>')
;       {
;           if (c == '<')
;               COPY_pos(@curbuf.b_visual.vi_start, pos);
;           else
;               COPY_pos(@curbuf.b_visual.vi_end, pos);
;           if (@curbuf.b_visual.vi_mode == NUL)
                ;; Visual_mode has not yet been set, use a sane default.
;               @curbuf.b_visual.vi_mode = 'v';
;           return true;
;       }

;       if ('z' < c)        ;; some islower() and isupper() cannot handle characters above 127
;           return false;
;       if (asc_islower(c))
;       {
;           int i = c - 'a';
;           COPY_pos(@curbuf.b_namedm[i], pos);
;           return true;
;       }
;       if (asc_isupper(c))
;       {
;           int i = c - 'A';
;           COPY_pos(namedfm[i].fmark.mark, pos);
;           namedfm[i].fmark.fnum = fnum;
;           namedfm[i].fname = null;
;           return true;
;       }

;       return false;
    ))

;; Set the previous context mark to the current position and add it to the jump list.

(defn- #_void setpcmark []
    (§
        ;; for :global the mark is set only once
;       if (@global_busy != 0 || @listcmd_busy || @cmdmod.keepjumps)
;           return;

;       COPY_pos(@curwin.w_prev_pcmark, @curwin.w_pcmark);
;       COPY_pos(@curwin.w_pcmark, @curwin.w_cursor);

        ;; If jumplist is full: remove oldest entry.
;       if (++@curwin.w_jumplistlen > JUMPLISTSIZE)
;       {
;           @curwin.w_jumplistlen = JUMPLISTSIZE;
;           @curwin.w_jumplist[0].fname = null;
;           for (int i = 1; i < JUMPLISTSIZE; i++)
;               COPY_xfmark(@curwin.w_jumplist[i - 1], @curwin.w_jumplist[i]);
;       }
;       @curwin.w_jumplistidx = @curwin.w_jumplistlen;
;       xfmark_C fm = @curwin.w_jumplist[@curwin.w_jumplistlen - 1];

;       COPY_pos(fm.fmark.mark, @curwin.w_pcmark);
;       fm.fmark.fnum = @curbuf.b_fnum;
;       fm.fname = null;
    ))

;; To change context, call setpcmark(), then move the current position to
;; where ever, then call checkpcmark().  This ensures that the previous
;; context will only be changed if the cursor moved to a different line.
;; If pcmark was deleted (with "dG") the previous mark is restored.

(defn- #_void checkpcmark []
    (§
;       if (@curwin.w_prev_pcmark.lnum != 0
;               && (eqpos(@curwin.w_pcmark, @curwin.w_cursor) || @curwin.w_pcmark.lnum == 0))
;       {
;           COPY_pos(@curwin.w_pcmark, @curwin.w_prev_pcmark);
;           @curwin.w_prev_pcmark.lnum = 0;      ;; show it has been checked
;       }
    ))

;; Move "count" positions in the jump list (count may be negative).

(defn- #_pos_C movemark [#_int count]
    (§
;       cleanup_jumplist();

;       if (@curwin.w_jumplistlen == 0)          ;; nothing to jump to
;           return null;

;       for ( ; ; )
;       {
;           if (@curwin.w_jumplistidx + count < 0 || @curwin.w_jumplistlen <= @curwin.w_jumplistidx + count)
;               return null;

            ;; If first CTRL-O or CTRL-I command after a jump, add cursor position
            ;; to list.  Careful: If there are duplicates (CTRL-O immediately after
            ;; starting Vim on a file), another entry may have been removed.

;           if (@curwin.w_jumplistidx == @curwin.w_jumplistlen)
;           {
;               setpcmark();
;               --@curwin.w_jumplistidx;         ;; skip the new entry
;               if (@curwin.w_jumplistidx + count < 0)
;                   return null;
;           }

;           @curwin.w_jumplistidx += count;

;           pos_C pos;

;           xfmark_C jmp = @curwin.w_jumplist[@curwin.w_jumplistidx];
;           if (jmp.fmark.fnum == 0)
;               fname2fnum(jmp);
;           if (jmp.fmark.fnum != @curbuf.b_fnum)
;           {
                ;; jump to other file
;               if (buflist_findnr(jmp.fmark.fnum) == null)
;               {                                               ;; skip this one ..
;                   count += count < 0 ? -1 : 1;
;                   continue;
;               }
;               if (buflist_getfile(jmp.fmark.fnum, jmp.fmark.mark.lnum, 0, false) == false)
;                   return null;
                ;; set lnum again, autocommands my have changed it
;               COPY_pos(@curwin.w_cursor, jmp.fmark.mark);
;               pos = NOPOS;
;           }
;           else
;               pos = jmp.fmark.mark;

;           return pos;
;       }
    ))

;; Move "count" positions in the changelist (count may be negative).

(defn- #_pos_C movechangelist [#_int count]
    (§
;       if (@curbuf.b_changelistlen == 0)    ;; nothing to jump to
;           return null;

;       int n = @curwin.w_changelistidx;
;       if (n + count < 0)
;       {
;           if (n == 0)
;               return null;
;           n = 0;
;       }
;       else if (@curbuf.b_changelistlen <= n + count)
;       {
;           if (n == @curbuf.b_changelistlen - 1)
;               return null;
;           n = @curbuf.b_changelistlen - 1;
;       }
;       else
;           n += count;
;       @curwin.w_changelistidx = n;
;       return @curbuf.b_changelist[n];
    ))

;; Find mark "c" in buffer pointed to by "buf".
;; If "changefile" is true it's allowed to edit another file for '0, 'A, etc.
;; If "fnum" is not null store the fnum there for '0, 'A etc., don't edit another file.
;; Returns:
;; - pointer to pos_C if found.  lnum is 0 when mark not set, -1 when mark is
;;   in another file which can't be gotten. (caller needs to check lnum!)
;; - null if there is no mark called 'c'.
;; - -1 if mark is in other file and jumped there (only if changefile is true)

(defn- #_pos_C getmark_buf [#_buffer_C buf, #_int c, #_boolean changefile]
    (§
;       return getmark_buf_fnum(buf, c, changefile, null);
    ))

(defn- #_pos_C getmark [#_int c, #_boolean changefile]
    (§
;       return getmark_buf_fnum(@curbuf, c, changefile, null);
    ))

(atom! pos_C _1_pos_copy    (§_pos_C))

(defn- #_pos_C getmark_buf_fnum [#_buffer_C buf, #_int c, #_boolean changefile, #_int* fnum]
    (§
;       pos_C posp = null;

        ;; Check for special key, can't be a mark name and might cause islower() to crash.
;       if (c < 0)
;           return posp;
;       if ('~' < c)                                ;; check for islower()/isupper()
        ;
;       else if (c == '\'' || c == '`')             ;; previous context mark
;       {
;           COPY_pos(@_1_pos_copy, @curwin.w_pcmark); ;; need to make a copy because
;           posp = @_1_pos_copy;                     ;; w_pcmark may be changed soon
;       }
;       else if (c == '"')                          ;; to pos when leaving buffer
;           posp = buf.b_last_cursor;
;       else if (c == '^')                          ;; to where Insert mode stopped
;           posp = buf.b_last_insert;
;       else if (c == '.')                          ;; to where last change was made
;           posp = buf.b_last_change;
;       else if (c == '[')                          ;; to start of previous operator
;           posp = buf.b_op_start;
;       else if (c == ']')                          ;; to end of previous operator
;           posp = buf.b_op_end;
;       else if (c == '{' || c == '}')              ;; to previous/next paragraph
;       {
;           boolean slcb = @listcmd_busy;

;           pos_C pos = §_pos_C();
;           COPY_pos(pos, @curwin.w_cursor);
;           @listcmd_busy = true;                    ;; avoid that '' is changed
;           oparg_C oa = §_oparg_C();
;           boolean b;
;           { boolean[] __ = { oa.inclusive }; b = findpar(__, (c == '}') ? FORWARD : BACKWARD, 1L, NUL, false); oa.inclusive = __[0]; }
;           if (b)
;           {
;               COPY_pos(@_1_pos_copy, @curwin.w_cursor);
;               posp = @_1_pos_copy;
;           }
;           COPY_pos(@curwin.w_cursor, pos);
;           @listcmd_busy = slcb;
;       }
;       else if (c == '(' || c == ')')              ;; to previous/next sentence
;       {
;           boolean slcb = @listcmd_busy;

;           pos_C pos = §_pos_C();
;           COPY_pos(pos, @curwin.w_cursor);
;           @listcmd_busy = true;                    ;; avoid that '' is changed
;           if (findsent(c == ')' ? FORWARD : BACKWARD, 1L))
;           {
;               COPY_pos(@_1_pos_copy, @curwin.w_cursor);
;               posp = @_1_pos_copy;
;           }
;           COPY_pos(@curwin.w_cursor, pos);
;           @listcmd_busy = slcb;
;       }
;       else if (c == '<' || c == '>')              ;; start/end of visual area
;       {
;           pos_C startp = buf.b_visual.vi_start;
;           pos_C endp = buf.b_visual.vi_end;
;           if ((c == '<') == ltpos(startp, endp))
;               posp = startp;
;           else
;               posp = endp;

            ;; For Visual line mode, set mark at begin or end of line

;           if (buf.b_visual.vi_mode == 'V')
;           {
;               COPY_pos(@_1_pos_copy, posp);
;               posp = @_1_pos_copy;
;               if (c == '<')
;                   @_1_pos_copy.col = 0;
;               else
;                   @_1_pos_copy.col = MAXCOL;
;               @_1_pos_copy.coladd = 0;
;           }
;       }
;       else if (asc_islower(c))                    ;; normal named mark
;       {
;           posp = buf.b_namedm[c - 'a'];
;       }
;       else if (asc_isupper(c) || asc_isdigit(c))  ;; named file mark
;       {
;           if (asc_isdigit(c))
;               c = c - '0' + NMARKS;
;           else
;               c -= 'A';
;           posp = namedfm[c].fmark.mark;

;           if (namedfm[c].fmark.fnum == 0)
;               fname2fnum(namedfm[c]);

;           if (fnum != null)
;               fnum[0] = namedfm[c].fmark.fnum;
;           else if (namedfm[c].fmark.fnum != buf.b_fnum)
;           {
                ;; mark is in another file
;               posp = @_1_pos_copy;

;               if (namedfm[c].fmark.mark.lnum != 0 && changefile && namedfm[c].fmark.fnum != 0)
;               {
;                   if (buflist_getfile(namedfm[c].fmark.fnum, 1, GETF_SETMARK, false) == true)
;                   {
                        ;; Set the lnum now, autocommands could have changed it.
;                       COPY_pos(@curwin.w_cursor, namedfm[c].fmark.mark);
;                       return NOPOS;
;                   }
;                   @_1_pos_copy.lnum = -1; ;; can't get file
;               }
;               else
;                   @_1_pos_copy.lnum = 0;  ;; mark exists, but is not valid in current buffer
;           }
;       }

;       return posp;
    ))

;; Search for the next named mark in the current file.
;;
;; Returns pointer to pos_C of the next mark or null if no mark is found.

(defn- #_pos_C getnextmark [#_pos_C startpos, #_int dir, #_boolean begin_line]
    ;; startpos: where to start
    ;; dir: direction for search
    (§
;       pos_C result = null;
;       pos_C pos = §_pos_C();
;       COPY_pos(pos, startpos);

        ;; When searching backward and leaving the cursor on the first non-blank,
        ;; position must be in a previous line.
        ;; When searching forward and leaving the cursor on the first non-blank,
        ;; position must be in a next line.
;       if (dir == BACKWARD && begin_line)
;           pos.col = 0;
;       else if (dir == FORWARD && begin_line)
;           pos.col = MAXCOL;

;       for (int i = 0; i < NMARKS; i++)
;       {
;           if (0 < @curbuf.b_namedm[i].lnum)
;           {
;               if (dir == FORWARD)
;               {
;                   if ((result == null || ltpos(@curbuf.b_namedm[i], result)) && ltpos(pos, @curbuf.b_namedm[i]))
;                       result = @curbuf.b_namedm[i];
;               }
;               else
;               {
;                   if ((result == null || ltpos(result, @curbuf.b_namedm[i])) && ltpos(@curbuf.b_namedm[i], pos))
;                       result = @curbuf.b_namedm[i];
;               }
;           }
;       }

;       return result;
    ))

;; For an xtended filemark: set the fnum from the fname.
;; This is used for marks obtained from the .viminfo file.
;; It's postponed until the mark is used to avoid a long startup delay.

(defn- #_void fname2fnum [#_xfmark_C fm]
    (§
        
    ))

;; Check a if a position from a mark is valid.
;; Give and error message and return false if not.

(defn- #_boolean check_mark [#_pos_C pos]
    (§
;       if (pos == null)
;       {
;           emsg(e_umark);
;           return false;
;       }
;       if (pos.lnum <= 0)
;       {
            ;; 'lnum' is negative if mark is in another file and can't get that file,
            ;; error message already give then.
;           if (pos.lnum == 0)
;               emsg(e_marknotset);
;           return false;
;       }
;       if (@curbuf.b_ml.ml_line_count < pos.lnum)
;       {
;           emsg(e_markinval);
;           return false;
;       }
;       return true;
    ))

(atom! int mark_i -1)

;; clrallmarks() - clear all marks in the buffer 'buf'
;;
;; Used mainly when trashing the entire buffer during ":e" type commands

(defn- #_void clrallmarks [#_buffer_C buf]
    (§
;       if (@mark_i == -1)                   ;; first call ever: initialize
;           for (@mark_i = 0; @mark_i < NMARKS + 1; @mark_i++)
;           {
;               namedfm[@mark_i].fmark.mark.lnum = 0;
;               namedfm[@mark_i].fname = null;
;           }

;       for (@mark_i = 0; @mark_i < NMARKS; @mark_i++)
;           buf.b_namedm[@mark_i].lnum = 0;
;       buf.b_op_start.lnum = 0;            ;; start/end op mark cleared
;       buf.b_op_end.lnum = 0;
;       buf.b_last_cursor.lnum = 1;         ;; '" mark cleared
;       buf.b_last_cursor.col = 0;
;       buf.b_last_cursor.coladd = 0;
;       buf.b_last_insert.lnum = 0;         ;; '^ mark cleared
;       buf.b_last_change.lnum = 0;         ;; '. mark cleared
;       buf.b_changelistlen = 0;
    ))

;; Get name of file from a filemark.
;; When it's in the current buffer, return the text at the mark.
;; Returns an allocated string.

(defn- #_Bytes fm_getname [#_fmark_C fmark, #_int lead_len]
    (§
;       if (fmark.fnum == @curbuf.b_fnum)    ;; current buffer
;           return mark_line(fmark.mark, lead_len);

;       return null;
    ))

;; Return the line at mark "mp".  Truncate to fit in window.
;; The returned string has been allocated.

(defn- #_Bytes mark_line [#_pos_C mp, #_int lead_len]
    (§
;       if (mp.lnum == 0 || @curbuf.b_ml.ml_line_count < mp.lnum)
;           return STRDUP(u8("-invalid-"));

;       Bytes s = STRNDUP(skipwhite(ml_get(mp.lnum)), (int)@Columns);

        ;; Truncate the line to fit it in the window.
;       int len = 0;
;       Bytes p;
;       for (p = s; p.at(0) != NUL; p = p.plus(us_ptr2len_cc(p)))
;       {
;           len += mb_ptr2cells(p);
;           if ((int)@Columns - lead_len <= len)
;               break;
;       }
;       p.be(0, NUL);

;       return s;
    ))

;; print the marks

(defn- #_void ex_marks [#_exarg_C eap]
    (§
;       Bytes arg = eap.arg;

;       if (arg != null && arg.at(0) == NUL)
;           arg = null;

;       show_one_mark('\'', arg, @curwin.w_pcmark, null, true);
;       for (int i = 0; i < NMARKS; i++)
;           show_one_mark(i + 'a', arg, @curbuf.b_namedm[i], null, true);
;       for (int i = 0; i < NMARKS + EXTRA_MARKS; i++)
;       {
;           Bytes name;
;           if (namedfm[i].fmark.fnum != 0)
;               name = fm_getname(namedfm[i].fmark, 15);
;           else
;               name = namedfm[i].fname;
;           if (name != null)
;           {
;               show_one_mark(NMARKS <= i ? i - NMARKS + '0' : i + 'A', arg, namedfm[i].fmark.mark, name, namedfm[i].fmark.fnum == @curbuf.b_fnum);
;           }
;       }
;       show_one_mark('"', arg, @curbuf.b_last_cursor, null, true);
;       show_one_mark('[', arg, @curbuf.b_op_start, null, true);
;       show_one_mark(']', arg, @curbuf.b_op_end, null, true);
;       show_one_mark('^', arg, @curbuf.b_last_insert, null, true);
;       show_one_mark('.', arg, @curbuf.b_last_change, null, true);
;       show_one_mark('<', arg, @curbuf.b_visual.vi_start, null, true);
;       show_one_mark('>', arg, @curbuf.b_visual.vi_end, null, true);
;       show_one_mark(-1, arg, null, null, false);
    ))

(atom! boolean did_title)

(defn- #_void show_one_mark [#_int c, #_Bytes arg, #_pos_C p, #_Bytes name, #_boolean current]
    ;; current: in current file
    (§
;       if (c == -1)                            ;; finish up
;       {
;           if (@did_title)
;               @did_title = false;
;           else
;           {
;               if (arg == null)
;                   msg(u8("No marks set"));
;               else
;                   emsg2(u8("E283: No marks matching \"%s\""), arg);
;           }
;       }
        ;; don't output anything if 'q' typed at --more-- prompt
;       else if (!@got_int && (arg == null || vim_strchr(arg, c) != null) && p.lnum != 0)
;       {
;           if (!@did_title)
;           {
                ;; Highlight title.
;               msg_puts_title(u8("\nmark line  col file/text"));
;               @did_title = true;
;           }
;           msg_putchar('\n');
;           if (!@got_int)
;           {
;               libC.sprintf(@ioBuff, u8(" %c %6ld %4d "), c, p.lnum, p.col);
;               msg_outtrans(@ioBuff);
;               if (name == null && current)
;                   name = mark_line(p, 15);
;               if (name != null)
;                   msg_outtrans_attr(name, current ? hl_attr(HLF_D) : 0);
;           }
;           out_flush();                ;; show one line at a time
;       }
    ))

;; ":delmarks[!] [marks]"

(defn- #_void ex_delmarks [#_exarg_C eap]
    (§
;       if (eap.arg.at(0) == NUL && eap.forceit)
                ;; clear all marks
;           clrallmarks(@curbuf);
;       else if (eap.forceit)
;           emsg(e_invarg);
;       else if (eap.arg.at(0) == NUL)
;           emsg(e_argreq);
;       else
;       {
                ;; clear specified marks only
;           for (Bytes p = eap.arg; p.at(0) != NUL; p = p.plus(1))
;           {
;               boolean lower = asc_islower(p.at(0));
;               boolean digit = asc_isdigit(p.at(0));
;               if (lower || digit || asc_isupper(p.at(0)))
;               {
;                   int from, to;
;                   if (p.at(1) == (byte)'-')
;                   {
                            ;; clear range of marks
;                       from = p.at(0);
;                       to = p.at(2);
;                       if (!(lower ? asc_islower(p.at(2)) : (digit ? asc_isdigit(p.at(2)) : asc_isupper(p.at(2)))) || to < from)
;                       {
;                           emsg2(e_invarg2, p);
;                           return;
;                       }
;                       p = p.plus(2);
;                   }
;                   else
                            ;; clear one lower case mark
;                       from = to = p.at(0);

;                   for (int i = from; i <= to; i++)
;                   {
;                       if (lower)
;                           @curbuf.b_namedm[i - 'a'].lnum = 0;
;                       else
;                       {
;                           int n;
;                           if (digit)
;                               n = i - '0' + NMARKS;
;                           else
;                               n = i - 'A';

;                           namedfm[n].fmark.mark.lnum = 0;
;                           namedfm[n].fname = null;
;                       }
;                   }
;               }
;               else
;                   switch (p.at(0))
;                   {
;                       case '"': @curbuf.b_last_cursor.lnum = 0; break;
;                       case '^': @curbuf.b_last_insert.lnum = 0; break;
;                       case '.': @curbuf.b_last_change.lnum = 0; break;
;                       case '[': @curbuf.b_op_start.lnum    = 0; break;
;                       case ']': @curbuf.b_op_end.lnum      = 0; break;
;                       case '<': @curbuf.b_visual.vi_start.lnum = 0; break;
;                       case '>': @curbuf.b_visual.vi_end.lnum   = 0; break;
;                       case ' ': break;
;                       default:  emsg2(e_invarg2, p);
;                               return;
;                   }
;           }
;       }
    ))

;; print the jumplist

(defn- #_void ex_jumps [#_exarg_C _eap]
    (§
;       cleanup_jumplist();

            ;; Highlight title.
;       msg_puts_title(u8("\n jump line  col file/text"));

;       for (int i = 0; i < @curwin.w_jumplistlen && !@got_int; i++)
;       {
;           if (@curwin.w_jumplist[i].fmark.mark.lnum != 0)
;           {
;               if (@curwin.w_jumplist[i].fmark.fnum == 0)
;                   fname2fnum(@curwin.w_jumplist[i]);

;               Bytes name = fm_getname(@curwin.w_jumplist[i].fmark, 16);
;               if (name == null)       ;; file name not available
;                   continue;

;               msg_putchar('\n');
;               if (@got_int)
;                   break;

;               int x = @curwin.w_jumplistidx;
;               libC.sprintf(@ioBuff, u8("%c %2d %5ld %4d "),
;                   (i == x) ? (byte)'>' : (byte)' ',
;                   (x < i) ? i - x : x - i,
;                   @curwin.w_jumplist[i].fmark.mark.lnum,
;                   @curwin.w_jumplist[i].fmark.mark.col);
;               msg_outtrans(@ioBuff);
;               msg_outtrans_attr(name, (@curwin.w_jumplist[i].fmark.fnum == @curbuf.b_fnum) ? hl_attr(HLF_D) : 0);
;               ui_breakcheck();
;           }
;           out_flush();
;       }

;       if (@curwin.w_jumplistidx == @curwin.w_jumplistlen)
;           msg_puts(u8("\n>"));
    ))

;; print the changelist

(defn- #_void ex_changes [#_exarg_C _eap]
    (§
            ;; Highlight title.
;       msg_puts_title(u8("\nchange line  col text"));

;       for (int i = 0; i < @curbuf.b_changelistlen && !@got_int; i++)
;       {
;           if (@curbuf.b_changelist[i].lnum != 0)
;           {
;               msg_putchar('\n');
;               if (@got_int)
;                   break;
;               int x = @curwin.w_changelistidx;
;               libC.sprintf(@ioBuff, u8("%c %3d %5ld %4d "),
;                       (i == x) ? (byte)'>' : (byte)' ',
;                       (x < i) ? i - x : x - i,
;                       @curbuf.b_changelist[i].lnum,
;                       @curbuf.b_changelist[i].col);
;               msg_outtrans(@ioBuff);
;               Bytes name = mark_line(@curbuf.b_changelist[i], 17);
;               if (name == null)
;                   break;
;               msg_outtrans_attr(name, hl_attr(HLF_D));
;               ui_breakcheck();
;           }
;           out_flush();
;       }

;       if (@curwin.w_changelistidx == @curbuf.b_changelistlen)
;           msg_puts(u8("\n>"));
    ))

(defn- #_long one_adjust [#_long add, #_long line1, #_long line2, #_long amount, #_long amount_after]
    (§
;       if (line1 <= add && add <= line2)
;       {
;           if (amount == MAXLNUM)
;               add = 0;
;           else
;               add += amount;
;       }
;       else if (amount_after != 0 && line2 < add)
;           add += amount_after;

;       return add;
    ))

;; don't delete the line, just put at first deleted line
(defn- #_long one_adjust_nodel [#_long add, #_long line1, #_long line2, #_long amount, #_long amount_after]
    (§
;       if (line1 <= add && add <= line2)
;       {
;           if (amount == MAXLNUM)
;               add = line1;
;           else
;               add += amount;
;       }
;       else if (amount_after != 0 && line2 < add)
;           add += amount_after;

;       return add;
    ))

(atom! pos_C mark_initpos (new_pos 1, 0, 0))

;; Adjust marks between line1 and line2 (inclusive) to move 'amount' lines.
;; Must be called before changed_*(), appended_lines() or deleted_lines().
;; May be called before or after changing the text.
;; When deleting lines line1 to line2, use an 'amount' of MAXLNUM:
;; The marks within this range are made invalid.
;; If 'amount_after' is non-zero adjust marks after line2.
;; Example: Delete lines 34 and 35: mark_adjust(34, 35, MAXLNUM, -2);
;; Example: Insert two lines below 55: mark_adjust(56, MAXLNUM, 2, 0);
;;                                 or: mark_adjust(56, 55, MAXLNUM, 2);

(defn- #_void mark_adjust [#_long line1, #_long line2, #_long amount, #_long amount_after]
    (§
;       int fnum = @curbuf.b_fnum;

;       if (line2 < line1 && amount_after == 0L)                ;; nothing to do
;           return;

;       if (!@cmdmod.lockmarks)
;       {
            ;; named marks, lower case and upper case
;           for (int i = 0; i < NMARKS; i++)
;           {
;               @curbuf.b_namedm[i].lnum = one_adjust(@curbuf.b_namedm[i].lnum, line1, line2, amount, amount_after);
;               if (namedfm[i].fmark.fnum == fnum)
;                   namedfm[i].fmark.mark.lnum = one_adjust_nodel(namedfm[i].fmark.mark.lnum, line1, line2, amount, amount_after);
;           }
;           for (int i = NMARKS; i < NMARKS + EXTRA_MARKS; i++)
;           {
;               if (namedfm[i].fmark.fnum == fnum)
;                   namedfm[i].fmark.mark.lnum = one_adjust_nodel(namedfm[i].fmark.mark.lnum, line1, line2, amount, amount_after);
;           }

            ;; last Insert position
;           @curbuf.b_last_insert.lnum = one_adjust(@curbuf.b_last_insert.lnum, line1, line2, amount, amount_after);

            ;; last change position
;           @curbuf.b_last_change.lnum = one_adjust(@curbuf.b_last_change.lnum, line1, line2, amount, amount_after);

            ;; last cursor position, if it was set
;           if (!eqpos(@curbuf.b_last_cursor, @mark_initpos))
;               @curbuf.b_last_cursor.lnum = one_adjust(@curbuf.b_last_cursor.lnum, line1, line2, amount, amount_after);

            ;; list of change positions
;           for (int i = 0; i < @curbuf.b_changelistlen; i++)
;               @curbuf.b_changelist[i].lnum = one_adjust_nodel(@curbuf.b_changelist[i].lnum, line1, line2, amount, amount_after);

            ;; Visual area.
;           @curbuf.b_visual.vi_start.lnum = one_adjust_nodel(@curbuf.b_visual.vi_start.lnum, line1, line2, amount, amount_after);
;           @curbuf.b_visual.vi_end.lnum = one_adjust_nodel(@curbuf.b_visual.vi_end.lnum, line1, line2, amount, amount_after);
;       }

        ;; previous context mark
;       @curwin.w_pcmark.lnum = one_adjust(@curwin.w_pcmark.lnum, line1, line2, amount, amount_after);

        ;; previous pcmark
;       @curwin.w_prev_pcmark.lnum = one_adjust(@curwin.w_prev_pcmark.lnum, line1, line2, amount, amount_after);

        ;; saved cursor for formatting
;       if (@saved_cursor.lnum != 0)
;           @saved_cursor.lnum = one_adjust_nodel(@saved_cursor.lnum, line1, line2, amount, amount_after);

        ;; Adjust items in all windows related to the current buffer.

;       for (tabpage_C tab = @first_tabpage; tab != null; tab = null)
;           for (window_C win = (tab == @curtab) ? @firstwin : tab.tp_firstwin; win != null; win = win.w_next)
;           {
;               if (!@cmdmod.lockmarks)
                    ;; Marks in the jumplist.  When deleting lines, this may create
                    ;; duplicate marks in the jumplist, they will be removed later.
;                   for (int i = 0; i < win.w_jumplistlen; i++)
;                       if (win.w_jumplist[i].fmark.fnum == fnum)
;                           win.w_jumplist[i].fmark.mark.lnum = one_adjust_nodel(win.w_jumplist[i].fmark.mark.lnum, line1, line2, amount, amount_after);

;               if (win.w_buffer == @curbuf)
;               {
                    ;; the displayed Visual area
;                   if (win.w_old_cursor_lnum != 0)
;                   {
;                       win.w_old_cursor_lnum = one_adjust_nodel(win.w_old_cursor_lnum, line1, line2, amount, amount_after);
;                       win.w_old_visual_lnum = one_adjust_nodel(win.w_old_visual_lnum, line1, line2, amount, amount_after);
;                   }

                    ;; topline and cursor position for windows with the same buffer
                    ;; other than the current window
;                   if (win != @curwin)
;                   {
;                       if (line1 <= win.w_topline && win.w_topline <= line2)
;                       {
;                           if (amount == MAXLNUM)              ;; topline is deleted
;                           {
;                               if (line1 <= 1)
;                                   win.w_topline = 1;
;                               else
;                                   win.w_topline = line1 - 1;
;                           }
;                           else                                ;; keep topline on the same line
;                               win.w_topline += amount;
;                       }
;                       else if (amount_after != 0 && line2 < win.w_topline)
;                       {
;                           win.w_topline += amount_after;
;                       }
;                       if (line1 <= win.w_cursor.lnum && win.w_cursor.lnum <= line2)
;                       {
;                           if (amount == MAXLNUM)              ;; line with cursor is deleted
;                           {
;                               if (line1 <= 1)
;                                   win.w_cursor.lnum = 1;
;                               else
;                                   win.w_cursor.lnum = line1 - 1;
;                               win.w_cursor.col = 0;
;                           }
;                           else                                ;; keep cursor on the same line
;                               win.w_cursor.lnum += amount;
;                       }
;                       else if (amount_after != 0 && line2 < win.w_cursor.lnum)
;                           win.w_cursor.lnum += amount_after;
;                   }
;               }
;           }
    ))

;; This code is used often, needs to be fast.
(defn- #_void col_adjust [#_pos_C posp, #_long lnum, #_int mincol, #_long lnum_amount, #_long col_amount]
    (§
;       if (posp.lnum == lnum && mincol <= posp.col)
;       {
;           posp.lnum += lnum_amount;
;           if (col_amount < 0 && posp.col <= (int)-col_amount)
;               posp.col = 0;
;           else
;               posp.col += col_amount;
;       }
    ))

;; Adjust marks in line "lnum" at column "mincol" and further: add
;; "lnum_amount" to the line number and add "col_amount" to the column position.

(defn- #_void mark_col_adjust [#_long lnum, #_int mincol, #_long lnum_amount, #_long col_amount]
    (§
;       int fnum = @curbuf.b_fnum;

;       if ((col_amount == 0L && lnum_amount == 0L) || @cmdmod.lockmarks)
;           return; ;; nothing to do

        ;; named marks, lower case and upper case
;       for (int i = 0; i < NMARKS; i++)
;       {
;           col_adjust(@curbuf.b_namedm[i], lnum, mincol, lnum_amount, col_amount);
;           if (namedfm[i].fmark.fnum == fnum)
;               col_adjust(namedfm[i].fmark.mark, lnum, mincol, lnum_amount, col_amount);
;       }
;       for (int i = NMARKS; i < NMARKS + EXTRA_MARKS; i++)
;       {
;           if (namedfm[i].fmark.fnum == fnum)
;               col_adjust(namedfm[i].fmark.mark, lnum, mincol, lnum_amount, col_amount);
;       }

        ;; last Insert position
;       col_adjust(@curbuf.b_last_insert, lnum, mincol, lnum_amount, col_amount);

        ;; last change position
;       col_adjust(@curbuf.b_last_change, lnum, mincol, lnum_amount, col_amount);

        ;; list of change positions
;       for (int i = 0; i < @curbuf.b_changelistlen; i++)
;           col_adjust(@curbuf.b_changelist[i], lnum, mincol, lnum_amount, col_amount);

        ;; Visual area.
;       col_adjust(@curbuf.b_visual.vi_start, lnum, mincol, lnum_amount, col_amount);
;       col_adjust(@curbuf.b_visual.vi_end, lnum, mincol, lnum_amount, col_amount);

        ;; previous context mark
;       col_adjust(@curwin.w_pcmark, lnum, mincol, lnum_amount, col_amount);

        ;; previous pcmark
;       col_adjust(@curwin.w_prev_pcmark, lnum, mincol, lnum_amount, col_amount);

        ;; saved cursor for formatting
;       col_adjust(@saved_cursor, lnum, mincol, lnum_amount, col_amount);

        ;; Adjust items in all windows related to the current buffer.

;       for (window_C wp = @firstwin; wp != null; wp = wp.w_next)
;       {
            ;; marks in the jumplist
;           for (int i = 0; i < wp.w_jumplistlen; i++)
;               if (wp.w_jumplist[i].fmark.fnum == fnum)
;                   col_adjust(wp.w_jumplist[i].fmark.mark, lnum, mincol, lnum_amount, col_amount);

;           if (wp.w_buffer == @curbuf)
;           {
                ;; cursor position for other windows with the same buffer
;               if (wp != @curwin)
;                   col_adjust(wp.w_cursor, lnum, mincol, lnum_amount, col_amount);
;           }
;       }
    ))

;; When deleting lines, this may create duplicate marks in the jumplist.
;; They will be removed here for the current window.

(defn- #_void cleanup_jumplist []
    (§
;       int to = 0;

;       for (int from = 0; from < @curwin.w_jumplistlen; from++)
;       {
;           if (@curwin.w_jumplistidx == from)
;               @curwin.w_jumplistidx = to;
;           int i;
;           for (i = from + 1; i < @curwin.w_jumplistlen; i++)
;               if (@curwin.w_jumplist[i].fmark.fnum == @curwin.w_jumplist[from].fmark.fnum
;                       && @curwin.w_jumplist[from].fmark.fnum != 0
;                       && @curwin.w_jumplist[i].fmark.mark.lnum == @curwin.w_jumplist[from].fmark.mark.lnum)
;                   break;
;           if (@curwin.w_jumplistlen <= i)  ;; no duplicate
;               COPY_xfmark(@curwin.w_jumplist[to++], @curwin.w_jumplist[from]);
;           else
;               @curwin.w_jumplist[from].fname = null;
;       }

;       if (@curwin.w_jumplistidx == @curwin.w_jumplistlen)
;           @curwin.w_jumplistidx = to;
;       @curwin.w_jumplistlen = to;
    ))

;; Copy the jumplist from window "from" to window "to".

(defn- #_void copy_jumplist [#_window_C from, #_window_C to]
    (§
;       for (int i = 0; i < from.w_jumplistlen; i++)
;       {
;           COPY_xfmark(to.w_jumplist[i], from.w_jumplist[i]);
;           if (from.w_jumplist[i].fname != null)
;               to.w_jumplist[i].fname = STRDUP(from.w_jumplist[i].fname);
;       }
;       to.w_jumplistlen = from.w_jumplistlen;
;       to.w_jumplistidx = from.w_jumplistidx;
    ))

;; Free items in the jumplist of window "wp".

(defn- #_void free_jumplist [#_window_C wp]
    (§
;       for (int i = 0; i < wp.w_jumplistlen; i++)
;           wp.w_jumplist[i].fname = null;
    ))

(defn- #_void set_last_cursor [#_window_C win]
    (§
;       if (win.w_buffer != null)
;           COPY_pos(win.w_buffer.b_last_cursor, win.w_cursor);
    ))

;;; ============================================================================================== VimL

;; getchar.c --------------------------------------------------------------------------------------
;;
;; functions related with getting a character from the user/mapping/redo/...
;;
;; manipulations with redo buffer and stuff buffer
;; mappings and abbreviations

;; These buffers are used for storing:
;; - stuffed characters: A command that is translated into another command.
;; - redo characters: will redo the last change.
;; - recorded characters: for the "q" command.
;;
;; The bytes are stored like in the typeahead buffer:
;; - KB_SPECIAL introduces a special key (two more bytes follow).
;;   A literal KB_SPECIAL is stored as KB_SPECIAL KS_SPECIAL KE_FILLER.
;; - CSI introduces a GUI termcap code (also when gui.in_use is false,
;;   otherwise switching the GUI on would make mappings invalid).
;;   A literal CSI is stored as CSI KS_EXTRA KE_CSI.
;; These translations are also done on multi-byte characters!
;;
;; Escaping CSI bytes is done by the system-specific input functions, called by ui_inchar().
;; Escaping KB_SPECIAL is done by inchar().
;; Un-escaping is done by vgetc().

(atom! buffheader_C redobuff    (§_buffheader_C))
(atom! buffheader_C old_redobuff    (§_buffheader_C))
(atom! buffheader_C save_redobuff   (§_buffheader_C))
(atom! buffheader_C save_old_redobuff   (§_buffheader_C))
(atom! buffheader_C recordbuff  (§_buffheader_C))

(atom! int typeahead_char)      ;; typeahead char that's not flushed

;; When block_redo is true redo buffer will not be changed;
;; used by edit() to repeat insertions and 'V' command for redoing.

(atom! boolean block_redo)

;; Make a hash value for a mapping.
;; "mode" is the lower 4 bits of the State for the mapping.
;; "c1" is the first character of the "lhs".
;; Returns a value between 0 and 255, index in maphash.
;; Put Normal/Visual mode mappings mostly separately from Insert/Cmdline mode.

(defn- #_int map_hash [#_int mode, #_int c1]
    (§
;       return ((mode & (NORMAL + VISUAL + SELECTMODE + OP_PENDING)) != 0) ? c1 : (c1 ^ 0x80);
    ))

;; Each mapping is put in one of the 256 hash lists, to speed up finding it.

;   static mapblock_C[][] maphash = new mapblock_C[256][1];

;; List used for abbreviations.

;   static mapblock_C[] first_abbr = new mapblock_C[1];     ;; first entry in abbrlist

(atom! int keyNoremap)          ;; remapping flags

;; Variables used by vgetorpeek() and flush_buffers().
;;
;; typebuf.tb_buf[] contains all characters that are not consumed yet.
;; typebuf.tb_buf[typebuf.tb_off] is the first valid character.
;; typebuf.tb_buf[typebuf.tb_off + typebuf.tb_len - 1] is the last valid char.
;; typebuf.tb_buf[typebuf.tb_off + typebuf.tb_len] must be NUL.
;;
;; The head of the buffer may contain the result of mappings, abbreviations
;; and @a commands.  The length of this part is typebuf.tb_maplen.
;; typebuf.tb_silent is the part where <silent> applies.
;; After the head are characters that come from the terminal.
;; typebuf.tb_no_abbr_cnt is the number of characters in typebuf.tb_buf that
;; should not be considered for abbreviations.
;; Some parts of typebuf.tb_buf may not be mapped.  These parts are remembered
;; in typebuf.tb_noremap[], which is the same length as typebuf.tb_buf and
;; contains RM_NONE for the characters that are not to be remapped.
;; typebuf.tb_noremap[typebuf.tb_off] is the first valid flag.

(final int RM_YES          0)       ;; tb_noremap: remap
(final int RM_NONE         1)       ;; tb_noremap: don't remap
(final int RM_SCRIPT       2)       ;; tb_noremap: remap local script mappings
(final int RM_ABBR         4)       ;; tb_noremap: don't remap, do abbrev.

;; typebuf.tb_buf has three parts:
;;  room in front (for result of mappings),
;;  the middle for typeahead and
;;  room for new characters (which needs to be 3 * MAXMAPLEN).

(final int TYPELEN_INIT    (* 5 (+ MAXMAPLEN 3)))
(final Bytes    typebuf_init    (Bytes. TYPELEN_INIT))  ;; initial typebuf.tb_buf
(final Bytes    noremapbuf_init (Bytes. TYPELEN_INIT))  ;; initial typebuf.tb_noremap

(atom! int      last_recorded_len)          ;; number of last recorded chars

;; Free and clear a buffer.

(defn- #_void free_buff [#_buffheader_C buf]
    (§
;       buf.bh_first.bb_next = null;
    ))

;; Return the contents of a buffer as a single string.
;; KB_SPECIAL and CSI in the returned string are escaped.

(defn- #_Bytes get_buffcont [#_buffheader_C buffer, #_boolean dozero]
    ;; dozero: count == zero is not an error
    (§
;       int count = 0;

        ;; compute the total length of the string
;       for (buffblock_C bp = buffer.bh_first.bb_next; bp != null; bp = bp.bb_next)
;           count += STRLEN(bp.bb_str);

;       Bytes p = null;

;       if (0 < count || dozero)
;       {
;           p = new Bytes(count + 1);

;           Bytes q = p;
;           for (buffblock_C bp = buffer.bh_first.bb_next; bp != null; bp = bp.bb_next)
;               for (Bytes s = bp.bb_str; s.at(0) != NUL; )
;                   (q = q.plus(1)).be(-1, (s = s.plus(1)).at(-1));
;           q.be(0, NUL);
;       }

;       return p;
    ))

;; Return the contents of the record buffer as a single string and clear the record buffer.
;; KB_SPECIAL and CSI in the returned string are escaped.

(defn- #_Bytes get_recorded []
    (§
;       Bytes p = get_buffcont(@recordbuff, true);
;       free_buff(@recordbuff);

        ;; Remove the characters that were added the last time, these must be the
        ;; (possibly mapped) characters that stopped the recording.

;       int len = STRLEN(p);
;       if (@last_recorded_len <= len)
;       {
;           len -= @last_recorded_len;
;           p.be(len, NUL);
;       }

        ;; When stopping recording from Insert mode with CTRL-O q, also remove the CTRL-O.

;       if (0 < len && @restart_edit != 0 && p.at(len - 1) == Ctrl_O)
;           p.be(len - 1, NUL);

;       return p;
    ))

;; Return the contents of the redo buffer as a single string.
;; KB_SPECIAL and CSI in the returned string are escaped.

(defn- #_Bytes get_inserted []
    (§
;       return get_buffcont(@redobuff, false);
    ))

;; Add string "s" after the current block of buffer "buf".
;; KB_SPECIAL and CSI should have been escaped already.

(defn- #_void add_buff [#_buffheader_C buf, #_Bytes s, #_long slen]
    ;; slen: length of "s" or -1
    (§
;       if (slen < 0)
;           slen = STRLEN(s);
;       if (slen == 0)                          ;; don't add empty strings
;           return;

;       if (buf.bh_first.bb_next == null)       ;; first add to list
;       {
;           buf.bh_space = 0;
;           buf.bh_curr = buf.bh_first;
;       }
;       else if (buf.bh_curr == null)           ;; buffer has already been read
;       {
;           emsg(u8("E222: Add to read buffer"));
;           return;
;       }
;       else if (buf.bh_index != 0)
;       {
;           buffblock_C bp = buf.bh_first.bb_next;
;           int len = STRLEN(bp.bb_str.plus(buf.bh_index)) + 1;
;           BCOPY(bp.bb_str, 0, bp.bb_str, buf.bh_index, len);
;       }
;       buf.bh_index = 0;

;       if ((int)slen <= buf.bh_space)
;       {
;           int len = STRLEN(buf.bh_curr.bb_str);
;           vim_strncpy(buf.bh_curr.bb_str.plus(len), s, (int)slen);
;           buf.bh_space -= slen;
;       }
;       else
;       {
;           final int MINIMAL_SIZE = 20;            ;; minimal size for bb_str

;           int len = ((int)slen < MINIMAL_SIZE) ? MINIMAL_SIZE : (int)slen;

;           buffblock_C bp = §_buffblock_C();

;           bp.bb_str = new Bytes(len + 1);
;           vim_strncpy(bp.bb_str, s, (int)slen);
;           buf.bh_space = len - (int)slen;

;           bp.bb_next = buf.bh_curr.bb_next;
;           buf.bh_curr.bb_next = bp;
;           buf.bh_curr = bp;
;       }
    ))

;; Add number "n" to buffer "buf".

(defn- #_void add_num_buff [#_buffheader_C buf, #_long n]
    (§
;       Bytes number = new Bytes(32);

;       libC.sprintf(number, u8("%ld"), n);
;       add_buff(buf, number, -1L);
    ))

;; Add character 'c' to buffer "buf".
;; Translates special keys, NUL, CSI, KB_SPECIAL and multibyte characters.

(defn- #_void add_char_buff [#_buffheader_C buf, #_int c]
    (§
;       Bytes bytes = new Bytes(MB_MAXBYTES + 1);

;       int len = is_special(c) ? 1 : utf_char2bytes(c, bytes);

;       Bytes temp = new Bytes(4);

;       for (int i = 0; i < len; i++)
;       {
;           if (!is_special(c))
;               c = char_u(bytes.at(i));

;           if (is_special(c) || c == char_u(KB_SPECIAL) || c == NUL)
;           {
                ;; translate special key code into three byte sequence
;               temp.be(0, KB_SPECIAL);
;               temp.be(1, KB_SECOND(c));
;               temp.be(2, KB_THIRD(c));
;               temp.be(3, NUL);
;           }
;           else
;           {
;               temp.be(0, c);
;               temp.be(1, NUL);
;           }

;           add_buff(buf, temp, -1L);
;       }
    ))

;; First read ahead buffer.  Used for translated commands.
(atom! buffheader_C readbuf1    (§_buffheader_C))

;; Second read ahead buffer.  Used for redo.
(atom! buffheader_C readbuf2    (§_buffheader_C))

;; Get one byte from a read buffer.
;; If advance == true go to the next char.
;; No translation is done KB_SPECIAL and CSI are escaped.

(defn- #_byte read_readbuf [#_buffheader_C buf, #_boolean advance]
    (§
;       buffblock_C bp = buf.bh_first.bb_next;
;       if (bp == null) ;; buffer is empty
;           return NUL;

;       byte b = bp.bb_str.at(buf.bh_index);

;       if (advance && bp.bb_str.at(++buf.bh_index) == NUL)
;       {
;           buf.bh_first.bb_next = bp.bb_next;
;           buf.bh_index = 0;
;       }

;       return b;
    ))

;; Get one byte from the read buffers.
;; Use readbuf1 one first, use readbuf2 if that one is empty.
;; If advance == true go to the next char.
;; No translation is done KB_SPECIAL and CSI are escaped.

(defn- #_byte read_readbuffers [#_boolean advance]
    (§
;       byte b = read_readbuf(@readbuf1, advance);
;       if (b == NUL)
;           b = read_readbuf(@readbuf2, advance);
;       return b;
    ))

;; Prepare the read buffers for reading (if they contain something).

(defn- #_void start_stuff []
    (§
;       if (@readbuf1.bh_first.bb_next != null)
;       {
;           @readbuf1.bh_curr = @readbuf1.bh_first;
;           @readbuf1.bh_space = 0;
;       }
;       if (@readbuf2.bh_first.bb_next != null)
;       {
;           @readbuf2.bh_curr = @readbuf2.bh_first;
;           @readbuf2.bh_space = 0;
;       }
    ))

;; Return true if the stuff buffer is empty.

(defn- #_boolean stuff_empty []
    (§
;       return (@readbuf1.bh_first.bb_next == null && @readbuf2.bh_first.bb_next == null);
    ))

;; Return true if readbuf1 is empty.  There may still be redo characters in readbuf2.

(defn- #_boolean readbuf1_empty []
    (§
;       return (@readbuf1.bh_first.bb_next == null);
    ))

;; Set a typeahead character that won't be flushed.

(defn- #_void typeahead_noflush [#_int c]
    (§
;       @typeahead_char = c;
    ))

;; Remove the contents of the stuff buffer and the mapped characters
;; in the typeahead buffer (used in case of an error).
;; If "flush_typeahead" is true, flush all typeahead characters
;; (used when interrupted by a CTRL-C).

(defn- #_void flush_buffers [#_boolean flush_typeahead]
    (§
;       init_typebuf();

;       start_stuff();
;       while (read_readbuffers(true) != NUL)
        ;

;       if (flush_typeahead)            ;; remove all typeahead
;       {
            ;; We have to get all characters, because we may delete the first part of an escape sequence.
            ;; In an xterm we get one char at a time and we have to get them all.

;           while (inchar(@typebuf.tb_buf, @typebuf.tb_buflen - 1, 10L, @typebuf.tb_change_cnt) != 0)
            ;
;           @typebuf.tb_off = MAXMAPLEN;
;           @typebuf.tb_len = 0;
;       }
;       else                    ;; remove mapped characters at the start only
;       {
;           @typebuf.tb_off += @typebuf.tb_maplen;
;           @typebuf.tb_len -= @typebuf.tb_maplen;
;       }
;       @typebuf.tb_maplen = 0;
;       @typebuf.tb_silent = 0;
;       @cmd_silent = false;
;       @typebuf.tb_no_abbr_cnt = 0;
    ))

;; The previous contents of the redo buffer is kept in old_redobuffer.
;; This is used for the CTRL-O <.> command in insert mode.

(defn- #_void resetRedobuff []
    (§
;       if (!@block_redo)
;       {
;           free_buff(@old_redobuff);
;           COPY_buffheader(@old_redobuff, @redobuff);
;           @redobuff.bh_first.bb_next = null;
;       }
    ))

;; Discard the contents of the redo buffer and restore the previous redo buffer.

(defn- #_void cancelRedo []
    (§
;       if (!@block_redo)
;       {
;           free_buff(@redobuff);
;           COPY_buffheader(@redobuff, @old_redobuff);
;           @old_redobuff.bh_first.bb_next = null;
;           start_stuff();
;           while (read_readbuffers(true) != NUL)
            ;
;       }
    ))

;; Save redobuff and old_redobuff to save_redobuff and save_old_redobuff.
;; Used before executing autocommands and user functions.

(atom! int save__level)

(defn- #_void saveRedobuff []
    (§
;       if (@save__level++ == 0)
;       {
;           COPY_buffheader(@save_redobuff, @redobuff);
;           @redobuff.bh_first.bb_next = null;
;           COPY_buffheader(@save_old_redobuff, @old_redobuff);
;           @old_redobuff.bh_first.bb_next = null;

            ;; Make a copy, so that ":normal ." in a function works.
;           Bytes s = get_buffcont(@save_redobuff, false);
;           if (s != null)
;               add_buff(@redobuff, s, -1L);
;       }
    ))

;; Restore redobuff and old_redobuff from save_redobuff and save_old_redobuff.
;; Used after executing autocommands and user functions.

(defn- #_void restoreRedobuff []
    (§
;       if (--@save__level == 0)
;       {
;           free_buff(@redobuff);
;           COPY_buffheader(@redobuff, @save_redobuff);
;           free_buff(@old_redobuff);
;           COPY_buffheader(@old_redobuff, @save_old_redobuff);
;       }
    ))

;; Append "s" to the redo buffer.
;; KB_SPECIAL and CSI should already have been escaped.

(defn- #_void appendToRedobuff [#_Bytes s]
    (§
;       if (!@block_redo)
;           add_buff(@redobuff, s, -1L);
    ))

;; Append to Redo buffer literally, escaping special characters with CTRL-V.
;; KB_SPECIAL and CSI are escaped as well.

(defn- #_void appendToRedobuffLit [#_Bytes str, #_int len]
    ;; len: length of "str" or -1 for up to the NUL
    (§
;       if (@block_redo)
;           return;

;       for (Bytes[] s = { str }; (len < 0) ? (s[0].at(0) != NUL) : (BDIFF(s[0], str) < len); )
;       {
            ;; Put a string of normal characters in the redo buffer (that's faster).
;           Bytes start = s[0];
;           while (' ' <= s[0].at(0) && s[0].at(0) < DEL && (len < 0 || BDIFF(s[0], str) < len))
;               s[0] = s[0].plus(1);

            ;; Don't put '0' or '^' as last character, just in case a CTRL-D is typed next.
;           if (s[0].at(0) == NUL && (s[0].at(-1) == (byte)'0' || s[0].at(-1) == (byte)'^'))
;               s[0] = s[0].minus(1);
;           if (BLT(start, s[0]))
;               add_buff(@redobuff, start, BDIFF(s[0], start));

;           if (s[0].at(0) == NUL || (0 <= len && len <= BDIFF(s[0], str)))
;               break;

            ;; Handle a special or multibyte character.
            ;; Handle composing chars separately.
;           int c = us_ptr2char_adv(s, false);
;           if (c < ' ' || c == DEL || (s[0].at(0) == NUL && (c == '0' || c == '^')))
;               add_char_buff(@redobuff, Ctrl_V);

            ;; CTRL-V '0' must be inserted as CTRL-V 048
;           if (s[0].at(0) == NUL && c == '0')
;               add_buff(@redobuff, u8("048"), 3L);
;           else
;               add_char_buff(@redobuff, c);
;       }
    ))

;; Append a character to the redo buffer.
;; Translates special keys, NUL, CSI, KB_SPECIAL and multibyte characters.

(defn- #_void appendCharToRedobuff [#_int c]
    (§
;       if (!@block_redo)
;           add_char_buff(@redobuff, c);
    ))

;; Append a number to the redo buffer.

(defn- #_void appendNumberToRedobuff [#_long n]
    (§
;       if (!@block_redo)
;           add_num_buff(@redobuff, n);
    ))

;; Append string "s" to the stuff buffer.
;; CSI and KB_SPECIAL must already have been escaped.

(defn- #_void stuffReadbuff [#_Bytes s]
    (§
;       add_buff(@readbuf1, s, -1L);
    ))

;; Append string "s" to the redo stuff buffer.
;; CSI and KB_SPECIAL must already have been escaped.

(defn- #_void stuffRedoReadbuff [#_Bytes s]
    (§
;       add_buff(@readbuf2, s, -1L);
    ))

(defn- #_void stuffReadbuffLen [#_Bytes s, #_long len]
    (§
;       add_buff(@readbuf1, s, len);
    ))

;; Stuff "s" into the stuff buffer,
;; leaving special key codes unmodified and escaping other KB_SPECIAL and CSI bytes.
;; Change CR, LF and ESC into a space.

(defn- #_void stuffReadbuffSpec [#_Bytes _s]
    (§
;       for (Bytes[] s = { _s }; s[0].at(0) != NUL; )
;       {
;           if (s[0].at(0) == KB_SPECIAL && s[0].at(1) != NUL && s[0].at(2) != NUL)
;           {
                ;; Insert special key literally.
;               stuffReadbuffLen(s[0], 3L);
;               s[0] = s[0].plus(3);
;           }
;           else
;           {
;               int c = us_ptr2char_adv(s, true);
;               if (c == CAR || c == NL || c == ESC)
;                   c = ' ';
;               stuffcharReadbuff(c);
;           }
;       }
    ))

;; Append a character to the stuff buffer.
;; Translates special keys, NUL, CSI, KB_SPECIAL and multibyte characters.

(defn- #_void stuffcharReadbuff [#_int c]
    (§
;       add_char_buff(@readbuf1, c);
    ))

;; Append a number to the stuff buffer.

(defn- #_void stuffnumReadbuff [#_long n]
    (§
;       add_num_buff(@readbuf1, n);
    ))

(atom! buffblock_C redo_bp)
(atom! Bytes redo_sp)

;; Prepare for redo; return false if nothing to redo, true otherwise.
;; If old_redo is true, use old_redobuff instead of redobuff.

(defn- #_boolean init_redo [#_boolean old_redo]
    (§
;       if (old_redo)
;           @redo_bp = @old_redobuff.bh_first.bb_next;
;       else
;           @redo_bp = @redobuff.bh_first.bb_next;
;       if (@redo_bp == null)
;           return false;

;       @redo_sp = @redo_bp.bb_str;
;       return true;
    ))

;; Read a character from the redo buffer.
;; Translates KB_SPECIAL, CSI and multibyte characters.
;; The redo buffer is left as it is.

(defn- #_int read_redo []
    (§
;       if (@redo_sp.at(0) != NUL)
;       {
            ;; For a multi-byte character get all the bytes and return the converted character.
;           int n;
;           if (@redo_sp.at(0) != KB_SPECIAL || @redo_sp.at(1) == KS_SPECIAL)
;               n = mb_byte2len(char_u(@redo_sp.at(0)));
;           else
;               n = 1;

;           Bytes buf = new Bytes(MB_MAXBYTES + 1);

;           for (int i = 0; ; i++)
;           {
;               int c;
;               if (@redo_sp.at(0) == KB_SPECIAL)   ;; special key or escaped KB_SPECIAL
;               {
;                   c = toSpecial(@redo_sp.at(1), @redo_sp.at(2));
;                   @redo_sp = @redo_sp.plus(3);
;               }
;               else
;               {
;                   c = char_u(@redo_sp.at(0));
;                   @redo_sp = @redo_sp.plus(1);
;               }

;               if (@redo_sp.at(0) == NUL && @redo_bp.bb_next != null)
;               {
;                   @redo_bp = @redo_bp.bb_next;
;                   @redo_sp = @redo_bp.bb_str;
;               }

;               buf.be(i, c);
;               if (i == n - 1)                 ;; last byte of a character
;               {
;                   if (n != 1)
;                       c = us_ptr2char(buf);
;                   return c;
;               }

;               if (@redo_sp.at(0) == NUL)          ;; cannot happen?
;                   break;
;           }
;       }

;       return NUL;
    ))

;; Stuff the redo buffer into readbuf2.
;; Insert the redo count into the command.
;; If "old_redo" is true, the last but one command is repeated
;; instead of the last command (inserting text).
;; This is used for CTRL-O <.> in insert mode.
;;
;; Return false for failure, true otherwise.

(defn- #_boolean start_redo [#_long count, #_boolean old_redo]
    (§
        ;; init the pointers; return if nothing to redo
;       if (!init_redo(old_redo))
;           return false;

;       int c = read_redo();

        ;; copy the buffer name, if present
;       if (c == '"')
;       {
;           add_buff(@readbuf2, u8("\""), 1L);
;           c = read_redo();

            ;; if a numbered buffer is used, increment the number
;           if ('1' <= c && c < '9')
;               c++;
;           add_char_buff(@readbuf2, c);
;           c = read_redo();
;       }

;       if (c == 'v')   ;; redo Visual
;       {
;           COPY_pos(@VIsual, @curwin.w_cursor);
;           @VIsual_active = true;
;           @VIsual_select = false;
;           @VIsual_reselect = true;
;           @redo_VIsual_busy = true;
;           c = read_redo();
;       }

        ;; try to enter the count (in place of a previous count)
;       if (count != 0)
;       {
;           while (asc_isdigit(c))  ;; skip "old" count
;               c = read_redo();
;           add_num_buff(@readbuf2, count);
;       }

        ;; copy from the redo buffer into the stuff buffer
;       add_char_buff(@readbuf2, c);
;       while ((c = read_redo()) != NUL)
;           add_char_buff(@readbuf2, c);

;       return true;
    ))

;; Repeat the last insert (R, o, O, a, A, i or I command) by stuffing the redo buffer into readbuf2.
;; Return false for failure, true otherwise.

(defn- #_boolean start_redo_ins []
    (§
;       if (!init_redo(false))
;           return false;

;       start_stuff();

        ;; skip the count and the command character
;       for (int c; (c = read_redo()) != NUL; )
;       {
;           if (vim_strchr(u8("AaIiRrOo"), c) != null)
;           {
;               if (c == 'O' || c == 'o')
;                   add_buff(@readbuf2, NL_STR, -1L);
;               break;
;           }
;       }

        ;; copy the typed text from the redo buffer into the stuff buffer
;       for (int c; (c = read_redo()) != NUL; )
;           add_char_buff(@readbuf2, c);

;       @block_redo = true;
;       return true;
    ))

(defn- #_void stop_redo_ins []
    (§
;       @block_redo = false;
    ))

;; Initialize typebuf.tb_buf to point to typebuf_init.
;; calloc() cannot be used here: In out-of-memory situations it would
;; be impossible to type anything.

(defn- #_void init_typebuf []
    (§
;       if (@typebuf.tb_buf == null)
;       {
;           @typebuf.tb_buf = typebuf_init;
;           @typebuf.tb_noremap = noremapbuf_init;
;           @typebuf.tb_buflen = TYPELEN_INIT;
;           @typebuf.tb_len = 0;
;           @typebuf.tb_off = 0;
;           @typebuf.tb_change_cnt = 1;
;       }
    ))

;; Insert a string in position 'offset' in the typeahead buffer
;; (for "@r" and ":normal" command, vgetorpeek() and check_termcode()).
;;
;; If noremap is REMAP_YES, new string can be mapped again.
;; If noremap is REMAP_NONE, new string cannot be mapped again.
;; If noremap is REMAP_SKIP, fist char of new string cannot be mapped again,
;; but abbreviations are allowed.
;; If noremap is REMAP_SCRIPT, new string cannot be mapped again,
;; except for script-local mappings.
;; If noremap is > 0, that many characters of the new string cannot be mapped.
;;
;; If nottyped is true, the string does not return keyTyped
;; (don't use when offset is non-zero!).
;;
;; If silent is true, cmd_silent is set when the characters are obtained.
;;
;; Return false for failure, true otherwise.

(defn- #_boolean ins_typebuf [#_Bytes str, #_int noremap, #_int offset, #_boolean nottyped, #_boolean silent]
    (§
;       init_typebuf();
;       if (++@typebuf.tb_change_cnt == 0)
;           @typebuf.tb_change_cnt = 1;

;       int addlen = STRLEN(str);

        ;; Easy case: there is room in front of typebuf.tb_buf[typebuf.tb_off]

;       if (offset == 0 && addlen <= @typebuf.tb_off)
;       {
;           @typebuf.tb_off -= addlen;
;           BCOPY(@typebuf.tb_buf, @typebuf.tb_off, str, 0, addlen);
;       }

        ;; Need to allocate a new buffer.
        ;; In typebuf.tb_buf there must always be room for 3 * MAXMAPLEN + 4 characters.
        ;; We add some extra room to avoid having to allocate too often.

;       else
;       {
;           int newoff = MAXMAPLEN + 4;
;           int newlen = @typebuf.tb_len + addlen + newoff + 4 * (MAXMAPLEN + 4);
;           if (newlen < 0)                 ;; string is getting too long
;           {
;               emsg(e_toocompl);           ;; also calls flush_buffers
;               setcursor();
;               return false;
;           }
;           Bytes s1 = new Bytes(newlen);
;           Bytes s2 = new Bytes(newlen);
;           @typebuf.tb_buflen = newlen;

            ;; copy the old chars, before the insertion point
;           BCOPY(s1, newoff, @typebuf.tb_buf, @typebuf.tb_off, offset);
            ;; copy the new chars
;           BCOPY(s1, newoff + offset, str, 0, addlen);
            ;; copy the old chars, after the insertion point, including the NUL at the end
;           BCOPY(s1, newoff + offset + addlen, @typebuf.tb_buf, @typebuf.tb_off + offset, @typebuf.tb_len - offset + 1);
;           @typebuf.tb_buf = s1;

;           BCOPY(s2, newoff, @typebuf.tb_noremap, @typebuf.tb_off, offset);
;           BCOPY(s2, newoff + offset + addlen, @typebuf.tb_noremap, @typebuf.tb_off + offset, @typebuf.tb_len - offset);
;           @typebuf.tb_noremap = s2;

;           @typebuf.tb_off = newoff;
;       }
;       @typebuf.tb_len += addlen;

        ;; If noremap == REMAP_SCRIPT: do remap script-local mappings.
;       int val;
;       if (noremap == REMAP_SCRIPT)
;           val = RM_SCRIPT;
;       else if (noremap == REMAP_SKIP)
;           val = RM_ABBR;
;       else
;           val = RM_NONE;

        ;; Adjust typebuf.tb_noremap[] for the new characters:
        ;; If noremap == REMAP_NONE or REMAP_SCRIPT: new characters are (sometimes) not remappable.
        ;; If noremap == REMAP_YES: all the new characters are mappable.
        ;; If noremap  > 0: "noremap" characters are not remappable, the rest mappable.

;       int nrm;
;       if (noremap == REMAP_SKIP)
;           nrm = 1;
;       else if (noremap < 0)
;           nrm = addlen;
;       else
;           nrm = noremap;
;       for (int i = 0; i < addlen; i++)
;           @typebuf.tb_noremap.be(@typebuf.tb_off + i + offset, (0 <= --nrm) ? val : RM_YES);

        ;; 'tb_maplen' and 'tb_silent' only remember the length of mapped and/or silent mappings at the
        ;; start of the buffer, assuming that a mapped sequence doesn't result in typed characters.
;       if (nottyped || offset < @typebuf.tb_maplen)
;           @typebuf.tb_maplen += addlen;
;       if (silent || offset < @typebuf.tb_silent)
;       {
;           @typebuf.tb_silent += addlen;
;           @cmd_silent = true;
;       }
;       if (@typebuf.tb_no_abbr_cnt != 0 && offset == 0) ;; and not used for abbrev.s
;           @typebuf.tb_no_abbr_cnt += addlen;

;       return true;
    ))

;; Put character "c" back into the typeahead buffer.
;; Can be used for a character obtained by vgetc() that needs to be put back.
;; Uses cmd_silent, keyTyped and keyNoremap to restore the flags belonging to the char.

(defn- #_void ins_char_typebuf [#_int c]
    (§
;       Bytes buf = new Bytes(MB_MAXBYTES + 1);
;       if (is_special(c))
;       {
;           buf.be(0, KB_SPECIAL);
;           buf.be(1, KB_SECOND(c));
;           buf.be(2, KB_THIRD(c));
;           buf.be(3, NUL);
;       }
;       else
;       {
;           buf.be(utf_char2bytes(c, buf), NUL);
;       }
;       ins_typebuf(buf, @keyNoremap, 0, !@keyTyped, @cmd_silent);
    ))

;; Return true if the typeahead buffer was changed (while waiting for a character to arrive).
;; Happens when a message was received from a client or from feedkeys().
;; But check in a more generic way to avoid trouble: When "typebuf.tb_buf"
;; changed it was reallocated and the old pointer can no longer be used.
;; Or "typebuf.tb_off" may have been changed and we would overwrite characters that was just added.

(defn- #_boolean typebuf_changed [#_int tb_change_cnt]
    ;; tb_change_cnt: old value of typebuf.tb_change_cnt
    (§
;       return (tb_change_cnt != 0 && (@typebuf.tb_change_cnt != tb_change_cnt || @typebuf_was_filled));
    ))

;; Return true if there are no characters in the typeahead buffer that have
;; not been typed (result from a mapping or come from ":normal").

(defn- #_boolean typebuf_typed []
    (§
;       return (@typebuf.tb_maplen == 0);
    ))

;; Return the number of characters that are mapped (or not typed).

(defn- #_int typebuf_maplen []
    (§
;       return @typebuf.tb_maplen;
    ))

;; remove "len" characters from typebuf.tb_buf[typebuf.tb_off + offset]

(defn- #_void del_typebuf [#_int len, #_int offset]
    (§
;       if (len == 0)
;           return;         ;; nothing to do

;       @typebuf.tb_len -= len;

        ;; Easy case: Just increase typebuf.tb_off.

;       if (offset == 0 && 3 * MAXMAPLEN + 3 <= @typebuf.tb_buflen - (@typebuf.tb_off + len))
;           @typebuf.tb_off += len;

        ;; Have to move the characters in typebuf.tb_buf[] and typebuf.tb_noremap[]

;       else
;       {
;           int i = @typebuf.tb_off + offset;

            ;; Leave some extra room at the end to avoid reallocation.

;           if (MAXMAPLEN < @typebuf.tb_off)
;           {
;               BCOPY(@typebuf.tb_buf, MAXMAPLEN, @typebuf.tb_buf, @typebuf.tb_off, offset);
;               BCOPY(@typebuf.tb_noremap, MAXMAPLEN, @typebuf.tb_noremap, @typebuf.tb_off, offset);
;               @typebuf.tb_off = MAXMAPLEN;
;           }
            ;; adjust typebuf.tb_buf (include the NUL at the end)
;           BCOPY(@typebuf.tb_buf, @typebuf.tb_off + offset, @typebuf.tb_buf, i + len, @typebuf.tb_len - offset + 1);
            ;; adjust typebuf.tb_noremap[]
;           BCOPY(@typebuf.tb_noremap, @typebuf.tb_off + offset, @typebuf.tb_noremap, i + len, @typebuf.tb_len - offset);
;       }

;       if (offset < @typebuf.tb_maplen)             ;; adjust tb_maplen
;       {
;           if (@typebuf.tb_maplen < offset + len)
;               @typebuf.tb_maplen = offset;
;           else
;               @typebuf.tb_maplen -= len;
;       }
;       if (offset < @typebuf.tb_silent)             ;; adjust tb_silent
;       {
;           if (@typebuf.tb_silent < offset + len)
;               @typebuf.tb_silent = offset;
;           else
;               @typebuf.tb_silent -= len;
;       }
;       if (offset < @typebuf.tb_no_abbr_cnt)        ;; adjust tb_no_abbr_cnt
;       {
;           if (@typebuf.tb_no_abbr_cnt < offset + len)
;               @typebuf.tb_no_abbr_cnt = offset;
;           else
;               @typebuf.tb_no_abbr_cnt -= len;
;       }

        ;; Reset the flag that text received from a client or from feedkeys()
        ;; was inserted in the typeahead buffer.
;       @typebuf_was_filled = false;
;       if (++@typebuf.tb_change_cnt == 0)
;           @typebuf.tb_change_cnt = 1;
    ))

;; Write typed characters to script file.
;; If recording is on put the character in the recordbuffer.

(defn- #_void gotchars [#_Bytes chars, #_int len]
    (§
;       Bytes buf = new Bytes(2);

        ;; Remember how many chars were last recorded.
;       if (@Recording)
;           @last_recorded_len += len;

;       for (int todo = len; 0 < todo--; )
;       {
            ;; Handle one byte at a time; no translation to be done.
;           byte c = (chars = chars.plus(1)).at(-1);
;           updatescript(c);

;           if (@Recording)
;           {
;               buf.be(0, c);
;               add_buff(@recordbuff, buf, 1L);
;           }
;       }
;       may_sync_undo();

        ;; Since characters have been typed, consider the following to be in another mapping.
        ;; Search string will be kept in history.
;       @maptick++;
    ))

;; Sync undo.  Called when typed characters are obtained from the typeahead
;; buffer, or when a menu is used.
;; Do not sync:
;; - In Insert mode, unless cursor key has been used.
;; - While reading a script file.
;; - When no_u_sync is non-zero.

(defn- #_void may_sync_undo []
    (§
;       if ((@State & (INSERT + CMDLINE)) == 0 || @arrow_used)
;           u_sync(false);
    ))

;; Make "typebuf" empty and allocate new buffers.

(defn- #_void alloc_typebuf []
    (§
;       @typebuf.tb_buf = new Bytes(TYPELEN_INIT);
;       @typebuf.tb_noremap = new Bytes(TYPELEN_INIT);
;       @typebuf.tb_buflen = TYPELEN_INIT;
;       @typebuf.tb_off = 0;
;       @typebuf.tb_len = 0;
;       @typebuf.tb_maplen = 0;
;       @typebuf.tb_silent = 0;
;       @typebuf.tb_no_abbr_cnt = 0;
;       if (++@typebuf.tb_change_cnt == 0)
;           @typebuf.tb_change_cnt = 1;
    ))

;; Free the buffers of "typebuf".

(defn- #_void free_typebuf []
    (§
;       if (BNE(@typebuf.tb_buf, typebuf_init))
;           @typebuf.tb_buf = null;
;       if (BNE(@typebuf.tb_noremap, noremapbuf_init))
;           @typebuf.tb_noremap = null;
    ))

;; When doing ":so! file", the current typeahead needs to be saved,
;; and restored when "file" has been read completely.

(atom! int old_char         -1) ;; character put back by vungetc()
(atom! int old_mod_mask)        ;; mod_mask for ungotten character
(atom! int old_mouse_row)       ;; mouse_row related to old_char
(atom! int old_mouse_col)       ;; mouse_col related to old_char

;; Save all three kinds of typeahead, so that the user must type at a prompt.

(defn- #_void save_typeahead [#_tasave_C tp]
    (§
;       alloc_typebuf();

;       tp.old_char = @old_char;
;       tp.old_mod_mask = @old_mod_mask;
;       @old_char = -1;

;       COPY_buffheader(tp.save_readbuf1, @readbuf1);
;       @readbuf1.bh_first.bb_next = null;
;       COPY_buffheader(tp.save_readbuf2, @readbuf2);
;       @readbuf2.bh_first.bb_next = null;

;       save_input_buf(tp);
    ))

;; Restore the typeahead to what it was before calling save_typeahead().
;; The allocated memory is freed, can only be called once!

(defn- #_void restore_typeahead [#_tasave_C tp]
    (§
;       free_typebuf();

;       @old_char = tp.old_char;
;       @old_mod_mask = tp.old_mod_mask;

;       free_buff(@readbuf1);
;       COPY_buffheader(@readbuf1, tp.save_readbuf1);
;       free_buff(@readbuf2);
;       COPY_buffheader(@readbuf2, tp.save_readbuf2);

;       restore_input_buf(tp);
    ))

;; This function is called just before doing a blocking wait.
;; Thus after waiting 'updatetime' for a character to arrive.

(defn- #_void before_blocking []
    (§
;       updatescript(NUL);
    ))

;; updatescipt() is called when a character can be written into the script file
;; or when we have waited some time for a character (c == 0)

(defn- #_void updatescript [#_byte c]
    (§
        
    ))

;; Get the next input character.
;; Can return a special key or a multi-byte character.
;; Can return NUL when called recursively, use safe_vgetc() if that's not wanted.
;; This translates escaped KB_SPECIAL and CSI bytes to a KB_SPECIAL or CSI byte.
;; Collects the bytes of a multibyte character into the whole character.
;; Returns the modifiers in the global "mod_mask".

(defn- #_int vgetc []
    (§
;       int c;

        ;; If a character was put back with vungetc, it was already processed.
        ;; Return it directly.

;       if (@old_char != -1)
;       {
;           c = @old_char;
;           @old_char = -1;
;           @mod_mask = @old_mod_mask;
;           @mouse_row = @old_mouse_row;
;           @mouse_col = @old_mouse_col;
;       }
;       else
;       {
;           Bytes buf = new Bytes(MB_MAXBYTES + 1);

;           @mod_mask = 0;
;           @last_recorded_len = 0;

;           for ( ; ; )                     ;; this is done twice if there are modifiers
;           {
;               if (@mod_mask != 0)          ;; no mapping after modifier has been read
;               {
;                   @no_mapping++;
;                   @allow_keys++;
;               }
;               c = vgetorpeek(true);
;               if (@mod_mask != 0)
;               {
;                   --@no_mapping;
;                   --@allow_keys;
;               }

                ;; Get two extra bytes for special keys.
;               if (c == char_u(KB_SPECIAL))
;               {
;                   int save_allow_keys = @allow_keys;

;                   @no_mapping++;
;                   @allow_keys = 0;                 ;; make sure BS is not found
;                   int c2 = vgetorpeek(true);      ;; no mapping for these chars
;                   c = vgetorpeek(true);
;                   --@no_mapping;
;                   @allow_keys = save_allow_keys;

;                   if (c2 == char_u(KS_MODIFIER))
;                   {
;                       @mod_mask = c;
;                       continue;
;                   }
;                   c = toSpecial((byte)c2, (byte)c);
;               }

                ;; a keypad or special function key was not mapped, use it like its ASCII equivalent
;               switch (c)
;               {
;                   case K_KPLUS:       c = '+'; break;
;                   case K_KMINUS:      c = '-'; break;
;                   case K_KDIVIDE:     c = '/'; break;
;                   case K_KMULTIPLY:   c = '*'; break;
;                   case K_KENTER:      c = CAR; break;
;                   case K_KPOINT:      c = '.'; break;
;                   case K_K0:          c = '0'; break;
;                   case K_K1:          c = '1'; break;
;                   case K_K2:          c = '2'; break;
;                   case K_K3:          c = '3'; break;
;                   case K_K4:          c = '4'; break;
;                   case K_K5:          c = '5'; break;
;                   case K_K6:          c = '6'; break;
;                   case K_K7:          c = '7'; break;
;                   case K_K8:          c = '8'; break;
;                   case K_K9:          c = '9'; break;

;                   case K_XHOME:
;                   case K_ZHOME:       if (@mod_mask == MOD_MASK_SHIFT)
;                                       {
;                                           c = K_S_HOME;
;                                           @mod_mask = 0;
;                                       }
;                                       else if (@mod_mask == MOD_MASK_CTRL)
;                                       {
;                                           c = K_C_HOME;
;                                           @mod_mask = 0;
;                                       }
;                                       else
;                                           c = K_HOME;
;                                       break;
;                   case K_XEND:
;                   case K_ZEND:        if (@mod_mask == MOD_MASK_SHIFT)
;                                       {
;                                           c = K_S_END;
;                                           @mod_mask = 0;
;                                       }
;                                       else if (@mod_mask == MOD_MASK_CTRL)
;                                       {
;                                           c = K_C_END;
;                                           @mod_mask = 0;
;                                       }
;                                       else
;                                           c = K_END;
;                                       break;

;                   case K_XUP:         c = K_UP; break;
;                   case K_XDOWN:       c = K_DOWN; break;
;                   case K_XLEFT:       c = K_LEFT; break;
;                   case K_XRIGHT:      c = K_RIGHT; break;
;               }

                ;; For a multi-byte character get all the bytes and return the converted character.
                ;; Note: This will loop until enough bytes are received!

;               int n = mb_byte2len(c);
;               if (1 < n)
;               {
;                   @no_mapping++;
;                   buf.be(0, c);
;                   for (int i = 1; i < n; i++)
;                   {
;                       buf.be(i, vgetorpeek(true));
;                       if (buf.at(i) == KB_SPECIAL)
;                       {
                            ;; Must be a KB_SPECIAL - KS_SPECIAL - KE_FILLER sequence,
                            ;; which represents a KB_SPECIAL (0x80),
                            ;; or a CSI - KS_EXTRA - KE_CSI sequence, which represents a CSI (0x9B),
                            ;; of a KB_SPECIAL - KS_EXTRA - KE_CSI, which is CSI too.
;                           c = vgetorpeek(true);
;                           if (vgetorpeek(true) == KE_CSI && c == char_u(KS_EXTRA))
;                               buf.be(i, CSI);
;                       }
;                   }
;                   --@no_mapping;
;                   c = us_ptr2char(buf);
;               }

;               break;
;           }
;       }

;       return c;
    ))

;; Like vgetc(), but never return a NUL when called recursively,
;; get a key directly from the user (ignoring typeahead).

(defn- #_int safe_vgetc []
    (§
;       int c = vgetc();
;       if (c == NUL)
;           c = get_keystroke();
;       return c;
    ))

;; Like safe_vgetc(), but loop to handle K_IGNORE.
;; Also ignore scrollbar events.

(defn- #_int plain_vgetc []
    (§
;       int c;

;       do
;       {
;           c = safe_vgetc();
;       } while (c == K_IGNORE || c == K_VER_SCROLLBAR || c == K_HOR_SCROLLBAR);

;       return c;
    ))

;; Check if a character is available, such that vgetc() will not block.
;; If the next character is a special character or multi-byte, the returned character is not valid!.

(defn- #_int vpeekc []
    (§
;       if (@old_char != -1)
;           return @old_char;

;       return vgetorpeek(false);
    ))

;; Like vpeekc(), but don't allow mapping.  Do allow checking for terminal codes.

(defn- #_int vpeekc_nomap []
    (§
;       int c;

;       @no_mapping++;
;       @allow_keys++;
;       c = vpeekc();
;       --@no_mapping;
;       --@allow_keys;

;       return c;
    ))

;; Check if any character is available, also half an escape sequence.
;; Trick: when no typeahead found, but there is something in the typeahead
;; buffer, it must be an ESC that is recognized as the start of a key code.

(defn- #_int vpeekc_any []
    (§
;       int c = vpeekc();
;       if (c == NUL && 0 < @typebuf.tb_len)
;           c = ESC;
;       return c;
    ))

;; Call vpeekc() without causing anything to be mapped.
;; Return true if a character is available, false otherwise.

(defn- #_boolean char_avail []
    (§
;       int retval;

;       @no_mapping++;
;       retval = vpeekc();
;       --@no_mapping;

;       return (retval != NUL);
    ))

;; unget one character (can only be done once!)
(defn- #_void vungetc [#_int c]
    (§
;       @old_char = c;
;       @old_mod_mask = @mod_mask;
;       @old_mouse_row = @mouse_row;
;       @old_mouse_col = @mouse_col;
    ))

(atom! int __tc)

;; get a character:
;; 1. from the stuffbuffer
;;      This is used for abbreviated commands like "D" -> "d$".
;;      Also used to redo a command for ".".
;; 2. from the typeahead buffer
;;      Stores text obtained previously but not used yet.
;;      Also stores the result of mappings.
;;      Also used for the ":normal" command.
;; 3. from the user
;;      This may do a blocking wait if "advance" is true.
;;
;; if "advance" is true (vgetc()):
;;      really get the character.
;;      keyTyped is set to true in the case the user typed the key.
;;      keyStuffed is true if the character comes from the stuff buffer.
;; if "advance" is false (vpeekc()):
;;      just look whether there is a character available.
;;
;; When "no_mapping" is zero, checks for mappings in the current mode.
;; Only returns one byte (of a multi-byte character).
;; KB_SPECIAL and CSI may be escaped, need to get two more bytes then.

(defn- #_int vgetorpeek [#_boolean advance]
    (§
        ;; This function doesn't work very well when called recursively.
        ;; It may happen though, because of:
        ;;
        ;; 1. The call to add_to_showcmd(). char_avail() is then used to check
        ;; if there is a character available, which calls this function.
        ;; In that case we must return NUL, to indicate no character is available.
        ;;
        ;; 2. A GUI callback function writes to the screen, causing a wait_return().
        ;; Using ":normal" can also do this, but it saves the typeahead buffer,
        ;; thus it should be OK.  But don't get a key from the user then.

;       if (0 < @vgetc_busy && @ex_normal_busy == 0)
;           return NUL;

;       int local_State = get_real_state();

;       @vgetc_busy++;

;       if (advance)
;           @keyStuffed = false;

;       init_typebuf();
;       start_stuff();
;       if (advance && @typebuf.tb_maplen == 0)
;           @execReg = false;

;       boolean timedout = false;       ;; waited for more than 1 second for mapping to complete
;       int mapdepth = 0;               ;; check for recursive mapping
;       boolean mode_deleted = false;   ;; set when mode has been deleted

;       int c;

;       do
;       {
;; get a character: 1. from the stuffbuffer

;           if (@typeahead_char != 0)
;           {
;               c = @typeahead_char;
;               if (advance)
;                   @typeahead_char = 0;
;           }
;           else
;               c = char_u(read_readbuffers(advance));

;           if (c != NUL && !@got_int)
;           {
;               if (advance)
;               {
                    ;; keyTyped = false;
                    ;; When the command that stuffed something was typed,
                    ;; behave like the stuffed command was typed;
                    ;; needed e.g. for CTRL-W CTRl-] to open a fold.
;                   @keyStuffed = true;
;               }
;               if (@typebuf.tb_no_abbr_cnt == 0)
;                   @typebuf.tb_no_abbr_cnt = 1; ;; no abbreviations now
;           }
;           else
;           {
                ;; Loop until we either find a matching mapped key,
                ;; or we are sure that it is not a mapped key.
                ;; If a mapped key sequence is found, we go back to the start to try re-mapping.

;               for ( ; ; )
;               {
                    ;; ui_breakcheck() is slow, don't use it too often when inside a mapping.
                    ;; But call it each time for typed characters.

;                   if (@typebuf.tb_maplen != 0)
;                       line_breakcheck();
;                   else
;                       ui_breakcheck();            ;; check for CTRL-C

;                   if (@got_int)
;                   {
                        ;; flush all input
;                       int len = inchar(@typebuf.tb_buf, @typebuf.tb_buflen - 1, 0L, @typebuf.tb_change_cnt);

                        ;; If inchar() returns true (script file was active)
                        ;; or we are inside a mapping, get out of insert mode.
                        ;; Otherwise we behave like having gotten a CTRL-C.
                        ;; As a result typing CTRL-C in insert mode will really insert a CTRL-C.

;                       if ((len != 0 || @typebuf.tb_maplen != 0) && (@State & (INSERT + CMDLINE)) != 0)
;                           c = ESC;
;                       else
;                           c = Ctrl_C;

;                       flush_buffers(true);        ;; flush all typeahead

;                       if (advance)
;                       {
                            ;; Also record this character, it might be needed to get out of Insert mode.
;                           @typebuf.tb_buf.be(0, c);
;                           gotchars(@typebuf.tb_buf, 1);
;                       }
;                       @cmd_silent = false;

;                       break;
;                   }

;                   int keylen = 0;

;                   if (0 < @typebuf.tb_len)
;                   {
;                       int mp_match_len = 0;

                        ;; Check for a mappable key sequence.
                        ;; Walk through one maphash[] list until we find an entry that matches.
                        ;;
                        ;; Don't look for mappings if:
                        ;; - no_mapping set: mapping disabled (e.g. for CTRL-V)
                        ;; - typebuf.tb_buf[typebuf.tb_off] should not be remapped
                        ;; - in insert or cmdline mode and 'paste' option set
                        ;; - waiting for "hit return to continue" and CR or SPACE typed
                        ;; - waiting for a char with --more--
                        ;; - in Ctrl-X mode, and we get a valid char for that mode

;                       mapblock_C mp = null;
;                       int max_mlen = 0;
;                       int c1 = char_u(@typebuf.tb_buf.at(@typebuf.tb_off));
;                       if (@no_mapping == 0
;                               && (@no_zero_mapping == 0 || c1 != '0')
;                               && (@typebuf.tb_maplen == 0
;                                   || (@p_remap
;                                       && (@typebuf.tb_noremap.at(@typebuf.tb_off) & (RM_NONE|RM_ABBR)) == 0))
;                               && !(@p_paste && (@State & (INSERT + CMDLINE)) != 0)
;                               && !(@State == HITRETURN && (c1 == CAR || c1 == ' '))
;                               && @State != ASKMORE
;                               && @State != CONFIRM)
;                       {
                            ;; First try buffer-local mappings.
;                           int h1 = map_hash(local_State, c1);
;                           mp = @curbuf.b_maphash[h1][0];
;                           mapblock_C mp2 = maphash[h1][0];
;                           if (mp == null)
;                           {
                                ;; There are no buffer-local mappings.
;                               mp = mp2;
;                               mp2 = null;
;                           }

                            ;; Loop until a partly matching mapping is found or
                            ;; all (local) mappings have been checked.
                            ;; The longest full match is remembered in "mp_match".
                            ;; A full match is only accepted if there is no partly
                            ;; match, so "aa" and "aaa" can both be mapped.

;                           mapblock_C mp_match = null;
;                           boolean __;
;                           for ( ; mp != null; mp = mp.m_next, __ = (mp == null && (mp = mp2) == mp2 && (mp2 = null) == null))
;                           {
                                ;; Only consider an entry if the first character
                                ;; matches and it is for the current state.

;                               if (mp.m_keys.at(0) == c1 && (mp.m_mode & local_State) != 0)
;                               {
                                    ;; find the match length of this mapping
;                                   int mlen;
;                                   for (mlen = 1; mlen < @typebuf.tb_len; mlen++)
;                                   {
;                                       if (mp.m_keys.at(mlen) != @typebuf.tb_buf.at(@typebuf.tb_off + mlen))
;                                           break;
;                                   }

                                    ;; Don't allow mapping the first byte(s) of a multi-byte char.
                                    ;; Happens when mapping <M-a> and then changing 'encoding'.
                                    ;; Beware that 0x80 is escaped.
;                                   {
;                                       Bytes[] p1 = { mp.m_keys };
;                                       Bytes p2 = mb_unescape(p1);

;                                       if (p2 != null && us_ptr2len_cc(p2) < mb_byte2len(c1))
;                                           mlen = 0;
;                                   }

                                    ;; Check an entry whether it matches.
                                    ;; - full match: mlen == keylen
                                    ;; - partly match: mlen == typebuf.tb_len

;                                   keylen = mp.m_keylen;
;                                   if (mlen == keylen || (mlen == @typebuf.tb_len && @typebuf.tb_len < keylen))
;                                   {
                                        ;; If only script-local mappings are allowed,
                                        ;; check if the mapping starts with K_SNR.

;                                       Bytes s = @typebuf.tb_noremap.plus(@typebuf.tb_off);
;                                       if (s.at(0) == RM_SCRIPT
;                                               && (mp.m_keys.at(0) != KB_SPECIAL
;                                                || mp.m_keys.at(1) != KS_EXTRA
;                                                || mp.m_keys.at(2) != KE_SNR))
;                                           continue;

                                        ;; If one of the typed keys cannot be remapped, skip the entry.

;                                       int n;
;                                       for (n = mlen; 0 <= --n; )
;                                           if (((s = s.plus(1)).at(-1) & (RM_NONE|RM_ABBR)) != 0)
;                                               break;
;                                       if (0 <= n)
;                                           continue;

;                                       if (@typebuf.tb_len < keylen)
;                                       {
;                                           if (!timedout && !(mp_match != null && mp_match.m_nowait))
;                                           {
                                                ;; break at a partly match
;                                               keylen = KEYLEN_PART_MAP;
;                                               break;
;                                           }
;                                       }
;                                       else if (mp_match_len < keylen)
;                                       {
                                            ;; found a longer match
;                                           mp_match = mp;
;                                           mp_match_len = keylen;
;                                       }
;                                   }
;                                   else
                                        ;; No match; may have to check for termcode at next character.
;                                       if (max_mlen < mlen)
;                                           max_mlen = mlen;
;                               }
;                           }

                            ;; If no partly match found, use the longest full match.
;                           if (keylen != KEYLEN_PART_MAP)
;                           {
;                               mp = mp_match;
;                               keylen = mp_match_len;
;                           }
;                       }

                        ;; Check for match with 'pastetoggle'.
;                       if (@p_pt.at(0) != NUL && mp == null && (@State & (INSERT|NORMAL)) != 0)
;                       {
;                           int mlen;
;                           for (mlen = 0; mlen < @typebuf.tb_len && @p_pt.at(mlen) != NUL; mlen++)
;                               if (@p_pt.at(mlen) != @typebuf.tb_buf.at(@typebuf.tb_off + mlen))
;                                   break;
;                           if (@p_pt.at(mlen) == NUL)            ;; match
;                           {
                                ;; write chars to script file(s)
;                               if (@typebuf.tb_maplen < mlen)
;                                   gotchars(@typebuf.tb_buf.plus(@typebuf.tb_off + @typebuf.tb_maplen), mlen - @typebuf.tb_maplen);

;                               del_typebuf(mlen, 0);               ;; remove the chars
;                               set_option_value(u8("paste"), !@p_paste ? TRUE : FALSE, null, 0);
;                               if ((@State & INSERT) == 0)
;                               {
;                                   @msg_col = 0;
;                                   @msg_row = (int)@Rows - 1;
;                                   msg_clr_eos();                  ;; clear ruler
;                               }
;                               status_redraw_all();
;                               redraw_statuslines();
;                               showmode();
;                               setcursor();
;                               continue;
;                           }
                            ;; Need more chars for partly match.
;                           if (mlen == @typebuf.tb_len)
;                               keylen = KEYLEN_PART_KEY;
;                           else if (max_mlen < mlen)
                                ;; No match; may have to check for termcode at next character.
;                               max_mlen = mlen + 1;
;                       }

;                       if ((mp == null || mp_match_len <= max_mlen) && keylen != KEYLEN_PART_MAP)
;                       {
;                           int save_keylen = keylen;

                            ;; When no matching mapping found or found a non-matching mapping
                            ;; that matches at least what the matching mapping matched:
                            ;; Check if we have a terminal code, when:
                            ;; - mapping is allowed,
                            ;; - keys have not been mapped,
                            ;; - and not an ESC sequence, not in insert mode or "p_ek" is on,
                            ;; - and when not timed out.

;                           if ((@no_mapping == 0 || @allow_keys != 0)
;                                   && (@typebuf.tb_maplen == 0
;                                       || (@p_remap && @typebuf.tb_noremap.at(@typebuf.tb_off) == RM_YES))
;                                   && !timedout)
;                           {
;                               keylen = check_termcode(max_mlen + 1, null, 0, null);

                                ;; If no termcode matched but 'pastetoggle' matched partially,
                                ;; it's like an incomplete key sequence.
;                               if (keylen == 0 && save_keylen == KEYLEN_PART_KEY)
;                                   keylen = KEYLEN_PART_KEY;

                                ;; When getting a partial match, but the last characters were not typed,
                                ;; don't wait for a typed character to complete the termcode.
                                ;; This helps a lot when a ":normal" command ends in an ESC.

;                               if (keylen < 0 && @typebuf.tb_len == @typebuf.tb_maplen)
;                                   keylen = 0;
;                           }
;                           else
;                               keylen = 0;

;                           if (keylen == 0)        ;; no matching terminal code
;                           {
                                ;; When there was a matching mapping and no termcode could be
                                ;; replaced after another one, use that mapping (loop around).
                                ;; If there was no mapping use the character from the
                                ;; typeahead buffer right here.
;                               if (mp == null)
;                               {
;; get a character: 2. from the typeahead buffer

;                                   c = @typebuf.tb_buf.at(@typebuf.tb_off) & 0xff;
;                                   if (advance)    ;; remove chars from tb_buf
;                                   {
;                                       @cmd_silent = (0 < @typebuf.tb_silent);
;                                       if (0 < @typebuf.tb_maplen)
;                                           @keyTyped = false;
;                                       else
;                                       {
;                                           @keyTyped = true;
                                            ;; write char to script file(s)
;                                           gotchars(@typebuf.tb_buf.plus(@typebuf.tb_off), 1);
;                                       }
;                                       @keyNoremap = @typebuf.tb_noremap.at(@typebuf.tb_off);
;                                       del_typebuf(1, 0);
;                                   }
;                                   break;          ;; got character, break for loop
;                               }
;                           }
;                           if (0 < keylen)         ;; full matching terminal code
;                           {
;                               continue;           ;; try mapping again
;                           }

                            ;; Partial match: get some more characters.
                            ;; When a matching mapping was found use that one.
;                           if (mp == null || keylen < 0)
;                               keylen = KEYLEN_PART_KEY;
;                           else
;                               keylen = mp_match_len;
;                       }

                        ;; complete match
;                       if (0 <= keylen && keylen <= @typebuf.tb_len)
;                       {
                            ;; write chars to script file(s)
;                           if (@typebuf.tb_maplen < keylen)
;                               gotchars(@typebuf.tb_buf.plus(@typebuf.tb_off + @typebuf.tb_maplen), keylen - @typebuf.tb_maplen);

;                           @cmd_silent = (0 < @typebuf.tb_silent);
;                           del_typebuf(keylen, 0);     ;; remove the mapped keys

                            ;; Put the replacement string in front of mapstr.
                            ;; The depth check catches ":map x y" and ":map y x".

;                           if (@p_mmd <= ++mapdepth)
;                           {
;                               emsg(u8("E223: recursive mapping"));
;                               if ((@State & CMDLINE) != 0)
;                                   redrawcmdline();
;                               else
;                                   setcursor();
;                               flush_buffers(false);
;                               mapdepth = 0;           ;; for next one
;                               c = -1;
;                               break;
;                           }

                            ;; In Select mode and a Visual mode mapping is used:
                            ;; switch to Visual mode temporarily.
                            ;; Append K_SELECT to switch back to Select mode.

;                           if (@VIsual_active && @VIsual_select && (mp.m_mode & VISUAL) != 0)
;                           {
;                               @VIsual_select = false;
;                               ins_typebuf(K_SELECT_STRING, REMAP_NONE, 0, true, false);
;                           }

                            ;; Copy the values from *mp that are used, because
                            ;; evaluating the expression may invoke a function that
                            ;; redefines the mapping, thereby making *mp invalid.
;                           int save_m_noremap = mp.m_noremap;
;                           boolean save_m_silent = mp.m_silent;
;                           Bytes save_m_keys = null;      ;; only saved when needed
;                           Bytes save_m_str = null;       ;; only saved when needed

                            ;; Handle ":map <expr>": evaluate the {rhs} as an expression.
                            ;; Also save and restore the command line for "normal :".

;                           Bytes s;
;                           if (mp.m_expr)
;                           {
;                               int save_vgetc_busy = @vgetc_busy;

;                               @vgetc_busy = 0;
;                               save_m_keys = STRDUP(mp.m_keys);
;                               save_m_str = STRDUP(mp.m_str);
;                               s = eval_map_expr(save_m_str, NUL);
;                               @vgetc_busy = save_vgetc_busy;
;                           }
;                           else
;                               s = mp.m_str;

                            ;; Insert the 'to' part in the typebuf.tb_buf.
                            ;; If 'from' field is the same as the start of the 'to' field,
                            ;; don't remap the first character (but do allow abbreviations).
                            ;; If m_noremap is set, don't remap the whole 'to' part.

;                           boolean b = false;
;                           if (s != null)
;                           {
;                               int noremap;

;                               if (save_m_noremap != REMAP_YES)
;                                   noremap = save_m_noremap;
;                               else if (STRNCMP(s, (save_m_keys != null) ? save_m_keys : mp.m_keys, keylen) != 0)
;                                   noremap = REMAP_YES;
;                               else
;                                   noremap = REMAP_SKIP;
;                               b = ins_typebuf(s, noremap, 0, true, @cmd_silent || save_m_silent);
;                           }
;                           if (!b)
;                           {
;                               c = -1;
;                               break;
;                           }
;                           continue;
;                       }
;                   }

;; get a character: 3. from the user - handle <Esc> in Insert mode

                    ;; Special case: if we get an <ESC> in insert mode and there are no more
                    ;; characters at once, we pretend to go out of insert mode.  This prevents
                    ;; the one second delay after typing an <ESC>.  If we get something after
                    ;; all, we may have to redisplay the mode.  That the cursor is in the wrong
                    ;; place does not matter.

;                   int len = 0;
;                   int new_wcol = @curwin.w_wcol;
;                   int new_wrow = @curwin.w_wrow;
;                   if (advance
;                           && @typebuf.tb_len == 1
;                           && @typebuf.tb_buf.at(@typebuf.tb_off) == ESC
;                           && @no_mapping == 0
;                           && @ex_normal_busy == 0
;                           && @typebuf.tb_maplen == 0
;                           && (@State & INSERT) != 0
;                           && (@p_timeout || (keylen == KEYLEN_PART_KEY && @p_ttimeout))
;                           && (len = inchar(@typebuf.tb_buf.plus(@typebuf.tb_off + @typebuf.tb_len), 3, 25L,
;                                                                                   @typebuf.tb_change_cnt)) == 0)
;                   {
;                       if (@mode_displayed)
;                       {
;                           unshowmode(true);
;                           mode_deleted = true;
;                       }
;                       validate_cursor();
;                       int old_wcol = @curwin.w_wcol;
;                       int old_wrow = @curwin.w_wrow;

                        ;; move cursor left, if possible
;                       if (@curwin.w_cursor.col != 0)
;                       {
;                           int col = 0;
;                           if (0 < @curwin.w_wcol)
;                           {
;                               if (@did_ai)
;                               {
                                    ;; We are expecting to truncate the trailing white-space,
                                    ;; so find the last non-white character.

;                                   col = @curwin.w_wcol = 0;
;                                   Bytes ptr = ml_get_curline();
;                                   for (int vcol = col; col < @curwin.w_cursor.col; )
;                                   {
;                                       if (!vim_iswhite(ptr.at(col)))
;                                           @curwin.w_wcol = vcol;
;                                       vcol += lbr_chartabsize(ptr, ptr.plus(col), vcol);
;                                       col += us_ptr2len_cc(ptr.plus(col));
;                                   }
;                                   @curwin.w_wrow = @curwin.w_cline_row + @curwin.w_wcol / @curwin.w_width;
;                                   @curwin.w_wcol %= @curwin.w_width;
;                                   @curwin.w_wcol += curwin_col_off();
;                                   col = 0;        ;; no correction needed
;                               }
;                               else
;                               {
;                                   --@curwin.w_wcol;
;                                   col = @curwin.w_cursor.col - 1;
;                               }
;                           }
;                           else if (@curwin.w_onebuf_opt.@wo_wrap && 0 < @curwin.w_wrow)
;                           {
;                               --@curwin.w_wrow;
;                               @curwin.w_wcol = @curwin.w_width - 1;
;                               col = @curwin.w_cursor.col - 1;
;                           }

;                           if (0 < col && 0 < @curwin.w_wcol)
;                           {
                                ;; Correct when the cursor is on the right halve of a double-wide character.
;                               Bytes p = ml_get_curline();
;                               col -= us_head_off(p, p.plus(col));
;                               if (1 < us_ptr2cells(p.plus(col)))
;                                   --@curwin.w_wcol;
;                           }
;                       }
;                       setcursor();
;                       out_flush();
;                       new_wcol = @curwin.w_wcol;
;                       new_wrow = @curwin.w_wrow;
;                       @curwin.w_wcol = old_wcol;
;                       @curwin.w_wrow = old_wrow;
;                   }
;                   if (len < 0)
;                       continue;   ;; end of input script reached

                    ;; Allow mapping for just typed characters.
                    ;; When we get here, len is the number of extra bytes and typebuf.tb_len is 1.
;                   for (int n = 1; n <= len; n++)
;                       @typebuf.tb_noremap.be(@typebuf.tb_off + n, RM_YES);
;                   @typebuf.tb_len += len;

                    ;; buffer full, don't map
;                   if (@typebuf.tb_maplen + MAXMAPLEN <= @typebuf.tb_len)
;                   {
;                       timedout = true;
;                       continue;
;                   }

;                   if (0 < @ex_normal_busy)
;                   {
                        ;; No typeahead left and inside ":normal".
                        ;; Must return something to avoid getting stuck.
                        ;; When an incomplete mapping is present, behave like it timed out.
;                       if (0 < @typebuf.tb_len)
;                       {
;                           timedout = true;
;                           continue;
;                       }
                        ;; When 'insertmode' is set, ESC just beeps in Insert mode.
                        ;; Use CTRL-L to make edit() return.
                        ;; For the command line only CTRL-C always breaks it.
                        ;; For the cmdline window: Alternate between ESC and CTRL-C:
                        ;; ESC for most situations and CTRL-C to close the cmdline window.
;                       if (@p_im && (@State & INSERT) != 0)
;                           c = Ctrl_L;
;                       else if ((@State & CMDLINE) != 0 || (0 < @cmdwin_type && @__tc == ESC))
;                           c = Ctrl_C;
;                       else
;                           c = ESC;
;                       @__tc = c;
;                       break;
;                   }

;; get a character: 3. from the user - update display

                    ;; In insert mode a screen update is skipped when characters are still available.
                    ;; But when those available characters are part of a mapping, and we are going
                    ;; to do a blocking wait here.  Need to update the screen to display the changed
                    ;; text so far.  Also for when 'lazyredraw' is set and redrawing was postponed
                    ;; because there was something in the input buffer (e.g., termresponse).
;                   if (((@State & INSERT) != 0 || @p_lz) && (@State & CMDLINE) == 0
;                             && advance && @must_redraw != 0 && !@need_wait_return)
;                   {
;                       update_screen(0);
;                       setcursor();            ;; put cursor back where it belongs
;                   }

                    ;; If we have a partial match (and are going to wait for more input from the user),
                    ;; show the partially matched characters to the user with showcmd.

;                   int i = 0;
;                   int c1 = 0;
;                   if (0 < @typebuf.tb_len && advance && @exmode_active == 0)
;                   {
;                       if ((@State & (NORMAL | INSERT)) != 0 && @State != HITRETURN)
;                       {
                            ;; this looks nice when typing a dead character map
;                           if ((@State & INSERT) != 0
;                               && mb_ptr2cells(@typebuf.tb_buf.plus(@typebuf.tb_off + @typebuf.tb_len - 1)) == 1)
;                           {
;                               edit_putchar(@typebuf.tb_buf.at(@typebuf.tb_off + @typebuf.tb_len - 1), false);
;                               setcursor();    ;; put cursor back where it belongs
;                               c1 = 1;
;                           }
                            ;; need to use the col and row from above here
;                           int old_wcol = @curwin.w_wcol;
;                           int old_wrow = @curwin.w_wrow;
;                           @curwin.w_wcol = new_wcol;
;                           @curwin.w_wrow = new_wrow;
;                           push_showcmd();
;                           if (SHOWCMD_COLS < @typebuf.tb_len)
;                               i = @typebuf.tb_len - SHOWCMD_COLS;
;                           for ( ; i < @typebuf.tb_len; i++)
;                               add_to_showcmd(@typebuf.tb_buf.at(@typebuf.tb_off + i));
;                           @curwin.w_wcol = old_wcol;
;                           @curwin.w_wrow = old_wrow;
;                       }

                        ;; this looks nice when typing a dead character map
;                       if ((@State & CMDLINE) != 0
;                               && @cmdline_star == 0
;                               && mb_ptr2cells(@typebuf.tb_buf.plus(@typebuf.tb_off + @typebuf.tb_len - 1)) == 1)
;                       {
;                           putcmdline(@typebuf.tb_buf.at(@typebuf.tb_off + @typebuf.tb_len - 1), false);
;                           c1 = 1;
;                       }
;                   }

;; get a character: 3. from the user - get it

;                   int wait_tb_len = @typebuf.tb_len;
;                   len = inchar(@typebuf.tb_buf.plus(@typebuf.tb_off + @typebuf.tb_len),
;                           @typebuf.tb_buflen - @typebuf.tb_off - @typebuf.tb_len - 1,
;                           !advance
;                               ? 0
;                               : ((@typebuf.tb_len == 0
;                                       || !(@p_timeout || (@p_ttimeout && keylen == KEYLEN_PART_KEY)))
;                                       ? -1L
;                                       : ((keylen == KEYLEN_PART_KEY && 0 <= @p_ttm)
;                                               ? @p_ttm
;                                               : @p_tm)), @typebuf.tb_change_cnt);

;                   if (i != 0)
;                       pop_showcmd();
;                   if (c1 == 1)
;                   {
;                       if ((@State & INSERT) != 0)
;                           edit_unputchar();
;                       if ((@State & CMDLINE) != 0)
;                           unputcmdline();
;                       else
;                           setcursor();            ;; put cursor back where it belongs
;                   }

;                   if (len < 0)
;                       continue;                   ;; end of input script reached
;                   if (len == 0)                   ;; no character available
;                   {
;                       if (!advance)
;                       {
;                           c = NUL;
;                           break;
;                       }
;                       if (0 < wait_tb_len)        ;; timed out
;                       {
;                           timedout = true;
;                           continue;
;                       }
;                   }
;                   else
;                   {   ;; allow mapping for just typed characters
;                       while (@typebuf.tb_buf.at(@typebuf.tb_off + @typebuf.tb_len) != NUL)
;                           @typebuf.tb_noremap.be(@typebuf.tb_off + @typebuf.tb_len++, RM_YES);
;                   }
;               }
;           }
;       } while (c < 0 || (advance && c == NUL));   ;; if advance is false don't loop on NULs

        ;; The "INSERT" message is taken care of here:
        ;;   if we return an ESC to exit insert mode, the message is deleted;
        ;;   if we don't return an ESC, but deleted the message before, redisplay it.

;       if (advance && @p_smd && @msg_silent == 0 && (@State & INSERT) != 0)
;       {
;           if (c == ESC && !mode_deleted && @no_mapping == 0 && @mode_displayed)
;           {
;               if (@typebuf.tb_len != 0 && !@keyTyped)
;                   @redraw_cmdline = true;          ;; delete mode later
;               else
;                   unshowmode(false);
;           }
;           else if (c != ESC && mode_deleted)
;           {
;               if (@typebuf.tb_len != 0 && !@keyTyped)
;                   @redraw_cmdline = true;          ;; show mode later
;               else
;                   showmode();
;           }
;       }

;       --@vgetc_busy;

;       return c;
    ))

;; inchar() - get one character from
;;      1. a scriptfile
;;      2. the keyboard
;;
;; As much characters as we can get (upto 'maxlen') are put in "buf" and
;; NUL terminated (buffer length must be 'maxlen' + 1).
;; Minimum for "maxlen" is 3!!!!
;;
;; "tb_change_cnt" is the value of typebuf.tb_change_cnt if "buf" points into it.
;; When typebuf.tb_change_cnt changes (e.g., when a message is received from
;; a remote client) "buf" can no longer be used.  "tb_change_cnt" is 0 otherwise.
;;
;; If we got an interrupt all input is read until none is available.
;;
;; If wait_time == 0  there is no waiting for the char.
;; If wait_time == n  we wait for n msec for a character to arrive.
;; If wait_time == -1 we wait forever for a character to arrive.
;;
;; Return the number of obtained characters.
;; Return -1 when end of input script reached.

(defn- #_int inchar [#_Bytes buf, #_int maxlen, #_long wait_time, #_int tb_change_cnt]
    ;; wait_time: milli seconds
    (§
;       if (wait_time == -1L || 100L < wait_time)   ;; flush output before waiting
;       {
;           cursor_on();
;           out_flush();
;       }

;       @undo_off = false;                           ;; restart undo now

;       int len = 0;
;       boolean retesc = false;                     ;; return ESC with gotint

        ;; If we got an interrupt, skip all previously typed characters
        ;; and return true if quit reading script file.
        ;; Stop reading typeahead when a single CTRL-C was read,
        ;; fill_input_buf() returns this when not able to read from stdin.
        ;; Don't use *buf here, closescript() may have freed typebuf.tb_buf[]
        ;; and "buf" may be pointing inside typebuf.tb_buf[].

;       if (@got_int)
;       {
;           final int DUM_LEN = MAXMAPLEN * 3 + 3;
;           Bytes dum = new Bytes(DUM_LEN + 1);

;           for ( ; ; )
;           {
;               len = ui_inchar(dum, DUM_LEN, 0L, 0);
;               if (len == 0 || (len == 1 && dum.at(0) == 3))
;                   break;
;           }
;           return retesc ? 1 : 0;
;       }

        ;; Always flush the output characters when getting input characters from the user.

;       out_flush();

        ;; Fill up to a third of the buffer, because each character may be tripled below.

;       len = ui_inchar(buf, maxlen / 3, wait_time, tb_change_cnt);

;       if (typebuf_changed(tb_change_cnt))
;           return 0;

;       return fix_input_buffer(buf, len, false);
    ))

;; Fix typed characters for use by vgetc() and check_termcode().
;; buf[] must have room to triple the number of bytes!
;; Returns the new length.

(defn- #_int fix_input_buffer [#_Bytes buf, #_int len, #_boolean script]
    ;; script: true when reading from a script
    (§
        ;; Two characters are special: NUL and KB_SPECIAL.
        ;; When compiled With the GUI CSI is also special.
        ;; Replace        NUL by KB_SPECIAL KS_ZERO    KE_FILLER
        ;; Replace KB_SPECIAL by KB_SPECIAL KS_SPECIAL KE_FILLER
        ;; Replace        CSI by KB_SPECIAL KS_EXTRA   KE_CSI
        ;; Don't replace KB_SPECIAL when reading a script file.

;       Bytes p = buf;
;       for (int i = len; 0 <= --i; p = p.plus(1))
;       {
;           if (p.at(0) == NUL || (p.at(0) == KB_SPECIAL && !script
                    ;; timeout may generate K_CURSORHOLD
;                   && (i < 2 || p.at(1) != KS_EXTRA || p.at(2) != KE_CURSORHOLD)))
;           {
;               BCOPY(p, 3, p, 1, i);
;               p.be(2, KB_THIRD(char_u(p.at(0))));
;               p.be(1, KB_SECOND(char_u(p.at(0))));
;               p.be(0, KB_SPECIAL);
;               p = p.plus(2);
;               len += 2;
;           }
;       }
;       p.be(0, NUL);           ;; add trailing NUL

;       return len;
    ))

;; Return true when bytes are in the input buffer or in the typeahead buffer.
;; Normally the input buffer would be sufficient, but the server_to_input_buf()
;; or feedkeys() may insert characters in the typeahead buffer while we are
;; waiting for input to arrive.

(defn- #_boolean input_available []
    (§
;       return (!is_input_buf_empty() || @typebuf_was_filled);
    ))

;; map[!]                   : show all key mappings
;; map[!] {lhs}             : show key mapping for {lhs}
;; map[!] {lhs} {rhs}       : set key mapping for {lhs} to {rhs}
;; noremap[!] {lhs} {rhs}   : same, but no remapping for {rhs}
;; unmap[!] {lhs}           : remove key mapping for {lhs}
;; abbr                     : show all abbreviations
;; abbr {lhs}               : show abbreviations for {lhs}
;; abbr {lhs} {rhs}         : set abbreviation for {lhs} to {rhs}
;; noreabbr {lhs} {rhs}     : same, but no remapping for {rhs}
;; unabbr {lhs}             : remove abbreviation for {lhs}
;;
;; maptype: 0 for :map, 1 for :unmap, 2 for noremap.
;;
;; arg is pointer to any arguments.  Note: arg cannot be a read-only string,
;; it will be modified.
;;
;; for :map   mode is NORMAL + VISUAL + SELECTMODE + OP_PENDING
;; for :map!  mode is INSERT + CMDLINE
;; for :cmap  mode is CMDLINE
;; for :imap  mode is INSERT
;; for :nmap  mode is NORMAL
;; for :vmap  mode is VISUAL + SELECTMODE
;; for :xmap  mode is VISUAL
;; for :smap  mode is SELECTMODE
;; for :omap  mode is OP_PENDING
;;
;; for :abbr  mode is INSERT + CMDLINE
;; for :iabbr mode is INSERT
;; for :cabbr mode is CMDLINE
;;
;; Return 0 for success
;;        1 for invalid arguments
;;        2 for no match
;;        4 for out of mem
;;        5 for entry not unique

(defn- #_int do_map [#_int maptype, #_Bytes arg, #_int mode, #_boolean abbrev]
    ;; abbrev: not a mapping but an abbreviation
    (§
;       int retval = 0;

;       int len = 0;
;       boolean did_it = false;
;       boolean did_local = false;
;       boolean unique = false;
;       boolean nowait = false;
;       boolean silent = false;
;       boolean special = false;
;       boolean expr = false;

;       Bytes keys = arg;
;       mapblock_C[][] map_table = maphash;
;       mapblock_C[] abbr_table = first_abbr;

        ;; For ":noremap" don't remap, otherwise do remap.
;       int noremap;
;       if (maptype == 2)
;           noremap = REMAP_NONE;
;       else
;           noremap = REMAP_YES;

        ;; Accept <buffer>, <nowait>, <silent>, <expr> <script> and <unique> in any order.
;       for ( ; ; )
;       {
            ;; Check for "<buffer>": mapping local to buffer.

;           if (STRNCMP(keys, u8("<buffer>"), 8) == 0)
;           {
;               keys = skipwhite(keys.plus(8));
;               map_table = @curbuf.b_maphash;
;               abbr_table = @curbuf.b_first_abbr;
;               continue;
;           }

            ;; Check for "<nowait>": don't wait for more characters.

;           if (STRNCMP(keys, u8("<nowait>"), 8) == 0)
;           {
;               keys = skipwhite(keys.plus(8));
;               nowait = true;
;               continue;
;           }

            ;; Check for "<silent>": don't echo commands.

;           if (STRNCMP(keys, u8("<silent>"), 8) == 0)
;           {
;               keys = skipwhite(keys.plus(8));
;               silent = true;
;               continue;
;           }

            ;; Check for "<special>": accept special keys in <>

;           if (STRNCMP(keys, u8("<special>"), 9) == 0)
;           {
;               keys = skipwhite(keys.plus(9));
;               special = true;
;               continue;
;           }

            ;; Check for "<script>": remap script-local mappings only

;           if (STRNCMP(keys, u8("<script>"), 8) == 0)
;           {
;               keys = skipwhite(keys.plus(8));
;               noremap = REMAP_SCRIPT;
;               continue;
;           }

            ;; Check for "<expr>": {rhs} is an expression.

;           if (STRNCMP(keys, u8("<expr>"), 6) == 0)
;           {
;               keys = skipwhite(keys.plus(6));
;               expr = true;
;               continue;
;           }

            ;; Check for "<unique>": don't overwrite an existing mapping.

;           if (STRNCMP(keys, u8("<unique>"), 8) == 0)
;           {
;               keys = skipwhite(keys.plus(8));
;               unique = true;
;               continue;
;           }
;           break;
;       }

        ;; Find end of keys and skip CTRL-Vs (and backslashes) in it.
        ;; Accept backslash like CTRL-V when 'cpoptions' does not contain 'B'.
        ;; with :unmap white space is included in the keys, no argument possible.

;       Bytes p = keys;
;       boolean do_backslash = (vim_strbyte(@p_cpo, CPO_BSLASH) == null);
;       while (p.at(0) != NUL && (maptype == 1 || !vim_iswhite(p.at(0))))
;       {
;           if ((p.at(0) == Ctrl_V || (do_backslash && p.at(0) == (byte)'\\')) && p.at(1) != NUL)
;               p = p.plus(1);              ;; skip CTRL-V or backslash
;           p = p.plus(1);
;       }
;       if (p.at(0) != NUL)
;           (p = p.plus(1)).be(-1, NUL);

;       p = skipwhite(p);
;       Bytes rhs = p;
;       boolean hasarg = (rhs.at(0) != NUL);
;       boolean haskey = (keys.at(0) != NUL);

        ;; check for :unmap without argument
;       if (maptype == 1 && !haskey)
;           return 1;

        ;; If mapping has been given as ^V<C_UP> say, then replace the term codes
        ;; with the appropriate two bytes.  If it is a shifted special key,
        ;; unshift it too, giving another two bytes.
        ;; replace_termcodes() may move the result to allocated memory,
        ;; which needs to be freed later (keys_buf[0] and arg_buf[0]).
        ;; replace_termcodes() also removes CTRL-Vs and sometimes backslashes.

;       if (haskey)
;           keys = replace_termcodes(keys, true, true, special);
;       Bytes orig_rhs = rhs;
;       if (hasarg)
;       {
;           if (STRCASECMP(rhs, u8("<nop>")) == 0)      ;; "<Nop>" means nothing
;               rhs = u8("");
;           else
;               rhs = replace_termcodes(rhs, false, true, special);
;       }

        ;; check arguments and translate function keys

;       if (haskey)
;       {
;           len = STRLEN(keys);
;           if (MAXMAPLEN < len)            ;; maximum length of MAXMAPLEN chars
;               return 1;

;           if (abbrev && maptype != 1)
;           {
                ;; If an abbreviation ends in a keyword character,
                ;; the rest must be all keyword-char or all non-keyword-char.
                ;; Otherwise we won't be able to find the start of it
                ;; in a vi-compatible way.

;               int same = -1;

;               boolean first = us_iswordp(keys, @curbuf);
;               boolean last = first;
;               p = keys.plus(us_ptr2len_cc(keys));
;               int n = 1;
;               while (BLT(p, keys.plus(len)))
;               {
;                   n++;                                ;; nr of (multi-byte) chars
;                   last = us_iswordp(p, @curbuf);       ;; type of last char
;                   if (same == -1 && last != first)
;                       same = n - 1;                   ;; count of same char type
;                   p = p.plus(us_ptr2len_cc(p));
;               }
;               if (last && 2 < n && 0 <= same && same < n - 1)
;                   return 1;

                ;; An abbreviation cannot contain white space.
;               for (/*int */n = 0; n < len; n++)
;                   if (vim_iswhite(keys.at(n)))
;                       return 1;
;           }
;       }

;       if (haskey && hasarg && abbrev)     ;; if we will add an abbreviation
;           @no_abbr = false;                ;; reset flag that indicates there are no abbreviations

;       if (!haskey || (maptype != 1 && !hasarg))
;           msg_start();

        ;; Check if a new local mapping wasn't already defined globally.

;       if (map_table == @curbuf.b_maphash && haskey && hasarg && maptype != 1)
;       {
            ;; need to loop over all global hash lists
;           for (int hash = 0; hash < 256 && !@got_int; hash++)
;           {
;               mapblock_C mp;
;               if (abbrev)
;               {
;                   if (hash != 0)  ;; there is only one abbreviation list
;                       break;
;                   mp = first_abbr[0];
;               }
;               else
;                   mp = maphash[hash][0];

;               for ( ; mp != null && !@got_int; mp = mp.m_next)
;               {
                    ;; check entries with the same mode
;                   if ((mp.m_mode & mode) != 0
;                           && mp.m_keylen == len
;                           && unique
;                           && STRNCMP(mp.m_keys, keys, len) == 0)
;                   {
;                       if (abbrev)
;                           emsg2(u8("E224: global abbreviation already exists for %s"), mp.m_keys);
;                       else
;                           emsg2(u8("E225: global mapping already exists for %s"), mp.m_keys);
;                       return 5;
;                   }
;               }
;           }
;       }

        ;; When listing global mappings, also list buffer-local ones here.

;       if (map_table != @curbuf.b_maphash && !hasarg && maptype != 1)
;       {
            ;; need to loop over all global hash lists
;           for (int hash = 0; hash < 256 && !@got_int; hash++)
;           {
;               mapblock_C mp;
;               if (abbrev)
;               {
;                   if (hash != 0)  ;; there is only one abbreviation list
;                       break;
;                   mp = @curbuf.@b_first_abbr;
;               }
;               else
;                   mp = @curbuf.b_maphash[hash][0];
;               for ( ; mp != null && !@got_int; mp = mp.m_next)
;               {
                    ;; check entries with the same mode
;                   if ((mp.m_mode & mode) != 0)
;                   {
;                       if (!haskey)                    ;; show all entries
;                       {
;                           showmap(mp, true);
;                           did_local = true;
;                       }
;                       else
;                       {
;                           int n = mp.m_keylen;
;                           if (STRNCMP(mp.m_keys, keys, (n < len) ? n : len) == 0)
;                           {
;                               showmap(mp, true);
;                               did_local = true;
;                           }
;                       }
;                   }
;               }
;           }
;       }

        ;; Find an entry in the maphash[] list that matches.
        ;; For :unmap we may loop two times: once to try to unmap an entry with a
        ;; matching 'from' part, a second time, if the first fails, to unmap an
        ;; entry with a matching 'to' part.  This was done to allow ":ab foo bar"
        ;; to be unmapped by typing ":unab foo", where "foo" will be replaced by
        ;; "bar" because of the abbreviation.

;       for (int round = 0; (round == 0 || maptype == 1) && round <= 1 && !did_it && !@got_int; round++)
;       {
            ;; need to loop over all hash lists
;           for (int hash = 0; hash < 256 && !@got_int; hash++)
;           {
;               mapblock_C[] mpp0;
;               if (abbrev)
;               {
;                   if (0 < hash)   ;; there is only one abbreviation list
;                       break;
;                   mpp0 = abbr_table;
;               }
;               else
;                   mpp0 = map_table[hash];
;               for (mapblock_C mpp = null, mp = mpp0[0]; mp != null && !@got_int; mp = mpp.m_next)
;               {
;                   if ((mp.m_mode & mode) == 0)    ;; skip entries with wrong mode
;                   {
;                       mpp = mp;
;                       continue;
;                   }
;                   if (!haskey)                ;; show all entries
;                   {
;                       showmap(mp, map_table != maphash);
;                       did_it = true;
;                   }
;                   else                        ;; do we have a match?
;                   {
;                       int n;
;                       if (round != 0)         ;; second round: Try unmap "rhs" string
;                       {
;                           n = STRLEN(mp.m_str);
;                           p = mp.m_str;
;                       }
;                       else
;                       {
;                           n = mp.m_keylen;
;                           p = mp.m_keys;
;                       }
;                       if (STRNCMP(p, keys, (n < len) ? n : len) == 0)
;                       {
;                           if (maptype == 1)       ;; delete entry
;                           {
                                ;; Only accept a full match.  For abbreviations we
                                ;; ignore trailing space when matching with the
                                ;; "lhs", since an abbreviation can't have trailing space.
;                               if (n != len && (!abbrev || round != 0 || len < n || skipwhite(keys.plus(n)).at(0) != NUL))
;                               {
;                                   mpp = mp;
;                                   continue;
;                               }

                                ;; We reset the indicated mode bits.  If nothing is
                                ;; left the entry is deleted below.

;                               mp.m_mode &= ~mode;
;                               did_it = true;      ;; remember we did something
;                           }
;                           else if (!hasarg)       ;; show matching entry
;                           {
;                               showmap(mp, map_table != maphash);
;                               did_it = true;
;                           }
;                           else if (n != len)      ;; new entry is ambiguous
;                           {
;                               mpp = mp;
;                               continue;
;                           }
;                           else if (unique)
;                           {
;                               if (abbrev)
;                                   emsg2(u8("E226: abbreviation already exists for %s"), p);
;                               else
;                                   emsg2(u8("E227: mapping already exists for %s"), p);
;                               return 5;
;                           }
;                           else                    ;; new "rhs" for existing entry
;                           {
;                               mp.m_mode &= ~mode;     ;; remove mode bits
;                               if (mp.m_mode == 0 && !did_it) ;; reuse entry
;                               {
;                                   Bytes newstr = STRDUP(rhs);
;                                   mp.m_str = newstr;
;                                   mp.m_orig_str = STRDUP(orig_rhs);
;                                   mp.m_noremap = noremap;
;                                   mp.m_nowait = nowait;
;                                   mp.m_silent = silent;
;                                   mp.m_mode = mode;
;                                   mp.m_expr = expr;
;                                   did_it = true;
;                               }
;                           }
;                           if (mp.m_mode == 0)     ;; entry can be deleted
;                           {
;                               if (mpp == null)
;                                   mpp0[0] = map_free(mpp0[0]);
;                               else
;                                   mpp.m_next = map_free(mpp.m_next);
;                               continue;           ;; continue with *mpp
;                           }

                            ;; May need to put this entry into another hash list.

;                           int new_hash = map_hash(mp.m_mode, mp.m_keys.at(0));
;                           if (!abbrev && new_hash != hash)
;                           {
;                               if (mpp == null)
;                                   mpp0[0] = mp.m_next;
;                               else
;                                   mpp.m_next = mp.m_next;
;                               mp.m_next = map_table[new_hash][0];
;                               map_table[new_hash][0] = mp;

;                               continue;           ;; continue with *mpp
;                           }
;                       }
;                   }
;                   mpp = mp;
;               }
;           }
;       }

;       if (maptype == 1)                       ;; delete entry
;       {
;           if (!did_it)
;               retval = 2;                     ;; no match
;           else if (keys.at(0) == Ctrl_C)
;           {
                ;; If CTRL-C has been unmapped, reuse it for Interrupting.
;               if (map_table == @curbuf.b_maphash)
;                   @curbuf.b_mapped_ctrl_c &= ~mode;
;               else
;                   @mapped_ctrl_c &= ~mode;
;           }
;           return retval;
;       }

;       if (!haskey || !hasarg)                 ;; print entries
;       {
;           if (!did_it && !did_local)
;           {
;               if (abbrev)
;                   msg(u8("No abbreviation found"));
;               else
;                   msg(u8("No mapping found"));
;           }
;           return retval;                      ;; listing finished
;       }

;       if (did_it)                     ;; have added the new entry already
;           return retval;

        ;; Get here when adding a new entry to the maphash[] list or abbrlist.

;       mapblock_C mp = §_mapblock_C();

        ;; If CTRL-C has been mapped, don't always use it for Interrupting.
;       if (keys.at(0) == Ctrl_C)
;       {
;           if (map_table == @curbuf.b_maphash)
;               @curbuf.b_mapped_ctrl_c |= mode;
;           else
;               @mapped_ctrl_c |= mode;
;       }

;       mp.m_keys = STRDUP(keys);
;       mp.m_str = STRDUP(rhs);
;       mp.m_orig_str = STRDUP(orig_rhs);
;       mp.m_keylen = STRLEN(mp.m_keys);
;       mp.m_noremap = noremap;
;       mp.m_nowait = nowait;
;       mp.m_silent = silent;
;       mp.m_mode = mode;
;       mp.m_expr = expr;

        ;; add the new entry in front of the abbrlist or maphash[] list
;       if (abbrev)
;       {
;           mp.m_next = abbr_table[0];
;           abbr_table[0] = mp;
;       }
;       else
;       {
;           int n = map_hash(mp.m_mode, mp.m_keys.at(0));
;           mp.m_next = map_table[n][0];
;           map_table[n][0] = mp;
;       }

;       return retval;
    ))

;; Delete one entry from the abbrlist or maphash[].
;; "mpp" is a pointer to the m_next field of the PREVIOUS entry!

(defn- #_mapblock_C map_free [#_mapblock_C mp]
    (§
;       mp.m_keys = null;
;       mp.m_str = null;
;       mp.m_orig_str = null;

;       return mp.m_next;
    ))

;; Get the mapping mode from the command name.

(defn- #_int get_map_mode [#_Bytes* cmdp, #_boolean forceit]
    (§
;       int mode;

;       Bytes p = cmdp[0];
;       byte modec = (p = p.plus(1)).at(-1);

;       if (modec == 'i')
;           mode = INSERT;                                          ;; :imap
;       else if (modec == 'c')
;           mode = CMDLINE;                                         ;; :cmap
;       else if (modec == 'n' && p.at(0) != (byte)'o')                         ;; avoid :noremap
;           mode = NORMAL;                                          ;; :nmap
;       else if (modec == 'v')
;           mode = VISUAL + SELECTMODE;                             ;; :vmap
;       else if (modec == 'x')
;           mode = VISUAL;                                          ;; :xmap
;       else if (modec == 's')
;           mode = SELECTMODE;                                      ;; :smap
;       else if (modec == 'o')
;           mode = OP_PENDING;                                      ;; :omap
;       else
;       {
;           p = p.minus(1);
;           if (forceit)
;               mode = INSERT + CMDLINE;                            ;; :map !
;           else
;               mode = VISUAL + SELECTMODE + NORMAL + OP_PENDING;   ;; :map
;       }

;       cmdp[0] = p;
;       return mode;
    ))

;; Clear all mappings or abbreviations.
;; 'abbr' should be false for mappings, true for abbreviations.

(defn- #_void map_clear [#_Bytes _cmdp, #_Bytes arg, #_boolean forceit, #_boolean abbr]
    (§
;       Bytes[] cmdp = { _cmdp };

;       boolean local = (STRCMP(arg, u8("<buffer>")) == 0);
;       if (!local && arg.at(0) != NUL)
;       {
;           emsg(e_invarg);
;           return;
;       }

;       int mode = get_map_mode(cmdp, forceit);
;       map_clear_int(@curbuf, mode, local, abbr);
    ))

;; Clear all mappings in "mode".

(defn- #_void map_clear_int [#_buffer_C buf, #_int mode, #_boolean local, #_boolean abbr]
    ;; buf: buffer for local mappings
    ;; mode: mode in which to delete
    ;; local: true for buffer-local mappings
    ;; abbr: true for abbreviations
    (§
;       for (int hash = 0; hash < 256; hash++)
;       {
;           mapblock_C[] mpp0;

;           if (abbr)
;           {
;               if (0 < hash)       ;; there is only one abbrlist
;                   break;
;               if (local)
;                   mpp0 = buf.b_first_abbr;
;               else
;                   mpp0 = first_abbr;
;           }
;           else
;           {
;               if (local)
;                   mpp0 = buf.b_maphash[hash];
;               else
;                   mpp0 = maphash[hash];
;           }

;           for (mapblock_C mpp = null, mp = mpp0[0]; mp != null; mp = mpp.m_next)
;           {
;               if ((mp.m_mode & mode) != 0)
;               {
;                   mp.m_mode &= ~mode;
;                   if (mp.m_mode == 0) ;; entry can be deleted
;                   {
;                       if (mpp == null)
;                           mpp0[0] = map_free(mpp0[0]);
;                       else
;                           mpp.m_next = map_free(mpp.m_next);
;                       continue;
;                   }

                    ;; May need to put this entry into another hash list.

;                   int new_hash = map_hash(mp.m_mode, mp.m_keys.at(0));
;                   if (!abbr && new_hash != hash)
;                   {
;                       if (mpp == null)
;                           mpp0[0] = mp.m_next;
;                       else
;                           mpp.m_next = mp.m_next;
;                       if (local)
;                       {
;                           mp.m_next = buf.b_maphash[new_hash][0];
;                           buf.b_maphash[new_hash][0] = mp;
;                       }
;                       else
;                       {
;                           mp.m_next = maphash[new_hash][0];
;                           maphash[new_hash][0] = mp;
;                       }
;                       continue;           ;; continue with *mpp
;                   }
;               }
;               mpp = mp;
;           }
;       }
    ))

;; Return characters to represent the map mode in an allocated string.
;; Returns null when out of memory.

(defn- #_Bytes map_mode_to_chars [#_int mode]
    (§
;       barray_C mapmode = new barray_C(7);

;       if ((mode & (INSERT + CMDLINE)) == INSERT + CMDLINE)
;           ba_append(mapmode, (byte)'!');                        ;; :map!
;       else if ((mode & INSERT) != 0)
;           ba_append(mapmode, (byte)'i');                        ;; :imap
;       else if ((mode & CMDLINE) != 0)
;           ba_append(mapmode, (byte)'c');                        ;; :cmap
;       else if ((mode & (NORMAL + VISUAL + SELECTMODE + OP_PENDING)) == NORMAL + VISUAL + SELECTMODE + OP_PENDING)
;           ba_append(mapmode, (byte)' ');                        ;; :map
;       else
;       {
;           if ((mode & NORMAL) != 0)
;               ba_append(mapmode, (byte)'n');                    ;; :nmap
;           if ((mode & OP_PENDING) != 0)
;               ba_append(mapmode, (byte)'o');                    ;; :omap
;           if ((mode & (VISUAL + SELECTMODE)) == VISUAL + SELECTMODE)
;               ba_append(mapmode, (byte)'v');                    ;; :vmap
;           else
;           {
;               if ((mode & VISUAL) != 0)
;                   ba_append(mapmode, (byte)'x');                ;; :xmap
;               if ((mode & SELECTMODE) != 0)
;                   ba_append(mapmode, (byte)'s');                ;; :smap
;           }
;       }

;       ba_append(mapmode, NUL);
;       return new Bytes(mapmode.ba_data);
    ))

(defn- #_void showmap [#_mapblock_C mp, #_boolean local]
    ;; local: true for buffer-local map
    (§
;       if (@msg_didout || @msg_silent != 0)
;       {
;           msg_putchar('\n');
;           if (@got_int)        ;; 'q' typed at MORE prompt
;               return;
;       }

;       int len = 1;

;       Bytes mapchars = map_mode_to_chars(mp.m_mode);
;       if (mapchars != null)
;       {
;           msg_puts(mapchars);
;           len = STRLEN(mapchars);
;       }

;       while (++len <= 3)
;           msg_putchar(' ');

        ;; Display the LHS.  Get length of what we write.
;       len = msg_outtrans_special(mp.m_keys, true);
;       do
;       {
;           msg_putchar(' ');               ;; padd with blanks
;           len++;
;       } while (len < 12);

;       if (mp.m_noremap == REMAP_NONE)
;           msg_puts_attr(u8("*"), hl_attr(HLF_8));
;       else if (mp.m_noremap == REMAP_SCRIPT)
;           msg_puts_attr(u8("&"), hl_attr(HLF_8));
;       else
;           msg_putchar(' ');

;       if (local)
;           msg_putchar('@');
;       else
;           msg_putchar(' ');

        ;; Use false below if we only want things like <Up> to show up
        ;; as such on the rhs, and not M-x etc, true gets both.
;       if (mp.m_str.at(0) == NUL)
;           msg_puts_attr(u8("<Nop>"), hl_attr(HLF_8));
;       else
;       {
            ;; Remove escaping of CSI, because "m_str" is in a format to be used as typeahead.
;           Bytes s = STRDUP(mp.m_str);
;           vim_unescape_csi(s);
;           msg_outtrans_special(s, false);
;       }

;       out_flush();                        ;; show one line at a time
    ))

;; Return true if a map exists that has "str" in the rhs for mode "modechars".
;; Recognize termcap codes in "str".
;; Also checks mappings local to the current buffer.

(defn- #_boolean map_to_exists [#_Bytes str, #_Bytes modechars, #_boolean abbr]
    (§
;       Bytes rhs = replace_termcodes(str, false, true, false);

;       int mode = 0;
;       if (vim_strchr(modechars, 'n') != null)
;           mode |= NORMAL;
;       if (vim_strchr(modechars, 'v') != null)
;           mode |= VISUAL + SELECTMODE;
;       if (vim_strchr(modechars, 'x') != null)
;           mode |= VISUAL;
;       if (vim_strchr(modechars, 's') != null)
;           mode |= SELECTMODE;
;       if (vim_strchr(modechars, 'o') != null)
;           mode |= OP_PENDING;
;       if (vim_strchr(modechars, 'i') != null)
;           mode |= INSERT;
;       if (vim_strchr(modechars, 'c') != null)
;           mode |= CMDLINE;

;       return map_to_exists_mode(rhs, mode, abbr);
    ))

;; Return true if a map exists that has "str" in the rhs for mode "mode".
;; Also checks mappings local to the current buffer.

(defn- #_boolean map_to_exists_mode [#_Bytes rhs, #_int mode, #_boolean abbr]
    (§
        ;; Do it twice: once for global maps and once for local maps.
;       for (boolean expand_buffer = false; !expand_buffer; expand_buffer = true)
;       {
;           for (int hash = 0; hash < 256; hash++)
;           {
;               mapblock_C mp;

;               if (abbr)
;               {
;                   if (0 < hash)           ;; there is only one abbr list
;                       break;
;                   if (expand_buffer)
;                       mp = @curbuf.@b_first_abbr;
;                   else
;                       mp = first_abbr[0];
;               }
;               else if (expand_buffer)
;                   mp = @curbuf.b_maphash[hash][0];
;               else
;                   mp = maphash[hash][0];

;               for ( ; mp != null; mp = mp.m_next)
;               {
;                   if ((mp.m_mode & mode) != 0 && STRSTR(mp.m_str, rhs) != null)
;                       return true;
;               }
;           }
;       }

;       return false;
    ))

;; Check for an abbreviation.
;; Cursor is at ptr[col].  When inserting, mincol is where insert started.
;; "c" is the character typed before check_abbr was called.
;; It may have ABBR_OFF added to avoid prepending a CTRL-V to it.
;;
;; Historic vi practice:
;; The last character of an abbreviation must be an id character ([a-zA-Z0-9_]).
;; The characters in front of it must be all id characters or all non-id characters.
;; This allows for abbr. "#i" to "#include".
;;
;; Vim addition:
;; Allow for abbreviations that end in a non-keyword character.
;; Then there must be white space before the abbr.
;;
;; Return true if there is an abbreviation, false if not.

(defn- #_boolean check_abbr [#_int c, #_Bytes ptr, #_int col, #_int mincol]
    (§
;       if (@typebuf.tb_no_abbr_cnt != 0)            ;; abbrev. are not recursive
;           return false;

        ;; no remapping implies no abbreviation, except for CTRL-]
;       if ((@keyNoremap & (RM_NONE|RM_SCRIPT)) != 0 && c != Ctrl_RSB)
;           return false;

        ;; Check for word before the cursor: if it ends in a keyword char, all chars
        ;; before it must be keyword chars or non-keyword chars, but not white space.
        ;; If it ends in a non-keyword char, we accept any characters before it except white space.

;       if (col == 0)                               ;; cannot be an abbr.
;           return false;

;       Bytes p = us_prevptr(ptr, ptr.plus(col));

;       boolean vim_abbr = true;                    ;; Vim added abbr.
;       boolean is_id = true;
;       if (us_iswordp(p, @curbuf))
;       {
;           vim_abbr = false;                       ;; vi compatible abbr.
;           if (BLT(ptr, p))
;               is_id = us_iswordp(us_prevptr(ptr, p), @curbuf);
;       }

;       int clen = 1;                               ;; length in characters
;       while (BLT(ptr.plus(mincol), p))
;       {
;           p = us_prevptr(ptr, p);
;           if (vim_isspace(p.at(0)) || (!vim_abbr && is_id != us_iswordp(p, @curbuf)))
;           {
;               p = p.plus(us_ptr2len_cc(p));
;               break;
;           }
;           clen++;
;       }

;       int scol = BDIFF(p, ptr);              ;; starting column of the abbr.
;       if (scol < mincol)
;           scol = mincol;

;       if (scol < col)                     ;; there is a word in front of the cursor
;       {
;           ptr = ptr.plus(scol);
;           int len = col - scol;
;           mapblock_C mp = @curbuf.@b_first_abbr;
;           mapblock_C mp2 = first_abbr[0];
;           if (mp == null)
;           {
;               mp = mp2;
;               mp2 = null;
;           }
;           boolean __;
;           for ( ; mp != null; mp = mp.m_next, __ = (mp == null && (mp = mp2) == mp2 && (mp2 = null) == null))
;           {
;               int qlen = mp.m_keylen;
;               Bytes q = mp.m_keys;

;               if (vim_strbyte(mp.m_keys, KB_SPECIAL) != null)
;               {
                    ;; might have CSI escaped mp.m_keys
;                   q = STRDUP(mp.m_keys);
;                   vim_unescape_csi(q);
;                   qlen = STRLEN(q);
;               }

                ;; find entries with right mode and keys
;               boolean match = ((mp.m_mode & @State) != 0 && qlen == len && STRNCMP(q, ptr, len) == 0);
;               if (match)
;                   break;
;           }
;           if (mp != null)
;           {
;               Bytes tb = new Bytes(MB_MAXBYTES + 4);

                ;; Found a match:
                ;; insert the rest of the abbreviation in typebuf.tb_buf[].
                ;; This goes from end to start.
                ;;
                ;; Characters 0x000 - 0x100: normal chars, may need CTRL-V,
                ;; except KB_SPECIAL: becomes KB_SPECIAL KS_SPECIAL KE_FILLER.
                ;; Characters where is_special() == true: key codes, need KB_SPECIAL.
                ;; Other characters (with ABBR_OFF): don't use CTRL-V.
                ;;
                ;; Character CTRL-] is treated specially - it completes the
                ;; abbreviation, but is not inserted into the input stream.

;               int i = 0;
;               if (c != Ctrl_RSB)
;               {
;                   if (is_special(c) || c == char_u(KB_SPECIAL))   ;; special key code, split up
;                   {
;                       tb.be(i++, KB_SPECIAL);
;                       tb.be(i++, KB_SECOND(c));
;                       tb.be(i++, KB_THIRD(c));
;                   }
;                   else
;                   {
;                       if (c < ABBR_OFF && (c < ' ' || '~' < c))
;                           tb.be(i++, Ctrl_V);                       ;; special char needs CTRL-V

                        ;; if ABBR_OFF has been added, remove it here
;                       if (ABBR_OFF <= c)
;                           c -= ABBR_OFF;
;                       i += utf_char2bytes(c, tb.plus(i));
;                   }
;                   tb.be(i, NUL);
;                   ins_typebuf(tb, 1, 0, true, mp.m_silent);       ;; insert the last typed char
;               }

;               Bytes s = mp.m_str;
;               if (mp.m_expr)
;                   s = eval_map_expr(s, c);
;               if (s != null)
;               {
;                   ins_typebuf(s, mp.m_noremap, 0, true, mp.m_silent); ;; insert the to string
;                   @typebuf.tb_no_abbr_cnt += STRLEN(s) + i + 1;   ;; no abbrev. for these chars
;               }

;               tb.be(0, Ctrl_H);
;               tb.be(1, NUL);
;               len = clen;                                         ;; delete characters instead of bytes
;               while (0 < len--)                                   ;; delete the from string
;                   ins_typebuf(tb, 1, 0, true, mp.m_silent);

;               return true;
;           }
;       }

;       return false;
    ))

;; Evaluate the RHS of a mapping or abbreviations and take care of escaping special characters.

(defn- #_Bytes eval_map_expr [#_Bytes str, #_int c]
    ;; c: NUL or typed character for abbreviation
    (§
        ;; Remove escaping of CSI, because "str" is in a format to be used as typeahead.
;       Bytes expr = STRDUP(str);

;       vim_unescape_csi(expr);

;       cmdline_info_C save_cli = save_cmdline_alloc();

        ;; Forbid changing text or using ":normal" to avoid most of the bad side effects.
        ;; Also restore the cursor position.
;       @textlock++;
;       @ex_normal_lock++;

;       pos_C save_cursor = §_pos_C();
;       COPY_pos(save_cursor, @curwin.w_cursor);
;       int save_msg_col = @msg_col;
;       int save_msg_row = @msg_row;

;       Bytes p = eval_to_string(expr, null, false);

;       --@textlock;
;       --@ex_normal_lock;

;       COPY_pos(@curwin.w_cursor, save_cursor);
;       @msg_col = save_msg_col;
;       @msg_row = save_msg_row;

;       restore_cmdline_alloc(save_cli);

;       if (p == null)
;           return null;

        ;; Escape CSI in the result to be able to use the string as typeahead.
;       return vim_strsave_escape_csi(p);
    ))

;; Copy "p" to allocated memory, escaping KB_SPECIAL and CSI
;; so that the result can be put in the typeahead buffer.

(defn- #_Bytes vim_strsave_escape_csi [#_Bytes p]
    (§
        ;; Need a buffer to hold up to three times as much.
;       Bytes res = new Bytes(STRLEN(p) * 3 + 1);

;       Bytes d = res;
;       for (Bytes s = p; s.at(0) != NUL; )
;       {
;           if (s.at(0) == KB_SPECIAL && s.at(1) != NUL && s.at(2) != NUL)
;           {
                ;; Copy special key unmodified.
;               (d = d.plus(1)).be(-1, (s = s.plus(1)).at(-1));
;               (d = d.plus(1)).be(-1, (s = s.plus(1)).at(-1));
;               (d = d.plus(1)).be(-1, (s = s.plus(1)).at(-1));
;           }
;           else
;           {
                ;; Add character, possibly multi-byte to destination, escaping CSI and KB_SPECIAL.
;               int c = us_ptr2char(s);
;               d = add_char2buf(c, d);
;               for (int len = utf_char2len(c), end = us_ptr2len_cc(s); len < end; len += utf_char2len(c))
;               {
                    ;; Add following combining char.
;                   c = us_ptr2char(s.plus(len));
;                   d = add_char2buf(c, d);
;               }
;               s = s.plus(us_ptr2len_cc(s));
;           }
;       }
;       d.be(0, NUL);

;       return res;
    ))

;; Remove escaping from CSI and KB_SPECIAL characters.
;; Reverse of vim_strsave_escape_csi().
;; Works in-place.

(defn- #_void vim_unescape_csi [#_Bytes p]
    (§
;       Bytes d = p;
;       for (Bytes s = p; s.at(0) != NUL; )
;       {
;           if (s.at(0) == KB_SPECIAL && s.at(1) == KS_SPECIAL && s.at(2) == KE_FILLER)
;           {
;               (d = d.plus(1)).be(-1, KB_SPECIAL);
;               s = s.plus(3);
;           }
;           else if ((s.at(0) == KB_SPECIAL || s.at(0) == CSI) && s.at(1) == KS_EXTRA && s.at(2) == KE_CSI)
;           {
;               (d = d.plus(1)).be(-1, CSI);
;               s = s.plus(3);
;           }
;           else
;               (d = d.plus(1)).be(-1, (s = s.plus(1)).at(-1));
;       }
;       d.be(0, NUL);
    ))

;; Check all mappings for the presence of special key codes.
;; Used after ":set term=xxx".

(defn- #_void check_map_keycodes []
    (§
        ;; This this once for each buffer,
        ;; and then once for global mappings/abbreviations with bp == null.
;       for (buffer_C bp = @firstbuf; ; bp = bp.b_next)
;       {
            ;; Do the loop twice: Once for mappings, once for abbreviations.
            ;; Then loop over all map hash lists.

;           for (int abbr = 0; abbr <= 1; abbr++)
;               for (int hash = 0; hash < 256; hash++)
;               {
;                   mapblock_C mp;
;                   if (abbr != 0)
;                   {
;                       if (hash != 0)                  ;; there is only one abbr list
;                           break;
;                       if (bp != null)
;                           mp = bp.@b_first_abbr;
;                       else
;                           mp = first_abbr[0];
;                   }
;                   else
;                   {
;                       if (bp != null)
;                           mp = bp.b_maphash[hash][0];
;                       else
;                           mp = maphash[hash][0];
;                   }
;                   for ( ; mp != null; mp = mp.m_next)
;                   {
;                       for (int i = 0; i <= 1; i++)        ;; do this twice
;                       {
;                           Bytes p;
;                           if (i == 0)
;                               p = mp.m_keys;              ;; once for the "from" part
;                           else
;                               p = mp.m_str;               ;; and once for the "to" part
;                           while (p.at(0) != NUL)
;                           {
;                               if (p.at(0) == KB_SPECIAL)
;                               {
;                                   p = p.plus(1);
;                                   if (char_u(p.at(0)) < 0x80)     ;; for "normal" tcap entries
;                                   {
;                                       Bytes buf = new Bytes(3);

;                                       buf.be(0, p.at(0));
;                                       buf.be(1, p.at(1));
;                                       buf.be(2, NUL);
;                                       add_termcap_entry(buf, false);
;                                   }
;                                   p = p.plus(1);
;                               }
;                               p = p.plus(1);
;                           }
;                       }
;                   }
;               }

;           if (bp == null)
;               break;
;       }
    ))

;; Check the string "keys" against the lhs of all mappings.
;; Return pointer to rhs of mapping (mapblock.m_str); null when no mapping found.

(defn- #_Bytes check_map [#_Bytes keys, #_int mode, #_boolean exact, #_boolean ign_mod, #_boolean abbr, #_mapblock_C* mp_ptr, #_int* local_ptr]
    ;; exact: require exact match
    ;; ign_mod: ignore preceding modifier
    ;; abbr: do abbreviations
    ;; mp_ptr: return: pointer to mapblock or null
    ;; local_ptr: return: buffer-local mapping or null
    (§
;       int len = STRLEN(keys);
;       for (int local = 1; 0 <= local; --local)
            ;; loop over all hash lists
;           for (int hash = 0; hash < 256; hash++)
;           {
;               mapblock_C mp;
;               if (abbr)
;               {
;                   if (0 < hash)           ;; there is only one list.
;                       break;
;                   if (local != 0)
;                       mp = @curbuf.@b_first_abbr;
;                   else
;                       mp = first_abbr[0];
;               }
;               else if (local != 0)
;                   mp = @curbuf.b_maphash[hash][0];
;               else
;                   mp = maphash[hash][0];

;               for ( ; mp != null; mp = mp.m_next)
;               {
                    ;; skip entries with wrong mode, wrong length and not matching ones
;                   if ((mp.m_mode & mode) != 0 && (!exact || mp.m_keylen == len))
;                   {
;                       int minlen;
;                       if (mp.m_keylen < len)
;                           minlen = mp.m_keylen;
;                       else
;                           minlen = len;
;                       Bytes s = mp.m_keys;
;                       if (ign_mod && s.at(0) == KB_SPECIAL && s.at(1) == KS_MODIFIER && s.at(2) != NUL)
;                       {
;                           s = s.plus(3);
;                           if (mp.m_keylen - 3 < len)
;                               minlen = mp.m_keylen - 3;
;                       }
;                       if (STRNCMP(s, keys, minlen) == 0)
;                       {
;                           if (mp_ptr != null)
;                               mp_ptr[0] = mp;
;                           if (local_ptr != null)
;                               local_ptr[0] = local;
;                           return mp.m_str;
;                       }
;                   }
;               }
;           }

;       return null;
    ))

;; Set up default mappings.

(defn- #_void init_mappings []
    (§
    ))

;; Add a mapping "map" for mode "mode".
;; Need to put string in allocated memory, because do_map() will modify it.

(defn- #_void add_map [#_Bytes map, #_int mode]
    (§
;       Bytes cpo_save = @p_cpo;

;       @p_cpo = u8("");                     ;; allow <> notation
;       Bytes s = STRDUP(map);
;       do_map(0, s, mode, false);

;       @p_cpo = cpo_save;
    ))

;;; ============================================================================================== VimM

;; edit.c: functions for Insert mode --------------------------------------------------------------

(final int BACKSPACE_CHAR              1)
(final int BACKSPACE_WORD              2)
(final int BACKSPACE_WORD_NOT_SPACE    3)
(final int BACKSPACE_LINE              4)

(atom! int      insStart_textlen)               ;; length of line when insert started
(atom! int      insStart_blank_vcol)            ;; vcol for first inserted blank
(atom! boolean  update_insStart_orig true)    ;; set insStart_orig to insStart

(atom! Bytes    last_insert)                    ;; the text of the previous insert,
                                                            ;; KB_SPECIAL and CSI are escaped
(atom! int      last_insert_skip)               ;; nr of chars in front of previous insert
(atom! int      new_insert_skip)                ;; nr of chars in front of current insert
(atom! int      did_restart_edit)               ;; "restart_edit" when calling edit()

(atom! boolean  can_cindent)                    ;; may do cindenting on this line

(atom! int      old_indent)                     ;; for ^^D command in insert mode

(atom! boolean  revins_on)                      ;; reverse insert mode on
(atom! int      revins_chars)                   ;; how much to skip after edit
(atom! int      revins_legal)                   ;; was the last char 'legal'
(atom! int      revins_scol)                    ;; start column of revins session

(atom! boolean  ins_need_undo)                  ;; call u_save() before inserting a char;
                                                            ;; set when edit() is called;
                                                            ;; after that arrow_used is used

(atom! boolean  did_add_space)          ;; auto_format() added an extra space under the cursor

(atom! long     o_lnum)

;; edit(): Start inserting text.
;;
;; "cmdchar" can be:
;; 'i'  normal insert command
;; 'a'  normal append command
;; 'R'  replace command
;; 'r'  "r<CR>" command: insert one <CR>.  Note: count can be > 1, for redo,
;;      but still only one <CR> is inserted.  The <Esc> is not used for redo.
;; 'g'  "gI" command.
;; 'V'  "gR" command for Virtual Replace mode.
;; 'v'  "gr" command for single character Virtual Replace mode.
;;
;; This function is not called recursively.  For CTRL-O commands, it returns
;; and lets the caller handle the Normal-mode command.
;;
;; Return true if a CTRL-O command caused the return (insert mode pending).

(defn- #_boolean edit [#_int cmdchar, #_boolean startln, #_long _count]
    ;; startln: if set, insert at start of line
    (§
;       long[] count = { _count };

;       boolean did_backspace = true;           ;; previous char was backspace
;       boolean line_is_white = false;          ;; line is empty before insert
;       long old_topline = 0;                   ;; topline before insertion
;       boolean[] inserted_space = { false };         ;; just inserted a space
;       boolean nomove = false;                 ;; don't move cursor on return

        ;; Remember whether editing was restarted after CTRL-O.
;       @did_restart_edit = @restart_edit;

        ;; sleep before redrawing, needed for "CTRL-O :" that results in an error message
;       check_for_delay(true);

        ;; set insStart_orig to insStart
;       @update_insStart_orig = true;

        ;; Don't allow inserting in the sandbox.
;       if (@sandbox != 0)
;       {
;           emsg(e_sandbox);
;           return false;
;       }
        ;; Don't allow changes in the buffer while editing the cmdline.
        ;; The caller of getcmdline() may get confused.
;       if (@textlock != 0)
;       {
;           emsg(e_secure);
;           return false;
;       }

        ;; Check if the cursor line needs redrawing before changing State.
        ;; If 'concealcursor' is "n", it needs to be redrawn without concealing.
;       conceal_check_cursor_line();

        ;; When doing a paste with the middle mouse button,
        ;; insStart is set to where the paste started.

;       if (@where_paste_started.lnum != 0)
;           COPY_pos(@insStart, @where_paste_started);
;       else
;       {
;           COPY_pos(@insStart, @curwin.w_cursor);
;           if (startln)
;               @insStart.col = 0;
;       }
;       @insStart_textlen = linetabsize(ml_get_curline());
;       @insStart_blank_vcol = MAXCOL;
;       if (!@did_ai)
;           @ai_col = 0;

;       if (cmdchar != NUL && @restart_edit == 0)
;       {
;           resetRedobuff();
;           appendNumberToRedobuff(count[0]);
;           if (cmdchar == 'V' || cmdchar == 'v')
;           {
                ;; "gR" or "gr" command
;               appendCharToRedobuff('g');
;               appendCharToRedobuff((cmdchar == 'v') ? 'r' : 'R');
;           }
;           else
;           {
;               appendCharToRedobuff(cmdchar);
;               if (cmdchar == 'g')             ;; "gI" command
;                   appendCharToRedobuff('I');
;               else if (cmdchar == 'r')        ;; "r<CR>" command
;                   count[0] = 1;                  ;; insert only one <CR>
;           }
;       }

;       int replaceState = REPLACE;
;       if (cmdchar == 'R')
;       {
;           @State = REPLACE;
;       }
;       else if (cmdchar == 'V' || cmdchar == 'v')
;       {
;           @State = VREPLACE;
;           replaceState = VREPLACE;
;           @orig_line_count = @curbuf.b_ml.ml_line_count;
;           @vr_lines_changed = 1;
;       }
;       else
;           @State = INSERT;

;       @stop_insert_mode = false;

        ;; Need to recompute the cursor position,
        ;; it might move when the cursor is on a TAB or special character.

;       curs_columns(true);

;       setmouse();
;       clear_showcmd();
        ;; there is no reverse replace mode
;       @revins_on = (@State == INSERT && @p_ri);
;       if (@revins_on)
;           undisplay_dollar();
;       @revins_chars = 0;
;       @revins_legal = 0;
;       @revins_scol = -1;

        ;; Handle restarting Insert mode.
        ;; Don't do this for "CTRL-O ." (repeat an insert): we get here with
        ;; restart_edit non-zero, and something in the stuff buffer.

;       if (@restart_edit != 0 && stuff_empty())
;       {
            ;; After a paste we consider text typed to be part of the insert for
            ;; the pasted text.  You can backspace over the pasted text too.

;           @arrow_used = (@where_paste_started.lnum == 0);
;           @restart_edit = 0;

            ;; If the cursor was after the end-of-line before the CTRL-O and it is
            ;; now at the end-of-line, put it after the end-of-line (this is not
            ;; correct in very rare cases).
            ;; Also do this if curswant is greater than the current virtual column.
            ;; E.g. after "^O$" or "^O80|".

;           validate_virtcol();
;           update_curswant();
;           if ((@ins_at_eol && @curwin.w_cursor.lnum == @o_lnum) || @curwin.w_virtcol < @curwin.w_curswant)
;           {
;               Bytes p = ml_get_curline().plus(@curwin.w_cursor.col);
;               if (p.at(0) != NUL)
;               {
;                   if (p.at(1) == NUL)
;                       @curwin.w_cursor.col++;
;                   else
;                   {
;                       int n = us_ptr2len_cc(p);
;                       if (p.at(n) == NUL)
;                           @curwin.w_cursor.col += n;
;                   }
;               }
;           }
;           @ins_at_eol = false;
;       }
;       else
;           @arrow_used = false;

        ;; We are in insert mode now, don't need to start it anymore.
;       @need_start_insertmode = false;

        ;; Need to save the line for undo before inserting the first char.
;       @ins_need_undo = true;

;       @where_paste_started.lnum = 0;
;       @can_cindent = true;

        ;; If 'showmode' is set, show the current (insert/replace/..) mode.
        ;; A warning message for changing a readonly file is given here, before
        ;; actually changing anything.  It's put after the mode, if any.

;       int i = 0;
;       if (@p_smd && @msg_silent == 0)
;           i = showmode();

;       if (!@p_im && @did_restart_edit == 0)
;           change_warning(i == 0 ? 0 : i + 1);

;       ui_cursor_shape();          ;; may show different cursor shape
;       do_digraph(-1);             ;; clear digraphs

        ;; Get the current length of the redo buffer,
        ;; those characters have to be skipped if we want to get to the inserted characters.

;       Bytes ptr = get_inserted();
;       if (ptr == null)
;           @new_insert_skip = 0;
;       else
;           @new_insert_skip = STRLEN(ptr);

;       @old_indent = 0;

        ;; Main loop in Insert mode: repeat until Insert mode is left.

;       for (int lastc = 0, c = 0; ; )
;       {
;           if (@revins_legal == 0)
;               @revins_scol = -1;       ;; reset on illegal motions
;           else
;               @revins_legal = 0;
;           if (@arrow_used)     ;; don't repeat insert when arrow key used
;               count[0] = 0;

;           if (@update_insStart_orig)
;               COPY_pos(@insStart_orig, @insStart);

;           doESCkey:
;           {
;               if (@stop_insert_mode)
;               {
                    ;; ":stopinsert" used or 'insertmode' reset
;                   count[0] = 0;
;                   break doESCkey;
;               }

                ;; set curwin.w_curswant for next K_DOWN or K_UP
;               if (!@arrow_used)
;                   @curwin.w_set_curswant = true;

                ;; If there is no typeahead may check for timestamps
                ;; (e.g., for when a menu invoked a shell command).
;               if (stuff_empty())
;               {
;                   @did_check_timestamps = false;
;                   if (@need_check_timestamps)
;                       check_timestamps(false);
;               }

                ;; When emsg() was called msg_scroll will have been set.

;               @msg_scroll = false;

                ;; If we inserted a character at the last position of the last line in the window,
                ;; scroll the window one line up.  This avoids an extra redraw.
                ;; This is detected when the cursor column is smaller after inserting something.
                ;; Don't do this when the topline changed already,
                ;; it has already been adjusted (by insertchar() calling open_line())).

;               if (@curbuf.b_mod_set && @curwin.w_onebuf_opt.@wo_wrap && !did_backspace && @curwin.w_topline == old_topline)
;               {
;                   int mincol = @curwin.w_wcol;
;                   validate_cursor_col();

;                   if (@curwin.w_wcol < mincol - @curbuf.@b_p_ts
;                       && @curwin.w_wrow == @curwin.w_winrow + @curwin.w_height - 1 - @p_so
;                       && @curwin.w_cursor.lnum != @curwin.w_topline)
;                   {
;                       set_topline(@curwin, @curwin.w_topline + 1);
;                   }
;               }

                ;; May need to adjust w_topline to show the cursor.
;               update_topline();

;               did_backspace = false;

;               validate_cursor();              ;; may set must_redraw

                ;; Redraw the display when no characters are waiting.
                ;; Also shows mode, ruler and positions cursor.

;               ins_redraw(true);

;               if (@curwin.w_onebuf_opt.@wo_scb)
;                   do_check_scrollbind(true);

;               if (@curwin.w_onebuf_opt.@wo_crb)
;                   do_check_cursorbind();
;               update_curswant();
;               old_topline = @curwin.w_topline;

                ;; Get a character for Insert mode.  Ignore K_IGNORE.

;               if (c != K_CURSORHOLD)
;                   lastc = c;          ;; remember the previous char for CTRL-D
;               do
;               {
;                   c = safe_vgetc();
;               } while (c == K_IGNORE);

                ;; Don't want K_CURSORHOLD for the second key, e.g., after CTRL-V.
;               @did_cursorhold = true;

                ;; CTRL-\ CTRL-N goes to Normal mode,
                ;; CTRL-\ CTRL-G goes to mode selected with 'insertmode',
                ;; CTRL-\ CTRL-O is like CTRL-O but without moving the cursor.
;               if (c == Ctrl_BSL)
;               {
                    ;; may need to redraw when no more chars available now
;                   ins_redraw(false);

;                   @no_mapping++;
;                   @allow_keys++;
;                   c = plain_vgetc();
;                   --@no_mapping;
;                   --@allow_keys;

;                   if (c != Ctrl_N && c != Ctrl_G && c != Ctrl_O)
;                   {
                        ;; it's something else
;                       vungetc(c);
;                       c = Ctrl_BSL;
;                   }
;                   else if (c == Ctrl_G && @p_im)
;                       continue;
;                   else
;                   {
;                       if (c == Ctrl_O)
;                       {
;                           ins_ctrl_o();
;                           @ins_at_eol = false; ;; cursor keeps its column
;                           nomove = true;
;                       }
;                       count[0] = 0;
;                       break doESCkey;
;                   }
;               }

;               c = do_digraph(c);

;               if (c == Ctrl_V || c == Ctrl_Q)
;               {
;                   ins_ctrl_v();
;                   c = Ctrl_V;         ;; pretend CTRL-V is last typed character
;                   continue;
;               }

;               if (cindent_on())
;               {
                    ;; A key name preceded by a bang means this key is not to be inserted.
                    ;; Skip ahead to the re-indenting below.
                    ;; A key name preceded by a star means that indenting has to be done
                    ;; before inserting the key.
;                   line_is_white = inindent(0);
;                   if (in_cinkeys(c, '!', line_is_white))
;                   {
                        ;; Indent now if a key was typed that is in 'cinkeys'.
;                       if (in_cinkeys(c, ' ', line_is_white) && stop_arrow())
;                           do_c_expr_indent();
;                       continue;
;                   }
;                   if (@can_cindent && in_cinkeys(c, '*', line_is_white) && stop_arrow())
;                       do_c_expr_indent();
;               }

;               if (@curwin.w_onebuf_opt.@wo_rl)
;                   switch (c)
;                   {
;                       case K_LEFT:    c = K_RIGHT;   break;
;                       case K_S_LEFT:  c = K_S_RIGHT; break;
;                       case K_C_LEFT:  c = K_C_RIGHT; break;
;                       case K_RIGHT:   c = K_LEFT;    break;
;                       case K_S_RIGHT: c = K_S_LEFT;  break;
;                       case K_C_RIGHT: c = K_C_LEFT;  break;
;                   }

                ;; If 'keymodel' contains "startsel", may start selection.
                ;; If it does, a CTRL-O and c will be stuffed, we need to get these characters.

;               if (ins_start_select(c))
;                   continue;

;               normalchar:
;               {
                    ;; The big switch to handle a character in insert mode.

;                   switch (c)
;                   {
;                       case ESC:                           ;; end input mode
;                           if (echeck_abbr(ESC + ABBR_OFF))
;                               break normalchar;
                            ;; FALLTHROUGH

;                       case Ctrl_C:                        ;; end input mode
;                           if (c == Ctrl_C && @cmdwin_type != 0)
;                           {
                                ;; Close the cmdline window.
;                               @cmdwin_result = K_IGNORE;
;                               @got_int = false;            ;; don't stop executing autocommands et al.
;                               nomove = true;
;                               break doESCkey;
;                           }

                            ;; When 'insertmode' set, and not halfway a mapping, don't leave Insert mode.
;                           if (goto_im())
;                           {
;                               if (@got_int)
;                               {
;                                   vgetc();                ;; flush all buffers
;                                   @got_int = false;
;                               }
;                               else
;                                   vim_beep();
;                               break normalchar;
;                           }
;                           break doESCkey;

;                       case Ctrl_Z:                        ;; suspend when 'insertmode' set
;                           if (!@p_im)
;                               break;            ;; insert CTRL-Z as normal char
;                           stuffReadbuff(u8(":st\r"));
;                           c = Ctrl_O;
                            ;; FALLTHROUGH

;                       case Ctrl_O:                        ;; execute one command
;                           if (echeck_abbr(Ctrl_O + ABBR_OFF))
;                               break normalchar;
;                           ins_ctrl_o();

                            ;; Don't move the cursor left when 'virtualedit' has "onemore".
;                           if ((@ve_flags & VE_ONEMORE) != 0)
;                           {
;                               @ins_at_eol = false;
;                               nomove = true;
;                           }
;                           count[0] = 0;
;                           break doESCkey;

;                       case K_INS:                         ;; toggle insert/replace mode
;                       case K_KINS:
;                           ins_insert(replaceState);
;                           break normalchar;

;                       case K_SELECT:                      ;; end of Select mode mapping - ignore
;                           break normalchar;

;                       case K_HELP:                        ;; Help key works like <ESC> <Help>
;                       case K_F1:
;                       case K_XF1:
;                           stuffcharReadbuff(K_HELP);
;                           if (@p_im)
;                               @need_start_insertmode = true;
;                           break doESCkey;

;                       case K_ZERO:                        ;; insert the previously inserted text
;                       case NUL:
;                       case Ctrl_A:
                            ;; For ^@ the trailing ESC will end the insert, unless there is an error.
;                           if (!stuff_inserted(NUL, 1L, (c == Ctrl_A)) && c != Ctrl_A && !@p_im)
;                               break doESCkey;             ;; quit insert mode
;                           inserted_space[0] = false;
;                           break normalchar;

;                       case Ctrl_R:                        ;; insert the contents of a register
;                           ins_reg();
;                           auto_format(false, true);
;                           inserted_space[0] = false;
;                           break normalchar;

;                       case Ctrl_G:                        ;; commands starting with CTRL-G
;                           ins_ctrl_g();
;                           break normalchar;

;                       case Ctrl_HAT:                      ;; switch input mode and/or langmap
;                           ins_ctrl_hat();
;                           break normalchar;

;                       case Ctrl__:                        ;; switch between languages
;                           if (!@p_ari)
;                               break;
;                           ins_ctrl_();
;                           break normalchar;

;                       case Ctrl_D:                        ;; make indent one shiftwidth smaller
                            ;; FALLTHROUGH
;                       case Ctrl_T:                        ;; make indent one shiftwidth greater
;                           ins_shift(c, lastc);
;                           auto_format(false, true);
;                           inserted_space[0] = false;
;                           break normalchar;

;                       case K_DEL:                         ;; delete character under the cursor
;                       case K_KDEL:
;                           ins_del();
;                           auto_format(false, true);
;                           break normalchar;

;                       case K_BS:                          ;; delete character before the cursor
;                       case Ctrl_H:
;                           did_backspace = ins_bs(c, BACKSPACE_CHAR, inserted_space);
;                           auto_format(false, true);
;                           break normalchar;

;                       case Ctrl_W:                        ;; delete word before the cursor
;                           did_backspace = ins_bs(c, BACKSPACE_WORD, inserted_space);
;                           auto_format(false, true);
;                           break normalchar;

;                       case Ctrl_U:                        ;; delete all inserted text in current line
;                           did_backspace = ins_bs(c, BACKSPACE_LINE, inserted_space);
;                           auto_format(false, true);
;                           inserted_space[0] = false;
;                           break normalchar;

;                       case K_LEFTMOUSE:                   ;; mouse keys
;                       case K_LEFTMOUSE_NM:
;                       case K_LEFTDRAG:
;                       case K_LEFTRELEASE:
;                       case K_LEFTRELEASE_NM:
;                       case K_MIDDLEMOUSE:
;                       case K_MIDDLEDRAG:
;                       case K_MIDDLERELEASE:
;                       case K_RIGHTMOUSE:
;                       case K_RIGHTDRAG:
;                       case K_RIGHTRELEASE:
;                       case K_X1MOUSE:
;                       case K_X1DRAG:
;                       case K_X1RELEASE:
;                       case K_X2MOUSE:
;                       case K_X2DRAG:
;                       case K_X2RELEASE:
;                           ins_mouse(c);
;                           break normalchar;

;                       case K_MOUSEDOWN:                   ;; default action for scroll wheel up: scroll up
;                           ins_mousescroll(MSCR_DOWN);
;                           break normalchar;

;                       case K_MOUSEUP:                     ;; default action for scroll wheel down: scroll down
;                           ins_mousescroll(MSCR_UP);
;                           break normalchar;

;                       case K_MOUSELEFT:                   ;; scroll wheel left
;                           ins_mousescroll(MSCR_LEFT);
;                           break normalchar;

;                       case K_MOUSERIGHT:                  ;; scroll wheel right
;                           ins_mousescroll(MSCR_RIGHT);
;                           break normalchar;

;                       case K_IGNORE:                      ;; something mapped to nothing
;                           break normalchar;

;                       case K_CURSORHOLD:                  ;; didn't type something for a while
;                           @did_cursorhold = true;
;                           break normalchar;

;                       case K_HOME:                        ;; <Home>
;                       case K_KHOME:
;                       case K_S_HOME:
;                       case K_C_HOME:
;                           ins_home(c);
;                           break normalchar;

;                       case K_END:                         ;; <End>
;                       case K_KEND:
;                       case K_S_END:
;                       case K_C_END:
;                           ins_end(c);
;                           break normalchar;

;                       case K_LEFT:                        ;; <Left>
;                           if ((@mod_mask & (MOD_MASK_SHIFT|MOD_MASK_CTRL)) != 0)
;                               ins_s_left();
;                           else
;                               ins_left();
;                           break normalchar;

;                       case K_S_LEFT:                      ;; <S-Left>
;                       case K_C_LEFT:
;                           ins_s_left();
;                           break normalchar;

;                       case K_RIGHT:                       ;; <Right>
;                           if ((@mod_mask & (MOD_MASK_SHIFT|MOD_MASK_CTRL)) != 0)
;                               ins_s_right();
;                           else
;                               ins_right();
;                           break normalchar;

;                       case K_S_RIGHT:                     ;; <S-Right>
;                       case K_C_RIGHT:
;                           ins_s_right();
;                           break normalchar;

;                       case K_UP:                          ;; <Up>
;                           if ((@mod_mask & MOD_MASK_SHIFT) != 0)
;                               ins_pageup();
;                           else
;                               ins_up(false);
;                           break normalchar;

;                       case K_S_UP:                        ;; <S-Up>
;                       case K_PAGEUP:
;                       case K_KPAGEUP:
;                           ins_pageup();
;                           break normalchar;

;                       case K_DOWN:                        ;; <Down>
;                           if ((@mod_mask & MOD_MASK_SHIFT) != 0)
;                               ins_pagedown();
;                           else
;                               ins_down(false);
;                           break normalchar;

;                       case K_S_DOWN:                      ;; <S-Down>
;                       case K_PAGEDOWN:
;                       case K_KPAGEDOWN:
;                           ins_pagedown();
;                           break normalchar;

;                       case K_DROP:                        ;; drag-n-drop event
;                           ins_drop();
;                           break normalchar;

;                       case K_S_TAB:                       ;; when not mapped, use like a normal TAB
;                           c = TAB;
                            ;; FALLTHROUGH
;                       case TAB:                           ;; TAB or Complete patterns along path
;                           inserted_space[0] = false;
;                           if (ins_tab())
;                               break;            ;; insert TAB as a normal char
;                           auto_format(false, true);
;                           break normalchar;

;                       case K_KENTER:                      ;; <Enter>
;                           c = CAR;
                            ;; FALLTHROUGH
;                       case CAR:
;                       case NL:
;                           if (@cmdwin_type != 0)
;                           {
                                ;; Execute the command in the cmdline window.
;                               @cmdwin_result = CAR;
;                               break doESCkey;
;                           }
;                           if (ins_eol(c) && !@p_im)
;                               break doESCkey;             ;; out of memory
;                           auto_format(false, false);
;                           inserted_space[0] = false;
;                           break normalchar;

;                       case Ctrl_K:                        ;; digraph or keyword completion
;                           c = ins_digraph();
;                           if (c == NUL)
;                               break normalchar;
;                           break;

;                       case Ctrl_L:                        ;; whole line completion after ^X
;                       {
                            ;; CTRL-L with 'insertmode' set: Leave Insert mode.
;                           if (@p_im)
;                           {
;                               if (echeck_abbr(Ctrl_L + ABBR_OFF))
;                                   break normalchar;
;                               break doESCkey;
;                           }
;                           break;
;                       }

;                       case Ctrl_Y:                        ;; copy from previous line or scroll down
;                       case Ctrl_E:                        ;; copy from next     line or scroll up
;                           c = ins_ctrl_ey(c);
;                           break normalchar;

;                       default:
;                           if (c == @intr_char)             ;; special interrupt char
;                           {
                                ;; When 'insertmode' set, and not halfway a mapping, don't leave Insert mode.
;                               if (goto_im())
;                               {
;                                   if (@got_int)
;                                   {
;                                       vgetc();                ;; flush all buffers
;                                       @got_int = false;
;                                   }
;                                   else
;                                       vim_beep();
;                                   break normalchar;
;                               }
;                               break doESCkey;
;                           }
;                           break;
;                   }

                    ;; Insert a normal character.

;                   if (!@p_paste)
;                   {
                        ;; Trigger InsertCharPre.
;                       Bytes s = do_insert_char_pre(c);

;                       if (s != null)
;                       {
;                           if (s.at(0) != NUL && stop_arrow())
;                           {
                                ;; Insert the new value of v:char literally.
;                               for (Bytes p = s; p.at(0) != NUL; p = p.plus(us_ptr2len_cc(p)))
;                               {
;                                   c = us_ptr2char(p);
;                                   if (c == CAR || c == K_KENTER || c == NL)
;                                       ins_eol(c);
;                                   else
;                                       ins_char(c);
;                               }
;                               appendToRedobuffLit(s, -1);
;                           }
;                           c = NUL;
;                       }

                        ;; If the new value is already inserted or an empty string,
                        ;; then don't insert any character.
;                       if (c == NUL)
;                           break normalchar;
;                   }
                    ;; Try to perform smart-indenting.
;                   ins_try_si(c);

;                   if (c == ' ')
;                   {
;                       inserted_space[0] = true;
;                       if (inindent(0))
;                           @can_cindent = false;
;                       if (@insStart_blank_vcol == MAXCOL && @curwin.w_cursor.lnum == @insStart.lnum)
;                           @insStart_blank_vcol = get_nolist_virtcol();
;                   }

                    ;; Insert a normal character and check for abbreviations on a special character.
                    ;; Let CTRL-] expand abbreviations without inserting it.
                    ;; Add ABBR_OFF for characters above 0x100, this is what check_abbr() expects.
;                   if (vim_iswordc(c, @curbuf) || (!echeck_abbr((0x100 <= c) ? (c + ABBR_OFF) : c) && c != Ctrl_RSB))
;                   {
;                       insert_special(c, false, false);
;                       @revins_legal++;
;                       @revins_chars++;
;                   }

;                   auto_format(false, true);
;               }

                ;; If typed something may trigger CursorHoldI again.
;               if (c != K_CURSORHOLD)
;                   @did_cursorhold = false;

                ;; If the cursor was moved we didn't just insert a space.
;               if (@arrow_used)
;                   inserted_space[0] = false;

;               if (@can_cindent && cindent_on())
;               {
                    ;; Indent now if a key was typed that is in 'cinkeys'.
;                   if (in_cinkeys(c, ' ', line_is_white) && stop_arrow())
;                       do_c_expr_indent();
;               }

;               continue;
;           }

            ;; This is the ONLY return from edit()!

            ;; Always update o_lnum, so that a "CTRL-O ." that adds a line
            ;; still puts the cursor back after the inserted text.
;           if (@ins_at_eol && gchar_cursor() == NUL)
;               @o_lnum = @curwin.w_cursor.lnum;

;           if (ins_esc(count, cmdchar, nomove))
;           {
;               @did_cursorhold = false;
;               return (c == Ctrl_O);
;           }
;       }

        ;; NOTREACHED
    ))

;; Redraw for Insert mode.
;; This is postponed until getting the next character to make '$' in the 'cpo' option work correctly.
;; Only redraw when there are no characters available.
;; This speeds up inserting sequences of characters (e.g., for CTRL-R).

(defn- #_void ins_redraw [#_boolean ready]
    ;; ready: not busy with something
    (§
;       if (char_avail())
;           return;

;       long conceal_old_cursor_line = 0;
;       long conceal_new_cursor_line = 0;
;       boolean conceal_update_lines = false;

        ;; Trigger CursorMoved if the cursor moved.
        ;; Not when the popup menu is visible, the command might delete it.
;       if (ready && 0 < @curwin.w_onebuf_opt.@wo_cole && !eqpos(@last_cursormoved, @curwin.w_cursor))
;       {
;           conceal_old_cursor_line = @last_cursormoved.lnum;
;           conceal_new_cursor_line = @curwin.w_cursor.lnum;
;           conceal_update_lines = true;

;           COPY_pos(@last_cursormoved, @curwin.w_cursor);
;       }

;       if (@must_redraw != 0)
;           update_screen(0);
;       else if (@clear_cmdline || @redraw_cmdline)
;           showmode();             ;; clear cmdline and show mode
;       if ((conceal_update_lines
;               && (conceal_old_cursor_line != conceal_new_cursor_line || conceal_cursor_line(@curwin)))
;               || @need_cursor_line_redraw)
;       {
;           if (conceal_old_cursor_line != conceal_new_cursor_line)
;               update_single_line(@curwin, conceal_old_cursor_line);
;           update_single_line(@curwin, conceal_new_cursor_line == 0 ? @curwin.w_cursor.lnum : conceal_new_cursor_line);
;           @curwin.w_valid &= ~VALID_CROW;
;       }
;       showruler(false);
;       setcursor();
;       @emsg_on_display = false;    ;; may remove error message now
    ))

;; Handle a CTRL-V or CTRL-Q typed in Insert mode.

(defn- #_void ins_ctrl_v []
    (§
;       boolean did_putchar = false;

        ;; may need to redraw when no more chars available now
;       ins_redraw(false);

;       if (redrawing() && !char_avail())
;       {
;           edit_putchar('^', true);
;           did_putchar = true;
;       }
;       appendToRedobuff(CTRL_V_STR);   ;; CTRL-V

;       add_to_showcmd_c(Ctrl_V);

;       int c = get_literal();
;       if (did_putchar)
            ;; When the line fits in 'columns' the '^' is at the start
            ;; of the next line and will not removed by the redraw.
;           edit_unputchar();
;       clear_showcmd();
;       insert_special(c, false, true);
;       @revins_chars++;
;       @revins_legal++;
    ))

;; Put a character directly onto the screen.  It's not stored in a buffer.
;; Used while handling CTRL-K, CTRL-V, etc. in Insert mode.

(atom! int  pc_status)
(final int PC_STATUS_UNSET 0)                   ;; "pc_bytes" was not set
(final int PC_STATUS_RIGHT 1)                   ;; right halve of double-wide char
(final int PC_STATUS_LEFT  2)                   ;; left halve of double-wide char
(final int PC_STATUS_SET   3)                   ;; "pc_bytes" was filled

(final Bytes pc_bytes (Bytes. (inc MB_MAXBYTES)))   ;; saved bytes
(atom! int  pc_attr)
(atom! int  pc_row)
(atom! int  pc_col)

(defn- #_void edit_putchar [#_int c, #_boolean highlight]
    (§
;       if (@screenLines != null)
;       {
;           update_topline();       ;; just in case w_topline isn't valid
;           validate_cursor();

;           int attr = highlight ? hl_attr(HLF_8) : 0;

;           @pc_row = @curwin.w_winrow + @curwin.w_wrow;
;           @pc_col = @curwin.w_wincol;
;           @pc_status = PC_STATUS_UNSET;
;           if (@curwin.w_onebuf_opt.@wo_rl)
;           {
;               @pc_col += @curwin.w_width - 1 - @curwin.w_wcol;

;               int fix_col = mb_fix_col(@pc_col, @pc_row);
;               if (fix_col != @pc_col)
;               {
;                   screen_putchar(' ', @pc_row, fix_col, attr);
;                   --@curwin.w_wcol;
;                   @pc_status = PC_STATUS_RIGHT;
;               }
;           }
;           else
;           {
;               @pc_col += @curwin.w_wcol;
;               if (mb_lefthalve(@pc_row, @pc_col))
;                   @pc_status = PC_STATUS_LEFT;
;           }

            ;; save the character to be able to put it back
;           if (@pc_status == PC_STATUS_UNSET)
;           {
;               screen_getbytes(@pc_row, @pc_col, pc_bytes, pc_attr);
;               @pc_status = PC_STATUS_SET;
;           }
;           screen_putchar(c, @pc_row, @pc_col, attr);
;       }
    ))

;; Undo the previous edit_putchar().

(defn- #_void edit_unputchar []
    (§
;       if (@pc_status != PC_STATUS_UNSET && @msg_scrolled <= @pc_row)
;       {
;           if (@pc_status == PC_STATUS_RIGHT)
;               @curwin.w_wcol++;
;           if (@pc_status == PC_STATUS_RIGHT || @pc_status == PC_STATUS_LEFT)
;               redrawWinline(@curwin.w_cursor.lnum);
;           else
;               screen_puts(pc_bytes, @pc_row - @msg_scrolled, @pc_col, @pc_attr);
;       }
    ))

;; Called when p_dollar is set: display a '$' at the end of the changed text
;; Only works when cursor is in the line that changes.

(defn- #_void display_dollar [#_int col]
    (§
;       if (!redrawing())
;           return;

;       cursor_off();
;       int save_col = @curwin.w_cursor.col;
;       @curwin.w_cursor.col = col;

        ;; If on the last byte of a multi-byte move to the first byte.
;       Bytes p = ml_get_curline();
;       @curwin.w_cursor.col -= us_head_off(p, p.plus(col));

;       curs_columns(false);                    ;; recompute w_wrow and w_wcol
;       if (@curwin.w_wcol < @curwin.w_width)
;       {
;           edit_putchar('$', false);
;           @dollar_vcol = @curwin.w_virtcol;
;       }
;       @curwin.w_cursor.col = save_col;
    ))

;; Call this function before moving the cursor from the normal insert position in insert mode.

(defn- #_void undisplay_dollar []
    (§
;       if (0 <= @dollar_vcol)
;       {
;           @dollar_vcol = -1;
;           redrawWinline(@curwin.w_cursor.lnum);
;       }
    ))

;; Insert an indent (for <Tab> or CTRL-T) or delete an indent (for CTRL-D).
;; Keep the cursor on the same character.
;; type == INDENT_INC   increase indent (for CTRL-T or <Tab>)
;; type == INDENT_DEC   decrease indent (for CTRL-D)
;; type == INDENT_SET   set indent to "amount"
;; If round is true, round the indent to 'shiftwidth' (only with _INC and _DEC).

(defn- #_void change_indent [#_int type, #_int amount, #_boolean round, #_int replaced, #_boolean call_changed_bytes]
    ;; replaced: replaced character, put on replace stack
    ;; call_changed_bytes: call changed_bytes()
    (§
;       Bytes orig_line = null;
;       int orig_col = 0;

        ;; VREPLACE mode needs to know what the line was like before changing.
;       if ((@State & VREPLACE_FLAG) != 0)
;       {
;           orig_line = STRDUP(ml_get_curline());   ;; Deal with null below
;           orig_col = @curwin.w_cursor.col;
;       }

        ;; for the following tricks we don't want list mode
;       boolean save_p_list = @curwin.w_onebuf_opt.@wo_list;
;       @curwin.w_onebuf_opt.@wo_list = false;
;       int vc = getvcol_nolist(@curwin.w_cursor);
;       int vcol = vc;

        ;; For Replace mode we need to fix the replace stack later, which is only
        ;; possible when the cursor is in the indent.  Remember the number of
        ;; characters before the cursor if it's possible.

;       int start_col = @curwin.w_cursor.col;

        ;; determine offset from first non-blank
;       int new_cursor_col = @curwin.w_cursor.col;
;       beginline(BL_WHITE);
;       new_cursor_col -= @curwin.w_cursor.col;

;       int insstart_less = @curwin.w_cursor.col;    ;; reduction for insStart.col

        ;; If the cursor is in the indent, compute how many screen columns the
        ;; cursor is to the left of the first non-blank.

;       if (new_cursor_col < 0)
;           vcol = get_indent() - vcol;

;       if (0 < new_cursor_col)         ;; can't fix replace stack
;           start_col = -1;

        ;; Set the new indent.  The cursor will be put on the first non-blank.

;       if (type == INDENT_SET)
;           set_indent(amount, call_changed_bytes ? SIN_CHANGED : 0);
;       else
;       {
;           int save_State = @State;

            ;; Avoid being called recursively.
;           if ((@State & VREPLACE_FLAG) != 0)
;               @State = INSERT;
;           shift_line(type == INDENT_DEC, round, 1, call_changed_bytes);

;           @State = save_State;
;       }
;       insstart_less -= @curwin.w_cursor.col;

        ;; Try to put cursor on same character.
        ;; If the cursor is at or after the first non-blank in the line,
        ;; compute the cursor column relative to the column of the first non-blank character.
        ;; If we are not in insert mode, leave the cursor on the first non-blank.
        ;; If the cursor is before the first non-blank, position it relative
        ;; to the first non-blank, counted in screen columns.

;       if (0 <= new_cursor_col)
;       {
            ;; When changing the indent while the cursor is touching it, reset insStart_col to 0.

;           if (new_cursor_col == 0)
;               insstart_less = MAXCOL;
;           new_cursor_col += @curwin.w_cursor.col;
;       }
;       else if ((@State & INSERT) == 0)
;           new_cursor_col = @curwin.w_cursor.col;
;       else
;       {
            ;; Compute the screen column where the cursor should be.

;           vcol = get_indent() - vcol;
;           @curwin.w_virtcol = (vcol < 0) ? 0 : vcol;

            ;; Advance the cursor until we reach the right screen column.

;           int last_vcol = vcol = 0;
;           new_cursor_col = -1;
;           Bytes ptr = ml_get_curline();
;           while (vcol <= @curwin.w_virtcol)
;           {
;               last_vcol = vcol;
;               if (0 <= new_cursor_col)
;                   new_cursor_col += us_ptr2len_cc(ptr.plus(new_cursor_col));
;               else
;                   new_cursor_col++;
;               vcol += lbr_chartabsize(ptr, ptr.plus(new_cursor_col), vcol);
;           }
;           vcol = last_vcol;

            ;; May need to insert spaces to be able to position the cursor on
            ;; the right screen column.

;           if (vcol != @curwin.w_virtcol)
;           {
;               @curwin.w_cursor.col = new_cursor_col;
;               int i = @curwin.w_virtcol - vcol;
;               ptr = new Bytes(i + 1);

;               new_cursor_col += i;
;               ptr.be(i, NUL);
;               while (0 <= --i)
;                   ptr.be(i, (byte)' ');
;               ins_str(ptr);
;           }

            ;; When changing the indent while the cursor is in it, reset insStart_col to 0.

;           insstart_less = MAXCOL;
;       }

;       @curwin.w_onebuf_opt.@wo_list = save_p_list;

;       if (new_cursor_col <= 0)
;           @curwin.w_cursor.col = 0;
;       else
;           @curwin.w_cursor.col = new_cursor_col;
;       @curwin.w_set_curswant = true;
;       changed_cline_bef_curs();

        ;; May have to adjust the start of the insert.

;       if ((@State & INSERT) != 0)
;       {
;           if (@curwin.w_cursor.lnum == @insStart.lnum && @insStart.col != 0)
;           {
;               if (@insStart.col <= insstart_less)
;                   @insStart.col = 0;
;               else
;                   @insStart.col -= insstart_less;
;           }
;           if (@ai_col <= insstart_less)
;               @ai_col = 0;
;           else
;               @ai_col -= insstart_less;
;       }

        ;; For REPLACE mode, may have to fix the replace stack, if it's possible.
        ;; If the number of characters before the cursor decreased, need to pop a
        ;; few characters from the replace stack.
        ;; If the number of characters before the cursor increased, need to push a
        ;; few NULs onto the replace stack.

;       if ((@State & REPLACE_FLAG) != 0 && (@State & VREPLACE_FLAG) == 0 && 0 <= start_col)
;       {
;           while (@curwin.w_cursor.col < start_col)
;           {
;               replace_join(0);        ;; remove a NUL from the replace stack
;               --start_col;
;           }
;           while (start_col < @curwin.w_cursor.col || replaced != NUL)
;           {
;               replace_push(NUL);
;               if (replaced != NUL)
;               {
;                   replace_push(replaced);
;                   replaced = NUL;
;               }
;               start_col++;
;           }
;       }

        ;; For VREPLACE mode, we also have to fix the replace stack.  In this case
        ;; it is always possible because we backspace over the whole line and then
        ;; put it back again the way we wanted it.

;       if ((@State & VREPLACE_FLAG) != 0)
;       {
            ;; If 'orig_line' didn't allocate, just return.
            ;; At least we did the job, even if you can't backspace.
;           if (orig_line == null)
;               return;

            ;; Save new line.
;           Bytes new_line = STRDUP(ml_get_curline());

            ;; We only put back the new line up to the cursor.
;           new_line.be(@curwin.w_cursor.col, NUL);

            ;; Put back original line.
;           ml_replace(@curwin.w_cursor.lnum, orig_line, false);
;           @curwin.w_cursor.col = orig_col;

            ;; Backspace from cursor to start of line.
;           backspace_until_column(0);

            ;; Insert new stuff into line again.
;           ins_bytes(new_line);
;       }
    ))

;; Truncate the space at the end of a line.  This is to be used only in an
;; insert mode.  It handles fixing the replace stack for REPLACE and VREPLACE modes.

(defn- #_void truncate_spaces [#_Bytes line]
    (§
        ;; find start of trailing white space
;       int i;
;       for (i = STRLEN(line) - 1; 0 <= i && vim_iswhite(line.at(i)); i--)
;       {
;           if ((@State & REPLACE_FLAG) != 0)
;               replace_join(0);        ;; remove a NUL from the replace stack
;       }
;       line.be(i + 1, NUL);
    ))

;; Backspace the cursor until the given column.  Handles REPLACE and VREPLACE
;; modes correctly.  May also be used when not in insert mode at all.
;; Will attempt not to go before "col" even when there is a composing character.

(defn- #_void backspace_until_column [#_int col]
    (§
;       while (col < @curwin.w_cursor.col)
;       {
;           --@curwin.w_cursor.col;
;           if ((@State & REPLACE_FLAG) != 0)
;               replace_do_bs(col);
;           else if (!del_char_after_col(col))
;               break;
;       }
    ))

;; Like del_char(), but make sure not to go before column "limit_col".
;; Only matters when there are composing characters.
;; Return true when something was deleted.

(defn- #_boolean del_char_after_col [#_int limit_col]
    (§
;       if (0 <= limit_col)
;       {
;           int ecol = @curwin.w_cursor.col + 1;

            ;; Make sure the cursor is at the start of a character, but
            ;; skip forward again when going too far back because of a
            ;; composing character.
;           mb_adjust_pos(@curbuf, @curwin.w_cursor);
;           while (@curwin.w_cursor.col < limit_col)
;           {
;               int l = us_ptr2len(ml_get_cursor());

;               if (l == 0)     ;; end of line
;                   break;
;               @curwin.w_cursor.col += l;
;           }
;           if (ml_get_cursor().at(0) == NUL || @curwin.w_cursor.col == ecol)
;               return false;
;           del_bytes(ecol - @curwin.w_cursor.col, false, true);
;       }
;       else
;           del_char(false);
;       return true;
    ))

;; Next character is interpreted literally.
;; A one, two or three digit decimal number is interpreted as its byte value.
;; If one or two digits are entered, the next character is given to vungetc().
;; For Unicode a character > 255 may be returned.

(defn- #_int get_literal []
    (§
;       if (@got_int)
;           return Ctrl_C;

;       boolean hex = false;
;       boolean octal = false;
;       int unicode = 0;

;       int nc;
;       @no_mapping++;               ;; don't map the next key hits

;       int cc = 0;
;       int i = 0;
;       for ( ; ; )
;       {
;           nc = plain_vgetc();

;           if ((@State & CMDLINE) == 0 && mb_byte2len(nc) == 1)
;               add_to_showcmd(nc);

;           if (nc == 'x' || nc == 'X')
;               hex = true;
;           else if (nc == 'o' || nc == 'O')
;               octal = true;
;           else if (nc == 'u' || nc == 'U')
;               unicode = nc;
;           else
;           {
;               if (hex || unicode != 0)
;               {
;                   if (!asc_isxdigit(nc))
;                       break;
;                   cc = cc * 16 + hex2nr(nc);
;               }
;               else if (octal)
;               {
;                   if (nc < '0' || '7' < nc)
;                       break;
;                   cc = cc * 8 + nc - '0';
;               }
;               else
;               {
;                   if (!asc_isdigit(nc))
;                       break;
;                   cc = cc * 10 + nc - '0';
;               }

;               i++;
;           }

;           if (cc > 255 && unicode == 0)
;               cc = 255;           ;; limit range to 0-255
;           nc = 0;

;           if (hex)                ;; hex: up to two chars
;           {
;               if (2 <= i)
;                   break;
;           }
;           else if (unicode != 0)  ;; Unicode: up to four or eight chars
;           {
;               if ((unicode == 'u' && 4 <= i) || (unicode == 'U' && 8 <= i))
;                   break;
;           }
;           else if (3 <= i)        ;; decimal or octal: up to three chars
;               break;
;       }
;       if (i == 0)                 ;; no number entered
;       {
;           if (nc == K_ZERO)       ;; NUL is stored as NL
;           {
;               cc = '\n';
;               nc = 0;
;           }
;           else
;           {
;               cc = nc;
;               nc = 0;
;           }
;       }

;       if (cc == 0)                ;; NUL is stored as NL
;           cc = '\n';

;       --@no_mapping;
;       if (nc != 0)
;           vungetc(nc);

;       @got_int = false;            ;; CTRL-C typed after CTRL-V is not an interrupt
;       return cc;
    ))

;; Insert character, taking care of special keys and mod_mask

(defn- #_void insert_special [#_int c, #_boolean allow_modmask, #_boolean ctrlv]
    ;; ctrlv: c was typed after CTRL-V
    (§
        ;; Special function key, translate into "<Key>".  Up to the last '>' is
        ;; inserted with ins_str(), so as not to replace characters in replace mode.
        ;; Only use mod_mask for special keys, to avoid things like <S-Space>,
        ;; unless 'allow_modmask' is true.

;       if (is_special(c) || (@mod_mask != 0 && allow_modmask))
;       {
;           Bytes p = get_special_key_name(c, @mod_mask);
;           int len = STRLEN(p);
;           c = p.at(len - 1);
;           if (2 < len)
;           {
;               if (!stop_arrow())
;                   return;
;               p.be(len - 1, NUL);
;               ins_str(p);
;               appendToRedobuffLit(p, -1);
;               ctrlv = false;
;           }
;       }
;       if (stop_arrow())
;           insertchar(c, ctrlv ? INSCHAR_CTRLV : 0, -1);
    ))

;; Special characters in this context are those that need processing other
;; than the simple insertion that can be performed here.  This includes ESC
;; which terminates the insert, and CR/NL which need special processing to
;; open up a new line.  This routine tries to optimize insertions performed by
;; the "redo", "undo" or "put" commands, so it needs to know when it should
;; stop and defer processing to the "normal" mechanism.
;; '0' and '^' are special, because they can be followed by CTRL-D.

(defn- #_boolean isspecial [#_int c]
    (§
;       return (c < ' ' || DEL <= c || c == '0' || c == '^');
    ))

(defn- #_boolean whitechar [#_int cc]
    (§
;       return (vim_iswhite(cc) && !utf_iscomposing(us_ptr2char(ml_get_cursor().plus(1))));
    ))

;; "flags": INSCHAR_FORMAT - force formatting
;;          INSCHAR_CTRLV  - char typed just after CTRL-V
;;          INSCHAR_NO_FEX - don't use 'formatexpr'
;;
;;   NOTE: passes the flags value straight through to internal_format() which,
;;         beside INSCHAR_FORMAT (above), is also looking for these:
;;          INSCHAR_DO_COM   - format comments
;;          INSCHAR_COM_LIST - format comments with num list or 2nd line indent

(defn- #_void insertchar [#_int c, #_int flags, #_int second_indent]
    ;; c: character to insert or NUL
    ;; flags: INSCHAR_FORMAT, etc.
    ;; second_indent: indent for second line if >= 0
    (§
;       boolean force_format = ((flags & INSCHAR_FORMAT) != 0);

;       int textwidth = comp_textwidth(force_format);
;       boolean fo_ins_blank = has_format_option(FO_INS_BLANK);

        ;; Try to break the line in two or more pieces when:
        ;; - Always do this if we have been called to do formatting only.
        ;; - Always do this when 'formatoptions' has the 'a' flag and the line ends in white space.
        ;; - Otherwise:
        ;;   - Don't do this if inserting a blank
        ;;   - Don't do this if an existing character is being replaced, unless we're in VREPLACE mode.
        ;;   - Do this if the cursor is not on the line where insert started
        ;;   or - 'formatoptions' doesn't have 'l' or the line was not too long before the insert.
        ;;      - 'formatoptions' doesn't have 'b' or a blank was inserted at or before 'textwidth'

;       if (0 < textwidth
;               && (force_format
;                   || (!vim_iswhite(c)
;                       && !((@State & REPLACE_FLAG) != 0
;                           && (@State & VREPLACE_FLAG) == 0
;                           && ml_get_cursor().at(0) != NUL)
;                       && (@curwin.w_cursor.lnum != @insStart.lnum
;                           || ((!has_format_option(FO_INS_LONG) || @insStart_textlen <= textwidth)
;                               && (!fo_ins_blank || @insStart_blank_vcol <= textwidth))))))
;       {
;           int virtcol = get_nolist_virtcol() + mb_char2cells(c != NUL ? c : gchar_cursor());

;           internal_format(textwidth, second_indent, flags, c == NUL, c);
;       }

;       if (c == NUL)           ;; only formatting was wanted
;           return;

        ;; Check whether this character should end a comment.
;       if (@did_ai && c == @end_comment_pending)
;       {
;           Bytes line;
;           Bytes[] p = new Bytes[1];

            ;; Need to remove existing (middle) comment leader and insert end
            ;; comment leader.  First, check what comment leader we can find.

;           int i = get_leader_len(line = ml_get_curline(), p, false, true);
;           if (0 < i && vim_strchr(p[0], COM_MIDDLE) != null)
;           {
;               Bytes lead_end = new Bytes(COM_MAX_LEN);    ;; end-comment string

                ;; Skip middle-comment string.
;               while (p[0].at(0) != NUL && p[0].at(-1) != (byte)':')           ;; find end of middle flags
;                   p[0] = p[0].plus(1);
;               int middle_len = copy_option_part(p, lead_end, COM_MAX_LEN, u8(","));
                ;; Don't count trailing white space for middle_len.
;               while (0 < middle_len && vim_iswhite(lead_end.at(middle_len - 1)))
;                   --middle_len;

                ;; Find the end-comment string.
;               while (p[0].at(0) != NUL && p[0].at(-1) != (byte)':')           ;; find end of end flags
;                   p[0] = p[0].plus(1);
;               int end_len = copy_option_part(p, lead_end, COM_MAX_LEN, u8(","));

                ;; Skip white space before the cursor.
;               i = @curwin.w_cursor.col;
;               while (0 <= --i && vim_iswhite(line.at(i)))
                ;
;               i++;

                ;; Skip to before the middle leader.
;               i -= middle_len;

                ;; Check some expected things before we go on.
;               if (0 <= i && lead_end.at(end_len - 1) == @end_comment_pending)
;               {
                    ;; Backspace over all the stuff we want to replace.
;                   backspace_until_column(i);

                    ;; Insert the end-comment string, except for the last
                    ;; character, which will get inserted as normal later.

;                   ins_bytes_len(lead_end, end_len - 1);
;               }
;           }
;       }
;       @end_comment_pending = NUL;

;       @did_ai = false;
;       @did_si = false;
;       @can_si = false;
;       @can_si_back = false;

        ;; If there's any pending input, grab up to INPUT_BUFLEN at once.
        ;; This speeds up normal text input considerably.
        ;; Don't do this when 'cindent' or 'indentexpr' is set, because we might
        ;; need to re-indent at a ':', or any other character (but not what 'paste' is set)..
        ;; Don't do this when there an InsertCharPre autocommand is defined,
        ;; because we need to fire the event for every character.

;       if (!isspecial(c)
;               && utf_char2len(c) == 1
;               && vpeekc() != NUL
;               && (@State & REPLACE_FLAG) == 0
;               && !cindent_on()
;               && !@p_ri)
;       {
;           final int INPUT_BUFLEN = 100;
;           Bytes buf = new Bytes(INPUT_BUFLEN + 1);
;           int virtcol = 0;

;           buf.be(0, c);
;           int i = 1;
;           if (0 < textwidth)
;               virtcol = get_nolist_virtcol();

            ;; Stop the string when:
            ;; - no more chars available
            ;; - finding a special character (command key)
            ;; - buffer is full
            ;; - running into the 'textwidth' boundary
            ;; - need to check for abbreviation: A non-word char after a word-char

;           while ((c = vpeekc()) != NUL
;                   && !isspecial(c)
;                   && mb_byte2len(c) == 1
;                   && i < INPUT_BUFLEN
;                   && (textwidth == 0 || (virtcol += mb_byte2cells(buf.at(i - 1))) < textwidth)
;                   && !(!@no_abbr && !vim_iswordc(c, @curbuf) && vim_iswordc(buf.at(i - 1), @curbuf)))
;           {
;               c = vgetc();
;               buf.be(i++, c);
;           }

;           do_digraph(-1);                 ;; clear digraphs
;           do_digraph(buf.at(i - 1));      ;; may be the start of a digraph
;           buf.be(i, NUL);
;           ins_str(buf);
;           if ((flags & INSCHAR_CTRLV) != 0)
;           {
;               redo_literal(buf.at(0));
;               i = 1;
;           }
;           else
;               i = 0;
;           if (buf.at(i) != NUL)
;               appendToRedobuffLit(buf.plus(i), -1);
;       }
;       else
;       {
;           int cc = utf_char2len(c);
;           if (1 < cc)
;           {
;               Bytes buf = new Bytes(MB_MAXBYTES + 1);

;               utf_char2bytes(c, buf);
;               buf.be(cc, NUL);
;               ins_char_bytes(buf, cc);
;               appendCharToRedobuff(c);
;           }
;           else
;           {
;               ins_char(c);
;               if ((flags & INSCHAR_CTRLV) != 0)
;                   redo_literal(c);
;               else
;                   appendCharToRedobuff(c);
;           }
;       }
    ))

;; Format text at the current insert position.
;;
;; If the INSCHAR_COM_LIST flag is present, then the value of second_indent
;; will be the comment leader length sent to open_line().

(defn- #_void internal_format [#_int textwidth, #_int second_indent, #_int flags, #_boolean format_only, #_int c]
    ;; c: character to be inserted (can be NUL)
    (§
;       boolean haveto_redraw = false;
;       boolean fo_ins_blank = has_format_option(FO_INS_BLANK);
;       boolean fo_multibyte = has_format_option(FO_MBYTE_BREAK);
;       boolean fo_white_par = has_format_option(FO_WHITE_PAR);
;       boolean first_line = true;
;       boolean no_leader = false;
;       boolean do_comments = ((flags & INSCHAR_DO_COM) != 0);
;       boolean has_lbr = @curwin.w_onebuf_opt.@wo_lbr;

        ;; make sure win_lbr_chartabsize() counts correctly
;       @curwin.w_onebuf_opt.@wo_lbr = false;

        ;; When 'ai' is off we don't want a space under the cursor to be deleted.
        ;; Replace it with an 'x' temporarily.

;       int save_char = NUL;
;       if (!@curbuf.@b_p_ai && (@State & VREPLACE_FLAG) == 0)
;       {
;           int cc = gchar_cursor();
;           if (vim_iswhite(cc))
;           {
;               save_char = cc;
;               pchar_cursor('x');
;           }
;       }

        ;; Repeat breaking lines, until the current line is not too long.

;       while (!@got_int)
;       {
;           int end_foundcol = 0;       ;; column for start of word
;           int orig_col = 0;
;           Bytes saved_text = null;

;           int virtcol = get_nolist_virtcol() + mb_char2cells(c != NUL ? c : gchar_cursor());
;           if (virtcol <= textwidth)
;               break;

;           if (no_leader)
;               do_comments = false;
;           else if ((flags & INSCHAR_FORMAT) == 0 && has_format_option(FO_WRAP_COMS))
;               do_comments = true;

            ;; Don't break until after the comment leader.
;           int leader_len = 0;
;           if (do_comments)
;               leader_len = get_leader_len(ml_get_curline(), null, false, true);

            ;; If the line doesn't start with a comment leader, then don't start one
            ;; in a following broken line.  Avoids that a %word moved to the start
            ;; of the next line causes all following lines to start with %.
;           if (leader_len == 0)
;               no_leader = true;
;           if ((flags & INSCHAR_FORMAT) == 0 && leader_len == 0 && !has_format_option(FO_WRAP))
;               break;

;           int startcol = @curwin.w_cursor.col;     ;; cursor column at entry
;           if (startcol == 0)
;               break;

            ;; find column of textwidth border
;           coladvance(textwidth);
;           int wantcol = @curwin.w_cursor.col;      ;; column at textwidth border

;           @curwin.w_cursor.col = startcol;
;           int foundcol = 0;                       ;; column for start of spaces

            ;; Find position to break at.
            ;; Stop at first entered white when 'formatoptions' has 'v'.

;           while ((!fo_ins_blank && !has_format_option(FO_INS_VI))
;                       || (flags & INSCHAR_FORMAT) != 0
;                       || @curwin.w_cursor.lnum != @insStart.lnum
;                       || @insStart.col <= @curwin.w_cursor.col)
;           {
;               int cc;
;               if (@curwin.w_cursor.col == startcol && c != NUL)
;                   cc = c;
;               else
;                   cc = gchar_cursor();

;               if (whitechar(cc))
;               {
                    ;; remember position of blank just before text
;                   int end_col = @curwin.w_cursor.col;

                    ;; find start of sequence of blanks
;                   while (0 < @curwin.w_cursor.col && whitechar(cc))
;                   {
;                       dec_cursor();
;                       cc = gchar_cursor();
;                   }
;                   if (@curwin.w_cursor.col == 0 && whitechar(cc))
;                       break;                      ;; only spaces in front of text

                    ;; Don't break until after the comment leader.
;                   if (@curwin.w_cursor.col < leader_len)
;                       break;

;                   if (has_format_option(FO_ONE_LETTER))
;                   {
                        ;; do not break after one-letter words
;                       if (@curwin.w_cursor.col == 0)
;                           break;                  ;; one-letter word at begin

                        ;; do not break "#a b" when 'tw' is 2
;                       if (@curwin.w_cursor.col <= leader_len)
;                           break;

;                       int col = @curwin.w_cursor.col;
;                       dec_cursor();
;                       if (whitechar(gchar_cursor()))
;                           continue;               ;; one-letter, continue

;                       @curwin.w_cursor.col = col;
;                   }

;                   inc_cursor();

;                   end_foundcol = end_col + 1;
;                   foundcol = @curwin.w_cursor.col;

;                   if (@curwin.w_cursor.col <= wantcol)
;                       break;
;               }
;               else if (0x100 <= cc && fo_multibyte)
;               {
                    ;; Break after or before a multi-byte character.
;                   if (@curwin.w_cursor.col != startcol)
;                   {
                        ;; Don't break until after the comment leader.
;                       if (@curwin.w_cursor.col < leader_len)
;                           break;

;                       int col = @curwin.w_cursor.col;
;                       inc_cursor();
                        ;; Don't change end_foundcol if already set.
;                       if (foundcol != @curwin.w_cursor.col)
;                       {
;                           foundcol = @curwin.w_cursor.col;
;                           end_foundcol = foundcol;
;                           if (@curwin.w_cursor.col <= wantcol)
;                               break;
;                       }
;                       @curwin.w_cursor.col = col;
;                   }

;                   if (@curwin.w_cursor.col == 0)
;                       break;

;                   int col = @curwin.w_cursor.col;

;                   dec_cursor();
;                   if (whitechar(gchar_cursor()))
;                       continue;           ;; break with space

                    ;; Don't break until after the comment leader.
;                   if (@curwin.w_cursor.col < leader_len)
;                       break;

;                   @curwin.w_cursor.col = col;

;                   foundcol = @curwin.w_cursor.col;
;                   end_foundcol = foundcol;
;                   if (@curwin.w_cursor.col <= wantcol)
;                       break;
;               }

;               if (@curwin.w_cursor.col == 0)
;                   break;

;               dec_cursor();
;           }

;           if (foundcol == 0)              ;; no spaces, cannot break line
;           {
;               @curwin.w_cursor.col = startcol;
;               break;
;           }

            ;; Going to break the line, remove any "$" now.
;           undisplay_dollar();

            ;; Offset between cursor position and line break is used by replace stack functions.
            ;; VREPLACE does not use this, and backspaces over the text instead.

;           if ((@State & VREPLACE_FLAG) != 0)
;               orig_col = startcol;        ;; will start backspacing from here
;           else
;               @replace_offset = startcol - end_foundcol;

            ;; Adjust startcol for spaces that will be deleted and
            ;; characters that will remain on top line.

;           @curwin.w_cursor.col = foundcol;
;           while (whitechar(gchar_cursor()) && (!fo_white_par || @curwin.w_cursor.col < startcol))
;               inc_cursor();
;           startcol -= @curwin.w_cursor.col;
;           if (startcol < 0)
;               startcol = 0;

;           if ((@State & VREPLACE_FLAG) != 0)
;           {
                ;; In VREPLACE mode, we will backspace over the text to be
                ;; wrapped, so save a copy now to put on the next line.

;               saved_text = STRDUP(ml_get_cursor());
;               @curwin.w_cursor.col = orig_col;
;               saved_text.be(startcol, NUL);

                ;; Backspace over characters that will move to the next line.
;               if (!fo_white_par)
;                   backspace_until_column(foundcol);
;           }
;           else
;           {
                ;; Put cursor after pos to break line.
;               if (!fo_white_par)
;                   @curwin.w_cursor.col = foundcol;
;           }

            ;; Split the line just before the margin.
            ;; Only insert/delete lines, but don't really redraw the window.

;           open_line(FORWARD, OPENLINE_DELSPACES + OPENLINE_MARKFIX
;                   + (fo_white_par ? OPENLINE_KEEPTRAIL : 0)
;                   + (do_comments ? OPENLINE_DO_COM : 0)
;                   + ((flags & INSCHAR_COM_LIST) != 0 ? OPENLINE_COM_LIST : 0)
;                   , ((flags & INSCHAR_COM_LIST) != 0 ? second_indent : @old_indent));
;           if ((flags & INSCHAR_COM_LIST) == 0)
;               @old_indent = 0;

;           @replace_offset = 0;
;           if (first_line)
;           {
;               if ((flags & INSCHAR_COM_LIST) == 0)
;               {
                    ;; This section is for auto-wrap of numeric lists.  When not
                    ;; in insert mode (i.e. format_lines()), the INSCHAR_COM_LIST
                    ;; flag will be set and open_line() will handle it (as seen
                    ;; above).  The code here (and in get_number_indent()) will
                    ;; recognize comments if needed...

;                   if (second_indent < 0 && has_format_option(FO_Q_NUMBER))
;                       second_indent = get_number_indent(@curwin.w_cursor.lnum - 1);
;                   if (0 <= second_indent)
;                   {
;                       if ((@State & VREPLACE_FLAG) != 0)
;                           change_indent(INDENT_SET, second_indent, false, NUL, true);
;                       else if (0 < leader_len && 0 < second_indent - leader_len)
;                       {
;                           int padding = second_indent - leader_len;

                            ;; We started at the first_line of a numbered list
                            ;; that has a comment.  the open_line() function has
                            ;; inserted the proper comment leader and positioned
                            ;; the cursor at the end of the split line.  Now we
                            ;; add the additional whitespace needed after the
                            ;; comment leader for the numbered list.
;                           for (int i = 0; i < padding; i++)
;                               ins_str(u8(" "));
;                           changed_bytes(@curwin.w_cursor.lnum, leader_len);
;                       }
;                       else
;                           set_indent(second_indent, SIN_CHANGED);
;                   }
;               }
;               first_line = false;
;           }

;           if ((@State & VREPLACE_FLAG) != 0)
;           {
                ;; In VREPLACE mode we have backspaced over the text to be
                ;; moved, now we re-insert it into the new line.

;               ins_bytes(saved_text);
;           }
;           else
;           {
                ;; Check if cursor is not past the NUL off the line, cindent
                ;; may have added or removed indent.

;               @curwin.w_cursor.col += startcol;
;               int len = STRLEN(ml_get_curline());
;               if (@curwin.w_cursor.col > len)
;                   @curwin.w_cursor.col = len;
;           }

;           haveto_redraw = true;
;           @can_cindent = true;
            ;; moved the cursor, don't autoindent or cindent now
;           @did_ai = false;
;           @did_si = false;
;           @can_si = false;
;           @can_si_back = false;
;           line_breakcheck();
;       }

;       if (save_char != NUL)               ;; put back space after cursor
;           pchar_cursor(save_char);

;       @curwin.w_onebuf_opt.@wo_lbr = has_lbr;
;       if (!format_only && haveto_redraw)
;       {
;           update_topline();
;           redraw_curbuf_later(VALID);
;       }
    ))

;; Called after inserting or deleting text: When 'formatoptions' includes
;; the 'a' flag format from the current line until the end of the paragraph.
;; Keep the cursor at the same position relative to the text.
;; The caller must have saved the cursor line for undo, following ones will be saved here.

(defn- #_void auto_format [#_boolean trailblank, #_boolean prev_line]
    ;; trailblank: when true also format with trailing blank
    ;; prev_line: may start in previous line
    (§
;       if (!has_format_option(FO_AUTO))
;           return;

;       pos_C pos = §_pos_C();
;       COPY_pos(pos, @curwin.w_cursor);
;       Bytes old = ml_get_curline();

        ;; may remove added space
;       check_auto_format(false);

        ;; Don't format in Insert mode when the cursor is on a trailing blank, the
        ;; user might insert normal text next.  Also skip formatting when "1" is
        ;; in 'formatoptions' and there is a single character before the cursor.
        ;; Otherwise the line would be broken and when typing another non-white
        ;; next they are not joined back together.
;       boolean wasatend = (pos.col == STRLEN(old));
;       if (old.at(0) != NUL && !trailblank && wasatend)
;       {
;           dec_cursor();
;           int cc = gchar_cursor();
;           if (!whitechar(cc) && 0 < @curwin.w_cursor.col && has_format_option(FO_ONE_LETTER))
;               dec_cursor();
;           cc = gchar_cursor();
;           if (whitechar(cc))
;           {
;               COPY_pos(@curwin.w_cursor, pos);
;               return;
;           }
;           COPY_pos(@curwin.w_cursor, pos);
;       }

        ;; With the 'c' flag in 'formatoptions' and 't' missing: only format comments.
;       if (has_format_option(FO_WRAP_COMS) && !has_format_option(FO_WRAP)
;                                        && get_leader_len(old, null, false, true) == 0)
;       {
;           return;
;       }

        ;; May start formatting in a previous line, so that after "x" a word is
        ;; moved to the previous line if it fits there now.  Only when this is not
        ;; the start of a paragraph.

;       if (prev_line && !paragraph_start(@curwin.w_cursor.lnum))
;       {
;           --@curwin.w_cursor.lnum;
;           if (!u_save_cursor())
;               return;
;       }

        ;; Do the formatting and restore the cursor position.
        ;; "saved_cursor" will be adjusted for the text formatting.

;       COPY_pos(@saved_cursor, pos);
;       format_lines(-1, false);
;       COPY_pos(@curwin.w_cursor, @saved_cursor);
;       @saved_cursor.lnum = 0;

;       if (@curwin.w_cursor.lnum > @curbuf.b_ml.ml_line_count)
;       {
            ;; "cannot happen"
;           @curwin.w_cursor.lnum = @curbuf.b_ml.ml_line_count;
;           coladvance(MAXCOL);
;       }
;       else
;           check_cursor_col();

        ;; Insert mode: If the cursor is now after the end of the line while it previously
        ;; wasn't, the line was broken.  Because of the rule above we need to add a space
        ;; when 'w' is in 'formatoptions' to keep a paragraph formatted.
;       if (!wasatend && has_format_option(FO_WHITE_PAR))
;       {
;           Bytes p = ml_get_curline();
;           int len = STRLEN(p);
;           if (@curwin.w_cursor.col == len)
;           {
;               p = STRNDUP(p, len + 2);
;               p.be(len, (byte)' ');
;               p.be(len + 1, NUL);
;               ml_replace(@curwin.w_cursor.lnum, p, false);
                ;; remove the space later
;               @did_add_space = true;
;           }
;           else
                ;; may remove added space
;               check_auto_format(false);
;       }

;       check_cursor();
    ))

;; When an extra space was added to continue a paragraph for auto-formatting,
;; delete it now.  The space must be under the cursor, just after the insert position.

(defn- #_void check_auto_format [#_boolean end_insert]
    ;; end_insert: true when ending Insert mode
    (§
;       if (@did_add_space)
;       {
;           int cc = gchar_cursor();
;           if (!whitechar(cc))
                ;; Somehow the space was removed already.
;               @did_add_space = false;
;           else
;           {
;               int c = ' ';

;               if (!end_insert)
;               {
;                   inc_cursor();
;                   c = gchar_cursor();
;                   dec_cursor();
;               }
;               if (c != NUL)
;               {
                    ;; The space is no longer at the end of the line, delete it.
;                   del_char(false);
;                   @did_add_space = false;
;               }
;           }
;       }
    ))

;; Find out textwidth to be used for formatting:
;;      if 'textwidth' option is set, use it
;;      else if 'wrapmargin' option is set, use curwin.w_width - 'wrapmargin'
;;      if invalid value, use 0.
;;      Set default to window width (maximum 79) for "gq" operator.

(defn- #_int comp_textwidth [#_boolean ff]
    ;; ff: force formatting (for "gq" command)
    (§
;       int textwidth = (int)@curbuf.@b_p_tw;
;       if (textwidth == 0 && @curbuf.@b_p_wm != 0)
;       {
            ;; The width is the window width minus 'wrapmargin' minus
            ;; all the things that add to the margin.
;           textwidth = @curwin.w_width - (int)@curbuf.@b_p_wm;
;           if (@cmdwin_type != 0)
;               textwidth -= 1;
;           if (@curwin.w_onebuf_opt.@wo_nu || @curwin.w_onebuf_opt.@wo_rnu)
;               textwidth -= 8;
;       }
;       if (textwidth < 0)
;           textwidth = 0;
;       if (ff && textwidth == 0)
;       {
;           textwidth = @curwin.w_width - 1;
;           if (79 < textwidth)
;               textwidth = 79;
;       }
;       return textwidth;
    ))

;; Put a character in the redo buffer, for when just after a CTRL-V.

(defn- #_void redo_literal [#_int c]
    (§
;       Bytes buf = new Bytes(10);

        ;; Only digits need special treatment.  Translate them into a string of three digits.
;       if (asc_isdigit(c))
;       {
;           vim_snprintf(buf, buf.size(), u8("%03d"), c);
;           appendToRedobuff(buf);
;       }
;       else
;           appendCharToRedobuff(c);
    ))

;; start_arrow() is called when an arrow key is used in insert mode.
;; For undo/redo it resembles hitting the <ESC> key.

(defn- #_void start_arrow [#_pos_C end_insert_pos]
    ;; end_insert_pos: can be null
    (§
;       if (!@arrow_used)                ;; something has been inserted
;       {
;           appendToRedobuff(ESC_STR);
;           stop_insert(end_insert_pos, false, false);
;           @arrow_used = true;          ;; this means we stopped the current insert
;       }
    ))

;; stop_arrow() is called before a change is made in insert mode.
;; If an arrow key has been used, start a new insertion.
;; Returns false if undo is impossible, shouldn't insert then.

(defn- #_boolean stop_arrow []
    (§
;       if (@arrow_used)
;       {
;           COPY_pos(@insStart, @curwin.w_cursor);    ;; new insertion starts here
;           if (@insStart_orig.col < @insStart.col && !@ins_need_undo)
                ;; Don't update the original insert position when moved to the right,
                ;; except when nothing was inserted yet.
;               @update_insStart_orig = false;
;           @insStart_textlen = linetabsize(ml_get_curline());

;           if (u_save_cursor())
;           {
;               @arrow_used = false;
;               @ins_need_undo = false;
;           }

;           @ai_col = 0;
;           if ((@State & VREPLACE_FLAG) != 0)
;           {
;               @orig_line_count = @curbuf.b_ml.ml_line_count;
;               @vr_lines_changed = 1;
;           }
;           resetRedobuff();
;           appendToRedobuff(u8("1i"));         ;; pretend we start an insertion
;           @new_insert_skip = 2;
;       }
;       else if (@ins_need_undo)
;       {
;           if (u_save_cursor())
;               @ins_need_undo = false;
;       }

;       return (@arrow_used || !@ins_need_undo);
    ))

;; Do a few things to stop inserting.
;; "end_insert_pos" is where insert ended.
;; It is null when we already jumped to another window/buffer.

(defn- #_void stop_insert [#_pos_C end_insert_pos, #_boolean esc, #_boolean nomove]
    ;; esc: called by ins_esc()
    ;; nomove: <c-\><c-o>, don't move cursor
    (§
;       stop_redo_ins();
;       replace_flush();            ;; abandon replace stack

        ;; Save the inserted text for later redo with ^@ and CTRL-A.
        ;; Don't do it when "restart_edit" was set and nothing was inserted,
        ;; otherwise CTRL-O w and then <Left> will clear "last_insert".

;       Bytes ptr = get_inserted();
;       if (@did_restart_edit == 0 || (ptr != null && @new_insert_skip < STRLEN(ptr)))
;       {
;           @last_insert = ptr;
;           @last_insert_skip = @new_insert_skip;
;       }

;       if (!@arrow_used && end_insert_pos != null)
;       {
;           int cc;

            ;; Auto-format now.  It may seem strange to do this when stopping an
            ;; insertion (or moving the cursor), but it's required when appending
            ;; a line and having it end in a space.  But only do it when something
            ;; was actually inserted, otherwise undo won't work.
;           if (!@ins_need_undo && has_format_option(FO_AUTO))
;           {
;               pos_C tpos = §_pos_C();
;               COPY_pos(tpos, @curwin.w_cursor);

                ;; When the cursor is at the end of the line after a space
                ;; the formatting will move it to the following word.
                ;; Avoid that by moving the cursor onto the space.
;               cc = 'x';
;               if (0 < @curwin.w_cursor.col && gchar_cursor() == NUL)
;               {
;                   dec_cursor();
;                   cc = gchar_cursor();
;                   if (!vim_iswhite(cc))
;                       COPY_pos(@curwin.w_cursor, tpos);
;               }

;               auto_format(true, false);

;               if (vim_iswhite(cc))
;               {
;                   if (gchar_cursor() != NUL)
;                       inc_cursor();
                    ;; If the cursor is still at the same character, also keep the "coladd".
;                   if (gchar_cursor() == NUL
;                           && @curwin.w_cursor.lnum == tpos.lnum
;                           && @curwin.w_cursor.col == tpos.col)
;                       @curwin.w_cursor.coladd = tpos.coladd;
;               }
;           }

            ;; If a space was inserted for auto-formatting, remove it now.
;           check_auto_format(true);

            ;; If we just did an auto-indent, remove the white space from the end of the line,
            ;; and put the cursor back.  Do this when ESC was used or moving the cursor up/down.
            ;; Check for the old position still being valid, just in case the text got changed
            ;; unexpectedly.
;           if (!nomove && @did_ai
;                   && (esc || (vim_strbyte(@p_cpo, CPO_INDENT) == null
;                                   && @curwin.w_cursor.lnum != end_insert_pos.lnum))
;                   && end_insert_pos.lnum <= @curbuf.b_ml.ml_line_count)
;           {
;               pos_C tpos = §_pos_C();
;               COPY_pos(tpos, @curwin.w_cursor);

;               COPY_pos(@curwin.w_cursor, end_insert_pos);
;               check_cursor_col();                     ;; make sure it is not past the line
;               for ( ; ; )
;               {
;                   if (gchar_cursor() == NUL && 0 < @curwin.w_cursor.col)
;                       --@curwin.w_cursor.col;
;                   cc = gchar_cursor();
;                   if (!vim_iswhite(cc))
;                       break;
;                   if (del_char(true) == false)
;                       break;  ;; should not happen
;               }
;               if (@curwin.w_cursor.lnum != tpos.lnum)
;                   COPY_pos(@curwin.w_cursor, tpos);
;               else
;               {
                    ;; reset tpos, could have been invalidated in the loop above
;                   COPY_pos(tpos, @curwin.w_cursor);
;                   tpos.col++;
;                   if (cc != NUL && gchar_pos(tpos) == NUL)
;                       @curwin.w_cursor.col++;      ;; put cursor back on the NUL
;               }

                ;; <C-S-Right> may have started Visual mode, adjust the position for deleted characters.
;               if (@VIsual_active && @VIsual.lnum == @curwin.w_cursor.lnum)
;               {
;                   int len = STRLEN(ml_get_curline());

;                   if (len < @VIsual.col)
;                   {
;                       @VIsual.col = len;
;                       @VIsual.coladd = 0;
;                   }
;               }
;           }
;       }

;       @did_ai = false;
;       @did_si = false;
;       @can_si = false;
;       @can_si_back = false;

        ;; Set '[ and '] to the inserted text.
        ;; When end_insert_pos is null we are now in a different buffer.
;       if (end_insert_pos != null)
;       {
;           COPY_pos(@curbuf.b_op_start, @insStart);
;           COPY_pos(@curbuf.b_op_start_orig, @insStart_orig);
;           COPY_pos(@curbuf.b_op_end, end_insert_pos);
;       }
    ))

;; Set the last inserted text to a single character.
;; Used for the replace command.

(defn- #_void set_last_insert [#_int c]
    (§
;       @last_insert = new Bytes(MB_MAXBYTES * 3 + 5);

;       Bytes s = @last_insert;
        ;; Use the CTRL-V only when entering a special char.
;       if (c < ' ' || c == DEL)
;           (s = s.plus(1)).be(-1, Ctrl_V);
;       s = add_char2buf(c, s);
;       (s = s.plus(1)).be(-1, ESC);
;       (s = s.plus(1)).be(-1, NUL);
;       @last_insert_skip = 0;
    ))

;; Add character "c" to buffer "s".
;; Escape the special meaning of KB_SPECIAL and CSI.
;; Handle multi-byte characters.
;; Returns a pointer to after the added bytes.

(defn- #_Bytes add_char2buf [#_int c, #_Bytes s]
    (§
;       Bytes temp = new Bytes(MB_MAXBYTES + 1);
;       int len = utf_char2bytes(c, temp);
;       for (int i = 0; i < len; i++)
;       {
;           byte b = temp.at(i);
            ;; Need to escape KB_SPECIAL and CSI like in the typeahead buffer.
;           if (b == KB_SPECIAL)
;           {
;               (s = s.plus(1)).be(-1, KB_SPECIAL);
;               (s = s.plus(1)).be(-1, KS_SPECIAL);
;               (s = s.plus(1)).be(-1, KE_FILLER);
;           }
;           else
;               (s = s.plus(1)).be(-1, b);
;       }
;       return s;
    ))

;; Move cursor to start of line:
;;  if (flags & BL_WHITE) move to first non-white;
;;  if (flags & BL_SOL)   move to first non-white if startofline is set, otherwise keep "curswant" column;
;;  if (flags & BL_FIX)   don't leave the cursor on a NUL.

(defn- #_void beginline [#_int flags]
    (§
;       if ((flags & BL_SOL) != 0 && !@p_sol)
;           coladvance(@curwin.w_curswant);
;       else
;       {
;           @curwin.w_cursor.col = 0;
;           @curwin.w_cursor.coladd = 0;

;           if ((flags & (BL_WHITE | BL_SOL)) != 0)
;           {
;               for (Bytes ptr = ml_get_curline(); vim_iswhite(ptr.at(0))
;                                  && !((flags & BL_FIX) != 0 && ptr.at(1) == NUL); ptr = ptr.plus(1))
;                   @curwin.w_cursor.col++;
;           }
;           @curwin.w_set_curswant = true;
;       }
    ))

;; oneright oneleft cursor_down cursor_up
;;
;; Move one char {right,left,down,up}.
;; Doesn't move onto the NUL past the end of the line, unless it is allowed.
;; Return true when successful, false when we hit a line of file boundary.

(defn- #_boolean oneright []
    (§
;       if (virtual_active())
;       {
;           pos_C prevpos = §_pos_C();
;           COPY_pos(prevpos, @curwin.w_cursor);

            ;; Adjust for multi-wide char (excluding TAB).
;           Bytes ptr = ml_get_cursor();
;           coladvance(getviscol() + ((ptr.at(0) != TAB && vim_isprintc(us_ptr2char(ptr))) ? mb_ptr2cells(ptr) : 1));
;           @curwin.w_set_curswant = true;
            ;; Return true if the cursor moved, false otherwise (at window edge).
;           return (prevpos.col != @curwin.w_cursor.col || prevpos.coladd != @curwin.w_cursor.coladd);
;       }

;       Bytes ptr = ml_get_cursor();
;       if (ptr.at(0) == NUL)
;           return false;           ;; already at the very end

;       int l = us_ptr2len_cc(ptr);

        ;; Move "l" bytes right, but don't end up on the NUL, unless 'virtualedit' contains "onemore".
;       if (ptr.at(l) == NUL && (@ve_flags & VE_ONEMORE) == 0)
;           return false;
;       @curwin.w_cursor.col += l;

;       @curwin.w_set_curswant = true;
;       return true;
    ))

(defn- #_boolean oneleft []
    (§
;       if (virtual_active())
;       {
;           int v = getviscol();
;           if (v == 0)
;               return false;

            ;; We might get stuck on 'showbreak', skip over it.
;           for (int width = 1; ; )
;           {
;               coladvance(v - width);
                ;; getviscol() is slow, skip it when 'showbreak' is empty,
                ;; 'breakindent' is not set and there are no multi-byte characters
;               if (getviscol() < v)
;                   break;
;               width++;
;           }

;           if (@curwin.w_cursor.coladd == 1)
;           {
                ;; Adjust for multi-wide char (not a TAB).
;               Bytes ptr = ml_get_cursor();
;               if (ptr.at(0) != TAB && vim_isprintc(us_ptr2char(ptr)) && 1 < mb_ptr2cells(ptr))
;                   @curwin.w_cursor.coladd = 0;
;           }

;           @curwin.w_set_curswant = true;
;           return true;
;       }

;       if (@curwin.w_cursor.col == 0)
;           return false;

;       @curwin.w_set_curswant = true;
;       --@curwin.w_cursor.col;

        ;; If the character on the left of the current cursor is a multi-byte character,
        ;; move to its first byte.
;       mb_adjust_pos(@curbuf, @curwin.w_cursor);
;       return true;
    ))

(defn- #_boolean cursor_up [#_long n, #_boolean upd_topline]
    ;; upd_topline: When true: update topline
    (§
;       if (0 < n)
;       {
;           long lnum = @curwin.w_cursor.lnum;
            ;; This fails if the cursor is already in the first line or the count
            ;; is larger than the line number and '-' is in 'cpoptions'.
;           if (lnum <= 1 || (lnum <= n && vim_strbyte(@p_cpo, CPO_MINUS) != null))
;               return false;
;           if (lnum <= n)
;               lnum = 1;
;           else
;               lnum -= n;
;           @curwin.w_cursor.lnum = lnum;
;       }

        ;; try to advance to the column we want to be at
;       coladvance(@curwin.w_curswant);

;       if (upd_topline)
;           update_topline();       ;; make sure curwin.w_topline is valid

;       return true;
    ))

;; Cursor down a number of logical lines.

(defn- #_boolean cursor_down [#_long n, #_boolean upd_topline]
    ;; upd_topline: When true: update topline
    (§
;       if (0 < n)
;       {
;           long lnum = @curwin.w_cursor.lnum;
            ;; This fails if the cursor is already in the last line
            ;; or would move beyond the last line and '-' is in 'cpoptions'.
;           if (@curbuf.b_ml.ml_line_count <= lnum
;                   || (@curbuf.b_ml.ml_line_count < lnum + n && vim_strbyte(@p_cpo, CPO_MINUS) != null))
;               return false;
;           if (@curbuf.b_ml.ml_line_count <= lnum + n)
;               lnum = @curbuf.b_ml.ml_line_count;
;           else
;               lnum += n;
;           @curwin.w_cursor.lnum = lnum;
;       }

        ;; try to advance to the column we want to be at
;       coladvance(@curwin.w_curswant);

;       if (upd_topline)
;           update_topline();       ;; make sure curwin.w_topline is valid

;       return true;
    ))

;; Stuff the last inserted text in the read buffer.
;; Last_insert actually is a copy of the redo buffer, so we
;; first have to remove the command.

(defn- #_boolean stuff_inserted [#_int c, #_long count, #_boolean no_esc]
    ;; c: Command character to be inserted
    ;; count: Repeat this many times
    ;; no_esc: Don't add an ESC at the end
    (§
;       Bytes ptr = get_last_insert();
;       if (ptr == null)
;       {
;           emsg(e_noinstext);
;           return false;
;       }

        ;; may want to stuff the command character, to start Insert mode
;       if (c != NUL)
;           stuffcharReadbuff(c);
;       Bytes esc_ptr = vim_strrchr(ptr, ESC);
;       if (esc_ptr != null)
;           esc_ptr.be(0, NUL);     ;; remove the ESC

;       byte last = NUL;

        ;; when the last char is either "0" or "^" it will be quoted if no ESC comes
        ;; after it OR if it will inserted more than once and "ptr" starts with ^D.

;       Bytes last_ptr = (esc_ptr != null) ? esc_ptr.minus(1) : ptr.plus(STRLEN(ptr) - 1);
;       if (BLE(ptr, last_ptr) && (last_ptr.at(0) == (byte)'0' || last_ptr.at(0) == (byte)'^')
;               && (no_esc || (ptr.at(0) == Ctrl_D && 1 < count)))
;       {
;           last = last_ptr.at(0);
;           last_ptr.be(0, NUL);
;       }

;       do
;       {
;           stuffReadbuff(ptr);
            ;; a trailing "0" is inserted as "<C-V>048", "^" as "<C-V>^"
;           if (last != NUL)
;               stuffReadbuff((last == '0') ? u8("\026\060\064\070") : u8("\026^"));
;       } while (0 < --count);

;       if (last != NUL)
;           last_ptr.be(0, last);

;       if (esc_ptr != null)
;           esc_ptr.be(0, ESC);     ;; put the ESC back

        ;; may want to stuff a trailing ESC, to get out of Insert mode
;       if (!no_esc)
;           stuffcharReadbuff(ESC);

;       return true;
    ))

(defn- #_Bytes get_last_insert []
    (§
;       if (@last_insert == null)
;           return null;

;       return @last_insert.plus(@last_insert_skip);
    ))

;; Get last inserted string, and remove trailing <Esc>.
;; Returns pointer to allocated memory (must be freed) or null.

(defn- #_Bytes get_last_insert_save []
    (§
;       if (@last_insert == null)
;           return null;

;       Bytes s = STRDUP(@last_insert.plus(@last_insert_skip));
;       int len = STRLEN(s);
;       if (0 < len && s.at(len - 1) == ESC)       ;; remove trailing ESC
;           s.be(len - 1, NUL);
;       return s;
    ))

;; Check the word in front of the cursor for an abbreviation.
;; Called when the non-id character "c" has been entered.
;; When an abbreviation is recognized it is removed from the text and
;; the replacement string is inserted in typebuf.tb_buf[], followed by "c".

(defn- #_boolean echeck_abbr [#_int c]
    (§
        ;; Don't check for abbreviation in paste mode, when disabled,
        ;; or just after moving around with cursor keys.
;       if (@p_paste || @no_abbr || @arrow_used)
;           return false;

;       return check_abbr(c, ml_get_curline(), @curwin.w_cursor.col,
;                   (@curwin.w_cursor.lnum == @insStart.lnum) ? @insStart.col : 0);
    ))

;; replace-stack functions
;;
;; When replacing characters, the replaced characters are remembered for each
;; new character.  This is used to re-insert the old text when backspacing.
;;
;; There is a NUL headed list of characters for each character that is
;; currently in the file after the insertion point.  When BS is used, one NUL
;; headed list is put back for the deleted character.
;;
;; For a newline, there are two NUL headed lists.  One contains the characters
;; that the NL replaced.  The extra one stores the characters after the cursor
;; that were deleted (always white space).
;;
;; Replace_offset is normally 0, in which case replace_push will add a new
;; character at the end of the stack.  If replace_offset is not 0, that many
;; characters will be left on the stack above the newly inserted character.

(atom! Bytes    replace_stack)
(atom! int      replace_stack_nr)       ;; next entry in replace stack
(atom! int      replace_stack_len)      ;; max. number of entries

(defn- #_void replace_push [#_int c]
    ;; c: character that is replaced (NUL is none)
    (§
;       if (@replace_stack_nr < @replace_offset)      ;; nothing to do
;           return;

;       if (@replace_stack_len <= @replace_stack_nr)
;       {
;           @replace_stack_len += 50;
;           Bytes p = new Bytes(@replace_stack_len);
;           if (@replace_stack != null)
;               BCOPY(p, @replace_stack, @replace_stack_nr);
;           @replace_stack = p;
;       }

;       Bytes p = @replace_stack.plus(@replace_stack_nr - @replace_offset);
;       if (@replace_offset != 0)
;           BCOPY(p, 1, p, 0, @replace_offset);
;       p.be(0, c);
;       @replace_stack_nr++;
    ))

;; Push a character onto the replace stack.
;; Handles a multi-byte character in reverse byte order, so that the first byte is popped off first.
;; Return the number of bytes done (includes composing characters).

(defn- #_int replace_push_mb [#_Bytes p]
    (§
;       int l = us_ptr2len_cc(p);

;       for (int j = l - 1; 0 <= j; --j)
;           replace_push(p.at(j));

;       return l;
    ))

;; Pop one item from the replace stack.
;; return -1 if stack empty
;; return replaced character or NUL otherwise

(defn- #_int replace_pop []
    (§
;       if (@replace_stack_nr == 0)
;           return -1;

;       return @replace_stack.at(--@replace_stack_nr);
    ))

;; Join the top two items on the replace stack.  This removes to "off"'th NUL encountered.

(defn- #_void replace_join [#_int off]
    ;; off: offset for which NUL to remove
    (§
;       for (int i = @replace_stack_nr; 0 <= --i; )
;           if (@replace_stack.at(i) == NUL && off-- <= 0)
;           {
;               --@replace_stack_nr;
;               BCOPY(@replace_stack, i, @replace_stack, i + 1, @replace_stack_nr - i);
;               return;
;           }
    ))

;; Pop bytes from the replace stack until a NUL is found, and insert them
;; before the cursor.  Can only be used in REPLACE or VREPLACE mode.

(defn- #_void replace_pop_ins []
    (§
;       int oldState = @State;
;       @State = NORMAL;                     ;; don't want REPLACE here

;       for (int cc; 0 < (cc = replace_pop()); )
;       {
;           mb_replace_pop_ins(cc);
;           dec_cursor();
;       }

;       @State = oldState;
    ))

;; Insert bytes popped from the replace stack. "cc" is the first byte.
;; If it indicates a multi-byte char, pop the other bytes too.

(defn- #_void mb_replace_pop_ins [#_int cc]
    (§
;       Bytes buf = new Bytes(MB_MAXBYTES + 1);

;       int n = mb_byte2len(cc);
;       if (1 < n)
;       {
;           buf.be(0, cc);
;           for (int i = 1; i < n; i++)
;               buf.be(i, replace_pop());
;           ins_bytes_len(buf, n);
;       }
;       else
;           ins_char(cc);

        ;; Handle composing chars.
;       for ( ; ; )
;       {
;           int c = replace_pop();
;           if (c == -1)            ;; stack empty
;               break;
;           if ((n = mb_byte2len(c)) == 1)
;           {
                ;; Not a multi-byte char, put it back.
;               replace_push(c);
;               break;
;           }
;           else
;           {
;               buf.be(0, c);
;               for (int i = 1; i < n; i++)
;                   buf.be(i, replace_pop());
;               if (utf_iscomposing(us_ptr2char(buf)))
;                   ins_bytes_len(buf, n);
;               else
;               {
                    ;; Not a composing char, put it back.
;                   for (int i = n - 1; 0 <= i; --i)
;                       replace_push(buf.at(i));
;                   break;
;               }
;           }
;       }
    ))

;; make the replace stack empty
;; (called when exiting replace mode)

(defn- #_void replace_flush []
    (§
;       @replace_stack = null;
;       @replace_stack_len = 0;
;       @replace_stack_nr = 0;
    ))

;; Handle doing a BS for one character.
;; cc < 0: replace stack empty, just move cursor
;; cc == 0: character was inserted, delete it
;; cc > 0: character was replaced, put cc (first byte of original char) back
;; and check for more characters to be put back
;; When "limit_col" is >= 0, don't delete before this column.  Matters when
;; using composing characters, use del_char_after_col() instead of del_char().

(defn- #_void replace_do_bs [#_int limit_col]
    (§
;       int orig_len = 0;
;       int orig_vcols = 0;

;       int cc = replace_pop();
;       if (0 < cc)
;       {
;           int[] start_vcol = new int[1];
;           if ((@State & VREPLACE_FLAG) != 0)
;           {
                ;; Get the number of screen cells used by the character we are going to delete.
;               getvcol(@curwin, @curwin.w_cursor, null, start_vcol, null);
;               orig_vcols = chartabsize(ml_get_cursor(), start_vcol[0]);
;           }

;           del_char_after_col(limit_col);
;           if ((@State & VREPLACE_FLAG) != 0)
;               orig_len = STRLEN(ml_get_cursor());
;           replace_push(cc);

;           replace_pop_ins();

;           if ((@State & VREPLACE_FLAG) != 0)
;           {
                ;; Get the number of screen cells used by the inserted characters.
;               Bytes p = ml_get_cursor();
;               int ins_len = STRLEN(p) - orig_len;
;               int vcol = start_vcol[0];
;               for (int i = 0; i < ins_len; i++)
;               {
;                   vcol += chartabsize(p.plus(i), vcol);
;                   i += us_ptr2len_cc(p) - 1;
;               }
;               vcol -= start_vcol[0];

                ;; Delete spaces that were inserted after the cursor to keep the text aligned.
;               @curwin.w_cursor.col += ins_len;
;               while (orig_vcols < vcol && gchar_cursor() == ' ')
;               {
;                   del_char(false);
;                   orig_vcols++;
;               }
;               @curwin.w_cursor.col -= ins_len;
;           }

            ;; mark the buffer as changed and prepare for displaying
;           changed_bytes(@curwin.w_cursor.lnum, @curwin.w_cursor.col);
;       }
;       else if (cc == 0)
;           del_char_after_col(limit_col);
    ))

;; Return true if C-indenting is on.

(defn- #_boolean cindent_on []
    (§
;       return (!@p_paste && @curbuf.@b_p_cin);
    ))

;; Re-indent the current line, based on the current contents of it and the
;; surrounding lines.  Fixing the cursor position seems really easy -- I'm very
;; confused what all the part that handles Control-T is doing that I'm not.
;; "getindent" should be "get_c_indent" or "get_lisp_indent".

(defn- #_void fixthisline [#_getindent_F getindent]
    (§
;       change_indent(INDENT_SET, getindent(), false, NUL, true);
;       if (linewhite(@curwin.w_cursor.lnum))
;           @did_ai = true;      ;; delete the indent if the line stays empty
    ))

(defn- #_void fix_indent []
    (§
;       if (@p_paste)
;           return;

;       if (@curbuf.@b_p_lisp && @curbuf.@b_p_ai)
;           fixthisline(get_lisp_indent);
;       else if (cindent_on())
;           do_c_expr_indent();
    ))

;; return true if 'cinkeys' contains the key "keytyped",
;; when == '*':     Only if key is preceded with '*'    (indent before insert)
;; when == '!':     Only if key is preceded with '!'    (don't insert)
;; when == ' ':     Only if key is not preceded with '*'(indent afterwards)
;;
;; "keytyped" can have a few special values:
;; KEY_OPEN_FORW
;; KEY_OPEN_BACK
;; KEY_COMPLETE     just finished completion.
;;
;; If line_is_empty is true accept keys with '0' before them.

(defn- #_boolean in_cinkeys [#_int keytyped, #_int when, #_boolean line_is_empty]
    (§
;       if (keytyped == NUL)
            ;; Can happen with CTRL-Y and CTRL-E on a short line.
;           return false;

;       Bytes look = @curbuf.@b_p_cink;     ;; 'indentexpr' empty: use 'cinkeys'

;       while (look.at(0) != NUL)
;       {
;           boolean try_match;

            ;; Find out if we want to try a match with this key,
            ;; depending on 'when' and a '*' or '!' before the key.

;           switch (when)
;           {
;               case '*': try_match = (look.at(0) == (byte)'*'); break;
;               case '!': try_match = (look.at(0) == (byte)'!'); break;
;                default: try_match = (look.at(0) != (byte)'*'); break;
;           }
;           if (look.at(0) == (byte)'*' || look.at(0) == (byte)'!')
;               look = look.plus(1);

            ;; If there is a '0', only accept a match if the line is empty.
            ;; But may still match when typing last char of a word.

;           boolean try_match_word;
;           if (look.at(0) == (byte)'0')
;           {
;               try_match_word = try_match;
;               if (!line_is_empty)
;                   try_match = false;
;               look = look.plus(1);
;           }
;           else
;               try_match_word = false;

            ;; does it look like a control character?

;           if (look.at(0) == (byte)'^' && '?' <= look.at(1) && look.at(1) <= '_')
;           {
;               if (try_match && keytyped == ctrl_key(look.at(1)))
;                   return true;
;               look = look.plus(2);
;           }

            ;; 'o' means "o" command, open forward.
            ;; 'O' means "O" command, open backward.

;           else if (look.at(0) == (byte)'o')
;           {
;               if (try_match && keytyped == KEY_OPEN_FORW)
;                   return true;
;               look = look.plus(1);
;           }
;           else if (look.at(0) == (byte)'O')
;           {
;               if (try_match && keytyped == KEY_OPEN_BACK)
;                   return true;
;               look = look.plus(1);
;           }

            ;; 'e' means to check for "else" at start of line and just before the cursor.

;           else if (look.at(0) == (byte)'e')
;           {
;               if (try_match && keytyped == 'e' && 4 <= @curwin.w_cursor.col)
;               {
;                   Bytes p = ml_get_curline();
;                   if (BEQ(skipwhite(p), p.plus(@curwin.w_cursor.col - 4))
;                            && STRNCMP(p.plus(@curwin.w_cursor.col - 4), u8("else"), 4) == 0)
;                       return true;
;               }
;               look = look.plus(1);
;           }

            ;; ':' only causes an indent if it is at the end of a label or case statement,
            ;; or when it was before typing the ':' (to fix class::method for C++).

;           else if (look.at(0) == (byte)':')
;           {
;               if (try_match && keytyped == ':')
;               {
;                   Bytes p = ml_get_curline();
;                   if (cin_iscase(p, false) || cin_isscopedecl(p) || cin_islabel())
;                       return true;
                    ;; Need to get the line again after cin_islabel().
;                   p = ml_get_curline();
;                   if (2 < @curwin.w_cursor.col
;                           && p.at(@curwin.w_cursor.col - 1) == (byte)':'
;                           && p.at(@curwin.w_cursor.col - 2) == (byte)':')
;                   {
;                       p.be(@curwin.w_cursor.col - 1, (byte)' ');
;                       boolean i = (cin_iscase(p, false) || cin_isscopedecl(p) || cin_islabel());
;                       p = ml_get_curline();
;                       p.be(@curwin.w_cursor.col - 1, (byte)':');
;                       if (i)
;                           return true;
;                   }
;               }
;               look = look.plus(1);
;           }

            ;; Is it a key in <>, maybe?

;           else if (look.at(0) == (byte)'<')
;           {
;               if (try_match)
;               {
                    ;; Make up some named keys <o>, <O>, <e>, <0>, <>>, <<>, <*>, <:> and <!>
                    ;; so that people can re-indent on o, O, e, 0, <, >, *, : and ! keys
                    ;; if they really really want to.

;                   if (vim_strbyte(u8("<>!*oOe0:"), look.at(1)) != null && keytyped == look.at(1))
;                       return true;

;                   if (keytyped == get_special_key_code(look.plus(1)))
;                       return true;
;               }
;               while (look.at(0) != NUL && look.at(0) != (byte)'>')
;                   look = look.plus(1);
;               while (look.at(0) == (byte)'>')
;                   look = look.plus(1);
;           }

            ;; Is it a word: "=word"?

;           else if (look.at(0) == (byte)'=' && look.at(1) != (byte)',' && look.at(1) != NUL)
;           {
;               boolean icase = false;
;               look = look.plus(1);
;               if (look.at(0) == (byte)'~')
;               {
;                   icase = true;
;                   look = look.plus(1);
;               }
;               Bytes p = vim_strchr(look, ',');
;               if (p == null)
;                   p = look.plus(STRLEN(look));
;               int diff = BDIFF(p, look);
;               if ((try_match || try_match_word) && diff <= @curwin.w_cursor.col)
;               {
;                   boolean match = false;

                    ;; TODO: multi-byte
;                   if (keytyped == (int)p.at(-1)
;                       || (icase && keytyped < 256 && asc_tolower(keytyped) == asc_tolower((int)p.at(-1))))
;                   {
;                       Bytes line = ml_get_cursor();
;                       if ((@curwin.w_cursor.col == diff
;                                   || !us_iswordb(line.at(-diff - 1), @curbuf))
;                               && (icase
;                                   ? us_strnicmp(line.minus(diff), look, diff)
;                                   : STRNCMP(line.minus(diff), look, diff)) == 0)
;                           match = true;
;                   }
;                   if (match && try_match_word && !try_match)
;                   {
                        ;; "0=word": Check if there are only blanks before the word.
;                       Bytes line = ml_get_curline();
;                       if (BDIFF(skipwhite(line), line) != @curwin.w_cursor.col - diff)
;                           match = false;
;                   }
;                   if (match)
;                       return true;
;               }
;               look = p;
;           }

            ;; ok, it's a boring generic character.

;           else
;           {
;               if (try_match && look.at(0) == keytyped)
;                   return true;
;               look = look.plus(1);
;           }

            ;; Skip over ", ".

;           look = skip_to_option_part(look);
;       }

;       return false;
    ))

(defn- #_void ins_reg []
    (§
;       boolean need_redraw = false;
;       int literally = 0;
;       boolean vis_active = @VIsual_active;

        ;; If we are going to wait for a character, show a '"'.

;       @pc_status = PC_STATUS_UNSET;
;       if (redrawing() && !char_avail())
;       {
            ;; may need to redraw when no more chars available now
;           ins_redraw(false);

;           edit_putchar('"', true);
;           add_to_showcmd_c(Ctrl_R);
;       }

        ;; Don't map the register name.
        ;; This also prevents the mode message to be deleted when ESC is hit.

;       @no_mapping++;
;       int regname = plain_vgetc();
;       if (regname == Ctrl_R || regname == Ctrl_O || regname == Ctrl_P)
;       {
            ;; Get a third key for literal register insertion.
;           literally = regname;
;           add_to_showcmd_c(literally);
;           regname = plain_vgetc();
;       }
;       --@no_mapping;

        ;; Don't call u_sync() while typing the expression or giving an error message for it.
        ;; Only call it explicitly.
;       @no_u_sync++;
;       if (regname == '=')
;       {
            ;; Sync undo when evaluating the expression calls setline() or append(),
            ;; so that it can be undone separately.
;           @u_sync_once = 2;

;           regname = get_expr_register();
;       }
;       if (regname == NUL || !valid_yank_reg(regname, false))
;       {
;           vim_beep();
;           need_redraw = true;     ;; remove the '"'
;       }
;       else
;       {
;           if (literally == Ctrl_O || literally == Ctrl_P)
;           {
                ;; Append the command to the redo buffer.
;               appendCharToRedobuff(Ctrl_R);
;               appendCharToRedobuff(literally);
;               appendCharToRedobuff(regname);

;               do_put(regname, BACKWARD, 1, (literally == Ctrl_P ? PUT_FIXINDENT : 0) | PUT_CURSEND);
;           }
;           else if (insert_reg(regname, literally != 0) == false)
;           {
;               vim_beep();
;               need_redraw = true; ;; remove the '"'
;           }
;           else if (@stop_insert_mode)
                ;; When the '=' register was used and a function was invoked that
                ;; did ":stopinsert" then stuff_empty() returns false but we won't
                ;; insert anything, need to remove the '"'
;               need_redraw = true;
;       }
;       --@no_u_sync;
;       if (@u_sync_once == 1)
;           @ins_need_undo = true;
;       @u_sync_once = 0;
;       clear_showcmd();

        ;; If the inserted register is empty, we need to remove the '"'.
;       if (need_redraw || stuff_empty())
;           edit_unputchar();

        ;; Disallow starting Visual mode here, would get a weird mode.
;       if (!vis_active && @VIsual_active)
;           end_visual_mode();
    ))

;; CTRL-G commands in Insert mode.

(defn- #_void ins_ctrl_g []
    (§
        ;; Don't map the second key.  This also prevents the mode message to be deleted when ESC is hit.

;       @no_mapping++;
;       int c = plain_vgetc();
;       --@no_mapping;
;       switch (c)
;       {
            ;; CTRL-G k and CTRL-G <Up>: cursor up to insStart.col.
;           case K_UP:
;           case Ctrl_K:
;           case 'k': ins_up(true);
;                     break;

            ;; CTRL-G j and CTRL-G <Down>: cursor down to insStart.col.
;           case K_DOWN:
;           case Ctrl_J:
;           case 'j': ins_down(true);
;                     break;

            ;; CTRL-G u: start new undoable edit.
;           case 'u': u_sync(true);
;                     @ins_need_undo = true;

                      ;; Need to reset insStart, esp. because a BS that joins
                      ;; a line to the previous one must save for undo.
;                     @update_insStart_orig = false;
;                     COPY_pos(@insStart, @curwin.w_cursor);
;                     break;

            ;; Unknown CTRL-G command, reserved for future expansion.
;           default:  vim_beep();
;       }
    ))

;; CTRL-^ in Insert mode.

(defn- #_void ins_ctrl_hat []
    (§
        
;       showmode();
    ))

(atom! boolean disabled_redraw)

;; Handle ESC in insert mode.
;; Returns true when leaving insert mode, false when going to repeat the insert.

(defn- #_boolean ins_esc [#_long* count, #_int cmdchar, #_boolean nomove]
    ;; nomove: don't move cursor
    (§
;       int temp = @curwin.w_cursor.col;

;       if (@disabled_redraw)
;       {
;           --@redrawingDisabled;
;           @disabled_redraw = false;
;       }
;       if (!@arrow_used)
;       {
            ;; Don't append the ESC for "r<CR>" and "grx".
            ;; When 'insertmode' is set only CTRL-L stops Insert mode.
            ;; Needed for when "count" is non-zero.

;           if (cmdchar != 'r' && cmdchar != 'v')
;               appendToRedobuff(@p_im ? u8("\014") : ESC_STR);

            ;; Repeating insert may take a long time.  Check for interrupt now and then.

;           if (0 < count[0])
;           {
;               line_breakcheck();
;               if (@got_int)
;                   count[0] = 0;
;           }

;           if (0 < --count[0])       ;; repeat what was typed
;           {
                ;; Vi repeats the insert without replacing characters.
;               if (vim_strbyte(@p_cpo, CPO_REPLCNT) != null)
;                   @State &= ~REPLACE_FLAG;

;               start_redo_ins();
;               if (cmdchar == 'r' || cmdchar == 'v')
;                   stuffRedoReadbuff(ESC_STR);     ;; no ESC in redo buffer
;               @redrawingDisabled++;
;               @disabled_redraw = true;
;               return false;       ;; repeat the insert
;           }
;           stop_insert(@curwin.w_cursor, true, nomove);
;           undisplay_dollar();
;       }

        ;; When an autoindent was removed, curswant stays after the indent.
;       if (@restart_edit == NUL && temp == @curwin.w_cursor.col)
;           @curwin.w_set_curswant = true;

        ;; Remember the last Insert position in the '^ mark.
;       if (!@cmdmod.keepjumps)
;           COPY_pos(@curbuf.b_last_insert, @curwin.w_cursor);

        ;; The cursor should end up on the last inserted character.
        ;; Don't do it for CTRL-O, unless past the end of the line.

;       if (!nomove
;               && (@curwin.w_cursor.col != 0 || 0 < @curwin.w_cursor.coladd)
;               && (@restart_edit == NUL || (gchar_cursor() == NUL && !@VIsual_active))
;               && !@revins_on)
;       {
;           if (0 < @curwin.w_cursor.coladd || @ve_flags == VE_ALL)
;           {
;               oneleft();
;               if (@restart_edit != NUL)
;                   @curwin.w_cursor.coladd++;
;           }
;           else
;           {
;               --@curwin.w_cursor.col;
                ;; Correct cursor for multi-byte character.
;               mb_adjust_pos(@curbuf, @curwin.w_cursor);
;           }
;       }

;       @State = NORMAL;
        ;; need to position cursor again (e.g. when on a TAB )
;       changed_cline_bef_curs();

;       setmouse();
;       ui_cursor_shape();          ;; may show different cursor shape

        ;; When recording or for CTRL-O, need to display the new mode.
        ;; Otherwise remove the mode message.

;       if (@Recording || @restart_edit != NUL)
;           showmode();
;       else if (@p_smd)
;           msg(u8(""));

;       return true;            ;; exit Insert mode
    ))

;; Toggle language: revins_on.
;; Move to end of reverse inserted text.

(defn- #_void ins_ctrl_ []
    (§
;       if (@revins_on && @revins_chars != 0 && 0 <= @revins_scol)
;       {
;           while (gchar_cursor() != NUL && 0 < @revins_chars--)
;               @curwin.w_cursor.col++;
;       }
;       @p_ri = !@p_ri;
;       @revins_on = (@State == INSERT && @p_ri);
;       if (@revins_on)
;       {
;           @revins_scol = @curwin.w_cursor.col;
;           @revins_legal++;
;           @revins_chars = 0;
;           undisplay_dollar();
;       }
;       else
;           @revins_scol = -1;
;       showmode();
    ))

;; If 'keymodel' contains "startsel", may start selection.
;; Returns true when a CTRL-O and other keys stuffed.

(defn- #_boolean ins_start_select [#_int c]
    (§
;       if (@km_startsel)
;           switch (c)
;           {
;               case K_KHOME:
;               case K_KEND:
;               case K_PAGEUP:
;               case K_KPAGEUP:
;               case K_PAGEDOWN:
;               case K_KPAGEDOWN:
;                   if ((@mod_mask & MOD_MASK_SHIFT) == 0)
;                       break;
                    ;; FALLTHROUGH
;               case K_S_LEFT:
;               case K_S_RIGHT:
;               case K_S_UP:
;               case K_S_DOWN:
;               case K_S_END:
;               case K_S_HOME:
                    ;; Start selection right away, the cursor can move with
                    ;; CTRL-O when beyond the end of the line.
;                   start_selection();

                    ;; Execute the key in (insert) Select mode.
;                   stuffcharReadbuff(Ctrl_O);
;                   if (@mod_mask != 0)
;                   {
;                       Bytes buf = new Bytes(4);

;                       buf.be(0, KB_SPECIAL);
;                       buf.be(1, KS_MODIFIER);
;                       buf.be(2, @mod_mask);
;                       buf.be(3, NUL);
;                       stuffReadbuff(buf);
;                   }
;                   stuffcharReadbuff(c);
;                   return true;
;           }

;       return false;
    ))

;; <Insert> key in Insert mode: toggle insert/replace mode.

(defn- #_void ins_insert [#_int replaceState]
    (§
;       if ((@State & REPLACE_FLAG) != 0)
;           @State = INSERT;
;       else
;           @State = replaceState;
;       appendCharToRedobuff(K_INS);
;       showmode();
;       ui_cursor_shape();          ;; may show different cursor shape
    ))

;; Pressed CTRL-O in Insert mode.

(defn- #_void ins_ctrl_o []
    (§
;       if ((@State & VREPLACE_FLAG) != 0)
;           @restart_edit = 'V';
;       else if ((@State & REPLACE_FLAG) != 0)
;           @restart_edit = 'R';
;       else
;           @restart_edit = 'I';

;       if (virtual_active())
;           @ins_at_eol = false;     ;; cursor always keeps its column
;       else
;           @ins_at_eol = (gchar_cursor() == NUL);
    ))

;; If the cursor is on an indent, ^T/^D insert/delete one shiftwidth.
;; Otherwise ^T/^D behave like a "<<" or ">>".
;; Always round the indent to 'shiftwidth', this is compatible with vi.
;; But vi only supports ^T and ^D after an autoindent, we support it everywhere.

(defn- #_void ins_shift [#_int c, #_int lastc]
    (§
;       if (!stop_arrow())
;           return;

;       appendCharToRedobuff(c);

        ;; 0^D and ^^D: remove all indent.

;       if (c == Ctrl_D && (lastc == '0' || lastc == '^') && 0 < @curwin.w_cursor.col)
;       {
;           --@curwin.w_cursor.col;
;           del_char(false);                ;; delete the '^' or '0'
            ;; In Replace mode, restore the characters that '^' or '0' replaced.
;           if ((@State & REPLACE_FLAG) != 0)
;               replace_pop_ins();
;           if (lastc == '^')
;               @old_indent = get_indent();  ;; remember curr. indent
;           change_indent(INDENT_SET, 0, true, NUL, true);
;       }
;       else
;           change_indent((c == Ctrl_D) ? INDENT_DEC : INDENT_INC, 0, true, NUL, true);

;       if (@did_ai && skipwhite(ml_get_curline()).at(0) != NUL)
;           @did_ai = false;
;       @did_si = false;
;       @can_si = false;
;       @can_si_back = false;
;       @can_cindent = false;        ;; no cindenting after ^D or ^T
    ))

(defn- #_void ins_del []
    (§
;       if (!stop_arrow())
;           return;

;       if (gchar_cursor() == NUL)              ;; delete newline
;       {
;           int temp = @curwin.w_cursor.col;
;           if (!can_bs(BS_EOL)                 ;; only if "eol" included
;                   || do_join(2, false, true, false, false) == false)
;               vim_beep();
;           else
;               @curwin.w_cursor.col = temp;
;       }
;       else if (del_char(false) == false)      ;; delete char under cursor
;           vim_beep();

;       @did_ai = false;
;       @did_si = false;
;       @can_si = false;
;       @can_si_back = false;

;       appendCharToRedobuff(K_DEL);
    ))

;; Delete one character for ins_bs().

(defn- #_void ins_bs_one [#_int* vcolp]
    (§
;       dec_cursor();
;       getvcol(@curwin, @curwin.w_cursor, vcolp, null, null);
;       if ((@State & REPLACE_FLAG) != 0)
;       {
            ;; Don't delete characters before the insert point when in Replace mode.
;           if (@curwin.w_cursor.lnum != @insStart.lnum || @insStart.col <= @curwin.w_cursor.col)
;               replace_do_bs(-1);
;       }
;       else
;           del_char(false);
    ))

;; Handle Backspace, delete-word and delete-line in Insert mode.
;; Return true when backspace was actually used.

(defn- #_boolean ins_bs [#_int c, #_int mode, #_boolean* inserted_space_p]
    (§
;       boolean did_backspace = false;

        ;; can't delete anything in an empty file
        ;; can't backup past first character in buffer
        ;; can't backup past starting point unless 'backspace' > 1
        ;; can backup to a previous line if 'backspace' == 0

;       if (bufempty()
;           || (!@revins_on
;               && ((@curwin.w_cursor.lnum == 1 && @curwin.w_cursor.col == 0)
;                   || (!can_bs(BS_START)
;                       && (@arrow_used
;                           || (@curwin.w_cursor.lnum == @insStart_orig.lnum
;                               && @curwin.w_cursor.col <= @insStart_orig.col)))
;                   || (!can_bs(BS_INDENT) && !@arrow_used && 0 < @ai_col && @curwin.w_cursor.col <= @ai_col)
;                   || (!can_bs(BS_EOL) && @curwin.w_cursor.col == 0))))
;       {
;           vim_beep();
;           return false;
;       }

;       if (!stop_arrow())
;           return false;

;       boolean in_indent = inindent(0);
;       if (in_indent)
;           @can_cindent = false;
;       @end_comment_pending = NUL;  ;; After BS, don't auto-end comment
;       if (@revins_on)              ;; put cursor after last inserted char
;           inc_cursor();

        ;; Virtualedit:
        ;;  BACKSPACE_CHAR eats a virtual space
        ;;  BACKSPACE_WORD eats all coladd
        ;;  BACKSPACE_LINE eats all coladd and keeps going

;       if (0 < @curwin.w_cursor.coladd)
;       {
;           if (mode == BACKSPACE_CHAR)
;           {
;               --@curwin.w_cursor.coladd;
;               return true;
;           }
;           if (mode == BACKSPACE_WORD)
;           {
;               @curwin.w_cursor.coladd = 0;
;               return true;
;           }
;           @curwin.w_cursor.coladd = 0;
;       }

        ;; delete newline!

;       if (@curwin.w_cursor.col == 0)
;       {
;           long lnum = @insStart.lnum;
;           if (@curwin.w_cursor.lnum == lnum || @revins_on)
;           {
;               if (!u_save(@curwin.w_cursor.lnum - 2, @curwin.w_cursor.lnum + 1))
;                   return false;
;               --@insStart.lnum;
;               @insStart.col = MAXCOL;
;           }

            ;; In replace mode:
            ;; cc < 0: NL was inserted, delete it
            ;; cc >= 0: NL was replaced, put original characters back

;           int cc = -1;
;           if ((@State & REPLACE_FLAG) != 0)
;               cc = replace_pop();     ;; returns -1 if NL was inserted

            ;; In replace mode, in the line we started replacing, we only move the cursor.

;           if ((@State & REPLACE_FLAG) != 0 && @curwin.w_cursor.lnum <= lnum)
;           {
;               dec_cursor();
;           }
;           else
;           {
;               if ((@State & VREPLACE_FLAG) == 0 || @orig_line_count < @curwin.w_cursor.lnum)
;               {
;                   int temp = gchar_cursor();      ;; remember current char
;                   --@curwin.w_cursor.lnum;

                    ;; When "aw" is in 'formatoptions' we must delete the space at the end of
                    ;; the line, otherwise the line will be broken again when auto-formatting.

;                   if (has_format_option(FO_AUTO) && has_format_option(FO_WHITE_PAR))
;                   {
;                       Bytes ptr = ml_get_buf(@curbuf, @curwin.w_cursor.lnum, true);

;                       int len = STRLEN(ptr);
;                       if (0 < len && ptr.at(len - 1) == (byte)' ')
;                           ptr.be(len - 1, NUL);
;                   }

;                   do_join(2, false, false, false, false);
;                   if (temp == NUL && gchar_cursor() != NUL)
;                       inc_cursor();
;               }
;               else
;                   dec_cursor();

                ;; In REPLACE mode we have to put back the text that was replaced by the NL.
                ;; On the replace stack is first a NUL-terminated sequence of characters
                ;; that were deleted and then the characters that NL replaced.

;               if ((@State & REPLACE_FLAG) != 0)
;               {
                    ;; Do the next ins_char() in NORMAL state, to prevent ins_char()
                    ;; from replacing characters and avoiding showmatch().

;                   int oldState = @State;
;                   @State = NORMAL;

                    ;; restore characters (blanks) deleted after cursor

;                   while (0 < cc)
;                   {
;                       int save_col = @curwin.w_cursor.col;
;                       mb_replace_pop_ins(cc);
;                       @curwin.w_cursor.col = save_col;
;                       cc = replace_pop();
;                   }
                    ;; restore the characters that NL replaced
;                   replace_pop_ins();
;                   @State = oldState;
;               }
;           }
;           @did_ai = false;
;       }
;       else
;       {
            ;; Delete character(s) before the cursor.

;           if (@revins_on)          ;; put cursor on last inserted char
;               dec_cursor();
;           int mincol = 0;
                                                    ;; keep indent
;           if (mode == BACKSPACE_LINE && (@curbuf.@b_p_ai || cindent_on()) && !@revins_on)
;           {
;               int save_col = @curwin.w_cursor.col;
;               beginline(BL_WHITE);
;               if (@curwin.w_cursor.col < save_col)
;                   mincol = @curwin.w_cursor.col;
;               @curwin.w_cursor.col = save_col;
;           }

            ;; Handle deleting one 'shiftwidth' or 'softtabstop'.

;           if (mode == BACKSPACE_CHAR
;                   && ((@p_sta && in_indent)
;                       || (get_sts_value() != 0
;                           && 0 < @curwin.w_cursor.col
;                           && (ml_get_cursor().at(-1) == TAB
;                               || (ml_get_cursor().at(-1) == (byte)' '
;                                   && (!inserted_space_p[0]
;                                       || @arrow_used))))))
;           {
;               inserted_space_p[0] = false;

;               int ts;
;               if (@p_sta && in_indent)
;                   ts = (int)get_sw_value(@curbuf);
;               else
;                   ts = (int)get_sts_value();

                ;; Compute the virtual column where we want to be.  Since 'showbreak' may
                ;; get in the way, need to get the last column of the previous character.
;               int[] vcol = new int[1];
;               getvcol(@curwin, @curwin.w_cursor, vcol, null, null);
;               int start_vcol = vcol[0];
;               dec_cursor();
;               int[] want_vcol = new int[1];
;               getvcol(@curwin, @curwin.w_cursor, null, null, want_vcol);
;               inc_cursor();
;               want_vcol[0] = (want_vcol[0] / ts) * ts;

                ;; delete characters until we are at or before "want_vcol"
;               while (want_vcol[0] < vcol[0] && vim_iswhite(ml_get_cursor().at(-1)))
;                   ins_bs_one(vcol);

                ;; insert extra spaces until we are at "want_vcol"
;               while (vcol[0] < want_vcol[0])
;               {
                    ;; Remember the first char we inserted.
;                   if (@curwin.w_cursor.lnum == @insStart_orig.lnum && @curwin.w_cursor.col < @insStart_orig.col)
;                       @insStart_orig.col = @curwin.w_cursor.col;

;                   if ((@State & VREPLACE_FLAG) != 0)
;                       ins_char(' ');
;                   else
;                   {
;                       ins_str(u8(" "));
;                       if ((@State & REPLACE_FLAG) != 0)
;                           replace_push(NUL);
;                   }
;                   getvcol(@curwin, @curwin.w_cursor, vcol, null, null);
;               }

                ;; If we are now back where we started delete one character.
                ;; Can happen when using 'sts' and 'linebreak'.
;               if (start_vcol <= vcol[0])
;                   ins_bs_one(vcol);
;           }

            ;; Delete upto starting point, start of line or previous word.

;           else
;           {
;               int prev_cclass = 0;
;               int cclass = us_get_class(ml_get_cursor(), @curbuf);

;               boolean temp = false;
;               do
;               {
;                   if (!@revins_on) ;; put cursor on char to be deleted
;                       dec_cursor();

;                   int cc = gchar_cursor();
                    ;; look multi-byte character class
;                   prev_cclass = cclass;
;                   cclass = us_get_class(ml_get_cursor(), @curbuf);

                    ;; start of word?
;                   if (mode == BACKSPACE_WORD && !vim_isspace(cc))
;                   {
;                       mode = BACKSPACE_WORD_NOT_SPACE;
;                       temp = vim_iswordc(cc, @curbuf);
;                   }
                    ;; end of word?
;                   else if (mode == BACKSPACE_WORD_NOT_SPACE
;                           && ((vim_isspace(cc) || vim_iswordc(cc, @curbuf) != temp) || prev_cclass != cclass))
;                   {
;                       if (!@revins_on)
;                           inc_cursor();
;                       else if ((@State & REPLACE_FLAG) != 0)
;                           dec_cursor();
;                       break;
;                   }
;                   if ((@State & REPLACE_FLAG) != 0)
;                       replace_do_bs(-1);
;                   else
;                   {
;                       int[] cpc = new int[MAX_MCO];   ;; composing characters
;                       if (@p_deco)
;                           us_ptr2char_cc(ml_get_cursor(), cpc);
;                       del_char(false);

                        ;; If there are combining characters and 'delcombine' is set
                        ;; move the cursor back.  Don't back up before the base character.

;                       if (@p_deco && cpc[0] != NUL)
;                           inc_cursor();
;                       if (0 < @revins_chars)
;                       {
;                           @revins_chars--;
;                           @revins_legal++;
;                       }
;                       if (@revins_on && gchar_cursor() == NUL)
;                           break;
;                   }
                    ;; Just a single backspace?:
;                   if (mode == BACKSPACE_CHAR)
;                       break;
;               } while (@revins_on ||
;                       (mincol < @curwin.w_cursor.col
;                       && (@curwin.w_cursor.lnum != @insStart_orig.lnum
;                           || @curwin.w_cursor.col != @insStart_orig.col)));
;           }
;           did_backspace = true;
;       }

;       @did_si = false;
;       @can_si = false;
;       @can_si_back = false;
;       if (@curwin.w_cursor.col <= 1)
;           @did_ai = false;

        ;; It's a little strange to put backspaces into the redo buffer,
        ;; but it makes auto-indent a lot easier to deal with.

;       appendCharToRedobuff(c);

        ;; If deleted before the insertion point, adjust it.
;       if (@curwin.w_cursor.lnum == @insStart_orig.lnum && @curwin.w_cursor.col < @insStart_orig.col)
;           @insStart_orig.col = @curwin.w_cursor.col;

        ;; vi: the cursor moves backward but the character that was there remains visible
        ;; vim: the cursor moves backward and the character that was there is erased from the screen
        ;; We can emulate vi by pretending there is a dollar displayed even when there isn't.

;       if (vim_strbyte(@p_cpo, CPO_BACKSPACE) != null && @dollar_vcol == -1)
;           @dollar_vcol = @curwin.w_virtcol;

;       return did_backspace;
    ))

(defn- #_void ins_mouse [#_int c]
    (§
;       window_C old_curwin = @curwin;

;       if (!mouse_has(MOUSE_INSERT))
;           return;

;       undisplay_dollar();

;       pos_C tpos = §_pos_C();
;       COPY_pos(tpos, @curwin.w_cursor);

;       if (do_mouse(null, c, BACKWARD, 1, 0))
;       {
;           window_C new_curwin = @curwin;

;           if (@curwin != old_curwin && win_valid(old_curwin))
;           {
                ;; Mouse took us to another window.
                ;; We need to go back to the previous one to stop insert there properly.
;               @curwin = old_curwin;
;               @curbuf = @curwin.w_buffer;
;           }
;           start_arrow(@curwin == old_curwin ? tpos : null);
;           if (@curwin != new_curwin && win_valid(new_curwin))
;           {
;               @curwin = new_curwin;
;               @curbuf = @curwin.w_buffer;
;           }
;           @can_cindent = true;
;       }

        ;; redraw status lines (in case another window became active)
;       redraw_statuslines();
    ))

(defn- #_void ins_mousescroll [#_int dir]
    (§
;       window_C old_curwin = @curwin;

;       pos_C tpos = §_pos_C();
;       COPY_pos(tpos, @curwin.w_cursor);

;       if (0 <= @mouse_row && 0 <= @mouse_col)
;       {
;           int[] row = { @mouse_row };
;           int[] col = { @mouse_col };

            ;; find the window at the pointer coordinates
;           @curwin = mouse_find_win(row, col);
;           @curbuf = @curwin.w_buffer;
;       }

;       if (@curwin == old_curwin)
;           undisplay_dollar();

;       if (dir == MSCR_DOWN || dir == MSCR_UP)
;       {
;           if ((@mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL)) != 0)
;               scroll_redraw(dir != MSCR_DOWN, @curwin.w_botline - @curwin.w_topline);
;           else
;               scroll_redraw(dir != MSCR_DOWN, 3L);
;       }

;       @curwin.w_redr_status = true;

;       @curwin = old_curwin;
;       @curbuf = @curwin.w_buffer;

;       if (!eqpos(@curwin.w_cursor, tpos))
;       {
;           start_arrow(tpos);
;           @can_cindent = true;
;       }
    ))

(defn- #_void ins_left []
    (§
;       undisplay_dollar();

;       pos_C tpos = §_pos_C();
;       COPY_pos(tpos, @curwin.w_cursor);

;       if (oneleft() == true)
;       {
;           start_arrow(tpos);
            ;; If exit reversed string, position is fixed.
;           if (@revins_scol != -1 && @revins_scol <= @curwin.w_cursor.col)
;               @revins_legal++;
;           @revins_chars++;
;       }

        ;; if 'whichwrap' set for cursor in insert mode may go to previous line

;       else if (vim_strchr(@p_ww, '[') != null && 1 < @curwin.w_cursor.lnum)
;       {
;           start_arrow(tpos);
;           --@curwin.w_cursor.lnum;
;           coladvance(MAXCOL);
;           @curwin.w_set_curswant = true;   ;; so we stay at the end
;       }
;       else
;           vim_beep();
    ))

(defn- #_void ins_home [#_int c]
    (§
;       undisplay_dollar();

;       pos_C tpos = §_pos_C();
;       COPY_pos(tpos, @curwin.w_cursor);

;       if (c == K_C_HOME)
;           @curwin.w_cursor.lnum = 1;
;       @curwin.w_cursor.col = 0;
;       @curwin.w_cursor.coladd = 0;
;       @curwin.w_curswant = 0;

;       start_arrow(tpos);
    ))

(defn- #_void ins_end [#_int c]
    (§
;       undisplay_dollar();

;       pos_C tpos = §_pos_C();
;       COPY_pos(tpos, @curwin.w_cursor);

;       if (c == K_C_END)
;           @curwin.w_cursor.lnum = @curbuf.b_ml.ml_line_count;
;       coladvance(MAXCOL);
;       @curwin.w_curswant = MAXCOL;

;       start_arrow(tpos);
    ))

(defn- #_void ins_s_left []
    (§
;       undisplay_dollar();

;       if (1 < @curwin.w_cursor.lnum || 0 < @curwin.w_cursor.col)
;       {
;           start_arrow(@curwin.w_cursor);
;           bck_word(1L, false, false);
;           @curwin.w_set_curswant = true;
;       }
;       else
;           vim_beep();
    ))

(defn- #_void ins_right []
    (§
;       undisplay_dollar();

;       if (gchar_cursor() != NUL || virtual_active())
;       {
;           start_arrow(@curwin.w_cursor);
;           @curwin.w_set_curswant = true;
;           if (virtual_active())
;               oneright();
;           else
;               @curwin.w_cursor.col += us_ptr2len_cc(ml_get_cursor());

;           @revins_legal++;
;           if (0 < @revins_chars)
;               @revins_chars--;
;       }
        ;; if 'whichwrap' set for cursor in insert mode, may move the cursor to the next line
;       else if (vim_strchr(@p_ww, ']') != null && @curwin.w_cursor.lnum < @curbuf.b_ml.ml_line_count)
;       {
;           start_arrow(@curwin.w_cursor);
;           @curwin.w_set_curswant = true;
;           @curwin.w_cursor.lnum++;
;           @curwin.w_cursor.col = 0;
;       }
;       else
;           vim_beep();
    ))

(defn- #_void ins_s_right []
    (§
;       undisplay_dollar();

;       if (@curwin.w_cursor.lnum < @curbuf.b_ml.ml_line_count || gchar_cursor() != NUL)
;       {
;           start_arrow(@curwin.w_cursor);
;           fwd_word(1L, false, false);
;           @curwin.w_set_curswant = true;
;       }
;       else
;           vim_beep();
    ))

(defn- #_void ins_up [#_boolean startcol]
    ;; startcol: when true move to insStart.col
    (§
;       long old_topline = @curwin.w_topline;

;       undisplay_dollar();

;       pos_C tpos = §_pos_C();
;       COPY_pos(tpos, @curwin.w_cursor);

;       if (cursor_up(1L, true) == true)
;       {
;           if (startcol)
;               coladvance(getvcol_nolist(@insStart));
;           if (old_topline != @curwin.w_topline)
;               redraw_later(VALID);
;           start_arrow(tpos);
;           @can_cindent = true;
;       }
;       else
;           vim_beep();
    ))

(defn- #_void ins_pageup []
    (§
;       undisplay_dollar();

;       if ((@mod_mask & MOD_MASK_CTRL) == 0)
;       {
;           pos_C tpos = §_pos_C();
;           COPY_pos(tpos, @curwin.w_cursor);

;           if (onepage(BACKWARD, 1L) == true)
;           {
;               start_arrow(tpos);
;               @can_cindent = true;
;           }
;           else
;               vim_beep();
;       }
    ))

(defn- #_void ins_down [#_boolean startcol]
    ;; startcol: when true move to insStart.col
    (§
;       long old_topline = @curwin.w_topline;

;       undisplay_dollar();

;       pos_C tpos = §_pos_C();
;       COPY_pos(tpos, @curwin.w_cursor);

;       if (cursor_down(1L, true) == true)
;       {
;           if (startcol)
;               coladvance(getvcol_nolist(@insStart));
;           if (old_topline != @curwin.w_topline)
;               redraw_later(VALID);
;           start_arrow(tpos);
;           @can_cindent = true;
;       }
;       else
;           vim_beep();
    ))

(defn- #_void ins_pagedown []
    (§
;       undisplay_dollar();

;       if ((@mod_mask & MOD_MASK_CTRL) == 0)
;       {
;           pos_C tpos = §_pos_C();
;           COPY_pos(tpos, @curwin.w_cursor);

;           if (onepage(FORWARD, 1L) == true)
;           {
;               start_arrow(tpos);
;               @can_cindent = true;
;           }
;           else
;               vim_beep();
;       }
    ))

(defn- #_void ins_drop []
    (§
;       do_put('~', BACKWARD, 1, PUT_CURSEND);
    ))

;; Handle TAB in Insert or Replace mode.
;; Return true when the TAB needs to be inserted like a normal character.

(defn- #_boolean ins_tab []
    (§
;       if (@insStart_blank_vcol == MAXCOL && @curwin.w_cursor.lnum == @insStart.lnum)
;           @insStart_blank_vcol = get_nolist_virtcol();
;       if (echeck_abbr(TAB + ABBR_OFF))
;           return false;

;       boolean ind = inindent(0);
;       if (ind)
;           @can_cindent = false;

        ;; When nothing special, insert TAB like a normal character

;       if (!@curbuf.@b_p_et
;               && !(@p_sta && ind && @curbuf.@b_p_ts != get_sw_value(@curbuf))
;               && get_sts_value() == 0)
;           return true;

;       if (!stop_arrow())
;           return true;

;       @did_ai = false;
;       @did_si = false;
;       @can_si = false;
;       @can_si_back = false;

;       appendToRedobuff(u8("\t"));

;       int temp;
;       if (@p_sta && ind)                       ;; insert tab in indent, use 'shiftwidth'
;           temp = (int)get_sw_value(@curbuf);
;       else if (@curbuf.@b_p_sts != 0)           ;; use 'softtabstop' when set
;           temp = (int)get_sts_value();
;       else                                    ;; otherwise use 'tabstop'
;           temp = (int)@curbuf.@b_p_ts;
;       temp -= get_nolist_virtcol() % temp;

        ;; Insert the first space with ins_char().  It will delete one char in
        ;; replace mode.  Insert the rest with ins_str(); it will not delete any
        ;; chars.  For VREPLACE mode, we use ins_char() for all characters.

;       ins_char(' ');
;       while (0 < --temp)
;       {
;           if ((@State & VREPLACE_FLAG) != 0)
;               ins_char(' ');
;           else
;           {
;               ins_str(u8(" "));
;               if ((@State & REPLACE_FLAG) != 0)    ;; no char replaced
;                   replace_push(NUL);
;           }
;       }

        ;; When 'expandtab' not set: Replace spaces by TABs where possible.

;       if (!@curbuf.@b_p_et && (get_sts_value() != 0 || (@p_sta && ind)))
;       {
;           boolean save_list = @curwin.w_onebuf_opt.@wo_list;

            ;; Get the current line.
            ;; For VREPLACE mode, don't make real changes yet, just work on a copy of the line.

;           pos_C pos = §_pos_C();
;           pos_C cursor;
;           Bytes saved_line = null;
;           Bytes ptr;
;           if ((@State & VREPLACE_FLAG) != 0)
;           {
;               COPY_pos(pos, @curwin.w_cursor);
;               cursor = pos;
;               saved_line = STRDUP(ml_get_curline());
;               ptr = saved_line.plus(pos.col);
;           }
;           else
;           {
;               ptr = ml_get_cursor();
;               cursor = @curwin.w_cursor;
;           }

            ;; When 'L' is not in 'cpoptions' a tab always takes up 'ts' spaces.
;           if (vim_strbyte(@p_cpo, CPO_LISTWM) == null)
;               @curwin.w_onebuf_opt.@wo_list = false;

            ;; Find first white before the cursor.
;           pos_C fpos = §_pos_C();
;           COPY_pos(fpos, @curwin.w_cursor);
;           while (0 < fpos.col && vim_iswhite(ptr.at(-1)))
;           {
;               --fpos.col;
;               ptr = ptr.minus(1);
;           }

            ;; In Replace mode, don't change characters before the insert point.
;           if ((@State & REPLACE_FLAG) != 0 && fpos.lnum == @insStart.lnum && fpos.col < @insStart.col)
;           {
;               ptr = ptr.plus(@insStart.col - fpos.col);
;               fpos.col = @insStart.col;
;           }

            ;; compute virtual column numbers of first white and cursor
;           int[] vcol = new int[1];
;           getvcol(@curwin, fpos, vcol, null, null);
;           int[] want_vcol = new int[1];
;           getvcol(@curwin, cursor, want_vcol, null, null);

;           int change_col = -1;
            ;; Use as many TABs as possible.
            ;; Beware of 'breakindent', 'showbreak' and 'linebreak' adding extra virtual columns.
;           while (vim_iswhite(ptr.at(0)))
;           {
;               int i = lbr_chartabsize(null, u8("\t"), vcol[0]);
;               if (want_vcol[0] < vcol[0] + i)
;                   break;
;               if (ptr.at(0) != TAB)
;               {
;                   ptr.be(0, TAB);
;                   if (change_col < 0)
;                   {
;                       change_col = fpos.col; ;; column of first change
                        ;; May have to adjust insStart.
;                       if (fpos.lnum == @insStart.lnum && fpos.col < @insStart.col)
;                           @insStart.col = fpos.col;
;                   }
;               }
;               fpos.col++;
;               ptr = ptr.plus(1);
;               vcol[0] += i;
;           }

;           if (0 <= change_col)
;           {
;               int repl_off = 0;
;               Bytes line = ptr;

                ;; Skip over the spaces we need.
;               while (vcol[0] < want_vcol[0] && ptr.at(0) == (byte)' ')
;               {
;                   vcol[0] += lbr_chartabsize(line, ptr, vcol[0]);
;                   ptr = ptr.plus(1);
;                   repl_off++;
;               }
;               if (want_vcol[0] < vcol[0])
;               {
                    ;; Must have a char with 'showbreak' just before it.
;                   ptr = ptr.minus(1);
;                   --repl_off;
;               }
;               fpos.col += repl_off;

                ;; Delete following spaces.
;               int i = cursor.col - fpos.col;
;               if (0 < i)
;               {
;                   BCOPY(ptr, 0, ptr, i, STRLEN(ptr, i) + 1);
                    ;; correct replace stack.
;                   if ((@State & REPLACE_FLAG) != 0 && (@State & VREPLACE_FLAG) == 0)
;                       for (temp = i; 0 <= --temp; )
;                           replace_join(repl_off);
;               }
;               cursor.col -= i;

                ;; In VREPLACE mode, we haven't changed anything yet.  Do it now by
                ;; backspacing over the changed spacing and then inserting the new spacing.

;               if ((@State & VREPLACE_FLAG) != 0)
;               {
                    ;; Backspace from real cursor to change_col.
;                   backspace_until_column(change_col);

                    ;; Insert each char in saved_line from changed_col to ptr-cursor.
;                   ins_bytes_len(saved_line.plus(change_col), cursor.col - change_col);
;               }
;           }

;           @curwin.w_onebuf_opt.@wo_list = save_list;
;       }

;       return false;
    ))

;; Handle CR or NL in insert mode.
;; Return true when out of memory or can't undo.

(defn- #_boolean ins_eol [#_int c]
    (§
;       if (echeck_abbr(c + ABBR_OFF))
;           return false;
;       if (!stop_arrow())
;           return true;

;       undisplay_dollar();

        ;; Strange Vi behaviour:
        ;; In Replace mode, typing a NL will not delete the character under the cursor.
        ;; Only push a NUL on the replace stack, nothing to put back when the NL is deleted.

;       if ((@State & REPLACE_FLAG) != 0 && (@State & VREPLACE_FLAG) == 0)
;           replace_push(NUL);

        ;; In VREPLACE mode, a NL replaces the rest of the line, and starts replacing the next line,
        ;; so we push all of the characters left on the line onto the replace stack.
        ;; This is not done here though, it is done in open_line().

        ;; Put cursor on NUL if on the last char and coladd is 1 (happens after CTRL-O).
;       if (virtual_active() && 0 < @curwin.w_cursor.coladd)
;           coladvance(getviscol());

        ;; NL in reverse insert will always start in the end of current line.
;       if (@revins_on)
;           @curwin.w_cursor.col += STRLEN(ml_get_cursor());

;       appendToRedobuff(NL_STR);
;       boolean b = open_line(FORWARD, has_format_option(FO_RET_COMS) ? OPENLINE_DO_COM : 0, @old_indent);
;       @old_indent = 0;
;       @can_cindent = true;

;       return (!b);
    ))

;; Handle digraph in insert mode.
;; Returns character still to be inserted, or NUL when nothing remaining to be done.

(defn- #_int ins_digraph []
    (§
;       boolean did_putchar = false;

;       @pc_status = PC_STATUS_UNSET;
;       if (redrawing() && !char_avail())
;       {
            ;; May need to redraw when no more chars available now.
;           ins_redraw(false);

;           edit_putchar('?', true);
;           did_putchar = true;
;           add_to_showcmd_c(Ctrl_K);
;       }

        ;; Don't map the digraph chars.
        ;; This also prevents the mode message to be deleted when ESC is hit.
;       @no_mapping++;
;       @allow_keys++;
;       int c = plain_vgetc();
;       --@no_mapping;
;       --@allow_keys;
;       if (did_putchar)
            ;; When the line fits in 'columns',
            ;; the '?' is at the start of the next line and will not be removed by the redraw.
;           edit_unputchar();

;       if (is_special(c) || @mod_mask != 0)         ;; special key
;       {
;           clear_showcmd();
;           insert_special(c, true, false);
;           return NUL;
;       }

;       if (c != ESC)
;       {
;           did_putchar = false;
;           if (redrawing() && !char_avail())
;           {
                ;; May need to redraw when no more chars available now.
;               ins_redraw(false);

;               if (mb_char2cells(c) == 1)
;               {
;                   ins_redraw(false);
;                   edit_putchar(c, true);
;                   did_putchar = true;
;               }
;               add_to_showcmd_c(c);
;           }
;           @no_mapping++;
;           @allow_keys++;
;           int cc = plain_vgetc();
;           --@no_mapping;
;           --@allow_keys;
;           if (did_putchar)
                ;; When the line fits in 'columns',
                ;; the '?' is at the start of the next line and will not be removed by a redraw.
;               edit_unputchar();
;           if (cc != ESC)
;           {
;               appendToRedobuff(CTRL_V_STR);
;               c = getdigraph(c, cc, true);
;               clear_showcmd();
;               return c;
;           }
;       }
;       clear_showcmd();
;       return NUL;
    ))

;; Handle CTRL-E and CTRL-Y in Insert mode: copy char from other line.
;; Returns the char to be inserted, or NUL if none found.

(defn- #_int ins_copychar [#_long lnum]
    (§
;       if (lnum < 1 || @curbuf.b_ml.ml_line_count < lnum)
;       {
;           vim_beep();
;           return NUL;
;       }

        ;; try to advance to the cursor column
;       Bytes line = ml_get(lnum);
;       Bytes[] ptr = { line };
;       Bytes prev_ptr = ptr[0];
;       validate_virtcol();

;       int temp = 0;
;       while (temp < @curwin.w_virtcol && ptr[0].at(0) != NUL)
;       {
;           prev_ptr = ptr[0];
;           temp += lbr_chartabsize_adv(line, ptr, temp);
;       }
;       if (@curwin.w_virtcol < temp)
;           ptr[0] = prev_ptr;

;       int c = us_ptr2char(ptr[0]);
;       if (c == NUL)
;           vim_beep();
;       return c;
    ))

;; CTRL-Y or CTRL-E typed in Insert mode.

(defn- #_int ins_ctrl_ey [#_int tc]
    (§
;       int c = ins_copychar(@curwin.w_cursor.lnum + (tc == Ctrl_Y ? -1 : 1));
;       if (c != NUL)
;       {
            ;; The character must be taken literally, insert like it was typed after a CTRL-V,
            ;; and pretend 'textwidth' wasn't set.  Digits, 'o' and 'x' are special after a
            ;; CTRL-V, don't use it for these.
;           if (c < 256 && !asc_isalnum(c))
;               appendToRedobuff(CTRL_V_STR); ;; CTRL-V

;           long tw_save = @curbuf.@b_p_tw;
;           @curbuf.@b_p_tw = -1;
;           insert_special(c, true, false);
;           @curbuf.@b_p_tw = tw_save;

;           @revins_chars++;
;           @revins_legal++;
;           c = Ctrl_V;                     ;; pretend CTRL-V is last character
;           auto_format(false, true);
;       }

;       return c;
    ))

;; Try to do some very smart auto-indenting.
;; Used when inserting a "normal" character.

(defn- #_void ins_try_si [#_int c]
    (§
        ;; do some very smart indenting when entering '{' or '}'

;       if (((@did_si || @can_si_back) && c == '{') || (@can_si && c == '}'))
;       {
;           pos_C pos;

            ;; for '}' set indent equal to indent of line containing matching '{'

;           if (c == '}' && (pos = findmatch(null, '{')) != null)
;           {
;               pos_C old_pos = §_pos_C();
;               COPY_pos(old_pos, @curwin.w_cursor);

                ;; If the matching '{' has a ')' immediately before it (ignoring
                ;; white-space), then line up with the start of the line containing
                ;; the matching '(' if there is one.  This handles the case where
                ;; an "if (..\n..) {" statement continues over multiple lines.

;               Bytes ptr = ml_get(pos.lnum);
;               int i = pos.col;
;               if (0 < i)          ;; skip blanks before '{'
;                   while (0 < --i && vim_iswhite(ptr.at(i)))
                    ;
;               @curwin.w_cursor.lnum = pos.lnum;
;               @curwin.w_cursor.col = i;
;               if (ptr.at(i) == (byte)')' && (pos = findmatch(null, '(')) != null)
;                   COPY_pos(@curwin.w_cursor, pos);
;               i = get_indent();
;               COPY_pos(@curwin.w_cursor, old_pos);
;               if ((@State & VREPLACE_FLAG) != 0)
;                   change_indent(INDENT_SET, i, false, NUL, true);
;               else
;                   set_indent(i, SIN_CHANGED);
;           }
;           else if (0 < @curwin.w_cursor.col)
;           {
                ;; when inserting '{' after "O" reduce indent,
                ;; but not more than indent of previous line

;               boolean temp = true;
;               if (c == '{' && @can_si_back && 1 < @curwin.w_cursor.lnum)
;               {
;                   pos_C old_pos = §_pos_C();
;                   COPY_pos(old_pos, @curwin.w_cursor);
;                   int i = get_indent();
;                   while (1 < @curwin.w_cursor.lnum)
;                   {
;                       Bytes ptr = skipwhite(ml_get(--@curwin.w_cursor.lnum));

                        ;; ignore empty lines and lines starting with '#'.
;                       if (ptr.at(0) != (byte)'#' && ptr.at(0) != NUL)
;                           break;
;                   }
;                   if (i <= get_indent())
;                       temp = false;
;                   COPY_pos(@curwin.w_cursor, old_pos);
;               }
;               if (temp)
;                   shift_line(true, false, 1, true);
;           }
;       }

        ;; set indent of '#' always to 0

;       if (0 < @curwin.w_cursor.col && @can_si && c == '#')
;       {
            ;; remember current indent for next line
;           @old_indent = get_indent();
;           set_indent(0, SIN_CHANGED);
;       }

        ;; Adjust ai_col, the char at this position can be deleted.
;       if (@ai_col > @curwin.w_cursor.col)
;           @ai_col = @curwin.w_cursor.col;
    ))

;; Get the value that w_virtcol would have when 'list' is off.
;; Unless 'cpo' contains the 'L' flag.

(defn- #_int get_nolist_virtcol []
    (§
;       if (@curwin.w_onebuf_opt.@wo_list && vim_strbyte(@p_cpo, CPO_LISTWM) == null)
;           return getvcol_nolist(@curwin.w_cursor);
;       validate_virtcol();
;       return @curwin.w_virtcol;
    ))

;; Handle the InsertCharPre autocommand.
;; "c" is the character that was typed.
;; Return a pointer to allocated memory with the replacement string.
;; Return null to continue inserting "c".

(defn- #_Bytes do_insert_char_pre [#_int c]
    (§
;       return null;
    ))

;;; ============================================================================================== VimN

;; regexp.c ---------------------------------------------------------------------------------------

;; Handling of regular expressions: vim_regcomp(), vim_regexec(), vim_regsub()
;;
;; Beware that some of this code is subtly aware of the way operator
;; precedence is structured in regular expressions.  Serious changes in
;; regular-expression syntax might require a total rethink.

;; The "internal use only" fields in regexp.h are present to pass info from
;; compile to execute that permits the execute phase to run lots faster on
;; simple cases.  They are:
;;
;; regstart     char that must begin a match; NUL if none obvious; Can be a
;;              multi-byte character.
;; reganch      is the match anchored (at beginning-of-line only)?
;; regmust      string (pointer into program) that match must include, or null
;; regmlen      length of regmust string
;; regflags     RF_ values or'ed together
;;
;; Regstart and reganch permit very fast decisions on suitable starting points
;; for a match, cutting down the work a lot.  Regmust permits fast rejection
;; of lines that cannot possibly match.  The regmust tests are costly enough
;; that vim_regcomp() supplies a regmust only if the r.e. contains something
;; potentially expensive (at present, the only such thing detected is * or +
;; at the start of the r.e., which can involve a lot of backup).  Regmlen is
;; supplied because the test in vim_regexec() needs it and vim_regcomp() is
;; computing it anyway.

;; Structure for regexp "program".  This is essentially a linear encoding
;; of a nondeterministic finite-state machine (aka syntax charts or
;; "railroad normal form" in parsing technology).  Each node is an opcode
;; plus a "next" pointer, possibly plus an operand.  "Next" pointers of
;; all nodes except BRANCH and BRACES_COMPLEX implement concatenation; a "next"
;; pointer with a BRANCH on both ends of it is connecting two alternatives.
;; (Here we have one of the subtle syntax dependencies: an individual BRANCH
;; (as opposed to a collection of them) is never concatenated with anything
;; because of operator precedence).  The "next" pointer of a BRACES_COMPLEX
;; node points to the node after the stuff to be repeated.
;; The operand of some types of node is a literal string; for others, it is a
;; node leading into a sub-FSM.  In particular, the operand of a BRANCH node
;; is the first node of the branch.
;; (NB this is *not* a tree structure: the tail of the branch connects to the
;; thing following the set of BRANCHes.)
;;
;; pattern      is coded like:
;;
;;                        +-----------------+
;;                        |                 V
;; <aa>\|<bb>   BRANCH <aa> BRANCH <bb> --> END
;;                   |      ^    |          ^
;;                   +------+    +----------+
;;
;;                     +------------------+
;;                     V                  |
;; <aa>*        BRANCH BRANCH <aa> --> BACK BRANCH --> NOTHING --> END
;;                   |      |               ^                      ^
;;                   |      +---------------+                      |
;;                   +---------------------------------------------+
;;
;;                     +----------------------+
;;                     V                      |
;; <aa>\+       BRANCH <aa> --> BRANCH --> BACK  BRANCH --> NOTHING --> END
;;                   |               |           ^                      ^
;;                   |               +-----------+                      |
;;                   +--------------------------------------------------+
;;
;;                                      +-------------------------+
;;                                      V                         |
;; <aa>\{}      BRANCH BRACE_LIMITS --> BRACE_COMPLEX <aa> --> BACK  END
;;                   |                              |                ^
;;                   |                              +----------------+
;;                   +-----------------------------------------------+
;;
;; <aa>\@!<bb>  BRANCH NOMATCH <aa> --> END  <bb> --> END
;;                   |       |                ^       ^
;;                   |       +----------------+       |
;;                   +--------------------------------+
;;
;;                                                    +---------+
;;                                                    |         V
;; \z[abc]      BRANCH BRANCH  a  BRANCH  b  BRANCH  c  BRANCH  NOTHING --> END
;;                   |      |          |          |     ^                   ^
;;                   |      |          |          +-----+                   |
;;                   |      |          +----------------+                   |
;;                   |      +---------------------------+                   |
;;                   +------------------------------------------------------+
;;
;; They all start with a BRANCH for "\|" alternatives, even when there is only
;; one alternative.

;; The opcodes are:

;; definition   number             opnd?    meaning
(final int END             0)       ;;      End of program or NOMATCH operand.
(final int BOL             1)       ;;      Match "" at beginning of line.
(final int EOL             2)       ;;      Match "" at end of line.
(final int BRANCH          3)       ;; node Match this alternative, or the next...
(final int BACK            4)       ;;      Match "", "next" ptr points backward.
(final int EXACTLY         5)       ;; str  Match this string.
(final int NOTHING         6)       ;;      Match empty string.
(final int STAR            7)       ;; node Match this (simple) thing 0 or more times.
(final int PLUS            8)       ;; node Match this (simple) thing 1 or more times.
(final int MATCH           9)       ;; node match the operand zero-width
(final int NOMATCH         10)      ;; node check for no match with operand
(final int BEHIND          11)      ;; node look behind for a match with operand
(final int NOBEHIND        12)      ;; node look behind for no match with operand
(final int SUBPAT          13)      ;; node match the operand here
(final int BRACE_SIMPLE    14)      ;; node Match this (simple) thing between m and
                                    ;;      n times (\{m,n\}).
(final int BOW             15)      ;;      Match "" after [^a-zA-Z0-9_]
(final int EOW             16)      ;;      Match "" at    [^a-zA-Z0-9_]
(final int BRACE_LIMITS    17)      ;; nr nr  define the min & max for BRACE_SIMPLE
                                    ;;      and BRACE_COMPLEX.
(final int NEWL            18)      ;;      Match line-break
(final int BHPOS           19)      ;;      End position for BEHIND or NOBEHIND

;; character classes: 20-48 normal, 50-78 include a line-break
(final int ADD_NL          30)

(final int ANY             20)      ;;      Match any one character.
(final int ANYOF           21)      ;; str  Match any character in this string.
(final int ANYBUT          22)      ;; str  Match any character not in this string.
(final int IDENT           23)      ;;      Match identifier char
(final int SIDENT          24)      ;;      Match identifier char but no digit
(final int KWORD           25)      ;;      Match keyword char
(final int SKWORD          26)      ;;      Match word char but no digit
(final int FNAME           27)      ;;      Match file name char
(final int SFNAME          28)      ;;      Match file name char but no digit
(final int PRINT           29)      ;;      Match printable char
(final int SPRINT          30)      ;;      Match printable char but no digit
(final int WHITE           31)      ;;      Match whitespace char
(final int NWHITE          32)      ;;      Match non-whitespace char
(final int DIGIT           33)      ;;      Match digit char
(final int NDIGIT          34)      ;;      Match non-digit char
(final int HEX             35)      ;;      Match hex char
(final int NHEX            36)      ;;      Match non-hex char
(final int OCTAL           37)      ;;      Match octal char
(final int NOCTAL          38)      ;;      Match non-octal char
(final int WORD            39)      ;;      Match word char
(final int NWORD           40)      ;;      Match non-word char
(final int HEAD            41)      ;;      Match head char
(final int NHEAD           42)      ;;      Match non-head char
(final int ALPHA           43)      ;;      Match alpha char
(final int NALPHA          44)      ;;      Match non-alpha char
(final int LOWER           45)      ;;      Match lowercase char
(final int NLOWER          46)      ;;      Match non-lowercase char
(final int UPPER           47)      ;;      Match uppercase char
(final int NUPPER          48)      ;;      Match non-uppercase char

(final int FIRST_NL        (+ ANY ADD_NL))
(final int LAST_NL         (+ NUPPER ADD_NL))

(defn- #_boolean with_nl [#_int op]
    (§
;       return (FIRST_NL <= op && op <= LAST_NL);
    ))

(final int MOPEN           80)  ;; -89       Mark this point in input as start of
                                    ;;       \( subexpr.  MOPEN + 0 marks start of match.
(final int MCLOSE          90)  ;; -99       Analogous to MOPEN.  MCLOSE + 0 marks
                                    ;;       end of match.
(final int BACKREF         100) ;; -109 node Match same string again \1-\9

(final int ZOPEN           110) ;; -119      Mark this point in input as start of \z( subexpr.
(final int ZCLOSE          120) ;; -129      Analogous to ZOPEN.
(final int ZREF            130) ;; -139 node Match external submatch \z1-\z9

(final int BRACE_COMPLEX   140) ;; -149 node Match nodes between m & n times

(final int NOPEN           150)     ;;      Mark this point in input as start of \%( subexpr.
(final int NCLOSE          151)     ;;      Analogous to NOPEN.

(final int MULTIBYTECODE   200)     ;; mbc  Match one multi-byte character
(final int RE_BOF          201)     ;;      Match "" at beginning of file.
(final int RE_EOF          202)     ;;      Match "" at end of file.
(final int CURSOR          203)     ;;      Match location of cursor.

(final int RE_LNUM         204)     ;; nr cmp  Match line number
(final int RE_COL          205)     ;; nr cmp  Match column number
(final int RE_VCOL         206)     ;; nr cmp  Match virtual column number

(final int RE_MARK         207)     ;; mark cmp  Match mark position
(final int RE_VISUAL       208)     ;;      Match Visual area
(final int RE_COMPOSING    209)     ;; any composing characters

;; Magic characters have a special meaning, they don't match literally.
;; Magic characters are negative.  This separates them from literal characters
;; (possibly multi-byte).  Only ASCII characters can be Magic.

(defn- #_final #_int Magic [#_int x]
    (§
;       return x - 256;
    ))

(defn- #_int un_Magic [#_int x]
    (§
;       return x + 256;
    ))

(defn- #_boolean is_Magic [#_int x]
    (§
;       return (x < 0);
    ))

(defn- #_int no_Magic [#_int x]
    (§
;       if (is_Magic(x))
;           return un_Magic(x);

;       return x;
    ))

(defn- #_int toggle_Magic [#_int x]
    (§
;       if (is_Magic(x))
;           return un_Magic(x);

;       return Magic(x);
    ))

;; The first byte of the regexp internal "program" is actually this magic number;
;; the start node begins in the second byte.
;; It's used to catch the most severe mutilation of the program by the caller.

(final byte! REGMAGIC 0234)

;; Opcode notes:
;;
;; BRANCH           The set of branches constituting a single choice are hooked
;;                  together with their "next" pointers, since precedence prevents
;;                  anything being concatenated to any individual branch.  The
;;                  "next" pointer of the last BRANCH in a choice points to the
;;                  thing following the whole choice.  This is also where the
;;                  final "next" pointer of each individual branch points; each
;;                  branch starts with the operand node of a BRANCH node.
;;
;; BACK             Normal "next" pointers all implicitly point forward; BACK
;;                  exists to make loop structures possible.
;;
;; STAR,PLUS        '=', and complex '*' and '+', are implemented as circular
;;                  BRANCH structures using BACK.  Simple cases (one character
;;                  per match) are implemented with STAR and PLUS for speed
;;                  and to minimize recursive plunges.
;;
;; BRACE_LIMITS     This is always followed by a BRACE_SIMPLE or BRACE_COMPLEX
;;                  node, and defines the min and max limits to be used for that node.
;;
;; MOPEN, MCLOSE    ... are numbered at compile time.
;; ZOPEN, ZCLOSE    ... ditto

;; A node is one char of opcode followed by two chars of "next" pointer.
;; "Next" pointers are stored as two 8-bit bytes, high order first.  The
;; value is a positive offset from the opcode of the node containing it.
;; An operand, if any, simply follows the node.  (Note that much of the
;; code generation knows about this implicit relationship.)
;;
;; Using two bytes for the "next" pointer is vast overkill for most things,
;; but allows patterns to get big without disasters.

(defn- #_int re_op [#_Bytes p]
    (§
;       return (int)p.at(0);
    ))

(defn- #_int re_next [#_Bytes p]
    (§
;       return ((int)p.at(1) << 8) + (int)p.at(2);
    ))

(defn- #_Bytes operand [#_Bytes p]
    (§
;       return p.plus(3);
    ))

;; Obtain an operand that was stored as four bytes, MSB first.
(defn- #_long operand_min [#_Bytes p]
    (§
;       return ((long)p.at(3) << 24) + ((long)p.at(4) << 16) + ((long)p.at(5) << 8) + (long)p.at(6);
    ))

;; Obtain a second operand stored as four bytes.
(defn- #_long operand_max [#_Bytes p]
    (§
;       return operand_min(p.plus(4));
    ))

;; Obtain a second single-byte operand stored after a four bytes operand.
(defn- #_byte operand_cmp [#_Bytes p]
    (§
;       return p.at(7);
    ))

(final long MAX_LIMIT       (<< 32767#_L 16#_L))

(final Bytes e_missingbracket  (u8 "E769: Missing ] after %s["))
(final Bytes e_unmatchedpp     (u8 "E53: Unmatched %s%%("))
(final Bytes e_unmatchedp      (u8 "E54: Unmatched %s("))
(final Bytes e_unmatchedpar    (u8 "E55: Unmatched %s)"))
(final Bytes e_z_not_allowed   (u8 "E66: \\z( not allowed here"))
(final Bytes e_z1_not_allowed  (u8 "E67: \\z1 et al. not allowed here"))
(final Bytes e_missing_sb      (u8 "E69: Missing ] after %s%%["))
(final Bytes e_empty_sb        (u8 "E70: Empty %s%%[]"))

(final int NOT_MULTI       0)
(final int MULTI_ONE       1)
(final int MULTI_MULT      2)

;; Return NOT_MULTI if c is not a "multi" operator.
;; Return MULTI_ONE if c is a single "multi" operator.
;; Return MULTI_MULT if c is a multi "multi" operator.

(defn- #_int re_multi_type [#_int c]
    (§
;       if (c == Magic('@') || c == Magic('=') || c == Magic('?'))
;           return MULTI_ONE;
;       if (c == Magic('*') || c == Magic('+') || c == Magic('{'))
;           return MULTI_MULT;

;       return NOT_MULTI;
    ))

;; Flags to be passed up and down.

(final int HASWIDTH        0x1)     ;; Known never to match null string.
(final int SIMPLE          0x2)     ;; Simple enough to be STAR/PLUS operand.
(final int SPSTART         0x4)     ;; Starts with * or +.
(final int HASNL           0x8)     ;; Contains some \n.
(final int HASLOOKBH       0x10)    ;; Contains "\@<=" or "\@<!".
(final int WORST           0)       ;; Worst case.

;; When regcode is set to this value, code is not emitted and size is computed instead.

(final Bytes JUST_CALC_SIZE (u8 ""))

(atom! Bytes reg_prev_sub)

;; REGEXP_INRANGE contains all characters which are always special in a [] range after '\'.
;; REGEXP_ABBR contains all characters which act as abbreviations after '\'.
;; These are:
;;  \n  - New line (NL).
;;  \r  - Carriage Return (CR).
;;  \t  - Tab (TAB).
;;  \e  - Escape (ESC).
;;  \b  - Backspace (Ctrl_H).
;;  \d  - Character code in decimal, e.g. \d123
;;  \o  - Character code in octal, e.g. \o80
;;  \x  - Character code in hex, e.g. \x4a
;;  \\u (sic!) - Multibyte character code, e.g. \u20ac
;;  \U  - Long multibyte character code, e.g. \U12345678

(final Bytes REGEXP_INRANGE (u8 "]^-n\\"))
(final Bytes REGEXP_ABBR (u8 "nrtebdoxuU"))

;; Translate '\x' to its control character, except "\n", which is Magic.

(defn- #_int backslash_trans [#_int c]
    (§
;       switch (c)
;       {
;           case 'r':   return CAR;
;           case 't':   return TAB;
;           case 'e':   return ESC;
;           case 'b':   return BS;
;       }
;       return c;
    ))

(final int CLASS_ALNUM 0)
(final int CLASS_ALPHA 1)
(final int CLASS_BLANK 2)
(final int CLASS_CNTRL 3)
(final int CLASS_DIGIT 4)
(final int CLASS_GRAPH 5)
(final int CLASS_LOWER 6)
(final int CLASS_PRINT 7)
(final int CLASS_PUNCT 8)
(final int CLASS_SPACE 9)
(final int CLASS_UPPER 10)
(final int CLASS_XDIGIT 11)
(final int CLASS_TAB 12)
(final int CLASS_RETURN 13)
(final int CLASS_BACKSPACE 14)
(final int CLASS_ESCAPE 15)
(final int CLASS_NONE 99)

(final Bytes* class_names
    [
        (u8 "alnum:]")
        (u8 "alpha:]")
        (u8 "blank:]")
        (u8 "cntrl:]")
        (u8 "digit:]")
        (u8 "graph:]")
        (u8 "lower:]")
        (u8 "print:]")
        (u8 "punct:]")
        (u8 "space:]")
        (u8 "upper:]")
        (u8 "xdigit:]")
        (u8 "tab:]")
        (u8 "return:]")
        (u8 "backspace:]")
        (u8 "escape:]")
    ])

;; Check for a character class name "[:name:]".  "pp" points to the '['.
;; Returns one of the CLASS_ items.  CLASS_NONE means that no item was
;; recognized.  Otherwise "pp" is advanced to after the item.

(defn- #_int get_char_class [#_Bytes* pp]
    (§
;       if (pp[0].at(1) == (byte)':')
;       {
;           for (int i = 0; i < class_names.length; i++)
;           {
;               int len = STRLEN(class_names[i]);
;               if (STRNCMP(pp[0].plus(2), class_names[i], len) == 0)
;               {
;                   pp[0] = pp[0].plus(len + 2);
;                   return i;
;               }
;           }
;       }
;       return CLASS_NONE;
    ))

;; Specific version of character class functions.
;; Using a table to keep this fast.

(atom! short* class_tab 256)

(final int RI_DIGIT    0x01)
(final int RI_HEX      0x02)
(final int RI_OCTAL    0x04)
(final int RI_WORD     0x08)
(final int RI_HEAD     0x10)
(final int RI_ALPHA    0x20)
(final int RI_LOWER    0x40)
(final int RI_UPPER    0x80)
(final int RI_WHITE    0x100)

(atom! boolean class_tab_done)

(defn- #_void init_class_tab []
    (§
;       if (@class_tab_done)
;           return;

;       for (int i = 0; i < 256; i++)
;       {
;           if ('0' <= i && i <= '7')
;               @class_tab[i] = RI_DIGIT + RI_HEX + RI_OCTAL + RI_WORD;
;           else if ('8' <= i && i <= '9')
;               @class_tab[i] = RI_DIGIT + RI_HEX + RI_WORD;
;           else if ('a' <= i && i <= 'f')
;               @class_tab[i] = RI_HEX + RI_WORD + RI_HEAD + RI_ALPHA + RI_LOWER;
;           else if ('g' <= i && i <= 'z')
;               @class_tab[i] = RI_WORD + RI_HEAD + RI_ALPHA + RI_LOWER;
;           else if ('A' <= i && i <= 'F')
;               @class_tab[i] = RI_HEX + RI_WORD + RI_HEAD + RI_ALPHA + RI_UPPER;
;           else if ('G' <= i && i <= 'Z')
;               @class_tab[i] = RI_WORD + RI_HEAD + RI_ALPHA + RI_UPPER;
;           else if (i == '_')
;               @class_tab[i] = RI_WORD + RI_HEAD;
;           else
;               @class_tab[i] = 0;
;       }
;       @class_tab[' '] |= RI_WHITE;
;       @class_tab['\t'] |= RI_WHITE;

;       @class_tab_done = true;
    ))

(defn- #_boolean ri_digit [#_int c]
    (§
;       return (c < 0x100 && (@class_tab[c] & RI_DIGIT) != 0);
    ))

(defn- #_boolean ri_hex [#_int c]
    (§
;       return (c < 0x100 && (@class_tab[c] & RI_HEX) != 0);
    ))

(defn- #_boolean ri_octal [#_int c]
    (§
;       return (c < 0x100 && (@class_tab[c] & RI_OCTAL) != 0);
    ))

(defn- #_boolean ri_word [#_int c]
    (§
;       return (c < 0x100 && (@class_tab[c] & RI_WORD) != 0);
    ))

(defn- #_boolean ri_head [#_int c]
    (§
;       return (c < 0x100 && (@class_tab[c] & RI_HEAD) != 0);
    ))

(defn- #_boolean ri_alpha [#_int c]
    (§
;       return (c < 0x100 && (@class_tab[c] & RI_ALPHA) != 0);
    ))

(defn- #_boolean ri_lower [#_int c]
    (§
;       return (c < 0x100 && (@class_tab[c] & RI_LOWER) != 0);
    ))

(defn- #_boolean ri_upper [#_int c]
    (§
;       return (c < 0x100 && (@class_tab[c] & RI_UPPER) != 0);
    ))

(defn- #_boolean ri_white [#_int c]
    (§
;       return (c < 0x100 && (@class_tab[c] & RI_WHITE) != 0);
    ))

;; flags for regflags
(final int RF_ICASE    1)   ;; ignore case
(final int RF_NOICASE  2)   ;; don't ignore case
(final int RF_HASNL    4)   ;; can match a NL
(final int RF_ICOMBINE 8)   ;; ignore combining characters
(final int RF_LOOKBH   16)  ;; uses "\@<=" or "\@<!"

;; Global work variables for vim_regcomp().

(atom! Bytes    regparse)                   ;; input-scan pointer
(atom! int      prevchr_len)                ;; byte length of previous char
(atom! int      num_complex_braces)         ;; complex \{...} count
(atom! int      regnpar)                    ;; () count
(atom! int      regnzpar)                   ;; \z() count
(atom! int      re_has_z)                   ;; \z item detected
(atom! Bytes    regcode)                    ;; code-emit pointer, or JUST_CALC_SIZE
(atom! int      regsize)                    ;; code size
(atom! boolean  reg_toolong)                ;; true when offset out of range
(atom! boolean* had_endbrace    NSUBEXP)    ;; flags, true if end of () found
(atom! int      regflags)                   ;; RF_ flags for prog
(atom! long*    brace_min       10)         ;; minimums for complex brace repeats
(atom! long*    brace_max       10)         ;; maximums for complex brace repeats
(atom! int*     brace_count     10)         ;; current counts for complex brace repeats
(atom! boolean  had_eol)                    ;; true when EOL found by vim_regcomp()
(atom! boolean  one_exactly)                ;; only do one char for EXACTLY

(atom! int      reg_magic)                  ;; magicness of the pattern:
(final int MAGIC_NONE      1)                   ;; "\V" very unmagic
(final int MAGIC_OFF       2)                   ;; "\M" or 'magic' off
(final int MAGIC_ON        3)                   ;; "\m" or 'magic'
(final int MAGIC_ALL       4)                   ;; "\v" very magic

(atom! boolean  reg_string)                 ;; matching with a string instead of a buffer line
(atom! boolean  reg_strict)                 ;; "[abc" is illegal

;; META contains all characters that may be magic, except '^' and '$'.

;; META[] is used often enough to justify turning it into a table.
(final byte* META_flags
    [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
;;                     %  &     (  )  *  +        .
        0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0,
;;         1  2  3  4  5  6  7  8  9        <  =  >  ?
        0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1,
;;      @  A     C  D     F     H  I     K  L  M     O
        1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1,
;;      P        S     U  V  W  X     Z  [           _
        1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1,
;;         a     c  d     f     h  i     k  l  m  n  o
        0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1,
;;      p        s     u  v  w  x     z  {  |     ~
        1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1
    ])

(atom! int      curchr)             ;; currently parsed character

;; Previous character.  Note: prevchr is sometimes -1 when we are not at the start,
;; e.g. in /[ ^I]^ the pattern was never found even if it existed,
;; because ^ was taken to be magic.

(atom! int      prevchr)
(atom! int      prevprevchr)        ;; previous-previous character
(atom! int      nextchr)            ;; used for ungetchr()

;; arguments for reg()
(final int REG_NOPAREN     0)           ;; toplevel reg()
(final int REG_PAREN       1)           ;; \(\)
(final int REG_ZPAREN      2)           ;; \z(\)
(final int REG_NPAREN      3)           ;; \%(\)

(class! #_final parse_state_C
    [
        (field Bytes        regparse)
        (field int          prevchr_len)
        (field int          curchr)
        (field int          prevchr)
        (field int          prevprevchr)
        (field int          nextchr)
        (field boolean      at_start)
        (field boolean      prev_at_start)
        (field int          regnpar)
    ])

;; Forward declarations for vim_regcomp()'s friends.

;   static regengine_C bt_regengine = new regengine_C()
;   {
;       public regprog_C regcomp(Bytes expr, int re_flags)
;       {
;           return bt_regcomp(expr, re_flags);
;       }

;       public long regexec_nl(regmatch_C rmp, Bytes line, int col, boolean line_lbr)
;       {
;           return bt_regexec_nl(rmp, line, col, line_lbr);
;       }

;       public long regexec_multi(regmmatch_C rmp, window_C win, buffer_C buf, long lnum, int col, timeval_C tm)
;       {
;           return bt_regexec_multi(rmp, win, buf, lnum, col, tm);
;       }
;   };

;   static regengine_C nfa_regengine = new regengine_C()
;   {
;       public regprog_C regcomp(Bytes expr, int re_flags)
;       {
;           return nfa_regcomp(expr, re_flags);
;       }

;       public long regexec_nl(regmatch_C rmp, Bytes line, int col, boolean line_lbr)
;       {
;           return nfa_regexec_nl(rmp, line, col, line_lbr);
;       }

;       public long regexec_multi(regmmatch_C rmp, window_C win, buffer_C buf, long lnum, int col, timeval_C tm)
;       {
;           return nfa_regexec_multi(rmp, win, buf, lnum, col, tm);
;       }
;   };

;; Return true if compiled regular expression "prog" can match a line break.

(defn- #_boolean re_multiline [#_regprog_C prog]
    (§
;       return ((prog.regflags & RF_HASNL) != 0);
    ))

;; Return true if compiled regular expression "prog" looks before the start
;; position (pattern contains "\@<=" or "\@<!").

(defn- #_boolean re_lookbehind [#_regprog_C prog]
    (§
;       return ((prog.regflags & RF_LOOKBH) != 0);
    ))

;; Check for an equivalence class name "[=a=]".  "pp" points to the '['.
;; Returns a character representing the class.  Zero means that no item was
;; recognized.  Otherwise "pp" is advanced to after the item.

(defn- #_int get_equi_class [#_Bytes* pp]
    (§
;       Bytes p = pp[0];
;       if (p.at(1) == (byte)'=')
;       {
;           int len = us_ptr2len_cc(p.plus(2));
;           if (p.at(len + 2) == (byte)'=' && p.at(len + 3) == (byte)']')
;           {
;               int c = us_ptr2char(p.plus(2));
;               pp[0] = pp[0].plus(len + 4);
;               return c;
;           }
;       }
;       return 0;
    ))

;; Produce the bytes for equivalence class "c".
;; Currently only handles latin1, latin9 and utf-8.
;;
;; NOTE! When changing this function, also change nfa_emit_equi_class()

(defn- #_void reg_equi_class [#_int c]
    (§
;       switch (c)
;       {
;           case 'A':
;           case 0xc0: case 0xc1: case 0xc2:
;           case 0xc3: case 0xc4: case 0xc5:
;           case 0x100: case 0x102: case 0x104:
;           case 0x1cd: case 0x1de: case 0x1e0:
;           case 0x1ea2:
;           {
;               regmbc('A');
;               regmbc(0xc0); regmbc(0xc1); regmbc(0xc2);
;               regmbc(0xc3); regmbc(0xc4); regmbc(0xc5);
;               regmbc(0x100); regmbc(0x102); regmbc(0x104);
;               regmbc(0x1cd); regmbc(0x1de); regmbc(0x1e0);
;               regmbc(0x1ea2);
;               return;
;           }
;           case 'a':
;           case 0xe0: case 0xe1: case 0xe2:
;           case 0xe3: case 0xe4: case 0xe5:
;           case 0x101: case 0x103: case 0x105:
;           case 0x1ce: case 0x1df: case 0x1e1:
;           case 0x1ea3:
;           {
;               regmbc('a');
;               regmbc(0xe0); regmbc(0xe1); regmbc(0xe2);
;               regmbc(0xe3); regmbc(0xe4); regmbc(0xe5);
;               regmbc(0x101); regmbc(0x103); regmbc(0x105);
;               regmbc(0x1ce); regmbc(0x1df); regmbc(0x1e1);
;               regmbc(0x1ea3);
;               return;
;           }

;           case 'B':
;           case 0x1e02: case 0x1e06:
;           {
;               regmbc('B');
;               regmbc(0x1e02); regmbc(0x1e06);
;               return;
;           }
;           case 'b':
;           case 0x1e03: case 0x1e07:
;           {
;               regmbc('b');
;               regmbc(0x1e03); regmbc(0x1e07);
;               return;
;           }

;           case 'C':
;           case 0xc7:
;           case 0x106: case 0x108: case 0x10a: case 0x10c:
;           {
;               regmbc('C');
;               regmbc(0xc7);
;               regmbc(0x106); regmbc(0x108); regmbc(0x10a); regmbc(0x10c);
;               return;
;           }
;           case 'c':
;           case 0xe7:
;           case 0x107: case 0x109: case 0x10b: case 0x10d:
;           {
;               regmbc('c');
;               regmbc(0xe7);
;               regmbc(0x107); regmbc(0x109); regmbc(0x10b); regmbc(0x10d);
;               return;
;           }

;           case 'D':
;           case 0x10e: case 0x110:
;           case 0x1e0a: case 0x1e0c: case 0x1e0e: case 0x1e10: case 0x1e12:
;           {
;               regmbc('D');
;               regmbc(0x10e); regmbc(0x110);
;               regmbc(0x1e0a); regmbc(0x1e0c); regmbc(0x1e0e); regmbc(0x1e10); regmbc(0x1e12);
;               return;
;           }
;           case 'd':
;           case 0x10f: case 0x111:
;           case 0x1e0b: case 0x1e0d: case 0x1e0f: case 0x1e11: case 0x1e13:
;           {
;               regmbc('d');
;               regmbc(0x10f); regmbc(0x111);
;               regmbc(0x1e0b); regmbc(0x1e0d); regmbc(0x1e0f); regmbc(0x1e11); regmbc(0x1e13);
;               return;
;           }

;           case 'E':
;           case 0xc8: case 0xc9: case 0xca: case 0xcb:
;           case 0x112: case 0x114: case 0x116: case 0x118: case 0x11a:
;           case 0x1eba: case 0x1ebc:
;           {
;               regmbc('E');
;               regmbc(0xc8); regmbc(0xc9); regmbc(0xca); regmbc(0xcb);
;               regmbc(0x112); regmbc(0x114); regmbc(0x116); regmbc(0x118); regmbc(0x11a);
;               regmbc(0x1eba); regmbc(0x1ebc);
;               return;
;           }
;           case 'e':
;           case 0xe8: case 0xe9: case 0xea: case 0xeb:
;           case 0x113: case 0x115: case 0x117: case 0x119: case 0x11b:
;           case 0x1ebb: case 0x1ebd:
;           {
;               regmbc('e');
;               regmbc(0xe8); regmbc(0xe9); regmbc(0xea); regmbc(0xeb);
;               regmbc(0x113); regmbc(0x115); regmbc(0x117); regmbc(0x119); regmbc(0x11b);
;               regmbc(0x1ebb); regmbc(0x1ebd);
;               return;
;           }

;           case 'F':
;           case 0x1e1e:
;           {
;               regmbc('F');
;               regmbc(0x1e1e);
;               return;
;           }
;           case 'f':
;           case 0x1e1f:
;           {
;               regmbc('f');
;               regmbc(0x1e1f);
;               return;
;           }

;           case 'G':
;           case 0x11c: case 0x11e: case 0x120: case 0x122:
;           case 0x1e4: case 0x1e6: case 0x1f4:
;           case 0x1e20:
;           {
;               regmbc('G');
;               regmbc(0x11c); regmbc(0x11e); regmbc(0x120); regmbc(0x122);
;               regmbc(0x1e4); regmbc(0x1e6); regmbc(0x1f4);
;               regmbc(0x1e20);
;               return;
;           }
;           case 'g':
;           case 0x11d: case 0x11f: case 0x121: case 0x123:
;           case 0x1e5: case 0x1e7: case 0x1f5:
;           case 0x1e21:
;           {
;               regmbc('g');
;               regmbc(0x11d); regmbc(0x11f); regmbc(0x121); regmbc(0x123);
;               regmbc(0x1e5); regmbc(0x1e7); regmbc(0x1f5);
;               regmbc(0x1e21);
;               return;
;           }

;           case 'H':
;           case 0x124: case 0x126:
;           case 0x1e22: case 0x1e26: case 0x1e28:
;           {
;               regmbc('H');
;               regmbc(0x124); regmbc(0x126);
;               regmbc(0x1e22); regmbc(0x1e26); regmbc(0x1e28);
;               return;
;           }
;           case 'h':
;           case 0x125: case 0x127:
;           case 0x1e23: case 0x1e27: case 0x1e29: case 0x1e96:
;           {
;               regmbc('h');
;               regmbc(0x125); regmbc(0x127);
;               regmbc(0x1e23); regmbc(0x1e27); regmbc(0x1e29); regmbc(0x1e96);
;               return;
;           }

;           case 'I':
;           case 0xcc: case 0xcd: case 0xce: case 0xcf:
;           case 0x128: case 0x12a: case 0x12c: case 0x12e: case 0x130:
;           case 0x1cf:
;           case 0x1ec8:
;           {
;               regmbc('I');
;               regmbc(0xcc); regmbc(0xcd); regmbc(0xce); regmbc(0xcf);
;               regmbc(0x128); regmbc(0x12a); regmbc(0x12c); regmbc(0x12e); regmbc(0x130);
;               regmbc(0x1cf);
;               regmbc(0x1ec8);
;               return;
;           }
;           case 'i':
;           case 0xec: case 0xed: case 0xee: case 0xef:
;           case 0x129: case 0x12b: case 0x12d: case 0x12f: case 0x131:
;           case 0x1d0:
;           case 0x1ec9:
;           {
;               regmbc('i');
;               regmbc(0xec); regmbc(0xed); regmbc(0xee); regmbc(0xef);
;               regmbc(0x129); regmbc(0x12b); regmbc(0x12d); regmbc(0x12f); regmbc(0x131);
;               regmbc(0x1d0);
;               regmbc(0x1ec9);
;               return;
;           }

;           case 'J':
;           case 0x134:
;           {
;               regmbc('J');
;               regmbc(0x134);
;               return;
;           }
;           case 'j':
;           case 0x135: case 0x1f0:
;           {
;               regmbc('j');
;               regmbc(0x135); regmbc(0x1f0);
;               return;
;           }

;           case 'K':
;           case 0x136: case 0x1e8:
;           case 0x1e30: case 0x1e34:
;           {
;               regmbc('K');
;               regmbc(0x136); regmbc(0x1e8);
;               regmbc(0x1e30); regmbc(0x1e34);
;               return;
;           }
;           case 'k':
;           case 0x137: case 0x1e9:
;           case 0x1e31: case 0x1e35:
;           {
;               regmbc('k');
;               regmbc(0x137); regmbc(0x1e9);
;               regmbc(0x1e31); regmbc(0x1e35);
;               return;
;           }

;           case 'L':
;           case 0x139: case 0x13b: case 0x13d: case 0x13f: case 0x141:
;           case 0x1e3a:
;           {
;               regmbc('L');
;               regmbc(0x139); regmbc(0x13b); regmbc(0x13d); regmbc(0x13f); regmbc(0x141);
;               regmbc(0x1e3a);
;               return;
;           }
;           case 'l':
;           case 0x13a: case 0x13c: case 0x13e: case 0x140: case 0x142:
;           case 0x1e3b:
;           {
;               regmbc('l');
;               regmbc(0x13a); regmbc(0x13c); regmbc(0x13e); regmbc(0x140); regmbc(0x142);
;               regmbc(0x1e3b);
;               return;
;           }

;           case 'M':
;           case 0x1e3e: case 0x1e40:
;           {
;               regmbc('M');
;               regmbc(0x1e3e); regmbc(0x1e40);
;               return;
;           }
;           case 'm':
;           case 0x1e3f: case 0x1e41:
;           {
;               regmbc('m');
;               regmbc(0x1e3f); regmbc(0x1e41);
;               return;
;           }

;           case 'N':
;           case 0xd1:
;           case 0x143: case 0x145: case 0x147:
;           case 0x1e44: case 0x1e48:
;           {
;               regmbc('N');
;               regmbc(0xd1);
;               regmbc(0x143); regmbc(0x145); regmbc(0x147);
;               regmbc(0x1e44); regmbc(0x1e48);
;               return;
;           }
;           case 'n':
;           case 0xf1:
;           case 0x144: case 0x146: case 0x148: case 0x149:
;           case 0x1e45: case 0x1e49:
;           {
;               regmbc('n');
;               regmbc(0xf1);
;               regmbc(0x144); regmbc(0x146); regmbc(0x148); regmbc(0x149);
;               regmbc(0x1e45); regmbc(0x1e49);
;               return;
;           }

;           case 'O':
;           case 0xd2: case 0xd3: case 0xd4:
;           case 0xd5: case 0xd6: case 0xd8:
;           case 0x14c: case 0x14e: case 0x150:
;           case 0x1a0: case 0x1d1: case 0x1ea: case 0x1ec:
;           case 0x1ece:
;           {
;               regmbc('O');
;               regmbc(0xd2); regmbc(0xd3); regmbc(0xd4);
;               regmbc(0xd5); regmbc(0xd6); regmbc(0xd8);
;               regmbc(0x14c); regmbc(0x14e); regmbc(0x150);
;               regmbc(0x1a0); regmbc(0x1d1); regmbc(0x1ea); regmbc(0x1ec);
;               regmbc(0x1ece);
;               return;
;           }
;           case 'o':
;           case 0xf2: case 0xf3: case 0xf4:
;           case 0xf5: case 0xf6: case 0xf8:
;           case 0x14d: case 0x14f: case 0x151:
;           case 0x1a1: case 0x1d2: case 0x1eb: case 0x1ed:
;           case 0x1ecf:
;           {
;               regmbc('o');
;               regmbc(0xf2); regmbc(0xf3); regmbc(0xf4);
;               regmbc(0xf5); regmbc(0xf6); regmbc(0xf8);
;               regmbc(0x14d); regmbc(0x14f); regmbc(0x151);
;               regmbc(0x1a1); regmbc(0x1d2); regmbc(0x1eb); regmbc(0x1ed);
;               regmbc(0x1ecf);
;               return;
;           }

;           case 'P':
;           case 0x1e54: case 0x1e56:
;           {
;               regmbc('P');
;               regmbc(0x1e54); regmbc(0x1e56);
;               return;
;           }
;           case 'p':
;           case 0x1e55: case 0x1e57:
;           {
;               regmbc('p');
;               regmbc(0x1e55); regmbc(0x1e57);
;               return;
;           }

;           case 'R':
;           case 0x154: case 0x156: case 0x158:
;           case 0x1e58: case 0x1e5e:
;           {
;               regmbc('R');
;               regmbc(0x154); regmbc(0x156); regmbc(0x158);
;               regmbc(0x1e58); regmbc(0x1e5e);
;               return;
;           }
;           case 'r':
;           case 0x155: case 0x157: case 0x159:
;           case 0x1e59: case 0x1e5f:
;           {
;               regmbc('r');
;               regmbc(0x155); regmbc(0x157); regmbc(0x159);
;               regmbc(0x1e59); regmbc(0x1e5f);
;               return;
;           }

;           case 'S':
;           case 0x15a: case 0x15c: case 0x15e: case 0x160:
;           case 0x1e60:
;           {
;               regmbc('S');
;               regmbc(0x15a); regmbc(0x15c); regmbc(0x15e); regmbc(0x160);
;               regmbc(0x1e60);
;               return;
;           }
;           case 's':
;           case 0x15b: case 0x15d: case 0x15f: case 0x161:
;           case 0x1e61:
;           {
;               regmbc('s');
;               regmbc(0x15b); regmbc(0x15d); regmbc(0x15f); regmbc(0x161);
;               regmbc(0x1e61);
;               return;
;           }

;           case 'T':
;           case 0x162: case 0x164: case 0x166:
;           case 0x1e6a: case 0x1e6e:
;           {
;               regmbc('T');
;               regmbc(0x162); regmbc(0x164); regmbc(0x166);
;               regmbc(0x1e6a); regmbc(0x1e6e);
;               return;
;           }
;           case 't':
;           case 0x163: case 0x165: case 0x167:
;           case 0x1e6b: case 0x1e6f: case 0x1e97:
;           {
;               regmbc('t');
;               regmbc(0x163); regmbc(0x165); regmbc(0x167);
;               regmbc(0x1e6b); regmbc(0x1e6f); regmbc(0x1e97);
;               return;
;           }

;           case 'U':
;           case 0xd9: case 0xda: case 0xdb: case 0xdc:
;           case 0x168: case 0x16a: case 0x16c: case 0x16e:
;           case 0x170: case 0x172: case 0x1af: case 0x1d3:
;           case 0x1ee6:
;           {
;               regmbc('U');
;               regmbc(0xd9); regmbc(0xda); regmbc(0xdb); regmbc(0xdc);
;               regmbc(0x168); regmbc(0x16a); regmbc(0x16c); regmbc(0x16e);
;               regmbc(0x170); regmbc(0x172); regmbc(0x1af); regmbc(0x1d3);
;               regmbc(0x1ee6);
;               return;
;           }
;           case 'u':
;           case 0xf9: case 0xfa: case 0xfb: case 0xfc:
;           case 0x169: case 0x16b: case 0x16d: case 0x16f:
;           case 0x171: case 0x173: case 0x1b0: case 0x1d4:
;           case 0x1ee7:
;           {
;               regmbc('u');
;               regmbc(0xf9); regmbc(0xfa); regmbc(0xfb); regmbc(0xfc);
;               regmbc(0x169); regmbc(0x16b); regmbc(0x16d); regmbc(0x16f);
;               regmbc(0x171); regmbc(0x173); regmbc(0x1b0); regmbc(0x1d4);
;               regmbc(0x1ee7);
;               return;
;           }

;           case 'V':
;           case 0x1e7c:
;           {
;               regmbc('V');
;               regmbc(0x1e7c);
;               return;
;           }
;           case 'v':
;           case 0x1e7d:
;           {
;               regmbc('v');
;               regmbc(0x1e7d);
;               return;
;           }

;           case 'W':
;           case 0x174:
;           case 0x1e80: case 0x1e82: case 0x1e84: case 0x1e86:
;           {
;               regmbc('W');
;               regmbc(0x174);
;               regmbc(0x1e80); regmbc(0x1e82); regmbc(0x1e84); regmbc(0x1e86);
;               return;
;           }
;           case 'w':
;           case 0x175:
;           case 0x1e81: case 0x1e83: case 0x1e85: case 0x1e87: case 0x1e98:
;           {
;               regmbc('w');
;               regmbc(0x175);
;               regmbc(0x1e81); regmbc(0x1e83); regmbc(0x1e85); regmbc(0x1e87); regmbc(0x1e98);
;               return;
;           }

;           case 'X':
;           case 0x1e8a: case 0x1e8c:
;           {
;               regmbc('X');
;               regmbc(0x1e8a); regmbc(0x1e8c);
;               return;
;           }
;           case 'x':
;           case 0x1e8b: case 0x1e8d:
;           {
;               regmbc('x');
;               regmbc(0x1e8b); regmbc(0x1e8d);
;               return;
;           }

;           case 'Y':
;           case 0xdd:
;           case 0x176: case 0x178:
;           case 0x1e8e: case 0x1ef2: case 0x1ef6: case 0x1ef8:
;           {
;               regmbc('Y');
;               regmbc(0xdd);
;               regmbc(0x176); regmbc(0x178);
;               regmbc(0x1e8e); regmbc(0x1ef2); regmbc(0x1ef6); regmbc(0x1ef8);
;               return;
;           }
;           case 'y':
;           case 0xfd: case 0xff:
;           case 0x177:
;           case 0x1e8f: case 0x1e99: case 0x1ef3: case 0x1ef7: case 0x1ef9:
;           {
;               regmbc('y');
;               regmbc(0xfd); regmbc(0xff);
;               regmbc(0x177);
;               regmbc(0x1e8f); regmbc(0x1e99); regmbc(0x1ef3); regmbc(0x1ef7); regmbc(0x1ef9);
;               return;
;           }

;           case 'Z':
;           case 0x179: case 0x17b: case 0x17d: case 0x1b5:
;           case 0x1e90: case 0x1e94:
;           {
;               regmbc('Z');
;               regmbc(0x179); regmbc(0x17b); regmbc(0x17d); regmbc(0x1b5);
;               regmbc(0x1e90); regmbc(0x1e94);
;               return;
;           }
;           case 'z':
;           case 0x17a: case 0x17c: case 0x17e: case 0x1b6:
;           case 0x1e91: case 0x1e95:
;           {
;               regmbc('z');
;               regmbc(0x17a); regmbc(0x17c); regmbc(0x17e); regmbc(0x1b6);
;               regmbc(0x1e91); regmbc(0x1e95);
;               return;
;           }
;       }

;       regmbc(c);
    ))

;; Check for a collating element "[.a.]".  "pp" points to the '['.
;; Returns a character.  Zero means that no item was recognized.
;; Otherwise "pp" is advanced to after the item.
;; Currently only single characters are recognized!

(defn- #_int get_coll_element [#_Bytes* pp]
    (§
;       Bytes p = pp[0];

;       if (p.at(1) == (byte)'.')
;       {
;           int len = us_ptr2len_cc(p.plus(2));
;           if (p.at(len + 2) == (byte)'.' && p.at(len + 3) == (byte)']')
;           {
;               int c = us_ptr2char(p.plus(2));
;               pp[0] = pp[0].plus(len + 4);
;               return c;
;           }
;       }

;       return 0;
    ))

(atom! boolean reg_cpo_lit)     ;; 'cpoptions' contains 'l' flag
(atom! boolean reg_cpo_bsl)     ;; 'cpoptions' contains '\' flag

(defn- #_void get_cpo_flags []
    (§
;       @reg_cpo_lit = (vim_strbyte(@p_cpo, CPO_LITERAL) != null);
;       @reg_cpo_bsl = (vim_strbyte(@p_cpo, CPO_BACKSL) != null);
    ))

;; Skip over a "[]" range.
;; "p" must point to the character after the '['.
;; The returned pointer is on the matching ']', or the terminating NUL.

(defn- #_Bytes skip_anyof [#_Bytes p]
    (§
;       if (p.at(0) == (byte)'^')      ;; Complement of range.
;           p = p.plus(1);
;       if (p.at(0) == (byte)']' || p.at(0) == (byte)'-')
;           p = p.plus(1);
;       while (p.at(0) != NUL && p.at(0) != (byte)']')
;       {
;           int l = us_ptr2len_cc(p);
;           if (1 < l)
;               p = p.plus(l);
;           else if (p.at(0) == (byte)'-')
;           {
;               p = p.plus(1);
;               if (p.at(0) != (byte)']' && p.at(0) != NUL)
;                   p = p.plus(us_ptr2len_cc(p));
;           }
;           else if (p.at(0) == (byte)'\\'
;                   && !@reg_cpo_bsl
;                   && (vim_strchr(REGEXP_INRANGE, p.at(1)) != null
;                       || (!@reg_cpo_lit && vim_strchr(REGEXP_ABBR, p.at(1)) != null)))
;               p = p.plus(2);
;           else if (p.at(0) == (byte)'[')
;           {
;               boolean b;
;               { Bytes[] __ = { p }; b = (get_char_class(__) == CLASS_NONE && get_equi_class(__) == 0 && get_coll_element(__) == 0); p = __[0]; }
;               if (b)
;                   p = p.plus(1); ;; not a class name
;           }
;           else
;               p = p.plus(1);
;       }

;       return p;
    ))

;; Skip past regular expression.
;; Stop at end of "startp" or where "dirc" is found ('/', '?', etc).
;; Take care of characters with a backslash in front of it.
;; Skip strings inside [ and ].
;; When "newp" is not null and "dirc" is '?', make an allocated copy of the expression
;; and change "\?" to "?".  If "*newp" is not null the expression is changed in-place.

(defn- #_Bytes skip_regexp [#_Bytes startp, #_byte dirc, #_boolean magic, #_Bytes* newp]
    (§
;       Bytes p = startp;

;       int mymagic;
;       if (magic)
;           mymagic = MAGIC_ON;
;       else
;           mymagic = MAGIC_OFF;

;       get_cpo_flags();

;       for ( ; p.at(0) != NUL; p = p.plus(us_ptr2len_cc(p)))
;       {
;           if (p.at(0) == dirc)       ;; found end of regexp
;               break;
;           if ((p.at(0) == (byte)'[' && MAGIC_ON <= mymagic) || (p.at(0) == (byte)'\\' && p.at(1) == (byte)'[' && mymagic <= MAGIC_OFF))
;           {
;               p = skip_anyof(p.plus(1));
;               if (p.at(0) == NUL)
;                   break;
;           }
;           else if (p.at(0) == (byte)'\\' && p.at(1) != NUL)
;           {
;               if (dirc == '?' && newp != null && p.at(1) == (byte)'?')
;               {
                    ;; change "\?" to "?", make a copy first.
;                   if (newp[0] == null)
;                   {
;                       newp[0] = STRDUP(startp);
;                       p = newp[0].plus(BDIFF(p, startp));
;                   }
;                   if (newp[0] != null)
;                       BCOPY(p, 0, p, 1, STRLEN(p, 1) + 1);
;                   else
;                       p = p.plus(1);
;               }
;               else
;                   p = p.plus(1);    ;; skip next character
;               if (p.at(0) == (byte)'v')
;                   mymagic = MAGIC_ALL;
;               else if (p.at(0) == (byte)'V')
;                   mymagic = MAGIC_NONE;
;           }
;       }

;       return p;
    ))

;; bt_regcomp() - compile a regular expression into internal code for the
;; traditional back track matcher.
;; Returns the program in allocated space.  Returns null for an error.
;;
;; We can't allocate space until we know how big the compiled form will be,
;; but we can't compile it (and thus know how big it is) until we've got a
;; place to put the code.  So we cheat:  we compile it twice, once with code
;; generation turned off and size counting turned on, and once "for real".
;; This also means that we don't allocate space until we are sure that the
;; thing really will compile successfully, and we never have to move the
;; code and thus invalidate pointers into it.
;;
;; Whether upper/lower case is to be ignored is decided when executing the
;; program, it does not matter here.
;;
;; Beware that the optimization-preparation code in here knows about some
;; of the structure of the compiled regexp.
;; "re_flags": RE_MAGIC and/or RE_STRING.

(defn- #_regprog_C bt_regcomp [#_Bytes expr, #_int re_flags]
    (§
;       if (expr == null)
;       {
;           emsg(e_null);
;           @rc_did_emsg = true;
;           return null;
;       }

;       init_class_tab();

        ;; First pass: determine size, legality.

;       regcomp_start(expr, re_flags);
;       @regcode = JUST_CALC_SIZE;
;       regc(REGMAGIC);
;       int[] flags = new int[1];
;       if (reg(REG_NOPAREN, flags) == null)
;           return null;

        ;; Allocate space.
;       bt_regprog_C r = new bt_regprog_C();
;       r.program = new Bytes(@regsize + 1);

        ;; Second pass: emit code.

;       regcomp_start(expr, re_flags);
;       @regcode = r.program;
;       regc(REGMAGIC);
;       if (reg(REG_NOPAREN, flags) == null || @reg_toolong)
;       {
;           if (@reg_toolong)
;           {
;               emsg(u8("E339: Pattern too long"));
;               @rc_did_emsg = true;
;           }
;           return null;
;       }

        ;; Dig out information for optimizations.
;       r.regstart = NUL;                   ;; Worst-case defaults.
;       r.reganch = 0;
;       r.regmust = null;
;       r.regmlen = 0;
;       r.regflags = @regflags;
;       if ((flags[0] & HASNL) != 0)
;           r.regflags |= RF_HASNL;
;       if ((flags[0] & HASLOOKBH) != 0)
;           r.regflags |= RF_LOOKBH;
        ;; Remember whether this pattern has any \z specials in it.
;       r.reghasz = @re_has_z;

;       Bytes scan = r.program.plus(1);        ;; First BRANCH.
;       if (re_op(regnext(scan)) == END)    ;; Only one top-level choice.
;       {
;           scan = operand(scan);

            ;; Starting-point info.
;           if (re_op(scan) == BOL || re_op(scan) == RE_BOF)
;           {
;               r.reganch++;
;               scan = regnext(scan);
;           }

;           if (re_op(scan) == EXACTLY)
;           {
;               r.regstart = us_ptr2char(operand(scan));
;           }
;           else if ((re_op(scan) == BOW
;                       || re_op(scan) == EOW
;                       || re_op(scan) == NOTHING
;                       || re_op(scan) == MOPEN + 0 || re_op(scan) == NOPEN
;                       || re_op(scan) == MCLOSE + 0 || re_op(scan) == NCLOSE)
;                    && re_op(regnext(scan)) == EXACTLY)
;           {
;               r.regstart = us_ptr2char(operand(regnext(scan)));
;           }

            ;; If there's something expensive in the r.e., find the longest literal string
            ;; that must appear and make it the regmust.  Resolve ties in favor of later strings,
            ;; since the regstart check works with the beginning of the r.e. and avoiding duplication
            ;; strengthens checking.  Not a strong reason, but sufficient in the absence of others.

            ;; When the r.e. starts with BOW, it is faster to look for a regmust first.
            ;; Used a lot for "#" and "*" commands.

;           if (((flags[0] & SPSTART) != 0 || re_op(scan) == BOW || re_op(scan) == EOW) && (flags[0] & HASNL) == 0)
;           {
;               Bytes longest = null;
;               int len = 0;
;               for ( ; scan != null; scan = regnext(scan))
;                   if (re_op(scan) == EXACTLY && len <= STRLEN(operand(scan)))
;                   {
;                       longest = operand(scan);
;                       len = STRLEN(operand(scan));
;                   }
;               r.regmust = longest;
;               r.regmlen = len;
;           }
;       }

;       r.engine = bt_regengine;
;       return (regprog_C)r;
    ))

;; Setup to parse the regexp.  Used once to get the length and once to do it.

(defn- #_void regcomp_start [#_Bytes expr, #_int re_flags]
    ;; re_flags: see vim_regcomp()
    (§
;       initchr(expr);
;       if ((re_flags & RE_MAGIC) != 0)
;           @reg_magic = MAGIC_ON;
;       else
;           @reg_magic = MAGIC_OFF;
;       @reg_string = ((re_flags & RE_STRING) != 0);
;       @reg_strict = ((re_flags & RE_STRICT) != 0);
;       get_cpo_flags();

;       @num_complex_braces = 0;
;       @regnpar = 1;
;       AFILL(@had_endbrace, false);
;       @regnzpar = 1;
;       @re_has_z = 0;
;       @regsize = 0;
;       @reg_toolong = false;
;       @regflags = 0;
;       @had_eol = false;
    ))

;; Check if during the previous call to vim_regcomp the EOL item "$" has been found.
;; This is messy, but it works fine.

(defn- #_boolean vim_regcomp_had_eol []
    (§
;       return @had_eol;
    ))

;; Parse regular expression, i.e. main body or parenthesized thing.
;;
;; Caller must absorb opening parenthesis.
;;
;; Combining parenthesis handling with the base level of regular expression
;; is a trifle forced, but the need to tie the tails of the branches to what
;; follows makes it hard to avoid.

(defn- #_Bytes reg [#_int paren, #_int* flagp]
    ;; paren: REG_NOPAREN, REG_PAREN, REG_NPAREN or REG_ZPAREN
    (§
;       Bytes ret;

;       flagp[0] = HASWIDTH;          ;; Tentatively.

;       int parno = 0;
;       if (paren == REG_ZPAREN)
;       {
            ;; Make a ZOPEN node.
;           if (NSUBEXP <= @regnzpar)
;           {
;               emsg(u8("E50: Too many \\z("));
;               @rc_did_emsg = true;
;               return null;
;           }
;           parno = @regnzpar;
;           @regnzpar++;
;           ret = regnode(ZOPEN + parno);
;       }
;       else if (paren == REG_PAREN)
;       {
            ;; Make a MOPEN node.
;           if (NSUBEXP <= @regnpar)
;           {
;               emsg2(u8("E51: Too many %s("), (@reg_magic == MAGIC_ALL) ? u8("") : u8("\\"));
;               @rc_did_emsg = true;
;               return null;
;           }
;           parno = @regnpar;
;           @regnpar++;
;           ret = regnode(MOPEN + parno);
;       }
;       else if (paren == REG_NPAREN)
;       {
            ;; Make a NOPEN node.
;           ret = regnode(NOPEN);
;       }
;       else
;           ret = null;

        ;; Pick up the branches, linking them together.
;       int[] flags = new int[1];
;       Bytes br = regbranch(flags);
;       if (br == null)
;           return null;
;       if (ret != null)
;           regtail(ret, br);       ;; [MZ]OPEN -> first.
;       else
;           ret = br;
        ;; If one of the branches can be zero-width, the whole thing can.
        ;; If one of the branches has * at start or matches a line-break, the whole thing can.
;       if ((flags[0] & HASWIDTH) == 0)
;           flagp[0] &= ~HASWIDTH;
;       flagp[0] |= flags[0] & (SPSTART | HASNL | HASLOOKBH);
;       while (peekchr() == Magic('|'))
;       {
;           skipchr();
;           br = regbranch(flags);
;           if (br == null || @reg_toolong)
;               return null;
;           regtail(ret, br);       ;; BRANCH -> BRANCH.
;           if ((flags[0] & HASWIDTH) == 0)
;               flagp[0] &= ~HASWIDTH;
;           flagp[0] |= flags[0] & (SPSTART | HASNL | HASLOOKBH);
;       }

        ;; Make a closing node, and hook it on the end.
;       Bytes ender = regnode(
;               (paren == REG_ZPAREN) ? ZCLOSE + parno :
;                   (paren == REG_PAREN) ? MCLOSE + parno :
;                       (paren == REG_NPAREN) ? NCLOSE : END);
;       regtail(ret, ender);

        ;; Hook the tails of the branches to the closing node.
;       for (br = ret; br != null; br = regnext(br))
;           regoptail(br, ender);

        ;; Check for proper termination.
;       if (paren != REG_NOPAREN && getchr() != Magic(')'))
;       {
;           if (paren == REG_ZPAREN)
;               emsg(u8("E52: Unmatched \\z("));
;           else if (paren == REG_NPAREN)
;               emsg2(e_unmatchedpp, (@reg_magic == MAGIC_ALL) ? u8("") : u8("\\"));
;           else
;               emsg2(e_unmatchedp, (@reg_magic == MAGIC_ALL) ? u8("") : u8("\\"));
;           @rc_did_emsg = true;
;           return null;
;       }
;       else if (paren == REG_NOPAREN && peekchr() != NUL)
;       {
;           if (@curchr == Magic(')'))
;               emsg2(e_unmatchedpar, (@reg_magic == MAGIC_ALL) ? u8("") : u8("\\"));
;           else
;               emsg(e_trailing);
;           @rc_did_emsg = true;
;           return null;                    ;; "Can't happen".
;       }

        ;; Here we set the flag allowing back references to this set of parentheses.

;       if (paren == REG_PAREN)
;           @had_endbrace[parno] = true;     ;; have seen the close paren
;       return ret;
    ))

;; Parse one alternative of an | operator.
;; Implements the & operator.

(defn- #_Bytes regbranch [#_int* flagp]
    (§
;       flagp[0] = (WORST | HASNL);           ;; Tentatively.

;       Bytes ret = regnode(BRANCH);

;       for (Bytes chain = null; ; )
;       {
;           int[] flags = new int[1];
;           Bytes latest = regconcat(flags);
;           if (latest == null)
;               return null;

            ;; If one of the branches has width, the whole thing has.
            ;; If one of the branches anchors at start-of-line, the whole thing does.
            ;; If one of the branches uses look-behind, the whole thing does.
;           flagp[0] |= flags[0] & (HASWIDTH | SPSTART | HASLOOKBH);
            ;; If one of the branches doesn't match a line-break, the whole thing doesn't.
;           flagp[0] &= ~HASNL | (flags[0] & HASNL);
;           if (chain != null)
;               regtail(chain, latest);
;           if (peekchr() != Magic('&'))
;               break;

;           skipchr();
;           regtail(latest, regnode(END)); ;; operand ends
;           if (@reg_toolong)
;               break;

;           reginsert(MATCH, latest);
;           chain = latest;
;       }

;       return ret;
    ))

;; Parse one alternative of an | or & operator.
;; Implements the concatenation operator.

(defn- #_Bytes regconcat [#_int* flagp]
    (§
;       Bytes first = null;
;       Bytes chain = null;

;       flagp[0] = WORST;             ;; Tentatively.

;       for (boolean cont = true; cont; )
;       {
;           switch (peekchr())
;           {
;               case NUL:
;               case -132: // case Magic('|'):
;               case -218: // case Magic('&'):
;               case -215: // case Magic(')'):
;                   cont = false;
;                   break;

;               case -166: // case Magic('Z'):
;                   @regflags |= RF_ICOMBINE;
;                   skipchr_keepstart();
;                   break;

;               case -157: // case Magic('c'):
;                   @regflags |= RF_ICASE;
;                   skipchr_keepstart();
;                   break;

;               case -189: // case Magic('C'):
;                   @regflags |= RF_NOICASE;
;                   skipchr_keepstart();
;                   break;

;               case -138: // case Magic('v'):
;                   @reg_magic = MAGIC_ALL;
;                   skipchr_keepstart();
;                   @curchr = -1;
;                   break;

;               case -147: // case Magic('m'):
;                   @reg_magic = MAGIC_ON;
;                   skipchr_keepstart();
;                   @curchr = -1;
;                   break;

;               case -179: // case Magic('M'):
;                   @reg_magic = MAGIC_OFF;
;                   skipchr_keepstart();
;                   @curchr = -1;
;                   break;

;               case -170: // case Magic('V'):
;                   @reg_magic = MAGIC_NONE;
;                   skipchr_keepstart();
;                   @curchr = -1;
;                   break;

;               default:
;               {
;                   int[] flags = new int[1];
;                   Bytes latest = regpiece(flags);
;                   if (latest == null || @reg_toolong)
;                       return null;

;                   flagp[0] |= flags[0] & (HASWIDTH | HASNL | HASLOOKBH);
;                   if (chain == null)  ;; First piece.
;                       flagp[0] |= flags[0] & SPSTART;
;                   else
;                       regtail(chain, latest);
;                   chain = latest;
;                   if (first == null)
;                       first = latest;
;                   break;
;               }
;           }
;       }

;       if (first == null)          ;; Loop ran zero times.
;           first = regnode(NOTHING);
;       return first;
    ))

;; Parse something followed by possible [*+=].
;;
;; Note that the branching code sequences used for = and the general cases
;; of * and + are somewhat optimized:  they use the same NOTHING node as
;; both the endmarker for their branch list and the body of the last branch.
;; It might seem that this node could be dispensed with entirely, but the
;; endmarker role is not redundant.

(defn- #_Bytes regpiece [#_int* flagp]
    (§
;       int[] flags = new int[1];
;       Bytes ret = regatom(flags);
;       if (ret == null)
;           return null;

;       int op = peekchr();
;       if (re_multi_type(op) == NOT_MULTI)
;       {
;           flagp[0] = flags[0];
;           return ret;
;       }

        ;; default flags
;       flagp[0] = (WORST | SPSTART | (flags[0] & (HASNL | HASLOOKBH)));

;       skipchr();
;       switch (op)
;       {
;           case -214: // case Magic('*'):
;           {
;               if ((flags[0] & SIMPLE) != 0)
;                   reginsert(STAR, ret);
;               else
;               {
                    ;; Emit x* as (x&|), where & means "self".
;                   reginsert(BRANCH, ret);             ;; Either x
;                   regoptail(ret, regnode(BACK));      ;; and loop
;                   regoptail(ret, ret);                ;; back
;                   regtail(ret, regnode(BRANCH));      ;; or
;                   regtail(ret, regnode(NOTHING));     ;; null.
;               }
;               break;
;           }

;           case -213: // case Magic('+'):
;           {
;               if ((flags[0] & SIMPLE) != 0)
;                   reginsert(PLUS, ret);
;               else
;               {
                    ;; Emit x+ as x(&|), where & means "self".
;                   Bytes next = regnode(BRANCH);      ;; Either
;                   regtail(ret, next);
;                   regtail(regnode(BACK), ret);        ;; loop back
;                   regtail(next, regnode(BRANCH));     ;; or
;                   regtail(ret, regnode(NOTHING));     ;; null.
;               }
;               flagp[0] = (WORST | HASWIDTH | (flags[0] & (HASNL | HASLOOKBH)));
;               break;
;           }

;           case -192: // case Magic('@'):
;           {
;               int lop = END;
;               int nr = getdecchrs();

;               switch (no_Magic(getchr()))
;               {
;                   case '=': lop = MATCH; break;                   ;; \@=
;                   case '!': lop = NOMATCH; break;                 ;; \@!
;                   case '>': lop = SUBPAT; break;                  ;; \@>
;                   case '<': switch (no_Magic(getchr()))
;                             {
;                                 case '=': lop = BEHIND; break;    ;; \@<=
;                                 case '!': lop = NOBEHIND; break;  ;; \@<!
;                             }
;                             break;
;               }
;               if (lop == END)
;               {
;                   emsg2(u8("E59: invalid character after %s@"), (@reg_magic == MAGIC_ALL) ? u8("") : u8("\\"));
;                   @rc_did_emsg = true;
;                   return null;
;               }
                ;; Look behind must match with behind_pos.
;               if (lop == BEHIND || lop == NOBEHIND)
;               {
;                   regtail(ret, regnode(BHPOS));
;                   flagp[0] |= HASLOOKBH;
;               }
;               regtail(ret, regnode(END));                 ;; operand ends
;               if (lop == BEHIND || lop == NOBEHIND)
;               {
;                   if (nr < 0)
;                       nr = 0;                             ;; no limit is same as zero limit
;                   reginsert_nr(lop, nr, ret);
;               }
;               else
;                   reginsert(lop, ret);
;               break;
;           }

;           case -193: // case Magic('?'):
;           case -195: // case Magic('='):
;           {
                ;; Emit x= as (x|).
;               reginsert(BRANCH, ret);                 ;; Either x
;               regtail(ret, regnode(BRANCH));          ;; or
;               Bytes next = regnode(NOTHING);         ;; null.
;               regtail(ret, next);
;               regoptail(ret, next);
;               break;
;           }

;           case -133: // case Magic('{'):
;           {
;               long[] minval = new long[1];
;               long[] maxval = new long[1];
;               if (!read_limits(minval, maxval))
;                   return null;

;               if ((flags[0] & SIMPLE) != 0)
;               {
;                   reginsert(BRACE_SIMPLE, ret);
;                   reginsert_limits(BRACE_LIMITS, minval[0], maxval[0], ret);
;               }
;               else
;               {
;                   if (10 <= @num_complex_braces)
;                   {
;                       emsg2(u8("E60: Too many complex %s{...}s"), (@reg_magic == MAGIC_ALL) ? u8("") : u8("\\"));
;                       @rc_did_emsg = true;
;                       return null;
;                   }
;                   reginsert(BRACE_COMPLEX + @num_complex_braces, ret);
;                   regoptail(ret, regnode(BACK));
;                   regoptail(ret, ret);
;                   reginsert_limits(BRACE_LIMITS, minval[0], maxval[0], ret);
;                   @num_complex_braces++;
;               }
;               if (0 < minval[0] && 0 < maxval[0])
;                   flagp[0] = (HASWIDTH | (flags[0] & (HASNL | HASLOOKBH)));
;               break;
;           }
;       }

;       if (re_multi_type(peekchr()) != NOT_MULTI)
;       {
            ;; Can't have a multi follow a multi.
;           if (peekchr() == Magic('*'))
;               libC.sprintf(@ioBuff, u8("E61: Nested %s*"), (MAGIC_ON <= @reg_magic) ? u8("") : u8("\\"));
;           else
;               libC.sprintf(@ioBuff, u8("E62: Nested %s%c"), (@reg_magic == MAGIC_ALL) ? u8("") : u8("\\"), no_Magic(peekchr()));

;           emsg(@ioBuff);
;           @rc_did_emsg = true;
;           return null;
;       }

;       return ret;
    ))

;; When making changes to "classchars" also change "nfa_classcodes".
(final Bytes classchars (u8 ".iIkKfFpPsSdDxXoOwWhHaAlLuU"))
(final int* classcodes
    [
        ANY,
        IDENT, SIDENT,
        KWORD, SKWORD,
        FNAME, SFNAME,
        PRINT, SPRINT,
        WHITE, NWHITE,
        DIGIT, NDIGIT,
        HEX,   NHEX,
        OCTAL, NOCTAL,
        WORD,  NWORD,
        HEAD,  NHEAD,
        ALPHA, NALPHA,
        LOWER, NLOWER,
        UPPER, NUPPER
    ])

;; Parse the lowest level.
;;
;; Optimization:  gobbles an entire sequence of ordinary characters so that
;; it can turn them into a single node, which is smaller to store and
;; faster to run.  Don't do this when one_exactly is set.

(defn- #_Bytes regatom [#_int* flagp]
    (§
;       Bytes ret;

;       int extra = 0;

;       flagp[0] = WORST;             ;; Tentatively.

;       int c = getchr();

;       collection:
;       {
;           switch (c)
;           {
;               case -162: // case Magic('^'):
;                   ret = regnode(BOL);
;                   break;

;               case -220: // case Magic('$'):
;                   ret = regnode(EOL);
;                   @had_eol = true;
;                   break;

;               case -196: // case Magic('<'):
;                   ret = regnode(BOW);
;                   break;

;               case -194: // case Magic('>'):
;                   ret = regnode(EOW);
;                   break;

;               case -161: // case Magic('_'):
;               {
;                   c = no_Magic(getchr());
;                   if (c == '^')           ;; "\_^" is start-of-line
;                   {
;                       ret = regnode(BOL);
;                       break;
;                   }
;                   if (c == '$')           ;; "\_$" is end-of-line
;                   {
;                       ret = regnode(EOL);
;                       @had_eol = true;
;                       break;
;                   }

;                   extra = ADD_NL;
;                   flagp[0] |= HASNL;

                    ;; "\_[" is character range plus newline
;                   if (c == '[')
;                       break collection;

                    ;; "\_x" is character class plus newline
                    ;; FALLTHROUGH
;               }

                ;; Character classes.

;               case -210: // case Magic('.'):
;               case -151: // case Magic('i'):
;               case -183: // case Magic('I'):
;               case -149: // case Magic('k'):
;               case -181: // case Magic('K'):
;               case -154: // case Magic('f'):
;               case -186: // case Magic('F'):
;               case -144: // case Magic('p'):
;               case -176: // case Magic('P'):
;               case -141: // case Magic('s'):
;               case -173: // case Magic('S'):
;               case -156: // case Magic('d'):
;               case -188: // case Magic('D'):
;               case -136: // case Magic('x'):
;               case -168: // case Magic('X'):
;               case -145: // case Magic('o'):
;               case -177: // case Magic('O'):
;               case -137: // case Magic('w'):
;               case -169: // case Magic('W'):
;               case -152: // case Magic('h'):
;               case -184: // case Magic('H'):
;               case -159: // case Magic('a'):
;               case -191: // case Magic('A'):
;               case -148: // case Magic('l'):
;               case -180: // case Magic('L'):
;               case -139: // case Magic('u'):
;               case -171: // case Magic('U'):
;               {
;                   Bytes p = vim_strchr(classchars, no_Magic(c));
;                   if (p == null)
;                   {
;                       emsg(u8("E63: invalid use of \\_"));
;                       @rc_did_emsg = true;
;                       return null;
;                   }
                    ;; When '.' is followed by a composing char ignore the dot,
                    ;; so that the composing char is matched here.
;                   if (c == Magic('.') && utf_iscomposing(peekchr()))
;                   {
;                       c = getchr();
;                       ret = regnode(MULTIBYTECODE);
;                       regmbc(c);
;                       flagp[0] |= HASWIDTH | SIMPLE;
;                       break;
;                   }
;                   ret = regnode(classcodes[BDIFF(p, classchars)] + extra);
;                   flagp[0] |= HASWIDTH | SIMPLE;
;                   break;
;               }

;               case -146: // case Magic('n'):
;               {
;                   if (@reg_string)
;                   {
                        ;; In a string "\n" matches a newline character.
;                       ret = regnode(EXACTLY);
;                       regc(NL);
;                       regc(NUL);
;                       flagp[0] |= HASWIDTH | SIMPLE;
;                   }
;                   else
;                   {
                        ;; In buffer text "\n" matches the end of a line.
;                       ret = regnode(NEWL);
;                       flagp[0] |= HASWIDTH | HASNL;
;                   }
;                   break;
;               }

;               case -216: // case Magic('('):
;               {
;                   if (@one_exactly)
;                   {
;                       emsg2(u8("E369: invalid item in %s%%[]"), (@reg_magic == MAGIC_ALL) ? u8("") : u8("\\"));
;                       @rc_did_emsg = true;
;                       return null;
;                   }
;                   int[] flags = new int[1];
;                   ret = reg(REG_PAREN, flags);
;                   if (ret == null)
;                       return null;
;                   flagp[0] |= flags[0] & (HASWIDTH | SPSTART | HASNL | HASLOOKBH);
;                   break;
;               }

;               case NUL:
;               case -132: // case Magic('|'):
;               case -218: // case Magic('&'):
;               case -215: // case Magic(')'):
;               {
;                   if (@one_exactly)
;                       emsg2(u8("E369: invalid item in %s%%[]"), (@reg_magic == MAGIC_ALL) ? u8("") : u8("\\"));
;                   else
;                       emsg(e_internal);       ;; Supposed to be caught earlier.
;                   @rc_did_emsg = true;
;                   return null;
;               }

;               case -195: // case Magic('='):
;               case -193: // case Magic('?'):
;               case -213: // case Magic('+'):
;               case -192: // case Magic('@'):
;               case -133: // case Magic('{'):
;               case -214: // case Magic('*'):
;               {
;                   c = no_Magic(c);
;                   libC.sprintf(@ioBuff, u8("E64: %s%c follows nothing"),
;                           (c == '*' ? MAGIC_ON <= @reg_magic : @reg_magic == MAGIC_ALL) ? u8("") : u8("\\"), c);

;                   emsg(@ioBuff);
;                   @rc_did_emsg = true;
;                   return null;
;               }

;               case -130: // case Magic('~'):                    ;; previous substitute pattern
;               {
;                   if (@reg_prev_sub != null)
;                   {
;                       ret = regnode(EXACTLY);
;                       Bytes lp = @reg_prev_sub;
;                       while (lp.at(0) != NUL)
;                           regc((lp = lp.plus(1)).at(-1));
;                       regc(NUL);
;                       if (@reg_prev_sub.at(0) != NUL)
;                       {
;                           flagp[0] |= HASWIDTH;
;                           if (BDIFF(lp, @reg_prev_sub) == 1)
;                               flagp[0] |= SIMPLE;
;                       }
;                   }
;                   else
;                   {
;                       emsg(e_nopresub);
;                       @rc_did_emsg = true;
;                       return null;
;                   }
;                   break;
;               }

;               case -207: // case Magic('1'):
;               case -206: // case Magic('2'):
;               case -205: // case Magic('3'):
;               case -204: // case Magic('4'):
;               case -203: // case Magic('5'):
;               case -202: // case Magic('6'):
;               case -201: // case Magic('7'):
;               case -200: // case Magic('8'):
;               case -199: // case Magic('9'):
;               {
;                   int refnum = c - Magic('0');

                    ;; Check if the back reference is legal.  We must have seen the close brace.
                    ;; TODO: Should also check that we don't refer to something
                    ;; that is repeated (+*=): what instance of the repetition should we match?

;                   if (!@had_endbrace[refnum])
;                   {
                        ;; Trick: check if "@<=" or "@<!" follows, in which case
                        ;; the \1 can appear before the referenced match.
;                       Bytes p;
;                       for (p = @regparse; p.at(0) != NUL; p = p.plus(1))
;                           if (p.at(0) == (byte)'@' && p.at(1) == (byte)'<' && (p.at(2) == (byte)'!' || p.at(2) == (byte)'='))
;                               break;
;                       if (p.at(0) == NUL)
;                       {
;                           emsg(u8("E65: Illegal back reference"));
;                           @rc_did_emsg = true;
;                           return null;
;                       }
;                   }
;                   ret = regnode(BACKREF + refnum);
;                   break;
;               }

;               case -134: // case Magic('z'):
;               {
;                   c = no_Magic(getchr());
;                   switch (c)
;                   {
;                       case '(':
;                       {
;                           if (@reg_do_extmatch != REX_SET)
;                           {
;                               emsg(e_z_not_allowed);
;                               @rc_did_emsg = true;
;                               return null;
;                           }
;                           if (@one_exactly)
;                           {
;                               emsg2(u8("E369: invalid item in %s%%[]"), (@reg_magic == MAGIC_ALL) ? u8("") : u8("\\"));
;                               @rc_did_emsg = true;
;                               return null;
;                           }
;                           int[] flags = new int[1];
;                           ret = reg(REG_ZPAREN, flags);
;                           if (ret == null)
;                               return null;
;                           flagp[0] |= flags[0] & (HASWIDTH|SPSTART|HASNL|HASLOOKBH);
;                           @re_has_z = REX_SET;
;                           break;
;                       }
;                       case '1':
;                       case '2':
;                       case '3':
;                       case '4':
;                       case '5':
;                       case '6':
;                       case '7':
;                       case '8':
;                       case '9':
;                       {
;                           if (@reg_do_extmatch != REX_USE)
;                           {
;                               emsg(e_z1_not_allowed);
;                               @rc_did_emsg = true;
;                               return null;
;                           }
;                           ret = regnode(ZREF + c - '0');
;                           @re_has_z = REX_USE;
;                           break;
;                       }
;                       case 's':
;                       {
;                           ret = regnode(MOPEN + 0);
;                           if (re_mult_next(u8("\\zs")) == false)
;                               return null;
;                           break;
;                       }
;                       case 'e':
;                       {
;                           ret = regnode(MCLOSE + 0);
;                           if (re_mult_next(u8("\\ze")) == false)
;                               return null;
;                           break;
;                       }
;                       default:
;                       {
;                           emsg(u8("E68: Invalid character after \\z"));
;                           @rc_did_emsg = true;
;                           return null;
;                       }
;                   }
;                   break;
;               }

;               case -219: // case Magic('%'):
;               {
;                   c = no_Magic(getchr());
;                   switch (c)
;                   {
                        ;; () without a back reference
;                       case '(':
;                       {
;                           if (@one_exactly)
;                           {
;                               emsg2(u8("E369: invalid item in %s%%[]"), (@reg_magic == MAGIC_ALL) ? u8("") : u8("\\"));
;                               @rc_did_emsg = true;
;                               return null;
;                           }
;                           int[] flags = new int[1];
;                           ret = reg(REG_NPAREN, flags);
;                           if (ret == null)
;                               return null;
;                           flagp[0] |= flags[0] & (HASWIDTH | SPSTART | HASNL | HASLOOKBH);
;                           break;
;                       }
                        ;; Catch \%^ and \%$ regardless of where they appear in the
                        ;; pattern -- regardless of whether or not it makes sense.
;                       case '^':
;                           ret = regnode(RE_BOF);
;                           break;

;                       case '$':
;                           ret = regnode(RE_EOF);
;                           break;

;                       case '#':
;                           ret = regnode(CURSOR);
;                           break;

;                       case 'V':
;                           ret = regnode(RE_VISUAL);
;                           break;

;                       case 'C':
;                           ret = regnode(RE_COMPOSING);
;                           break;

                        ;; \%[abc]: Emit as a list of branches,
                        ;; all ending at the last branch which matches nothing.
;                       case '[':
;                       {
;                           if (@one_exactly)        ;; doesn't nest
;                           {
;                               emsg2(u8("E369: invalid item in %s%%[]"), (@reg_magic == MAGIC_ALL) ? u8("") : u8("\\"));
;                               @rc_did_emsg = true;
;                               return null;
;                           }

;                           Bytes lastbranch;
;                           Bytes lastnode = null;
;                           Bytes br;

;                           ret = null;
;                           while ((c = getchr()) != ']')
;                           {
;                               if (c == NUL)
;                               {
;                                   emsg2(e_missing_sb, (@reg_magic == MAGIC_ALL) ? u8("") : u8("\\"));
;                                   @rc_did_emsg = true;
;                                   return null;
;                               }
;                               br = regnode(BRANCH);
;                               if (ret == null)
;                                   ret = br;
;                               else
;                                   regtail(lastnode, br);

;                               ungetchr();
;                               @one_exactly = true;
;                               lastnode = regatom(flagp);
;                               @one_exactly = false;
;                               if (lastnode == null)
;                                   return null;
;                           }
;                           if (ret == null)
;                           {
;                               emsg2(e_empty_sb, (@reg_magic == MAGIC_ALL) ? u8("") : u8("\\"));
;                               @rc_did_emsg = true;
;                               return null;
;                           }
;                           lastbranch = regnode(BRANCH);
;                           br = regnode(NOTHING);
;                           if (ret != JUST_CALC_SIZE)
;                           {
;                               regtail(lastnode, br);
;                               regtail(lastbranch, br);
                                ;; connect all branches to the NOTHING branch at the end
;                               for (br = ret; BNE(br, lastnode); )
;                               {
;                                   if (re_op(br) == BRANCH)
;                                   {
;                                       regtail(br, lastbranch);
;                                       br = operand(br);
;                                   }
;                                   else
;                                       br = regnext(br);
;                               }
;                           }
;                           flagp[0] &= ~(HASWIDTH | SIMPLE);
;                           break;
;                       }
;                       case 'd':   ;; %d123 decimal
;                       case 'o':   ;; %o123 octal
;                       case 'x':   ;; %xab hex 2
;                       case 'u':   ;; %uabcd hex 4
;                       case 'U':   ;; %U1234abcd hex 8
;                       {
;                           int i;
;                           switch (c)
;                           {
;                               case 'd': i = getdecchrs(); break;
;                               case 'o': i = getoctchrs(); break;
;                               case 'x': i = gethexchrs(2); break;
;                               case 'u': i = gethexchrs(4); break;
;                               case 'U': i = gethexchrs(8); break;
;                               default:  i = -1; break;
;                           }

;                           if (i < 0)
;                           {
;                               emsg2(u8("E678: Invalid character after %s%%[dxouU]"), (@reg_magic == MAGIC_ALL) ? u8("") : u8("\\"));
;                               @rc_did_emsg = true;
;                               return null;
;                           }
;                           if (use_multibytecode(i))
;                               ret = regnode(MULTIBYTECODE);
;                           else
;                               ret = regnode(EXACTLY);
;                           if (i == 0)
;                               regc(0x0a);
;                           else
;                               regmbc(i);
;                           regc(NUL);
;                           flagp[0] |= HASWIDTH;
;                           break;
;                       }
;                       default:
;                       {
;                           if (asc_isdigit(c) || c == '<' || c == '>' || c == '\'')
;                           {
;                               int cmp = c;
;                               if (cmp == '<' || cmp == '>')
;                                   c = getchr();

;                               long n = 0;
;                               while (asc_isdigit(c))
;                               {
;                                   n = n * 10 + (c - '0');
;                                   c = getchr();
;                               }

;                               if (c == '\'' && n == 0)
;                               {
                                    ;; "\%'m", "\%<'m" and "\%>'m": Mark
;                                   c = getchr();
;                                   ret = regnode(RE_MARK);
;                                   if (ret == JUST_CALC_SIZE)
;                                       @regsize += 2;
;                                   else
;                                   {
;                                       (@regcode = @regcode.plus(1)).be(-1, c);
;                                       (@regcode = @regcode.plus(1)).be(-1, cmp);
;                                   }
;                                   break;
;                               }
;                               else if (c == 'l' || c == 'c' || c == 'v')
;                               {
;                                   if (c == 'l')
;                                       ret = regnode(RE_LNUM);
;                                   else if (c == 'c')
;                                       ret = regnode(RE_COL);
;                                   else
;                                       ret = regnode(RE_VCOL);
;                                   if (ret == JUST_CALC_SIZE)
;                                       @regsize += 5;
;                                   else
;                                   {
                                        ;; put the number and the optional
                                        ;; comparator after the opcode
;                                       @regcode = re_put_long(@regcode, n);
;                                       (@regcode = @regcode.plus(1)).be(-1, cmp);
;                                   }
;                                   break;
;                               }
;                           }

;                           emsg2(u8("E71: Invalid character after %s%%"), (@reg_magic == MAGIC_ALL) ? u8("") : u8("\\"));
;                           @rc_did_emsg = true;
;                           return null;
;                       }
;                   }
;                   break;
;               }

;               case -165: // case Magic('['):
;                   break collection;

;               default:
;                   return do_multibyte(c, flagp);
;           }

;           return ret;
;       }

        ;; If there is no matching ']', we assume the '[' is a normal character.
        ;; This makes 'incsearch' and ":help [" work.

;       Bytes lp = skip_anyof(@regparse);

;       if (lp.at(0) == (byte)']')     ;; there is a matching ']'
;       {
;           int startc = -1;    ;; > 0 when next '-' is a range
;           int endc;

            ;; In a character class, different parsing rules apply.
            ;; Not even \ is special anymore, nothing is.

;           if (@regparse.at(0) == (byte)'^')       ;; Complement of range.
;           {
;               ret = regnode(ANYBUT + extra);
;               @regparse = @regparse.plus(1);
;           }
;           else
;               ret = regnode(ANYOF + extra);

            ;; At the start ']' and '-' mean the literal character.
;           if (@regparse.at(0) == (byte)']' || @regparse.at(0) == (byte)'-')
;           {
;               startc = @regparse.at(0);
;               regc((@regparse = @regparse.plus(1)).at(-1));
;           }

;           while (@regparse.at(0) != NUL && @regparse.at(0) != (byte)']')
;           {
;               if (@regparse.at(0) == (byte)'-')
;               {
;                   @regparse = @regparse.plus(1);
                    ;; The '-' is not used for a range at the end and after or before a '\n'.
;                   if (@regparse.at(0) == (byte)']' || @regparse.at(0) == NUL
;                           || startc == -1
;                           || (@regparse.at(0) == (byte)'\\' && @regparse.at(1) == (byte)'n'))
;                   {
;                       regc('-');
;                       startc = '-';       ;; [--x] is a range
;                   }
;                   else
;                   {
                        ;; Also accept "a-[.z.]".
;                       endc = 0;
;                       if (@regparse.at(0) == (byte)'[')
;                       {
;                           Bytes[] __ = { @regparse };
;                           endc = get_coll_element(__);
;                           @regparse = __[0];
;                       }
;                       if (endc == 0)
;                       {
;                           Bytes[] __ = { @regparse };
;                           endc = us_ptr2char_adv(__, true);
;                           @regparse = __[0];
;                       }

                        ;; Handle \o40, \x20 and \u20AC style sequences.
;                       if (endc == '\\' && !@reg_cpo_lit && !@reg_cpo_bsl)
;                           endc = coll_get_char();

;                       if (endc < startc)
;                       {
;                           emsg(e_invrange);
;                           @rc_did_emsg = true;
;                           return null;
;                       }
;                       if (1 < utf_char2len(startc) || 1 < utf_char2len(endc))
;                       {
                            ;; Limit to a range of 256 chars.
;                           if (startc + 256 < endc)
;                           {
;                               emsg(e_invrange);
;                               @rc_did_emsg = true;
;                               return null;
;                           }
;                           while (++startc <= endc)
;                               regmbc(startc);
;                       }
;                       else
;                       {
;                           while (++startc <= endc)
;                               regc(startc);
;                       }
;                       startc = -1;
;                   }
;               }

                ;; Only "\]", "\^", "\]" and "\\" are special in Vi.  Vim
                ;; accepts "\t", "\e", etc., but only when the 'l' flag in
                ;; 'cpoptions' is not included.
                ;; Posix doesn't recognize backslash at all.

;               else if (@regparse.at(0) == (byte)'\\'
;                       && !@reg_cpo_bsl
;                       && (vim_strchr(REGEXP_INRANGE, @regparse.at(1)) != null
;                           || (!@reg_cpo_lit && vim_strchr(REGEXP_ABBR, @regparse.at(1)) != null)))
;               {
;                   @regparse = @regparse.plus(1);
;                   if (@regparse.at(0) == (byte)'n')
;                   {
                        ;; '\n' in range: also match NL
;                       if (ret != JUST_CALC_SIZE)
;                       {
                            ;; Using \n inside [^] does not change what
                            ;; matches.  "[^\n]" is the same as ".".
;                           if (ret.at(0) == ANYOF)
;                           {
;                               ret.be(0, ANYOF + ADD_NL);
;                               flagp[0] |= HASNL;
;                           }
                            ;; else: must have had a \n already
;                       }
;                       @regparse = @regparse.plus(1);
;                       startc = -1;
;                   }
;                   else if (@regparse.at(0) == (byte)'d'
;                         || @regparse.at(0) == (byte)'o'
;                         || @regparse.at(0) == (byte)'x'
;                         || @regparse.at(0) == (byte)'u'
;                         || @regparse.at(0) == (byte)'U')
;                   {
;                       startc = coll_get_char();
;                       if (startc == 0)
;                           regc(0x0a);
;                       else
;                           regmbc(startc);
;                   }
;                   else
;                   {
;                       startc = backslash_trans((@regparse = @regparse.plus(1)).at(-1));
;                       regc(startc);
;                   }
;               }
;               else if (@regparse.at(0) == (byte)'[')
;               {
;                   int cu;

;                   int c_class;
;                   { Bytes[] __ = { @regparse }; c_class = get_char_class(__); @regparse = __[0]; }
;                   startc = -1;
                    ;; Characters assumed to be 8 bits!
;                   switch (c_class)
;                   {
;                       case CLASS_NONE:
;                       {
;                           { Bytes[] __ = { @regparse }; c_class = get_equi_class(__); @regparse = __[0]; }
;                           if (c_class != 0)
;                           {
                                ;; produce equivalence class
;                               reg_equi_class(c_class);
;                           }
;                           else
;                           {
;                               { Bytes[] __ = { @regparse }; c_class = get_coll_element(__); @regparse = __[0]; }
;                               if (c_class != 0)
;                               {
                                    ;; produce a collating element
;                                   regmbc(c_class);
;                               }
;                               else
;                               {
                                    ;; literal '[', allow [[-x] as a range
;                                   startc = (@regparse = @regparse.plus(1)).at(-1);
;                                   regc(startc);
;                               }
;                           }
;                           break;
;                       }
;                       case CLASS_ALNUM:
;                           for (cu = 1; cu <= 255; cu++)
;                               if (asc_isalnum(cu))
;                                   regc(cu);
;                           break;
;                       case CLASS_ALPHA:
;                           for (cu = 1; cu <= 255; cu++)
;                               if (asc_isalpha(cu))
;                                   regc(cu);
;                           break;
;                       case CLASS_BLANK:
;                           regc(' ');
;                           regc('\t');
;                           break;
;                       case CLASS_CNTRL:
;                           for (cu = 1; cu <= 255; cu++)
;                               if (asc_iscntrl(cu))
;                                   regc(cu);
;                           break;
;                       case CLASS_DIGIT:
;                           for (cu = 1; cu <= 255; cu++)
;                               if (asc_isdigit(cu))
;                                   regc(cu);
;                           break;
;                       case CLASS_GRAPH:
;                           for (cu = 1; cu <= 255; cu++)
;                               if (asc_isgraph(cu))
;                                   regc(cu);
;                           break;
;                       case CLASS_LOWER:
;                           for (cu = 1; cu <= 255; cu++)
;                               if (utf_islower(cu))
;                                   regc(cu);
;                           break;
;                       case CLASS_PRINT:
;                           for (cu = 1; cu <= 255; cu++)
;                               if (vim_isprintc(cu))
;                                   regc(cu);
;                           break;
;                       case CLASS_PUNCT:
;                           for (cu = 1; cu <= 255; cu++)
;                               if (asc_ispunct(cu))
;                                   regc(cu);
;                           break;
;                       case CLASS_SPACE:
;                           for (cu = 9; cu <= 13; cu++)
;                               regc(cu);
;                           regc(' ');
;                           break;
;                       case CLASS_UPPER:
;                           for (cu = 1; cu <= 255; cu++)
;                               if (utf_isupper(cu))
;                                   regc(cu);
;                           break;
;                       case CLASS_XDIGIT:
;                           for (cu = 1; cu <= 255; cu++)
;                               if (asc_isxdigit(cu))
;                                   regc(cu);
;                           break;
;                       case CLASS_TAB:
;                           regc('\t');
;                           break;
;                       case CLASS_RETURN:
;                           regc('\r');
;                           break;
;                       case CLASS_BACKSPACE:
;                           regc('\b');
;                           break;
;                       case CLASS_ESCAPE:
;                           regc('\033');
;                           break;
;                   }
;               }
;               else
;               {
                    ;; produce a multibyte character,
                    ;; including any following composing characters
;                   startc = us_ptr2char(@regparse);
;                   int len = us_ptr2len_cc(@regparse);
;                   if (utf_char2len(startc) != len)
;                       startc = -1;        ;; composing chars
;                   while (0 <= --len)
;                       regc((@regparse = @regparse.plus(1)).at(-1));
;               }
;           }
;           regc(NUL);
;           @prevchr_len = 1;                ;; last char was the ']'
;           if (@regparse.at(0) != (byte)']')
;           {
;               emsg(e_toomsbra);
;               @rc_did_emsg = true;
;               return null;                ;; Cannot happen?
;           }
;           skipchr();                      ;; let's be friends with the lexer again
;           flagp[0] |= HASWIDTH | SIMPLE;
;           return ret;
;       }

;       if (@reg_strict)
;       {
;           emsg2(e_missingbracket, (MAGIC_OFF < @reg_magic) ? u8("") : u8("\\"));
;           @rc_did_emsg = true;
;           return null;
;       }

;       return do_multibyte(c, flagp);
    ))

(defn- #_final #_Bytes do_multibyte [#_int c, #_int* flagp]
    (§
;       Bytes ret;

        ;; A multi-byte character is handled as a separate atom
        ;; if it's before a multi and when it's a composing char.
;       if (use_multibytecode(c))
;       {
;           ret = regnode(MULTIBYTECODE);
;           regmbc(c);
;           flagp[0] |= HASWIDTH | SIMPLE;
;           return ret;
;       }

;       ret = regnode(EXACTLY);

        ;; Append characters as long as:
        ;; - there is no following multi, we then need the character in
        ;;   front of it as a single character operand
        ;; - not running into a Magic character
        ;; - "one_exactly" is not set
        ;; But always emit at least one character.  Might be a Multi,
        ;; e.g., a "[" without matching "]".

;       int len;
;       for (len = 0; c != NUL && (len == 0 || (re_multi_type(peekchr()) == NOT_MULTI && !@one_exactly && !is_Magic(c))); len++)
;       {
;           c = no_Magic(c);

;           regmbc(c);

            ;; Need to get composing character too.
;           for ( ; ; )
;           {
;               int l = us_ptr2len(@regparse);
;               if (!utf_iscomposing(us_ptr2char(@regparse.plus(l))))
;                   break;
;               regmbc(us_ptr2char(@regparse));
;               skipchr();
;           }

;           c = getchr();
;       }
;       ungetchr();

;       regc(NUL);

;       flagp[0] |= HASWIDTH;
;       if (len == 1)
;           flagp[0] |= SIMPLE;

;       return ret;
    ))

;; Return true if MULTIBYTECODE should be used instead of EXACTLY for character "c".

(defn- #_boolean use_multibytecode [#_int c]
    (§
;       return (1 < utf_char2len(c)) && (re_multi_type(peekchr()) != NOT_MULTI || utf_iscomposing(c));
    ))

;; Emit a node.
;; Return pointer to generated code.

(defn- #_Bytes regnode [#_int op]
    (§
;       Bytes ret = @regcode;

;       if (ret == JUST_CALC_SIZE)
;           @regsize += 3;
;       else
;       {
;           (@regcode = @regcode.plus(1)).be(-1, op);
;           (@regcode = @regcode.plus(1)).be(-1, NUL);           ;; Null "next" pointer.
;           (@regcode = @regcode.plus(1)).be(-1, NUL);
;       }

;       return ret;
    ))

;; Emit (if appropriate) a byte of code.

(defn- #_void regc [#_int b]
    (§
;       if (@regcode == JUST_CALC_SIZE)
;           @regsize++;
;       else
;           (@regcode = @regcode.plus(1)).be(-1, b);
    ))

;; Emit (if appropriate) a multi-byte character of code.

(defn- #_void regmbc [#_int c]
    (§
;       if (@regcode == JUST_CALC_SIZE)
;           @regsize += utf_char2len(c);
;       else
;           @regcode = @regcode.plus(utf_char2bytes(c, @regcode));
    ))

;; Insert an operator in front of already-emitted operand.
;;
;; Means relocating the operand.

(defn- #_void reginsert [#_int op, #_Bytes opnd]
    (§
;       if (@regcode == JUST_CALC_SIZE)
;       {
;           @regsize += 3;
;           return;
;       }

;       Bytes src = @regcode;
;       @regcode = @regcode.plus(3);
;       Bytes dst = @regcode;
;       while (BLT(opnd, src))
;           (dst = dst.minus(1)).be(0, (src = src.minus(1)).at(0));

;       Bytes place = opnd; ;; Op node, where operand used to be.
;       (place = place.plus(1)).be(-1, op);
;       (place = place.plus(1)).be(-1, NUL);
;       place.be(0, NUL);
    ))

;; Insert an operator in front of already-emitted operand.
;; Add a number to the operator.

(defn- #_void reginsert_nr [#_int op, #_long val, #_Bytes opnd]
    (§
;       if (@regcode == JUST_CALC_SIZE)
;       {
;           @regsize += 7;
;           return;
;       }

;       Bytes src = @regcode;
;       @regcode = @regcode.plus(7);
;       Bytes dst = @regcode;
;       while (BLT(opnd, src))
;           (dst = dst.minus(1)).be(0, (src = src.minus(1)).at(0));

;       Bytes place = opnd; ;; Op node, where operand used to be.
;       (place = place.plus(1)).be(-1, op);
;       (place = place.plus(1)).be(-1, NUL);
;       (place = place.plus(1)).be(-1, NUL);
;       place = re_put_long(place, val);
    ))

;; Insert an operator in front of already-emitted operand.
;; The operator has the given limit values as operands.
;; Also set next pointer.
;;
;; Means relocating the operand.

(defn- #_void reginsert_limits [#_int op, #_long minval, #_long maxval, #_Bytes opnd]
    (§
;       if (@regcode == JUST_CALC_SIZE)
;       {
;           @regsize += 11;
;           return;
;       }

;       Bytes src = @regcode;
;       @regcode = @regcode.plus(11);
;       Bytes dst = @regcode;
;       while (BLT(opnd, src))
;           (dst = dst.minus(1)).be(0, (src = src.minus(1)).at(0));

;       Bytes place = opnd; ;; Op node, where operand used to be.
;       (place = place.plus(1)).be(-1, op);
;       (place = place.plus(1)).be(-1, NUL);
;       (place = place.plus(1)).be(-1, NUL);
;       place = re_put_long(place, minval);
;       place = re_put_long(place, maxval);
;       regtail(opnd, place);
    ))

;; Write a long as four bytes at "p" and return pointer to the next char.

(defn- #_Bytes re_put_long [#_Bytes p, #_long val]
    (§
;       (p = p.plus(1)).be(-1, (byte)((val >>> 24) & 0xff));
;       (p = p.plus(1)).be(-1, (byte)((val >>> 16) & 0xff));
;       (p = p.plus(1)).be(-1, (byte)((val >>>  8) & 0xff));
;       (p = p.plus(1)).be(-1, (byte)((val       ) & 0xff));
;       return p;
    ))

;; Set the next-pointer at the end of a node chain.

(defn- #_void regtail [#_Bytes p, #_Bytes val]
    (§
;       if (p == JUST_CALC_SIZE)
;           return;

        ;; Find last node.
;       Bytes scan = p;
;       for ( ; ; )
;       {
;           Bytes temp = regnext(scan);
;           if (temp == null)
;               break;
;           scan = temp;
;       }

;       int offset;
;       if (re_op(scan) == BACK)
;           offset = BDIFF(scan, val);
;       else
;           offset = BDIFF(val, scan);
        ;; When the offset uses more than 16 bits it can no longer fit in the two bytes available.
        ;; Use a global flag to avoid having to check return values in too many places.
;       if (0xffff < offset)
;           @reg_toolong = true;
;       else
;       {
;           scan.be(1, (byte)((offset >>> 8) & 0xff));
;           scan.be(2, (byte)((offset      ) & 0xff));
;       }
    ))

;; Like regtail, on item after a BRANCH; nop if none.

(defn- #_void regoptail [#_Bytes p, #_Bytes val]
    (§
        ;; When op is neither BRANCH nor BRACE_COMPLEX0-9, it is "operandless".
;       if (p == null || p == JUST_CALC_SIZE
;               || (re_op(p) != BRANCH && (re_op(p) < BRACE_COMPLEX || BRACE_COMPLEX + 9 < re_op(p))))
;           return;

;       regtail(operand(p), val);
    ))

;; Functions for getting characters from the regexp input.

(atom! boolean at_start)        ;; true when on the first character
(atom! boolean prev_at_start)   ;; true when on the second character

;; Start parsing at "str".

(defn- #_void initchr [#_Bytes str]
    (§
;       @regparse = str;
;       @prevchr_len = 0;
;       @curchr = @prevprevchr = @prevchr = @nextchr = -1;
;       @at_start = true;
;       @prev_at_start = false;
    ))

;; Save the current parse state, so that it can be restored and parsing
;; starts in the same state again.

(defn- #_void save_parse_state [#_parse_state_C ps]
    (§
;       ps.regparse = @regparse;
;       ps.prevchr_len = @prevchr_len;
;       ps.curchr = @curchr;
;       ps.prevchr = @prevchr;
;       ps.prevprevchr = @prevprevchr;
;       ps.nextchr = @nextchr;
;       ps.at_start = @at_start;
;       ps.prev_at_start = @prev_at_start;
;       ps.regnpar = @regnpar;
    ))

;; Restore a previously saved parse state.

(defn- #_void restore_parse_state [#_parse_state_C ps]
    (§
;       @regparse = ps.regparse;
;       @prevchr_len = ps.prevchr_len;
;       @curchr = ps.curchr;
;       @prevchr = ps.prevchr;
;       @prevprevchr = ps.prevprevchr;
;       @nextchr = ps.nextchr;
;       @at_start = ps.at_start;
;       @prev_at_start = ps.prev_at_start;
;       @regnpar = ps.regnpar;
    ))

(atom! int after_slash)

;; Get the next character without advancing.

(defn- #_int peekchr []
    (§
;       if (@curchr == -1)
;       {
;           switch (@curchr = @regparse.at(0))
;           {
;               case '.':
;               case '[':
;               case '~':
                    ;; magic when 'magic' is on
;                   if (MAGIC_ON <= @reg_magic)
;                       @curchr = Magic(@curchr);
;                   break;

;               case '(':
;               case ')':
;               case '{':
;               case '%':
;               case '+':
;               case '=':
;               case '?':
;               case '@':
;               case '!':
;               case '&':
;               case '|':
;               case '<':
;               case '>':
;               case '#':       ;; future ext.
;               case '"':       ;; future ext.
;               case '\'':      ;; future ext.
;               case ',':       ;; future ext.
;               case '-':       ;; future ext.
;               case ':':       ;; future ext.
;               case ';':       ;; future ext.
;               case '`':       ;; future ext.
;               case '/':       ;; can't be used in / command
                    ;; magic only after "\v"
;                   if (@reg_magic == MAGIC_ALL)
;                       @curchr = Magic(@curchr);
;                   break;

;               case '*':
                    ;; * is not magic as the very first character, e.g. "?*ptr",
                    ;; when after '^', e.g. "/^*ptr" and when after "\(", "\|", "\&".
                    ;; But "\(\*" is not magic, thus must be magic if "after_slash"
;                   if (MAGIC_ON <= @reg_magic
;                           && !@at_start
;                           && !(@prev_at_start && @prevchr == Magic('^'))
;                           && (@after_slash != 0
;                               || (@prevchr != Magic('(')
;                                   && @prevchr != Magic('&')
;                                   && @prevchr != Magic('|'))))
;                       @curchr = Magic('*');
;                   break;

;               case '^':
                    ;; '^' is only magic as the very first character
                    ;; and if it's after "\(", "\|", "\&' or "\n"
;                   if (MAGIC_OFF <= @reg_magic
;                           && (@at_start
;                               || @reg_magic == MAGIC_ALL
;                               || @prevchr == Magic('(')
;                               || @prevchr == Magic('|')
;                               || @prevchr == Magic('&')
;                               || @prevchr == Magic('n')
;                               || (no_Magic(@prevchr) == '('
;                                   && @prevprevchr == Magic('%'))))
;                   {
;                       @curchr = Magic('^');
;                       @at_start = true;
;                       @prev_at_start = false;
;                   }
;                   break;

;               case '$':
                    ;; '$' is only magic as the very last char
                    ;; and if it's in front of either "\|", "\)", "\&", or "\n"
;                   if (MAGIC_OFF <= @reg_magic)
;                   {
;                       Bytes p = @regparse.plus(1);
;                       boolean is_magic_all = (@reg_magic == MAGIC_ALL);

                        ;; ignore \c \C \m \M \v \V and \Z after '$'
;                       while (p.at(0) == (byte)'\\' && (p.at(1) == (byte)'c' || p.at(1) == (byte)'C'
;                                       || p.at(1) == (byte)'m' || p.at(1) == (byte)'M'
;                                       || p.at(1) == (byte)'v' || p.at(1) == (byte)'V' || p.at(1) == (byte)'Z'))
;                       {
;                           if (p.at(1) == (byte)'v')
;                               is_magic_all = true;
;                           else if (p.at(1) == (byte)'m' || p.at(1) == (byte)'M' || p.at(1) == (byte)'V')
;                               is_magic_all = false;
;                           p = p.plus(2);
;                       }
;                       if (p.at(0) == NUL
;                               || (p.at(0) == (byte)'\\'
;                                   && (p.at(1) == (byte)'|' || p.at(1) == (byte)'&' || p.at(1) == (byte)')' || p.at(1) == (byte)'n'))
;                               || (is_magic_all
;                                   && (p.at(0) == (byte)'|' || p.at(0) == (byte)'&' || p.at(0) == (byte)')'))
;                               || @reg_magic == MAGIC_ALL)
;                           @curchr = Magic('$');
;                   }
;                   break;

;               case '\\':
;               {
;                   int c = @regparse.at(1);

;                   if (c == NUL)
;                       @curchr = '\\';      ;; trailing '\'
;                   else if (char_u((byte)c) <= '~' && META_flags[c] != 0)
;                   {
                        ;; META contains everything that may be magic sometimes,
                        ;; except ^ and $ ("\^" and "\$" are only magic after "\v").
                        ;; We now fetch the next character and toggle its magicness.
                        ;; Therefore, \ is so meta-magic that it is not in META.

;                       @curchr = -1;
;                       @prev_at_start = @at_start;
;                       @at_start = false;   ;; be able to say "/\*ptr"
;                       @regparse = @regparse.plus(1);
;                       @after_slash++;
;                       peekchr();
;                       @regparse = @regparse.minus(1);
;                       --@after_slash;
;                       @curchr = toggle_Magic(@curchr);
;                   }
;                   else if (vim_strchr(REGEXP_ABBR, c) != null)
;                   {
                        ;; Handle abbreviations, like "\t" for TAB.

;                       @curchr = backslash_trans(c);
;                   }
;                   else if (@reg_magic == MAGIC_NONE && (c == '$' || c == '^'))
;                       @curchr = toggle_Magic(c);
;                   else
;                   {
                        ;; Next character can never be (made) magic?
                        ;; Then backslashing it won't do anything.

;                       @curchr = us_ptr2char(@regparse.plus(1));
;                   }
;                   break;
;               }

;               default:
;                   @curchr = us_ptr2char(@regparse);
;                   break;
;           }
;       }

;       return @curchr;
    ))

;; Eat one lexed character.  Do this in a way that we can undo it.

(defn- #_void skipchr []
    (§
        ;; peekchr() eats a backslash, do the same here
;       if (@regparse.at(0) == (byte)'\\')
;           @prevchr_len = 1;
;       else
;           @prevchr_len = 0;
;       if (@regparse.at(@prevchr_len) != NUL)
;       {
            ;; exclude composing chars that us_ptr2len_cc does include
;           @prevchr_len += us_ptr2len(@regparse.plus(@prevchr_len));
;       }
;       @regparse = @regparse.plus(@prevchr_len);
;       @prev_at_start = @at_start;
;       @at_start = false;
;       @prevprevchr = @prevchr;
;       @prevchr = @curchr;
;       @curchr = @nextchr;       ;; use previously unget char, or -1
;       @nextchr = -1;
    ))

;; Skip a character while keeping the value of prev_at_start for at_start.
;; prevchr and prevprevchr are also kept.

(defn- #_void skipchr_keepstart []
    (§
;       boolean as = @prev_at_start;
;       int pr = @prevchr;
;       int prpr = @prevprevchr;

;       skipchr();

;       @at_start = as;
;       @prevchr = pr;
;       @prevprevchr = prpr;
    ))

;; Get the next character from the pattern.  We know about magic and such, so
;; therefore we need a lexical analyzer.

(defn- #_int getchr []
    (§
;       int chr = peekchr();

;       skipchr();

;       return chr;
    ))

;; put character back.  Works only once!

(defn- #_void ungetchr []
    (§
;       @nextchr = @curchr;
;       @curchr = @prevchr;
;       @prevchr = @prevprevchr;
;       @at_start = @prev_at_start;
;       @prev_at_start = false;

        ;; Backup "regparse", so that it's at the same position as before the getchr().
;       @regparse = @regparse.minus(@prevchr_len);
    ))

;; Get and return the value of the hex string at the current position.
;; Return -1 if there is no valid hex number.
;; The position is updated:
;;     blahblah\%x20asdf
;;         before-^ ^-after
;; The parameter controls the maximum number of input characters.  This will be
;; 2 when reading a \%x20 sequence and 4 when reading a \%u20AC sequence.

(defn- #_int gethexchrs [#_int maxinputlen]
    (§
;       int nr = 0;
;       int i;

;       for (i = 0; i < maxinputlen; i++)
;       {
;           int c = @regparse.at(0);
;           if (!asc_isxdigit(c))
;               break;
;           nr <<= 4;
;           nr |= hex2nr(c);
;           @regparse = @regparse.plus(1);
;       }

;       if (i == 0)
;           return -1;

;       return nr;
    ))

;; Get and return the value of the decimal string immediately after the
;; current position.  Return -1 for invalid.  Consumes all digits.

(defn- #_int getdecchrs []
    (§
;       int nr = 0;
;       int i;

;       for (i = 0; ; i++)
;       {
;           int c = @regparse.at(0);
;           if (c < '0' || '9' < c)
;               break;
;           nr *= 10;
;           nr += c - '0';
;           @regparse = @regparse.plus(1);
;           @curchr = -1;    ;; no longer valid
;       }

;       if (i == 0)
;           return -1;

;       return nr;
    ))

;; get and return the value of the octal string immediately after the current
;; position. Return -1 for invalid, or 0-255 for valid.  Smart enough to handle
;; numbers > 377 correctly (for example, 400 is treated as 40) and doesn't
;; treat 8 or 9 as recognised characters.  Position is updated:
;;     blahblah\%o210asdf
;;         before-^  ^-after

(defn- #_int getoctchrs []
    (§
;       int nr = 0;
;       int i;

;       for (i = 0; i < 3 && nr < 040; i++)
;       {
;           int c = @regparse.at(0);
;           if (c < '0' || '7' < c)
;               break;
;           nr <<= 3;
;           nr |= hex2nr(c);
;           @regparse = @regparse.plus(1);
;       }

;       if (i == 0)
;           return -1;

;       return nr;
    ))

;; Get a number after a backslash that is inside [].
;; When nothing is recognized return a backslash.

(defn- #_int coll_get_char []
    (§
;       int nr = -1;

;       switch ((@regparse = @regparse.plus(1)).at(-1))
;       {
;           case 'd': nr = getdecchrs(); break;
;           case 'o': nr = getoctchrs(); break;
;           case 'x': nr = gethexchrs(2); break;
;           case 'u': nr = gethexchrs(4); break;
;           case 'U': nr = gethexchrs(8); break;
;       }
;       if (nr < 0)
;       {
            ;; If getting the number fails be backwards compatible: the character is a backslash.
;           @regparse = @regparse.minus(1);
;           nr = '\\';
;       }

;       return nr;
    ))

;; read_limits - Read two integers to be taken as a minimum and maximum.
;; If the first character is '-', then the range is reversed.
;; Should end with 'end'.  If minval is missing, zero is default,
;; if maxval is missing, a very big number is the default.

(defn- #_boolean read_limits [#_long* minval, #_long* maxval]
    (§
;       boolean reverse = false;

;       if (@regparse.at(0) == (byte)'-')
;       {
            ;; starts with '-', so reverse the range later
;           @regparse = @regparse.plus(1);
;           reverse = true;
;       }
;       Bytes first_char = @regparse;
;       { Bytes[] __ = { @regparse }; minval[0] = getdigits(__); @regparse = __[0]; }
;       if (@regparse.at(0) == (byte)',')                       ;; there is a comma
;       {
;           if (asc_isdigit((@regparse = @regparse.plus(1)).at(0)))
;           {
;               Bytes[] __ = { @regparse }; maxval[0] = getdigits(__); @regparse = __[0];
;           }
;           else
;               maxval[0] = MAX_LIMIT;
;       }
;       else if (asc_isdigit(first_char.at(0)))
;           maxval[0] = minval[0];                      ;; it was \{n} or \{-n}
;       else
;           maxval[0] = MAX_LIMIT;                      ;; it was \{} or \{-}
;       if (@regparse.at(0) == (byte)'\\')
;           @regparse = @regparse.plus(1);                ;; allow either \{...} or \{...\}
;       if (@regparse.at(0) != (byte)'}')
;       {
;           libC.sprintf(@ioBuff, u8("E554: Syntax error in %s{...}"), (@reg_magic == MAGIC_ALL) ? u8("") : u8("\\"));

;           emsg(@ioBuff);
;           @rc_did_emsg = true;
;           return false;
;       }

        ;; Reverse the range if there was a '-', or make sure it is in the right order otherwise.

;       if ((!reverse && maxval[0] < minval[0]) || (reverse && minval[0] < maxval[0]))
;       {
;           long tmp = minval[0];
;           minval[0] = maxval[0];
;           maxval[0] = tmp;
;       }
;       skipchr();          ;; let's be friends with the lexer again
;       return true;
    ))

;; Global work variables for vim_regexec().

;; The current match-position is remembered with these variables:
(atom! long     reglnum)                ;; line number, relative to first line
(atom! Bytes    regline)                ;; start of current line
(atom! Bytes    reginput)               ;; current input, points into "regline"

(atom! boolean  need_clear_subexpr)     ;; subexpressions still need to be cleared
(atom! boolean  need_clear_zsubexpr)    ;; extmatch subexpressions still need to be cleared

;; Structure used to save the current input state, when it needs to be
;; restored after trying a match.  Used by reg_save() and reg_restore().
;; Also stores the length of "backpos".

(class! #_final regsave_C
    [
        (field Bytes        rs_ptr)     ;; reginput pointer, for single-line regexp
        (field lpos_C       rs_pos      (§_lpos_C)) ;; reginput pos, for multi-line regexp
        (field int          rs_len)
    ])

(defn- #_void COPY_regsave [#_regsave_C rs1, #_regsave_C rs0]
    (§
;       rs1.rs_ptr = rs0.rs_ptr;
;       COPY_lpos(rs1.rs_pos, rs0.rs_pos);
;       rs1.rs_len = rs0.rs_len;
    ))

;; struct to save start/end pointer/position in for \(\)
(class! #_final save_se_C
    [
        (field Bytes        se_ptr)
        (field lpos_C       se_pos      (§_lpos_C))
    ])

(defn- #_save_se_C* ARRAY_save_se [#_int n]
    (vec (repeatedly n §_save_se_C)))

;; used for BEHIND and NOBEHIND matching
(class! #_final regbehind_C
    [
        (field regsave_C    save_after      (§_regsave_C))
        (field regsave_C    save_behind     (§_regsave_C))
        (field boolean      save_need_clear_subexpr)
        (field save_se_C*   save_start  (ARRAY_save_se NSUBEXP))
        (field save_se_C*   save_end    (ARRAY_save_se NSUBEXP))
    ])

;; Internal copy of 'ignorecase'.  It is set at each call to vim_regexec().
;; Normally it gets the value of "rm_ic" or "rmm_ic", but when the pattern
;; contains '\c' or '\C' the value is overruled.

(atom! boolean ireg_ic)

;; Similar to ireg_ic, but only for 'combining' characters.  Set with \Z flag
;; in the regexp.  Defaults to false, always.

(atom! boolean ireg_icombine)

;; Copy of "rmm_maxcol": maximum column to search for a match.  Zero when
;; there is no maximum.

(atom! int     ireg_maxcol)

;; Sometimes need to save a copy of a line.  Since calloc()/free() is very
;; slow, we keep one allocated piece of memory and only re-allocate it when
;; it's too small.  It's freed in bt_regexec_both() when finished.

(atom! Bytes reg_tofree)
(atom! int reg_tofree_len)

;; These variables are set when executing a regexp to speed up the execution.
;; Which ones are set depends on whether a single-line or multi-line match is
;; done:
;;                      single-line             multi-line
;; reg_match            regmatch_C              null
;; reg_mmatch           null                    regmmatch_C
;; reg_startp           reg_match.startp        <invalid>
;; reg_endp             reg_match.endp          <invalid>
;; reg_startpos         <invalid>               reg_mmatch.startpos
;; reg_endpos           <invalid>               reg_mmatch.endpos
;; reg_win              null                    window in which to search
;; reg_buf              curbuf                  buffer in which to search
;; reg_firstlnum        <invalid>               first line in which to search
;; reg_maxline          0                       last line nr
;; reg_line_lbr         false or true           false

(atom! regmatch_C   reg_match)
(atom! regmmatch_C  reg_mmatch)
(atom! Bytes*       reg_startp)
(atom! Bytes*       reg_endp)
(atom! lpos_C*      reg_startpos)
(atom! lpos_C*      reg_endpos)
(atom! window_C     reg_win)
(atom! buffer_C     reg_buf)
(atom! long         reg_firstlnum)
(atom! long         reg_maxline)
(atom! boolean      reg_line_lbr)       ;; "\n" in string is line break

;; Values for rs_state in regitem_C.
(final int
    RS_NOPEN 0,           ;; NOPEN and NCLOSE
    RS_MOPEN 1,           ;; MOPEN + [0-9]
    RS_MCLOSE 2,          ;; MCLOSE + [0-9]
    RS_ZOPEN 3,           ;; ZOPEN + [0-9]
    RS_ZCLOSE 4,          ;; ZCLOSE + [0-9]
    RS_BRANCH 5,          ;; BRANCH
    RS_BRCPLX_MORE 6,     ;; BRACE_COMPLEX and trying one more match
    RS_BRCPLX_LONG 7,     ;; BRACE_COMPLEX and trying longest match
    RS_BRCPLX_SHORT 8,    ;; BRACE_COMPLEX and trying shortest match
    RS_NOMATCH 9,         ;; NOMATCH
    RS_BEHIND1 10,        ;; BEHIND / NOBEHIND matching rest
    RS_BEHIND2 11,        ;; BEHIND / NOBEHIND matching behind part
    RS_STAR_LONG 12,      ;; STAR/PLUS/BRACE_SIMPLE longest match
    RS_STAR_SHORT 13)     ;; STAR/PLUS/BRACE_SIMPLE shortest match

;; When there are alternatives, a RS_ is put on the regstack to remember what we are doing.
;; Before it may be another type of item, depending on "rs_state", to remember more things.

(class! #_final regitem_C
    [
        (field int          rs_state)       ;; what we are doing, one of RS_ above
        (field Bytes        rs_scan)        ;; current node in program
        (field save_se_C    rs_sesave       (§_save_se_C))  ;; union room for saving reginput
        (field regsave_C    rs_regsave      (§_regsave_C))  ;; union room for saving reginput
        (field int          rs_no)          ;; submatch nr or BEHIND/NOBEHIND
    ])

;; Used for STAR, PLUS and BRACE_SIMPLE matching.
(class! #_final regstar_C
    [
        (field int          nextb)          ;; next byte
        (field int          nextb_ic)       ;; next byte reverse case
        (field long         count)
        (field long         minval)
        (field long         maxval)
    ])

;; Used to store input position when a BACK was encountered,
;; so that we now if we made any progress since the last time.

(class! #_final backpos_C
    [
        (field Bytes        bp_scan)        ;; "scan" where BACK was encountered
        (field regsave_C    bp_pos      (§_regsave_C))  ;; last input position
    ])

;; "regstack" and "backpos" are used by regmatch().
;; They are kept over calls to avoid invoking calloc() and free() often.
;; "regstack" is a stack with regitem_C items, sometimes preceded by regstar_C or regbehind_C.
;; "backpos" is a table with backpos_C items for BACK.

(atom! Object*      regstack)
(atom! backpos_C*   backpos)

;; Both for regstack and backpos tables we use the following strategy of allocation
;; (to reduce calloc/free calls):
;; - Initial size is fairly small.
;; - When needed, the tables are grown bigger (8 times at first, double after that).
;; - After executing the match we free the memory only if the array has grown.
;;   Thus the memory is kept allocated when it's at the initial size.
;; This makes it fast while not keeping a lot of memory allocated.
;; A three times speed increase was observed when using many simple patterns.

(final int REGSTACK_INITIAL 2048)
(final int BACKPOS_INITIAL    64)

;; Create "regstack" and "backpos".
;; We allocate *_INITIAL amount of bytes first and then set the grow size to much bigger value
;; to avoid many calloc calls in case of deep regular expressions.

(defn- #_void create_regstack []
    (§
        ;; Use Object item, since we push different things onto the regstack.
;       @regstack = new Growing<Object>(Object.class, REGSTACK_INITIAL);
;       @regstack.ga_grow(REGSTACK_INITIAL);
;       @regstack.ga_growsize = REGSTACK_INITIAL * 8;
    ))

(defn- #_void create_backpos []
    (§
;       @backpos = new Growing<backpos_C>(backpos_C.class, BACKPOS_INITIAL);
;       @backpos.ga_grow(BACKPOS_INITIAL);
;       @backpos.ga_growsize = BACKPOS_INITIAL * 8;
    ))

;; Get pointer to the line "lnum", which is relative to "reg_firstlnum".

(defn- #_Bytes reg_getline [#_long lnum]
    (§
        ;; When looking behind for a match/no-match, lnum is negative, but we can't go before line 1.
;       if (@reg_firstlnum + lnum < 1)
;           return null;
;       if (@reg_maxline < lnum)
            ;; Must have matched the "\n" in the last line.
;           return u8("");

;       return ml_get_buf(@reg_buf, @reg_firstlnum + lnum, false);
    ))

(atom! regsave_C    behind_pos      (§_regsave_C))

(final Bytes*       reg_startzp     NSUBEXP)                ;; Workspace to mark beginning
(final Bytes*       reg_endzp       NSUBEXP)                ;;   and end of \z(...\) matches
(final lpos_C*      reg_startzpos   (ARRAY_lpos NSUBEXP))   ;; idem, beginning pos
(final lpos_C*      reg_endzpos     (ARRAY_lpos NSUBEXP))   ;; idem, end pos

;; Match a regexp against a string.
;; "rmp.regprog" is a compiled regexp as returned by vim_regcomp().
;; Uses curbuf for line count and 'iskeyword'.
;; If "line_lbr" is true, consider a "\n" in "line" to be a line break.
;;
;; Returns 0 for failure, number of lines contained in the match otherwise.

(defn- #_long bt_regexec_nl [#_regmatch_C rmp, #_Bytes line, #_int col, #_boolean line_lbr]
    ;; line: string to match against
    ;; col: column to start looking for match
    (§
;       @reg_match = rmp;
;       @reg_mmatch = null;
;       @reg_maxline = 0;
;       @reg_line_lbr = line_lbr;
;       @reg_buf = @curbuf;
;       @reg_win = null;
;       @ireg_ic = rmp.rm_ic;
;       @ireg_icombine = false;
;       @ireg_maxcol = 0;

;       return bt_regexec_both(line, col, null);
    ))

;; Match a regexp against multiple lines.
;; "rmp.regprog" is a compiled regexp as returned by vim_regcomp().
;; Uses curbuf for line count and 'iskeyword'.
;;
;; Return zero if there is no match.  Return number of lines contained in the match otherwise.

(defn- #_long bt_regexec_multi [#_regmmatch_C rmp, #_window_C win, #_buffer_C buf, #_long lnum, #_int col, #_timeval_C tm]
    ;; win: window in which to search or null
    ;; buf: buffer in which to search
    ;; lnum: nr of line to start looking for match
    ;; col: column to start looking for match
    ;; tm: timeout limit or null
    (§
;       @reg_match = null;
;       @reg_mmatch = rmp;
;       @reg_buf = buf;
;       @reg_win = win;
;       @reg_firstlnum = lnum;
;       @reg_maxline = @reg_buf.b_ml.ml_line_count - lnum;
;       @reg_line_lbr = false;
;       @ireg_ic = rmp.rmm_ic;
;       @ireg_icombine = false;
;       @ireg_maxcol = rmp.rmm_maxcol;

;       return bt_regexec_both(null, col, tm);
    ))

;; Match a regexp against a string ("line" points to the string)
;; or multiple lines ("line" is null, use reg_getline()).
;; Returns 0 for failure, number of lines contained in the match otherwise.

(defn- #_long bt_regexec_both [#_Bytes line, #_int col, #_timeval_C tm]
    ;; col: column to start looking for match
    ;; tm: timeout limit or null
    (§
;       long retval = 0L;

;       if (@regstack == null)
;           create_regstack();
;       if (@backpos == null)
;           create_backpos();

;       bt_regprog_C prog;
;       if (@reg_match == null)
;       {
;           prog = (bt_regprog_C)@reg_mmatch.regprog;
;           line = reg_getline(0);
;           @reg_startpos = @reg_mmatch.startpos;
;           @reg_endpos = @reg_mmatch.endpos;
;       }
;       else
;       {
;           prog = (bt_regprog_C)@reg_match.regprog;
;           @reg_startp = @reg_match.startp;
;           @reg_endp = @reg_match.endp;
;       }

;       theend:
;       {
            ;; Be paranoid...
;           if (prog == null || line == null)
;           {
;               emsg(e_null);
;               break theend;
;           }

            ;; Check validity of program.
;           if (prog_magic_wrong())
;               break theend;

            ;; If the start column is past the maximum column: no need to try.
;           if (0 < @ireg_maxcol && @ireg_maxcol <= col)
;               break theend;

            ;; If pattern contains "\c" or "\C": overrule value of ireg_ic.
;           if ((prog.regflags & RF_ICASE) != 0)
;               @ireg_ic = true;
;           else if ((prog.regflags & RF_NOICASE) != 0)
;               @ireg_ic = false;

            ;; If pattern contains "\Z" overrule value of ireg_icombine.
;           if ((prog.regflags & RF_ICOMBINE) != 0)
;               @ireg_icombine = true;

            ;; If there is a "must appear" string, look for it.
;           if (prog.regmust != null)
;           {
;               int c = us_ptr2char(prog.regmust);
;               Bytes s = line.plus(col);

                ;; This is used very often, esp. for ":global".
                ;; Use three versions of the loop to avoid overhead of conditions.

;               if (!@ireg_ic)
;                   while ((s = vim_strchr(s, c)) != null)
;                   {
;                       int cmp;
;                       { int[] __ = { prog.regmlen }; cmp = cstrncmp(s, prog.regmust, __); prog.regmlen = __[0]; }
;                       if (cmp == 0)
;                           break;              ;; Found it.
;                       s = s.plus(us_ptr2len_cc(s));
;                   }
;               else
;                   while ((s = cstrchr(s, c)) != null)
;                   {
;                       int cmp;
;                       { int[] __ = { prog.regmlen }; cmp = cstrncmp(s, prog.regmust, __); prog.regmlen = __[0]; }
;                       if (cmp == 0)
;                           break;              ;; Found it.
;                       s = s.plus(us_ptr2len_cc(s));
;                   }
;               if (s == null)          ;; Not present.
;                   break theend;
;           }

;           @regline = line;
;           @reglnum = 0;
;           @reg_toolong = false;

            ;; Simplest case: Anchored match need be tried only once.
;           if (prog.reganch != 0)
;           {
;               int c = us_ptr2char(@regline.plus(col));
;               if (prog.regstart == NUL || prog.regstart == c
;                   || (@ireg_ic && ((utf_fold(prog.regstart) == utf_fold(c))
;                       || (c < 255 && prog.regstart < 255 && utf_tolower(prog.regstart) == utf_tolower(c)))))
;                   retval = regtry(prog, col);
;               else
;                   retval = 0;
;           }
;           else
;           {
;               int tm_count = 0;
                ;; Messy cases:  unanchored match.
;               while (!@got_int)
;               {
;                   if (prog.regstart != NUL)
;                   {
                        ;; Skip until the char we know it must start with.
                        ;; Used often, do some work to avoid call overhead.
;                       Bytes s = cstrchr(@regline.plus(col), prog.regstart);
;                       if (s == null)
;                       {
;                           retval = 0;
;                           break;
;                       }
;                       col = BDIFF(s, @regline);
;                   }

                    ;; Check for maximum column to try.
;                   if (0 < @ireg_maxcol && @ireg_maxcol <= col)
;                   {
;                       retval = 0;
;                       break;
;                   }

;                   retval = regtry(prog, col);
;                   if (0 < retval)
;                       break;

                    ;; if not currently on the first line, get it again
;                   if (@reglnum != 0)
;                   {
;                       @reglnum = 0;
;                       @regline = reg_getline(0);
;                   }
;                   if (@regline.at(col) == NUL)
;                       break;
;                   col += us_ptr2len_cc(@regline.plus(col));
                    ;; Check for timeout once in a twenty times to avoid overhead.
;                   if (tm != null && ++tm_count == 20)
;                   {
;                       tm_count = 0;
;                       if (profile_passed_limit(tm))
;                           break;
;                   }
;               }
;           }
;       }

        ;; Free "reg_tofree" when it's a bit big.
;       if (400 < @reg_tofree_len)
;           @reg_tofree = null;

        ;; Free backpos and regstack if they are bigger than their initial size.
;       if (BACKPOS_INITIAL < @backpos.ga_maxlen)
;       {
;           backpos_C[] bpp = @backpos.ga_data;
;           while (0 < @backpos.ga_len--)
;               bpp[@backpos.ga_len] = null;
;           @backpos.ga_clear();
;           @backpos = null;
;       }
;       if (REGSTACK_INITIAL < @regstack.ga_maxlen)
;       {
;           Object[] rpp = @regstack.ga_data;
;           while (0 < @regstack.ga_len--)
;               rpp[@regstack.ga_len] = null;
;           @regstack.ga_clear();
;           @regstack = null;
;       }

;       return retval;
    ))

;; Create a new extmatch and mark it as referenced once.

(defn- #_reg_extmatch_C make_extmatch []
    (§
;       reg_extmatch_C em = §_reg_extmatch_C();
;       em.refcnt = 1;
;       return em;
    ))

;; Add a reference to an extmatch.

(defn- #_reg_extmatch_C ref_extmatch [#_reg_extmatch_C em]
    (§
;       if (em != null)
;           em.refcnt++;
;       return em;
    ))

;; Try match of "prog" with at regline[col].
;; Returns 0 for failure, number of lines contained in the match otherwise.

(defn- #_long regtry [#_bt_regprog_C prog, #_int col]
    (§
;       @reginput = @regline.plus(col);
;       @need_clear_subexpr = true;
        ;; Clear the external match subpointers if necessary.
;       if (prog.reghasz == REX_SET)
;           @need_clear_zsubexpr = true;

;       if (regmatch(prog.program.plus(1)) == false)
;           return 0;

;       cleanup_subexpr();
;       if (@reg_match == null)
;       {
;           if (@reg_startpos[0].lnum < 0)
;           {
;               @reg_startpos[0].lnum = 0;
;               @reg_startpos[0].col = col;
;           }
;           if (@reg_endpos[0].lnum < 0)
;           {
;               @reg_endpos[0].lnum = @reglnum;
;               @reg_endpos[0].col = BDIFF(@reginput, @regline);
;           }
;           else
                ;; Use line number of "\ze".
;               @reglnum = @reg_endpos[0].lnum;
;       }
;       else
;       {
;           if (@reg_startp[0] == null)
;               @reg_startp[0] = @regline.plus(col);
;           if (@reg_endp[0] == null)
;               @reg_endp[0] = @reginput;
;       }
        ;; Package any found \z(...\) matches for export.  Default is none.
;       @re_extmatch_out = null;

;       if (prog.reghasz == REX_SET)
;       {
;           cleanup_zsubexpr();
;           @re_extmatch_out = make_extmatch();
;           for (int i = 0; i < NSUBEXP; i++)
;           {
;               if (@reg_match == null)
;               {
                    ;; Only accept single line matches.
;                   if (0 <= reg_startzpos[i].lnum
;                           && reg_endzpos[i].lnum == reg_startzpos[i].lnum
;                            && reg_endzpos[i].col >= reg_startzpos[i].col)
;                       @re_extmatch_out.matches[i] =
;                           STRNDUP(reg_getline(reg_startzpos[i].lnum).plus(reg_startzpos[i].col),
;                                      reg_endzpos[i].col - reg_startzpos[i].col);
;               }
;               else
;               {
;                   if (reg_startzp[i] != null && reg_endzp[i] != null)
;                       @re_extmatch_out.matches[i] =
;                               STRNDUP(reg_startzp[i], BDIFF(reg_endzp[i], reg_startzp[i]));
;               }
;           }
;       }
;       return 1 + @reglnum;
    ))

;; Get class of previous character.

(defn- #_int reg_prev_class []
    (§
;       if (BLT(@regline, @reginput))
;           return us_get_class(@reginput.minus(1 + us_head_off(@regline, @reginput.minus(1))), @reg_buf);

;       return -1;
    ))

;; Return true if the current reginput position matches the Visual area.

(defn- #_boolean reg_match_visual []
    (§
;       window_C wp = (@reg_win == null) ? @curwin : @reg_win;

        ;; Check if the buffer is the current buffer.
;       if (@reg_buf != @curbuf || @VIsual.lnum == 0)
;           return false;

;       pos_C top = §_pos_C();
;       pos_C bot = §_pos_C();
;       int mode;
;       if (@VIsual_active)
;       {
;           if (ltpos(@VIsual, wp.w_cursor))
;           {
;               COPY_pos(top, @VIsual);
;               COPY_pos(bot, wp.w_cursor);
;           }
;           else
;           {
;               COPY_pos(top, wp.w_cursor);
;               COPY_pos(bot, @VIsual);
;           }
;           mode = @VIsual_mode;
;       }
;       else
;       {
;           if (ltpos(@curbuf.b_visual.vi_start, @curbuf.b_visual.vi_end))
;           {
;               COPY_pos(top, @curbuf.b_visual.vi_start);
;               COPY_pos(bot, @curbuf.b_visual.vi_end);
;           }
;           else
;           {
;               COPY_pos(top, @curbuf.b_visual.vi_end);
;               COPY_pos(bot, @curbuf.b_visual.vi_start);
;           }
;           mode = @curbuf.b_visual.vi_mode;
;       }
;       long lnum = @reglnum + @reg_firstlnum;
;       if (lnum < top.lnum || bot.lnum < lnum)
;           return false;

;       if (mode == 'v')
;       {
;           int col = BDIFF(@reginput, @regline);
;           if ((lnum == top.lnum && col < top.col)
;            || (lnum == bot.lnum && col >= bot.col + ((@p_sel.at(0) != (byte)'e') ? 1 : 0)))
;               return false;
;       }
;       else if (mode == Ctrl_V)
;       {
;           int[] start1 = new int[1];
;           int[] end1 = new int[1];
;           getvvcol(wp, top, start1, null, end1);
;           int[] start2 = new int[1];
;           int[] end2 = new int[1];
;           getvvcol(wp, bot, start2, null, end2);
;           if (start2[0] < start1[0])
;               start1[0] = start2[0];
;           if (end1[0] < end2[0])
;               end1[0] = end2[0];
;           if (top.col == MAXCOL || bot.col == MAXCOL)
;               end1[0] = MAXCOL;
;           int cols = win_linetabsize(wp, @regline, BDIFF(@reginput, @regline));
;           if (cols < start1[0] || end1[0] - (@p_sel.at(0) == (byte)'e' ? 1 : 0) < cols)
;               return false;
;       }

;       return true;
    ))

;; The arguments from BRACE_LIMITS are stored here.  They are actually local
;; to regmatch(), but they are here to reduce the amount of stack space used
;; (it can be called recursively many times).

(atom! long     bl_minval)
(atom! long     bl_maxval)

(final int
    RA_FAIL 1,            ;; something failed, abort
    RA_CONT 2,            ;; continue in inner loop
    RA_BREAK 3,           ;; break inner loop
    RA_MATCH 4,           ;; successful match
    RA_NOMATCH 5)         ;; didn't match

;; regmatch - main matching routine
;;
;; Conceptually the strategy is simple:
;; check to see whether the current node matches, push an item onto the regstack
;; and loop to see whether the rest matches, and then act accordingly.
;;
;; In practice we make some effort to avoid using the regstack,
;; in particular by going through "ordinary" nodes (that don't need to know
;; whether the rest of the match failed) by a nested loop.
;;
;; Returns true when there is a match.
;; Leaves reginput and reglnum just after the last matched character.
;;
;; Returns false when there is no match.
;; Leaves reginput and reglnum in an undefined state!

(defn- #_boolean regmatch [#_Bytes scan]
    ;; scan: Current node.
    (§
;       int status;                 ;; one of the RA_ values:

        ;; Make "regstack" and "backpos" empty.
        ;; They are allocated and freed in bt_regexec_both() to reduce calloc()/free() calls.
;       @regstack.ga_len = 0;
;       @backpos.ga_len = 0;

        ;; Repeat until "regstack" is empty.

;       for ( ; ; )
;       {
            ;; Some patterns may take a long time to match, e.g., "\([a-z]\+\)\+Q".
            ;; Allow interrupting them with CTRL-C.
;           fast_breakcheck();

            ;; Repeat for items that can be matched sequentially, without using the regstack.

;           for ( ; ; )
;           {
;               if (@got_int || scan == null)
;               {
;                   status = RA_FAIL;
;                   break;
;               }
;               status = RA_CONT;

;               Bytes next = regnext(scan);        ;; Next node.

;               int op = re_op(scan);
                ;; Check for character class with NL added.
;               if (!@reg_line_lbr && with_nl(op) && @reg_match == null && @reginput.at(0) == NUL && @reglnum <= @reg_maxline)
;               {
;                   reg_nextline();
;               }
;               else if (@reg_line_lbr && with_nl(op) && @reginput.at(0) == (byte)'\n')
;               {
;                   @reginput = @reginput.plus(us_ptr2len_cc(@reginput));
;               }
;               else
;               {
;                   if (with_nl(op))
;                       op -= ADD_NL;
;                   int c = us_ptr2char(@reginput);
;                   switch (op)
;                   {
;                       case BOL:
;                           if (BNE(@reginput, @regline))
;                               status = RA_NOMATCH;
;                           break;

;                       case EOL:
;                           if (c != NUL)
;                               status = RA_NOMATCH;
;                           break;

;                       case RE_BOF:
                            ;; We're not at the beginning of the file when below the first
                            ;; line where we started, not at the start of the line or we
                            ;; didn't start at the first line of the buffer.
;                           if (@reglnum != 0 || BNE(@reginput, @regline) || (@reg_match == null && 1 < @reg_firstlnum))
;                               status = RA_NOMATCH;
;                           break;

;                       case RE_EOF:
;                           if (@reglnum != @reg_maxline || c != NUL)
;                               status = RA_NOMATCH;
;                           break;

;                       case CURSOR:
                            ;; Check if the buffer is in a window and compare the
                            ;; reg_win.w_cursor position to the match position.
;                           if (@reg_win == null
;                                   || @reglnum + @reg_firstlnum != @reg_win.w_cursor.lnum
;                                   || BDIFF(@reginput, @regline) != @reg_win.w_cursor.col)
;                               status = RA_NOMATCH;
;                           break;

;                       case RE_MARK:
;                       {
                            ;; Compare the mark position to the match position.
;                           int mark = operand(scan).at(0);
;                           int cmp = operand(scan).at(1);

;                           pos_C pos = getmark_buf(@reg_buf, mark, false);
;                           if (pos == null                 ;; mark doesn't exist
;                                   || pos.lnum <= 0        ;; mark isn't set in reg_buf
;                                   || (pos.lnum == @reglnum + @reg_firstlnum
;                                           ? (pos.col == BDIFF(@reginput, @regline)
;                                               ? (cmp == '<' || cmp == '>')
;                                               : (pos.col < BDIFF(@reginput, @regline)
;                                                   ? cmp != '>'
;                                                   : cmp != '<'))
;                                           : (pos.lnum < @reglnum + @reg_firstlnum
;                                               ? cmp != '>'
;                                               : cmp != '<')))
;                               status = RA_NOMATCH;
;                           break;
;                       }

;                       case RE_VISUAL:
;                           if (!reg_match_visual())
;                               status = RA_NOMATCH;
;                           break;

;                       case RE_LNUM:
;                           if (!(@reg_match == null) || !re_num_cmp(@reglnum + @reg_firstlnum, scan))
;                               status = RA_NOMATCH;
;                           break;

;                       case RE_COL:
;                           if (!re_num_cmp(BDIFF(@reginput, @regline) + 1, scan))
;                               status = RA_NOMATCH;
;                           break;

;                       case RE_VCOL:
;                           if (!re_num_cmp((long)win_linetabsize((@reg_win == null) ? @curwin : @reg_win,
;                                           @regline, BDIFF(@reginput, @regline)) + 1, scan))
;                               status = RA_NOMATCH;
;                           break;

;                       case BOW:                           ;; \<word; reginput points to w
;                       {
;                           if (c == NUL)                   ;; Can't match at end of line
;                               status = RA_NOMATCH;
;                           else
;                           {
;                               int this_class;

                                ;; Get class of current and previous char (if it exists).
;                               this_class = us_get_class(@reginput, @reg_buf);
;                               if (this_class <= 1)
;                                   status = RA_NOMATCH;    ;; not on a word at all
;                               else if (reg_prev_class() == this_class)
;                                   status = RA_NOMATCH;    ;; previous char is in same word
;                           }
;                           break;
;                       }

;                       case EOW:                           ;; word\>; reginput points after d
;                       {
;                           if (BEQ(@reginput, @regline))        ;; Can't match at start of line
;                               status = RA_NOMATCH;
;                           else
;                           {
;                               int this_class, prev_class;

                                ;; Get class of current and previous char (if it exists).
;                               this_class = us_get_class(@reginput, @reg_buf);
;                               prev_class = reg_prev_class();
;                               if (this_class == prev_class || prev_class == 0 || prev_class == 1)
;                                   status = RA_NOMATCH;
;                           }
;                           break; ;; Matched with EOW
;                       }

;                       case ANY:
                            ;; ANY does not match new lines.
;                           if (c == NUL)
;                               status = RA_NOMATCH;
;                           else
;                               @reginput = @reginput.plus(us_ptr2len_cc(@reginput));
;                           break;

;                       case IDENT:
;                           if (!vim_isIDc(c))
;                               status = RA_NOMATCH;
;                           else
;                               @reginput = @reginput.plus(us_ptr2len_cc(@reginput));
;                           break;

;                       case SIDENT:
;                           if (asc_isdigit(@reginput.at(0)) || !vim_isIDc(c))
;                               status = RA_NOMATCH;
;                           else
;                               @reginput = @reginput.plus(us_ptr2len_cc(@reginput));
;                           break;

;                       case KWORD:
;                           if (!us_iswordp(@reginput, @reg_buf))
;                               status = RA_NOMATCH;
;                           else
;                               @reginput = @reginput.plus(us_ptr2len_cc(@reginput));
;                           break;

;                       case SKWORD:
;                           if (asc_isdigit(@reginput.at(0)) || !us_iswordp(@reginput, @reg_buf))
;                               status = RA_NOMATCH;
;                           else
;                               @reginput = @reginput.plus(us_ptr2len_cc(@reginput));
;                           break;

;                       case FNAME:
;                           if (!vim_isfilec(c))
;                               status = RA_NOMATCH;
;                           else
;                               @reginput = @reginput.plus(us_ptr2len_cc(@reginput));
;                           break;

;                       case SFNAME:
;                           if (asc_isdigit(@reginput.at(0)) || !vim_isfilec(c))
;                               status = RA_NOMATCH;
;                           else
;                               @reginput = @reginput.plus(us_ptr2len_cc(@reginput));
;                           break;

;                       case PRINT:
;                           if (!vim_isprintc(us_ptr2char(@reginput)))
;                               status = RA_NOMATCH;
;                           else
;                               @reginput = @reginput.plus(us_ptr2len_cc(@reginput));
;                           break;

;                       case SPRINT:
;                           if (asc_isdigit(@reginput.at(0)) || !vim_isprintc(us_ptr2char(@reginput)))
;                               status = RA_NOMATCH;
;                           else
;                               @reginput = @reginput.plus(us_ptr2len_cc(@reginput));
;                           break;

;                       case WHITE:
;                           if (!vim_iswhite(c))
;                               status = RA_NOMATCH;
;                           else
;                               @reginput = @reginput.plus(us_ptr2len_cc(@reginput));
;                           break;

;                       case NWHITE:
;                           if (c == NUL || vim_iswhite(c))
;                               status = RA_NOMATCH;
;                           else
;                               @reginput = @reginput.plus(us_ptr2len_cc(@reginput));
;                           break;

;                       case DIGIT:
;                           if (!ri_digit(c))
;                               status = RA_NOMATCH;
;                           else
;                               @reginput = @reginput.plus(us_ptr2len_cc(@reginput));
;                           break;

;                       case NDIGIT:
;                           if (c == NUL || ri_digit(c))
;                               status = RA_NOMATCH;
;                           else
;                               @reginput = @reginput.plus(us_ptr2len_cc(@reginput));
;                           break;

;                       case HEX:
;                           if (!ri_hex(c))
;                               status = RA_NOMATCH;
;                           else
;                               @reginput = @reginput.plus(us_ptr2len_cc(@reginput));
;                           break;

;                       case NHEX:
;                           if (c == NUL || ri_hex(c))
;                               status = RA_NOMATCH;
;                           else
;                               @reginput = @reginput.plus(us_ptr2len_cc(@reginput));
;                           break;

;                       case OCTAL:
;                           if (!ri_octal(c))
;                               status = RA_NOMATCH;
;                           else
;                               @reginput = @reginput.plus(us_ptr2len_cc(@reginput));
;                           break;

;                       case NOCTAL:
;                           if (c == NUL || ri_octal(c))
;                               status = RA_NOMATCH;
;                           else
;                               @reginput = @reginput.plus(us_ptr2len_cc(@reginput));
;                           break;

;                       case WORD:
;                           if (!ri_word(c))
;                               status = RA_NOMATCH;
;                           else
;                               @reginput = @reginput.plus(us_ptr2len_cc(@reginput));
;                           break;

;                       case NWORD:
;                           if (c == NUL || ri_word(c))
;                               status = RA_NOMATCH;
;                           else
;                               @reginput = @reginput.plus(us_ptr2len_cc(@reginput));
;                           break;

;                       case HEAD:
;                           if (!ri_head(c))
;                               status = RA_NOMATCH;
;                           else
;                               @reginput = @reginput.plus(us_ptr2len_cc(@reginput));
;                           break;

;                       case NHEAD:
;                           if (c == NUL || ri_head(c))
;                               status = RA_NOMATCH;
;                           else
;                               @reginput = @reginput.plus(us_ptr2len_cc(@reginput));
;                           break;

;                       case ALPHA:
;                           if (!ri_alpha(c))
;                               status = RA_NOMATCH;
;                           else
;                               @reginput = @reginput.plus(us_ptr2len_cc(@reginput));
;                           break;

;                       case NALPHA:
;                           if (c == NUL || ri_alpha(c))
;                               status = RA_NOMATCH;
;                           else
;                               @reginput = @reginput.plus(us_ptr2len_cc(@reginput));
;                           break;

;                       case LOWER:
;                           if (!ri_lower(c))
;                               status = RA_NOMATCH;
;                           else
;                               @reginput = @reginput.plus(us_ptr2len_cc(@reginput));
;                           break;

;                       case NLOWER:
;                           if (c == NUL || ri_lower(c))
;                               status = RA_NOMATCH;
;                           else
;                               @reginput = @reginput.plus(us_ptr2len_cc(@reginput));
;                           break;

;                       case UPPER:
;                           if (!ri_upper(c))
;                               status = RA_NOMATCH;
;                           else
;                               @reginput = @reginput.plus(us_ptr2len_cc(@reginput));
;                           break;

;                       case NUPPER:
;                           if (c == NUL || ri_upper(c))
;                               status = RA_NOMATCH;
;                           else
;                               @reginput = @reginput.plus(us_ptr2len_cc(@reginput));
;                           break;

;                       case EXACTLY:
;                       {
;                           Bytes opnd = operand(scan);
                            ;; Inline the first byte, for speed.
;                           if (opnd.at(0) != @reginput.at(0) && !@ireg_ic)
;                               status = RA_NOMATCH;
;                           else if (opnd.at(0) == NUL)
;                           {
                                ;; match empty string always works; happens when "~" is empty.
;                           }
;                           else
;                           {
;                               int[] len = new int[1];
;                               if (opnd.at(1) == NUL && !@ireg_ic)
;                               {
;                                   len[0] = 1;        ;; matched a single byte above
;                               }
;                               else
;                               {
                                    ;; Need to match first byte again for multi-byte.
;                                   len[0] = STRLEN(opnd);
;                                   if (cstrncmp(opnd, @reginput, len) != 0)
;                                       status = RA_NOMATCH;
;                               }
                                ;; Check for following composing character, unless %C
                                ;; follows (skips over all composing chars).
;                               if (status != RA_NOMATCH
;                                       && utf_iscomposing(us_ptr2char(@reginput.plus(len[0])))
;                                       && !@ireg_icombine
;                                       && re_op(next) != RE_COMPOSING)
;                               {
                                    ;; This code makes a composing character get ignored,
                                    ;; which is the correct behavior (sometimes)
                                    ;; for voweled Hebrew texts.
;                                   status = RA_NOMATCH;
;                               }
;                               if (status != RA_NOMATCH)
;                                   @reginput = @reginput.plus(len[0]);
;                           }
;                           break;
;                       }

;                       case ANYOF:
;                       case ANYBUT:
;                           if (c == NUL)
;                               status = RA_NOMATCH;
;                           else if ((cstrchr(operand(scan), c) == null) == (op == ANYOF))
;                               status = RA_NOMATCH;
;                           else
;                               @reginput = @reginput.plus(us_ptr2len_cc(@reginput));
;                           break;

;                       case MULTIBYTECODE:
;                       {
;                           Bytes opnd = operand(scan);
                            ;; Safety check (just in case 'encoding' was changed since compiling the program).
;                           int len = us_ptr2len_cc(opnd);
;                           if (len < 2)
;                           {
;                               status = RA_NOMATCH;
;                               break;
;                           }
;                           int opndc = us_ptr2char(opnd);
;                           if (utf_iscomposing(opndc))
;                           {
                                ;; When only a composing char is given match at any
                                ;; position where that composing char appears.
;                               status = RA_NOMATCH;
;                               for (int i = 0; @reginput.at(i) != NUL; i += us_ptr2len(@reginput.plus(i)))
;                               {
;                                   int inpc = us_ptr2char(@reginput.plus(i));
;                                   if (!utf_iscomposing(inpc))
;                                   {
;                                       if (0 < i)
;                                           break;
;                                   }
;                                   else if (opndc == inpc)
;                                   {
                                        ;; Include all following composing chars.
;                                       len = i + us_ptr2len_cc(@reginput.plus(i));
;                                       status = RA_MATCH;
;                                       break;
;                                   }
;                               }
;                           }
;                           else
;                           {
;                               for (int i = 0; i < len; i++)
;                                   if (opnd.at(i) != @reginput.at(i))
;                                   {
;                                       status = RA_NOMATCH;
;                                       break;
;                                   }
;                           }

;                           @reginput = @reginput.plus(len);
;                           break;
;                       }

;                       case RE_COMPOSING:
;                       {
                            ;; Skip composing characters.
;                           while (utf_iscomposing(us_ptr2char(@reginput)))
;                               @reginput = @reginput.plus(us_ptr2len(@reginput));
;                           break;
;                       }

;                       case NOTHING:
;                           break;

;                       case BACK:
;                       {
                            ;; When we run into BACK we need to check if we don't keep
                            ;; looping without matching any input.  The second and later
                            ;; times a BACK is encountered it fails if the input is still
                            ;; at the same position as the previous time.
                            ;; The positions are stored in "backpos" and found by the
                            ;; current value of "scan", the position in the RE program.

;                           backpos_C[] bpp = @backpos.ga_data;

;                           int i;
;                           for (i = 0; i < @backpos.ga_len; i++)
;                               if (BEQ(bpp[i].bp_scan, scan))
;                                   break;
;                           if (i == @backpos.ga_len)
;                           {
                                ;; First time at this BACK, make room to store the pos.
;                               bpp = @backpos.ga_grow(1);
;                               bpp[i] = §_backpos_C();
;                               bpp[i].bp_scan = scan;
;                               @backpos.ga_len++;
;                           }
;                           else if (reg_save_equal(bpp[i].bp_pos))
                                ;; Still at same position as last time, fail.
;                               status = RA_NOMATCH;

;                           if (status != RA_FAIL && status != RA_NOMATCH)
;                               reg_save(bpp[i].bp_pos, @backpos);

;                           break;
;                       }

;                       case MOPEN + 0:     ;; Match start: \zs
;                       case MOPEN + 1:     ;; \(
;                       case MOPEN + 2:
;                       case MOPEN + 3:
;                       case MOPEN + 4:
;                       case MOPEN + 5:
;                       case MOPEN + 6:
;                       case MOPEN + 7:
;                       case MOPEN + 8:
;                       case MOPEN + 9:
;                       {
;                           int no = op - MOPEN;
;                           cleanup_subexpr();
;                           regitem_C rip = push_regitem(RS_MOPEN, scan);
;                           if (rip == null)
;                               status = RA_FAIL;
;                           else
;                           {
;                               rip.rs_no = no;
;                               @reg_startp[no] = save_se(rip.rs_sesave, @reg_startpos[no], @reg_startp[no]);
                                ;; We simply continue and handle the result when done.
;                           }
;                           break;
;                       }

;                       case NOPEN:         ;; \%(
;                       case NCLOSE:        ;; \) after \%(
;                           if (push_regitem(RS_NOPEN, scan) == null)
;                               status = RA_FAIL;
                            ;; We simply continue and handle the result when done.
;                           break;

;                       case ZOPEN + 1:
;                       case ZOPEN + 2:
;                       case ZOPEN + 3:
;                       case ZOPEN + 4:
;                       case ZOPEN + 5:
;                       case ZOPEN + 6:
;                       case ZOPEN + 7:
;                       case ZOPEN + 8:
;                       case ZOPEN + 9:
;                       {
;                           int no = op - ZOPEN;
;                           cleanup_zsubexpr();
;                           regitem_C rip = push_regitem(RS_ZOPEN, scan);
;                           if (rip == null)
;                               status = RA_FAIL;
;                           else
;                           {
;                               rip.rs_no = no;
;                               reg_startzp[no] = save_se(rip.rs_sesave, reg_startzpos[no], reg_startzp[no]);
                                ;; We simply continue and handle the result when done.
;                           }
;                           break;
;                       }

;                       case MCLOSE + 0:    ;; Match end: \ze
;                       case MCLOSE + 1:    ;; \)
;                       case MCLOSE + 2:
;                       case MCLOSE + 3:
;                       case MCLOSE + 4:
;                       case MCLOSE + 5:
;                       case MCLOSE + 6:
;                       case MCLOSE + 7:
;                       case MCLOSE + 8:
;                       case MCLOSE + 9:
;                       {
;                           int no = op - MCLOSE;
;                           cleanup_subexpr();
;                           regitem_C rip = push_regitem(RS_MCLOSE, scan);
;                           if (rip == null)
;                               status = RA_FAIL;
;                           else
;                           {
;                               rip.rs_no = no;
;                               @reg_endp[no] = save_se(rip.rs_sesave, @reg_endpos[no], @reg_endp[no]);
                                ;; We simply continue and handle the result when done.
;                           }
;                           break;
;                       }

;                       case ZCLOSE + 1:    ;; \) after \z(
;                       case ZCLOSE + 2:
;                       case ZCLOSE + 3:
;                       case ZCLOSE + 4:
;                       case ZCLOSE + 5:
;                       case ZCLOSE + 6:
;                       case ZCLOSE + 7:
;                       case ZCLOSE + 8:
;                       case ZCLOSE + 9:
;                       {
;                           int no = op - ZCLOSE;
;                           cleanup_zsubexpr();
;                           regitem_C rip = push_regitem(RS_ZCLOSE, scan);
;                           if (rip == null)
;                               status = RA_FAIL;
;                           else
;                           {
;                               rip.rs_no = no;
;                               reg_endzp[no] = save_se(rip.rs_sesave, reg_endzpos[no], reg_endzp[no]);
                                ;; We simply continue and handle the result when done.
;                           }
;                           break;
;                       }

;                       case BACKREF + 1:
;                       case BACKREF + 2:
;                       case BACKREF + 3:
;                       case BACKREF + 4:
;                       case BACKREF + 5:
;                       case BACKREF + 6:
;                       case BACKREF + 7:
;                       case BACKREF + 8:
;                       case BACKREF + 9:
;                       {
;                           int[] len = new int[1];

;                           int no = op - BACKREF;
;                           cleanup_subexpr();
;                           if (!(@reg_match == null))       ;; Single-line regexp
;                           {
;                               if (@reg_startp[no] == null || @reg_endp[no] == null)
;                               {
                                    ;; Backref was not set: Match an empty string.
;                                   len[0] = 0;
;                               }
;                               else
;                               {
                                    ;; Compare current input with back-ref in the same line.
;                                   len[0] = BDIFF(@reg_endp[no], @reg_startp[no]);
;                                   if (cstrncmp(@reg_startp[no], @reginput, len) != 0)
;                                       status = RA_NOMATCH;
;                               }
;                           }
;                           else                            ;; Multi-line regexp
;                           {
;                               if (@reg_startpos[no].lnum < 0 || @reg_endpos[no].lnum < 0)
;                               {
                                    ;; Backref was not set: Match an empty string.
;                                   len[0] = 0;
;                               }
;                               else
;                               {
;                                   if (@reg_startpos[no].lnum == @reglnum && @reg_endpos[no].lnum == @reglnum)
;                                   {
                                        ;; Compare back-ref within the current line.
;                                       len[0] = @reg_endpos[no].col - @reg_startpos[no].col;
;                                       if (cstrncmp(@regline.plus(@reg_startpos[no].col), @reginput, len) != 0)
;                                           status = RA_NOMATCH;
;                                   }
;                                   else
;                                   {
                                        ;; Messy situation: Need to compare between two lines.
;                                       int r = match_with_backref(
;                                                       @reg_startpos[no].lnum,
;                                                       @reg_startpos[no].col,
;                                                       @reg_endpos[no].lnum,
;                                                       @reg_endpos[no].col,
;                                                       len);

;                                       if (r != RA_MATCH)
;                                           status = r;
;                                   }
;                               }
;                           }

                            ;; Matched the backref, skip over it.
;                           @reginput = @reginput.plus(len[0]);
;                           break;
;                       }

;                       case ZREF + 1:
;                       case ZREF + 2:
;                       case ZREF + 3:
;                       case ZREF + 4:
;                       case ZREF + 5:
;                       case ZREF + 6:
;                       case ZREF + 7:
;                       case ZREF + 8:
;                       case ZREF + 9:
;                       {
;                           cleanup_zsubexpr();
;                           int no = op - ZREF;
;                           if (@re_extmatch_in != null && @re_extmatch_in.matches[no] != null)
;                           {
;                               int[] len = { STRLEN(@re_extmatch_in.matches[no]) };
;                               if (cstrncmp(@re_extmatch_in.matches[no], @reginput, len) != 0)
;                                   status = RA_NOMATCH;
;                               else
;                                   @reginput = @reginput.plus(len[0]);
;                           }
;                           else
;                           {
                                ;; Backref was not set: Match an empty string.
;                           }
;                           break;
;                       }

;                       case BRANCH:
;                       {
;                           if (re_op(next) != BRANCH) ;; No choice.
;                               next = operand(scan);       ;; Avoid recursion.
;                           else
;                           {
;                               regitem_C rip = push_regitem(RS_BRANCH, scan);
;                               if (rip == null)
;                                   status = RA_FAIL;
;                               else
;                                   status = RA_BREAK;      ;; rest is below
;                           }
;                           break;
;                       }

;                       case BRACE_LIMITS:
;                       {
;                           if (re_op(next) == BRACE_SIMPLE)
;                           {
;                               @bl_minval = operand_min(scan);
;                               @bl_maxval = operand_max(scan);
;                           }
;                           else if (BRACE_COMPLEX <= re_op(next) && re_op(next) < BRACE_COMPLEX + 10)
;                           {
;                               int no = re_op(next) - BRACE_COMPLEX;
;                               @brace_min[no] = operand_min(scan);
;                               @brace_max[no] = operand_max(scan);
;                               @brace_count[no] = 0;
;                           }
;                           else
;                           {
;                               emsg(e_internal);       ;; Shouldn't happen.
;                               status = RA_FAIL;
;                           }
;                           break;
;                       }

;                       case BRACE_COMPLEX + 0:
;                       case BRACE_COMPLEX + 1:
;                       case BRACE_COMPLEX + 2:
;                       case BRACE_COMPLEX + 3:
;                       case BRACE_COMPLEX + 4:
;                       case BRACE_COMPLEX + 5:
;                       case BRACE_COMPLEX + 6:
;                       case BRACE_COMPLEX + 7:
;                       case BRACE_COMPLEX + 8:
;                       case BRACE_COMPLEX + 9:
;                       {
;                           int no = op - BRACE_COMPLEX;
;                           ++@brace_count[no];

                            ;; If not matched enough times yet, try one more.
;                           if (@brace_count[no] <= (@brace_min[no] <= @brace_max[no] ? @brace_min[no] : @brace_max[no]))
;                           {
;                               regitem_C rip = push_regitem(RS_BRCPLX_MORE, scan);
;                               if (rip == null)
;                                   status = RA_FAIL;
;                               else
;                               {
;                                   rip.rs_no = no;
;                                   reg_save(rip.rs_regsave, @backpos);
;                                   next = operand(scan);
                                    ;; We continue and handle the result when done.
;                               }
;                               break;
;                           }

                            ;; If matched enough times, may try matching some more.
;                           if (@brace_min[no] <= @brace_max[no])
;                           {
                                ;; Range is the normal way around, use longest match.
;                               if (@brace_count[no] <= @brace_max[no])
;                               {
;                                   regitem_C rip = push_regitem(RS_BRCPLX_LONG, scan);
;                                   if (rip == null)
;                                       status = RA_FAIL;
;                                   else
;                                   {
;                                       rip.rs_no = no;
;                                       reg_save(rip.rs_regsave, @backpos);
;                                       next = operand(scan);
                                        ;; We continue and handle the result when done.
;                                   }
;                               }
;                           }
;                           else
;                           {
                                ;; Range is backwards, use shortest match first.
;                               if (@brace_count[no] <= @brace_min[no])
;                               {
;                                   regitem_C rip = push_regitem(RS_BRCPLX_SHORT, scan);
;                                   if (rip == null)
;                                       status = RA_FAIL;
;                                   else
;                                   {
;                                       reg_save(rip.rs_regsave, @backpos);
                                        ;; We continue and handle the result when done.
;                                   }
;                               }
;                           }
;                           break;
;                       }

;                       case BRACE_SIMPLE:
;                       case STAR:
;                       case PLUS:
;                       {
;                           regstar_C rst = §_regstar_C();

                            ;; Lookahead to avoid useless match attempts when we know
                            ;; what character comes next.

;                           if (re_op(next) == EXACTLY)
;                           {
;                               rst.nextb = operand(next).at(0);
;                               if (@ireg_ic)
;                               {
;                                   if (utf_isupper(rst.nextb))
;                                       rst.nextb_ic = utf_tolower(rst.nextb);
;                                   else
;                                       rst.nextb_ic = utf_toupper(rst.nextb);
;                               }
;                               else
;                                   rst.nextb_ic = rst.nextb;
;                           }
;                           else
;                           {
;                               rst.nextb = NUL;
;                               rst.nextb_ic = NUL;
;                           }

;                           if (op != BRACE_SIMPLE)
;                           {
;                               rst.minval = (op == STAR) ? 0 : 1;
;                               rst.maxval = MAX_LIMIT;
;                           }
;                           else
;                           {
;                               rst.minval = @bl_minval;
;                               rst.maxval = @bl_maxval;
;                           }

                            ;; When maxval > minval, try matching as much as possible, up to maxval.
                            ;; When maxval < minval, try matching at least the minimal number
                            ;; (since the range is backwards, that's also maxval!).

;                           rst.count = regrepeat(operand(scan), rst.maxval);
;                           if (@got_int)
;                           {
;                               status = RA_FAIL;
;                               break;
;                           }

;                           if (rst.minval <= rst.maxval ? rst.minval <= rst.count : rst.maxval <= rst.count)
;                           {
                                ;; It could match.  Prepare for trying to match
                                ;; what follows.  The code is below.  Parameters
                                ;; are stored in a regstar_C on the regstack.
;                               if (@p_mmp <= (@regstack.ga_len >>> 10))
;                               {
;                                   emsg(e_maxmempat);
;                                   status = RA_FAIL;
;                               }
;                               else
;                               {
;                                   @regstack.ga_grow(1);
;                                   @regstack.ga_data[@regstack.ga_len++] = rst;
;                                   rst = null;

;                                   regitem_C rip = push_regitem(rst.minval <= rst.maxval ? RS_STAR_LONG : RS_STAR_SHORT, scan);
;                                   if (rip == null)
;                                       status = RA_FAIL;
;                                   else
;                                       status = RA_BREAK;      ;; skip the restore bits
;                               }
;                           }
;                           else
;                               status = RA_NOMATCH;

;                           break;
;                       }

;                       case NOMATCH:
;                       case MATCH:
;                       case SUBPAT:
;                       {
;                           regitem_C rip = push_regitem(RS_NOMATCH, scan);
;                           if (rip == null)
;                               status = RA_FAIL;
;                           else
;                           {
;                               rip.rs_no = op;
;                               reg_save(rip.rs_regsave, @backpos);
;                               next = operand(scan);
                                ;; We continue and handle the result when done.
;                           }
;                           break;
;                       }

;                       case BEHIND:
;                       case NOBEHIND:
;                       {
                            ;; Need a bit of room to store extra positions.
;                           if (@p_mmp <= (@regstack.ga_len >>> 10))
;                           {
;                               emsg(e_maxmempat);
;                               status = RA_FAIL;
;                           }
;                           else
;                           {
;                               regbehind_C rbp = §_regbehind_C();

;                               @regstack.ga_grow(1);
;                               @regstack.ga_data[@regstack.ga_len++] = rbp;

;                               regitem_C rip = push_regitem(RS_BEHIND1, scan);
;                               if (rip == null)
;                                   status = RA_FAIL;
;                               else
;                               {
                                    ;; Need to save the subexpr to be able to restore them
                                    ;; when there is a match but we don't use it.
;                                   save_subexpr(rbp);

;                                   rip.rs_no = op;
;                                   reg_save(rip.rs_regsave, @backpos);
                                    ;; First try if what follows matches.
                                    ;; If it does, then we check the behind match by looping.
;                               }
;                           }
;                           break;
;                       }

;                       case BHPOS:
;                       {
;                           if (@reg_match == null)
;                           {
;                               if (@behind_pos.rs_pos.col != BDIFF(@reginput, @regline)
;                                       || @behind_pos.rs_pos.lnum != @reglnum)
;                                   status = RA_NOMATCH;
;                           }
;                           else if (BNE(@behind_pos.rs_ptr, @reginput))
;                               status = RA_NOMATCH;
;                           break;
;                       }

;                       case NEWL:
;                       {
;                           if ((c != NUL || !(@reg_match == null) || @reg_maxline < @reglnum || @reg_line_lbr)
;                                   && (c != '\n' || !@reg_line_lbr))
;                               status = RA_NOMATCH;
;                           else if (@reg_line_lbr)
;                               @reginput = @reginput.plus(us_ptr2len_cc(@reginput));
;                           else
;                               reg_nextline();
;                           break;
;                       }

;                       case END:
;                           status = RA_MATCH;  ;; Success!
;                           break;

;                       default:
;                           emsg(e_re_corr);
;                           status = RA_FAIL;
;                           break;
;                   }
;               }

                ;; If we can't continue sequentially, break the inner loop.
;               if (status != RA_CONT)
;                   break;

                ;; Continue in inner loop, advance to next item.
;               scan = next;
;           }

            ;; If there is something on the regstack, execute the code for the state.
            ;; If the state is popped then loop and use the older state.

;           while (0 < @regstack.ga_len && status != RA_FAIL)
;           {
;               Object vip = (1 < @regstack.ga_len) ? @regstack.ga_data[@regstack.ga_len - 2] : null;
;               regitem_C rip = (regitem_C)@regstack.ga_data[@regstack.ga_len - 1];

;               switch (rip.rs_state)
;               {
;                   case RS_NOPEN:
                        ;; Result is passed on as-is, simply pop the state.
;                       scan = pop_regitem();
;                       break;

;                   case RS_MOPEN:
                        ;; Pop the state.  Restore pointers when there is no match.
;                       if (status == RA_NOMATCH)
;                       {
;                           @reg_startp[rip.rs_no] = restore_se(rip.rs_sesave, @reg_startpos[rip.rs_no], @reg_startp[rip.rs_no]);
;                       }
;                       scan = pop_regitem();
;                       break;

;                   case RS_ZOPEN:
                        ;; Pop the state.  Restore pointers when there is no match.
;                       if (status == RA_NOMATCH)
;                       {
;                           reg_startzp[rip.rs_no] = restore_se(rip.rs_sesave, reg_startzpos[rip.rs_no], reg_startzp[rip.rs_no]);
;                       }
;                       scan = pop_regitem();
;                       break;

;                   case RS_MCLOSE:
                        ;; Pop the state.  Restore pointers when there is no match.
;                       if (status == RA_NOMATCH)
;                       {
;                           @reg_endp[rip.rs_no] = restore_se(rip.rs_sesave, @reg_endpos[rip.rs_no], @reg_endp[rip.rs_no]);
;                       }
;                       scan = pop_regitem();
;                       break;

;                   case RS_ZCLOSE:
                        ;; Pop the state.  Restore pointers when there is no match.
;                       if (status == RA_NOMATCH)
;                       {
;                           reg_endzp[rip.rs_no] = restore_se(rip.rs_sesave, reg_endzpos[rip.rs_no], reg_endzp[rip.rs_no]);
;                       }
;                       scan = pop_regitem();
;                       break;

;                   case RS_BRANCH:
;                   {
;                       if (status == RA_MATCH)
                            ;; this branch matched, use it
;                           scan = pop_regitem();
;                       else
;                       {
;                           if (status != RA_BREAK)
;                           {
                                ;; After a non-matching branch: try next one.
;                               reg_restore(rip.rs_regsave, @backpos);
;                               scan = rip.rs_scan;
;                           }
;                           if (scan == null || re_op(scan) != BRANCH)
;                           {
                                ;; no more branches, didn't find a match
;                               status = RA_NOMATCH;
;                               scan = pop_regitem();
;                           }
;                           else
;                           {
                                ;; Prepare to try a branch.
;                               rip.rs_scan = regnext(scan);
;                               reg_save(rip.rs_regsave, @backpos);
;                               scan = operand(scan);
;                           }
;                       }
;                       break;
;                   }

;                   case RS_BRCPLX_MORE:
                        ;; Pop the state.  Restore pointers when there is no match.
;                       if (status == RA_NOMATCH)
;                       {
;                           reg_restore(rip.rs_regsave, @backpos);
;                           --@brace_count[rip.rs_no];       ;; decrement match count
;                       }
;                       scan = pop_regitem();
;                       break;

;                   case RS_BRCPLX_LONG:
                        ;; Pop the state.  Restore pointers when there is no match.
;                       if (status == RA_NOMATCH)
;                       {
                            ;; There was no match, but we did find enough matches.
;                           reg_restore(rip.rs_regsave, @backpos);
;                           --@brace_count[rip.rs_no];
                            ;; continue with the items after "\{}"
;                           status = RA_CONT;
;                       }
;                       scan = pop_regitem();
;                       if (status == RA_CONT)
;                           scan = regnext(scan);
;                       break;

;                   case RS_BRCPLX_SHORT:
                        ;; Pop the state.  Restore pointers when there is no match.
;                       if (status == RA_NOMATCH)
                            ;; There was no match, try to match one more item.
;                           reg_restore(rip.rs_regsave, @backpos);
;                       scan = pop_regitem();
;                       if (status == RA_NOMATCH)
;                       {
;                           scan = operand(scan);
;                           status = RA_CONT;
;                       }
;                       break;

;                   case RS_NOMATCH:
                        ;; Pop the state.  If the operand matches for NOMATCH or
                        ;; doesn't match for MATCH/SUBPAT, we fail.  Otherwise backup,
                        ;; except for SUBPAT, and continue with the next item.
;                       if (status == (rip.rs_no == NOMATCH ? RA_MATCH : RA_NOMATCH))
;                           status = RA_NOMATCH;
;                       else
;                       {
;                           status = RA_CONT;
;                           if (rip.rs_no != SUBPAT)        ;; zero-width
;                               reg_restore(rip.rs_regsave, @backpos);
;                       }
;                       scan = pop_regitem();
;                       if (status == RA_CONT)
;                           scan = regnext(scan);
;                       break;

;                   case RS_BEHIND1:
;                       if (status == RA_NOMATCH)
;                       {
;                           scan = pop_regitem();
;                           drop_regbehind();
;                       }
;                       else
;                       {
                            ;; The stuff after BEHIND/NOBEHIND matches.
                            ;; Now try if the behind part does (not) match before the current
                            ;; position in the input.  This must be done at every position in the
                            ;; input and checking if the match ends at the current position.

                            ;; save the position after the found match for next
;                           reg_save(((regbehind_C)vip).save_after, @backpos);

                            ;; Start looking for a match with operand at the current position.
                            ;; Go back one character until we find the result, hitting the start
                            ;; of the line or the previous line (for multi-line matching).
                            ;; Set behind_pos to where the match should end, BHPOS will match it.
                            ;; Save the current value.
;                           COPY_regsave(((regbehind_C)vip).save_behind, @behind_pos);
;                           COPY_regsave(@behind_pos, rip.rs_regsave);

;                           rip.rs_state = RS_BEHIND2;

;                           reg_restore(rip.rs_regsave, @backpos);
;                           scan = operand(rip.rs_scan).plus(4);
;                       }
;                       break;

;                   case RS_BEHIND2:

                        ;; Looping for BEHIND / NOBEHIND match.

;                       if (status == RA_MATCH && reg_save_equal(@behind_pos))
;                       {
                            ;; found a match that ends where "next" started
;                           COPY_regsave(@behind_pos, ((regbehind_C)vip).save_behind);
;                           if (rip.rs_no == BEHIND)
;                               reg_restore(((regbehind_C)vip).save_after, @backpos);
;                           else
;                           {
                                ;; But we didn't want a match.  Need to restore the subexpr,
                                ;; because what follows matched, so they have been set.
;                               status = RA_NOMATCH;
;                               restore_subexpr((regbehind_C)vip);
;                           }
;                           scan = pop_regitem();
;                           drop_regbehind();
;                       }
;                       else
;                       {
                            ;; No match or a match that doesn't end where we want it:
                            ;; go back one character.  May go to previous line once.
;                           boolean no = true;
;                           long limit = operand_min(rip.rs_scan);
;                           if (@reg_match == null)
;                           {
;                               if (0 < limit
;                                       && ((rip.rs_regsave.rs_pos.lnum < @behind_pos.rs_pos.lnum
;                                           ? STRLEN(@regline)
;                                           : @behind_pos.rs_pos.col)
;                                       - rip.rs_regsave.rs_pos.col >= limit))
;                                   no = false;
;                               else if (rip.rs_regsave.rs_pos.col == 0)
;                               {
;                                   if (rip.rs_regsave.rs_pos.lnum < @behind_pos.rs_pos.lnum
;                                           || reg_getline(--rip.rs_regsave.rs_pos.lnum) == null)
;                                       no = false;
;                                   else
;                                   {
;                                       reg_restore(rip.rs_regsave, @backpos);
;                                       rip.rs_regsave.rs_pos.col = STRLEN(@regline);
;                                   }
;                               }
;                               else
;                               {
;                                   rip.rs_regsave.rs_pos.col -= us_head_off(@regline, @regline.plus(rip.rs_regsave.rs_pos.col - 1)) + 1;
;                               }
;                           }
;                           else
;                           {
;                               if (BEQ(rip.rs_regsave.rs_ptr, @regline))
;                                   no = false;
;                               else
;                               {
;                                   rip.rs_regsave.rs_ptr = rip.rs_regsave.rs_ptr.minus(us_ptr_back(@regline, rip.rs_regsave.rs_ptr));
;                                   if (0 < limit && limit < BDIFF(@behind_pos.rs_ptr, rip.rs_regsave.rs_ptr))
;                                       no = false;
;                               }
;                           }
;                           if (no == true)
;                           {
                                ;; Advanced, prepare for finding match again.
;                               reg_restore(rip.rs_regsave, @backpos);
;                               scan = operand(rip.rs_scan).plus(4);
;                               if (status == RA_MATCH)
;                               {
                                    ;; We did match, so subexpr may have been changed,
                                    ;; need to restore them for the next try.
;                                   status = RA_NOMATCH;
;                                   restore_subexpr((regbehind_C)vip);
;                               }
;                           }
;                           else
;                           {
                                ;; Can't advance.  For NOBEHIND that's a match.
;                               COPY_regsave(@behind_pos, ((regbehind_C)vip).save_behind);
;                               if (rip.rs_no == NOBEHIND)
;                               {
;                                   reg_restore(((regbehind_C)vip).save_after, @backpos);
;                                   status = RA_MATCH;
;                               }
;                               else
;                               {
                                    ;; We do want a proper match.  Need to restore the subexpr
                                    ;; if we had a match, because they may have been set.
;                                   if (status == RA_MATCH)
;                                   {
;                                       status = RA_NOMATCH;
;                                       restore_subexpr((regbehind_C)vip);
;                                   }
;                               }
;                               scan = pop_regitem();
;                               drop_regbehind();
;                           }
;                       }
;                       break;

;                   case RS_STAR_LONG:
;                   case RS_STAR_SHORT:
;                   {
;                       regstar_C rst = (regstar_C)vip;

;                       if (status == RA_MATCH)
;                       {
;                           scan = pop_regitem();
;                           drop_regstar();
;                           break;
;                       }

                        ;; Tried once already, restore input pointers.
;                       if (status != RA_BREAK)
;                           reg_restore(rip.rs_regsave, @backpos);

                        ;; Repeat until we found a position where it could match.
;                       for ( ; ; )
;                       {
;                           if (status != RA_BREAK)
;                           {
                                ;; Tried first position already, advance.
;                               if (rip.rs_state == RS_STAR_LONG)
;                               {
                                    ;; Trying for longest match, but couldn't
                                    ;; or didn't match -- back up one char.
;                                   if (--rst.count < rst.minval)
;                                       break;
;                                   if (BEQ(@reginput, @regline))
;                                   {
                                        ;; backup to last char of previous line
;                                       --@reglnum;
;                                       @regline = reg_getline(@reglnum);
                                        ;; Just in case regrepeat() didn't count right.
;                                       if (@regline == null)
;                                           break;
;                                       @reginput = @regline.plus(STRLEN(@regline));
;                                       fast_breakcheck();
;                                   }
;                                   else
;                                       @reginput = @reginput.minus(us_ptr_back(@regline, @reginput));
;                               }
;                               else
;                               {
                                    ;; Range is backwards, use shortest match first.
                                    ;; Careful: maxval and minval are exchanged!
                                    ;; Couldn't or didn't match: try advancing one char.
;                                   if (rst.count == rst.minval || regrepeat(operand(rip.rs_scan), 1L) == 0)
;                                       break;
;                                   rst.count++;
;                               }
;                               if (@got_int)
;                                   break;
;                           }
;                           else
;                               status = RA_NOMATCH;

                            ;; If it could match, try it.
;                           if (rst.nextb == NUL || @reginput.at(0) == rst.nextb || @reginput.at(0) == rst.nextb_ic)
;                           {
;                               reg_save(rip.rs_regsave, @backpos);
;                               scan = regnext(rip.rs_scan);
;                               status = RA_CONT;
;                               break;
;                           }
;                       }
;                       if (status != RA_CONT)
;                       {
                            ;; Failed.
;                           scan = pop_regitem();
;                           drop_regstar();
;                           status = RA_NOMATCH;
;                       }
;                   }
;                   break;
;               }

                ;; If we want to continue the inner loop or didn't pop a state continue matching loop.
;               if (status == RA_CONT || rip == (regitem_C)@regstack.ga_data[@regstack.ga_len - 1])
;                   break;
;           }

            ;; May need to continue with the inner loop, starting at "scan".
;           if (status == RA_CONT)
;               continue;

            ;; If the regstack is empty or something failed we are done.

;           if (@regstack.ga_len == 0 || status == RA_FAIL)
;           {
;               if (scan == null)
;               {
                    ;; We get here only if there's trouble -- normally
                    ;; "case END" is the terminating point.

;                   emsg(e_re_corr);
;               }
;               if (status == RA_FAIL)
;                   @got_int = true;
;               return (status == RA_MATCH);
;           }
;       }

        ;; NOTREACHED
    ))

;; Push an item onto the regstack.
;; Returns pointer to new item.  Returns null when out of memory.

(defn- #_regitem_C push_regitem [#_int state, #_Bytes scan]
    (§
;       if (@p_mmp <= (@regstack.ga_len >>> 10))
;       {
;           emsg(e_maxmempat);
;           return null;
;       }

;       regitem_C rip = §_regitem_C();

;       @regstack.ga_grow(1);
;       @regstack.ga_data[@regstack.ga_len++] = rip;

;       rip.rs_state = state;
;       rip.rs_scan = scan;

;       return rip;
    ))

;; Pop an item from the regstack.

(defn- #_Bytes pop_regitem []
    (§
;       regitem_C rip = (regitem_C)@regstack.ga_data[--@regstack.ga_len];
;       @regstack.ga_data[@regstack.ga_len] = null;

;       return rip.rs_scan;
    ))

(defn- #_void drop_regbehind []
    (§
;       @regstack.ga_data[--@regstack.ga_len] = null;
    ))

(defn- #_void drop_regstar []
    (§
;       @regstack.ga_data[--@regstack.ga_len] = null;
    ))

;; regrepeat - repeatedly match something simple, return how many.
;; Advances reginput (and reglnum) to just after the matched chars.

(defn- #_int regrepeat [#_Bytes p, #_long maxcount]
    ;; maxcount: maximum number of matches allowed
    (§
;       long count = 0;
;       int testval = 0;
;       int mask;

;       Bytes scan = @reginput;     ;; Make local copy of reginput for speed.
;       Bytes opnd = operand(p);

;       do_class:
;       {
;           switch (re_op(p))
;           {
;               case ANY:
;               case ANY + ADD_NL:
;                   while (count < maxcount)
;                   {
                        ;; Matching anything means we continue until end-of-line (or
                        ;; end-of-file for ANY + ADD_NL), only limited by maxcount.
;                       while (scan.at(0) != NUL && count < maxcount)
;                       {
;                           count++;
;                           scan = scan.plus(us_ptr2len_cc(scan));
;                       }
;                       if (@reg_match != null || !with_nl(re_op(p)) || @reg_maxline < @reglnum || @reg_line_lbr || count == maxcount)
;                           break;
;                       count++;                ;; count the line-break
;                       reg_nextline();
;                       scan = @reginput;
;                       if (@got_int)
;                           break;
;                   }
;                   break do_class;

;               case IDENT:
;               case IDENT + ADD_NL:
;                   testval = TRUE;
                    ;; FALLTHROUGH
;               case SIDENT:
;               case SIDENT + ADD_NL:
;                   while (count < maxcount)
;                   {
;                       if (vim_isIDc(us_ptr2char(scan)) && (testval != 0 || !asc_isdigit(scan.at(0))))
;                       {
;                           scan = scan.plus(us_ptr2len_cc(scan));
;                       }
;                       else if (scan.at(0) == NUL)
;                       {
;                           if (!(@reg_match == null) || !with_nl(re_op(p)) || @reg_maxline < @reglnum || @reg_line_lbr)
;                               break;
;                           reg_nextline();
;                           scan = @reginput;
;                           if (@got_int)
;                               break;
;                       }
;                       else if (@reg_line_lbr && scan.at(0) == (byte)'\n' && with_nl(re_op(p)))
;                           scan = scan.plus(1);
;                       else
;                           break;
;                       count++;
;                   }
;                   break do_class;

;               case KWORD:
;               case KWORD + ADD_NL:
;                   testval = TRUE;
                    ;; FALLTHROUGH
;               case SKWORD:
;               case SKWORD + ADD_NL:
;                   while (count < maxcount)
;                   {
;                       if (us_iswordp(scan, @reg_buf) && (testval != 0 || !asc_isdigit(scan.at(0))))
;                       {
;                           scan = scan.plus(us_ptr2len_cc(scan));
;                       }
;                       else if (scan.at(0) == NUL)
;                       {
;                           if (!(@reg_match == null) || !with_nl(re_op(p)) || @reg_maxline < @reglnum || @reg_line_lbr)
;                               break;
;                           reg_nextline();
;                           scan = @reginput;
;                           if (@got_int)
;                               break;
;                       }
;                       else if (@reg_line_lbr && scan.at(0) == (byte)'\n' && with_nl(re_op(p)))
;                           scan = scan.plus(1);
;                       else
;                           break;
;                       count++;
;                   }
;                   break do_class;

;               case FNAME:
;               case FNAME + ADD_NL:
;                   testval = TRUE;
                    ;; FALLTHROUGH
;               case SFNAME:
;               case SFNAME + ADD_NL:
;                   while (count < maxcount)
;                   {
;                       if (vim_isfilec(us_ptr2char(scan)) && (testval != 0 || !asc_isdigit(scan.at(0))))
;                       {
;                           scan = scan.plus(us_ptr2len_cc(scan));
;                       }
;                       else if (scan.at(0) == NUL)
;                       {
;                           if (!(@reg_match == null) || !with_nl(re_op(p)) || @reg_maxline < @reglnum || @reg_line_lbr)
;                               break;
;                           reg_nextline();
;                           scan = @reginput;
;                           if (@got_int)
;                               break;
;                       }
;                       else if (@reg_line_lbr && scan.at(0) == (byte)'\n' && with_nl(re_op(p)))
;                           scan = scan.plus(1);
;                       else
;                           break;
;                       count++;
;                   }
;                   break do_class;

;               case PRINT:
;               case PRINT + ADD_NL:
;                   testval = TRUE;
                    ;; FALLTHROUGH
;               case SPRINT:
;               case SPRINT + ADD_NL:
;                   while (count < maxcount)
;                   {
;                       if (scan.at(0) == NUL)
;                       {
;                           if (!(@reg_match == null) || !with_nl(re_op(p)) || @reg_maxline < @reglnum || @reg_line_lbr)
;                               break;
;                           reg_nextline();
;                           scan = @reginput;
;                           if (@got_int)
;                               break;
;                       }
;                       else if (vim_isprintc(us_ptr2char(scan)) && (testval != 0 || !asc_isdigit(scan.at(0))))
;                       {
;                           scan = scan.plus(us_ptr2len_cc(scan));
;                       }
;                       else if (@reg_line_lbr && scan.at(0) == (byte)'\n' && with_nl(re_op(p)))
;                           scan = scan.plus(1);
;                       else
;                           break;
;                       count++;
;                   }
;                   break do_class;

;               case WHITE:
;               case WHITE + ADD_NL:
;                   testval = mask = RI_WHITE;
;                   break;

;               case NWHITE:
;               case NWHITE + ADD_NL:
;                   mask = RI_WHITE;
;                   break;

;               case DIGIT:
;               case DIGIT + ADD_NL:
;                   testval = mask = RI_DIGIT;
;                   break;

;               case NDIGIT:
;               case NDIGIT + ADD_NL:
;                   mask = RI_DIGIT;
;                   break;

;               case HEX:
;               case HEX + ADD_NL:
;                   testval = mask = RI_HEX;
;                   break;

;               case NHEX:
;               case NHEX + ADD_NL:
;                   mask = RI_HEX;
;                   break;

;               case OCTAL:
;               case OCTAL + ADD_NL:
;                   testval = mask = RI_OCTAL;
;                   break;

;               case NOCTAL:
;               case NOCTAL + ADD_NL:
;                   mask = RI_OCTAL;
;                   break;

;               case WORD:
;               case WORD + ADD_NL:
;                   testval = mask = RI_WORD;
;                   break;

;               case NWORD:
;               case NWORD + ADD_NL:
;                   mask = RI_WORD;
;                   break;

;               case HEAD:
;               case HEAD + ADD_NL:
;                   testval = mask = RI_HEAD;
;                   break;

;               case NHEAD:
;               case NHEAD + ADD_NL:
;                   mask = RI_HEAD;
;                   break;

;               case ALPHA:
;               case ALPHA + ADD_NL:
;                   testval = mask = RI_ALPHA;
;                   break;

;               case NALPHA:
;               case NALPHA + ADD_NL:
;                   mask = RI_ALPHA;
;                   break;

;               case LOWER:
;               case LOWER + ADD_NL:
;                   testval = mask = RI_LOWER;
;                   break;

;               case NLOWER:
;               case NLOWER + ADD_NL:
;                   mask = RI_LOWER;
;                   break;

;               case UPPER:
;               case UPPER + ADD_NL:
;                   testval = mask = RI_UPPER;
;                   break;

;               case NUPPER:
;               case NUPPER + ADD_NL:
;                   mask = RI_UPPER;
;                   break;

;               case EXACTLY:
;               {
                    ;; This doesn't do a multi-byte character, because a MULTIBYTECODE would have
                    ;; been used for it.  It does handle single-byte characters, such as latin1.
;                   if (@ireg_ic)
;                   {
;                       int cu = utf_toupper(opnd.at(0));
;                       int cl = utf_tolower(opnd.at(0));
;                       while (count < maxcount && (scan.at(0) == cu || scan.at(0) == cl))
;                       {
;                           count++;
;                           scan = scan.plus(1);
;                       }
;                   }
;                   else
;                   {
;                       int cu = opnd.at(0);
;                       while (count < maxcount && scan.at(0) == cu)
;                       {
;                           count++;
;                           scan = scan.plus(1);
;                       }
;                   }
;                   break do_class;
;               }

;               case MULTIBYTECODE:
;               {
                    ;; Safety check (just in case 'encoding' was changed since compiling the program).
;                   int len = us_ptr2len_cc(opnd);
;                   if (1 < len)
;                   {
;                       int cf = 0;
;                       if (@ireg_ic)
;                           cf = utf_fold(us_ptr2char(opnd));
;                       while (count < maxcount)
;                       {
;                           int i;
;                           for (i = 0; i < len; i++)
;                               if (opnd.at(i) != scan.at(i))
;                                   break;
;                           if (i < len && (!@ireg_ic || utf_fold(us_ptr2char(scan)) != cf))
;                               break;
;                           scan = scan.plus(len);
;                           count++;
;                       }
;                   }
;                   break do_class;
;               }

;               case ANYOF:
;               case ANYOF + ADD_NL:
;                   testval = TRUE;
                    ;; FALLTHROUGH
;               case ANYBUT:
;               case ANYBUT + ADD_NL:
;                   while (count < maxcount)
;                   {
;                       int len;
;                       if (scan.at(0) == NUL)
;                       {
;                           if (!(@reg_match == null) || !with_nl(re_op(p)) || @reg_maxline < @reglnum || @reg_line_lbr)
;                               break;
;                           reg_nextline();
;                           scan = @reginput;
;                           if (@got_int)
;                               break;
;                       }
;                       else if (@reg_line_lbr && scan.at(0) == (byte)'\n' && with_nl(re_op(p)))
;                           scan = scan.plus(1);
;                       else if (1 < (len = us_ptr2len_cc(scan)))
;                       {
;                           if ((cstrchr(opnd, us_ptr2char(scan)) == null) == (testval != 0))
;                               break;
;                           scan = scan.plus(len);
;                       }
;                       else
;                       {
;                           if ((cstrchr(opnd, scan.at(0)) == null) == (testval != 0))
;                               break;
;                           scan = scan.plus(1);
;                       }
;                       count++;
;                   }
;                   break do_class;

;               case NEWL:
;                   while (count < maxcount
;                       && ((scan.at(0) == NUL && @reglnum <= @reg_maxline && !@reg_line_lbr && @reg_match == null)
;                           || (scan.at(0) == (byte)'\n' && @reg_line_lbr)))
;                   {
;                       count++;
;                       if (@reg_line_lbr)
;                           @reginput = @reginput.plus(us_ptr2len_cc(@reginput));
;                       else
;                           reg_nextline();
;                       scan = @reginput;
;                       if (@got_int)
;                           break;
;                   }
;                   break do_class;

;               default:                ;; Oh dear.  Called inappropriately.
;                   emsg(e_re_corr);
;                   break do_class;
;           }

;           while (count < maxcount)
;           {
;               int l;
;               if (scan.at(0) == NUL)
;               {
;                   if (@reg_match != null || !with_nl(re_op(p)) || @reg_maxline < @reglnum || @reg_line_lbr)
;                       break;
;                   reg_nextline();
;                   scan = @reginput;
;                   if (@got_int)
;                       break;
;               }
;               else if (1 < (l = us_ptr2len_cc(scan)))
;               {
;                   if (testval != 0)
;                       break;
;                   scan = scan.plus(l);
;               }
;               else if ((@class_tab[char_u(scan.at(0))] & mask) == testval)
;                   scan = scan.plus(1);
;               else if (@reg_line_lbr && scan.at(0) == (byte)'\n' && with_nl(re_op(p)))
;                   scan = scan.plus(1);
;               else
;                   break;
;               count++;
;           }
;       }

;       @reginput = scan;

;       return (int)count;
    ))

;; Dig the "next" pointer out of a node.
;; Returns null when calculating size, when there is no next item and when there is an error.

(defn- #_Bytes regnext [#_Bytes p]
    (§
;       if (p == JUST_CALC_SIZE || @reg_toolong)
;           return null;

;       int offset = re_next(p);
;       if (offset == 0)
;           return null;

;       if (re_op(p) == BACK)
;           return p.minus(offset);
;       else
;           return p.plus(offset);
    ))

;; Check the regexp program for its magic number.
;; Return true if it's wrong.

(defn- #_boolean prog_magic_wrong []
    (§
;       regprog_C prog = (@reg_match == null) ? @reg_mmatch.regprog : @reg_match.regprog;
;       if (prog.engine == nfa_regengine)
            ;; For NFA matcher we don't check the magic.
;           return false;

;       if (((bt_regprog_C)prog).program.at(0) != REGMAGIC)
;       {
;           emsg(e_re_corr);
;           return true;
;       }

;       return false;
    ))

;; Cleanup the subexpressions, if this wasn't done yet.
;; This construction is used to clear the subexpressions
;; only when they are used (to increase speed).

(defn- #_void cleanup_subexpr []
    (§
;       if (@need_clear_subexpr)
;       {
;           if (@reg_match == null)
;           {
;               for (int i = 0; i < NSUBEXP; i++)
;               {
                    ;; Use 0xff to set lnum to -1.
;                   MIN1_lpos(@reg_startpos[i]);
;                   MIN1_lpos(@reg_endpos[i]);
;               }
;           }
;           else
;           {
;               for (int i = 0; i < NSUBEXP; i++)
;               {
;                   @reg_startp[i] = null;
;                   @reg_endp[i] = null;
;               }
;           }
;           @need_clear_subexpr = false;
;       }
    ))

(defn- #_void cleanup_zsubexpr []
    (§
;       if (@need_clear_zsubexpr)
;       {
;           if (@reg_match == null)
;           {
;               for (int i = 0; i < NSUBEXP; i++)
;               {
                    ;; Use 0xff to set lnum to -1.
;                   MIN1_lpos(reg_startzpos[i]);
;                   MIN1_lpos(reg_endzpos[i]);
;               }
;           }
;           else
;           {
;               for (int i = 0; i < NSUBEXP; i++)
;               {
;                   reg_startzp[i] = null;
;                   reg_endzp[i] = null;
;               }
;           }
;           @need_clear_zsubexpr = false;
;       }
    ))

;; Save the current subexpr to "bp", so that they can be restored later by restore_subexpr().

(defn- #_void save_subexpr [#_regbehind_C bp]
    (§
        ;; When "need_clear_subexpr" is set we don't need to save the values,
        ;; only remember that this flag needs to be set again when restoring.
;       bp.save_need_clear_subexpr = @need_clear_subexpr;
;       if (!@need_clear_subexpr)
;       {
;           for (int i = 0; i < NSUBEXP; i++)
;           {
;               if (@reg_match == null)
;               {
;                   COPY_lpos(bp.save_start[i].se_pos, @reg_startpos[i]);
;                   COPY_lpos(bp.save_end[i].se_pos, @reg_endpos[i]);
;               }
;               else
;               {
;                   bp.save_start[i].se_ptr = @reg_startp[i];
;                   bp.save_end[i].se_ptr = @reg_endp[i];
;               }
;           }
;       }
    ))

;; Restore the subexpr from "bp".

(defn- #_void restore_subexpr [#_regbehind_C bp]
    (§
        ;; Only need to restore saved values when they are not to be cleared.
;       @need_clear_subexpr = bp.save_need_clear_subexpr;
;       if (!@need_clear_subexpr)
;       {
;           for (int i = 0; i < NSUBEXP; i++)
;           {
;               if (@reg_match == null)
;               {
;                   COPY_lpos(@reg_startpos[i], bp.save_start[i].se_pos);
;                   COPY_lpos(@reg_endpos[i], bp.save_end[i].se_pos);
;               }
;               else
;               {
;                   @reg_startp[i] = bp.save_start[i].se_ptr;
;                   @reg_endp[i] = bp.save_end[i].se_ptr;
;               }
;           }
;       }
    ))

;; Advance "reglnum", "regline" and "reginput" to the next line.

(defn- #_void reg_nextline []
    (§
;       @regline = reg_getline(++@reglnum);
;       @reginput = @regline;
;       fast_breakcheck();
    ))

;; Save the input line and position in a regsave_C.

(defn- #_void reg_save [#_regsave_C save, #_backpos_C* gap]
    (§
;       if (@reg_match == null)
;       {
;           save.rs_pos.col = BDIFF(@reginput, @regline);
;           save.rs_pos.lnum = @reglnum;
;       }
;       else
;           save.rs_ptr = @reginput;
;       save.rs_len = gap.ga_len;
    ))

;; Restore the input line and position from a regsave_C.

(defn- #_void reg_restore [#_regsave_C save, #_backpos_C* gap]
    (§
;       if (@reg_match == null)
;       {
;           if (@reglnum != save.rs_pos.lnum)
;           {
                ;; only call reg_getline() when the line number changed to save a bit of time
;               @reglnum = save.rs_pos.lnum;
;               @regline = reg_getline(@reglnum);
;           }
;           @reginput = @regline.plus(save.rs_pos.col);
;       }
;       else
;           @reginput = save.rs_ptr;
;       gap.ga_len = save.rs_len;
    ))

;; Return true if current position is equal to saved position.

(defn- #_boolean reg_save_equal [#_regsave_C save]
    (§
;       if (@reg_match == null)
;           return (@reglnum == save.rs_pos.lnum && BEQ(@reginput, @regline.plus(save.rs_pos.col)));

;       return BEQ(@reginput, save.rs_ptr);
    ))

;; Tentatively set the sub-expression start to the current position (after calling regmatch()
;; they will have changed).  Need to save the existing values for when there is no match.
;; Use se_save() to use pointer (save_se_multi()) or position (save_se_one()),
;; depending on REG_MULTI.

(defn- #_void save_se_multi [#_save_se_C savep, #_lpos_C posp]
    (§
;       COPY_lpos(savep.se_pos, posp);
;       posp.lnum = @reglnum;
;       posp.col = BDIFF(@reginput, @regline);
    ))

(defn- #_Bytes save_se_one [#_save_se_C savep, #_Bytes pp]
    (§
;       savep.se_ptr = pp;
;       pp = @reginput;
;       return pp;
    ))

;; Save the sub-expressions before attempting a match.
(defn- #_Bytes save_se [#_save_se_C savep, #_lpos_C posp, #_Bytes pp]
    (§
;       if (@reg_match == null)
;           save_se_multi(savep, posp);
;       else
;           pp = save_se_one(savep, pp);

;       return pp;
    ))

;; After a failed match restore the sub-expressions.
(defn- #_Bytes restore_se [#_save_se_C savep, #_lpos_C posp, #_Bytes pp]
    (§
;       if (@reg_match == null)
;           COPY_lpos(posp, savep.se_pos);
;       else
;           pp = savep.se_ptr;

;       return pp;
    ))

;; Compare a number with the operand of RE_LNUM, RE_COL or RE_VCOL.

(defn- #_boolean re_num_cmp [#_long val, #_Bytes scan]
    (§
;       long n = operand_min(scan);

;       if (operand_cmp(scan) == '>')
;           return (val > n);
;       if (operand_cmp(scan) == '<')
;           return (val < n);

;       return (val == n);
    ))

;; Check whether a backreference matches.
;; Returns RA_FAIL, RA_NOMATCH or RA_MATCH.
;; If "bytelen" is not null, it is set to the byte length of the match in the last line.

(defn- #_int match_with_backref [#_long start_lnum, #_int start_col, #_long end_lnum, #_int end_col, #_int* bytelen]
    (§
;       long clnum = start_lnum;
;       int ccol = start_col;

;       if (bytelen != null)
;           bytelen[0] = 0;

;       for ( ; ; )
;       {
            ;; Since getting one line may invalidate the other, need to make copy.
            ;; Slow!
;           if (BNE(@regline, @reg_tofree))
;           {
;               int len = STRLEN(@regline);
;               if (@reg_tofree == null || @reg_tofree_len <= len)
;               {
;                   len += 50;                              ;; get some extra
;                   @reg_tofree = new Bytes(len);
;                   @reg_tofree_len = len;
;               }
;               STRCPY(@reg_tofree, @regline);
;               @reginput = @reg_tofree.plus(BDIFF(@reginput, @regline));
;               @regline = @reg_tofree;
;           }

            ;; Get the line to compare with.
;           Bytes p = reg_getline(clnum);
;           int[] len = new int[1];
;           if (clnum == end_lnum)
;               len[0] = end_col - ccol;
;           else
;               len[0] = STRLEN(p, ccol);

;           if (cstrncmp(p.plus(ccol), @reginput, len) != 0)
;               return RA_NOMATCH;                          ;; doesn't match
;           if (bytelen != null)
;               bytelen[0] += len[0];
;           if (clnum == end_lnum)
;               break;                                      ;; match and at end!
;           if (@reg_maxline <= @reglnum)
;               return RA_NOMATCH;                          ;; text too short

            ;; Advance to next line.
;           reg_nextline();
;           if (bytelen != null)
;               bytelen[0] = 0;
;           clnum++;
;           ccol = 0;
;           if (@got_int)
;               return RA_FAIL;
;       }

        ;; Found a match!
        ;; Note that regline may now point to a copy of the line, that should not matter.
;       return RA_MATCH;
    ))

;; Used in a place where no * or \+ can follow.

(defn- #_boolean re_mult_next [#_Bytes what]
    (§
;       if (re_multi_type(peekchr()) == MULTI_MULT)
;       {
;           emsg2(u8("E888: (NFA regexp) cannot repeat %s"), what);
;           @rc_did_emsg = true;
;           return false;
;       }
;       return true;
    ))

(class! #_final decomp_C
    [
        (field int a) (field int b) (field int c)
    ])

;; 0xfb20 - 0xfb4f
(final decomp_C* decomp_table
    [
        (->decomp_C  0x5e2,     0,     0)   ;; 0xfb20   alt ayin
        (->decomp_C  0x5d0,     0,     0)   ;; 0xfb21   alt alef
        (->decomp_C  0x5d3,     0,     0)   ;; 0xfb22   alt dalet
        (->decomp_C  0x5d4,     0,     0)   ;; 0xfb23   alt he
        (->decomp_C  0x5db,     0,     0)   ;; 0xfb24   alt kaf
        (->decomp_C  0x5dc,     0,     0)   ;; 0xfb25   alt lamed
        (->decomp_C  0x5dd,     0,     0)   ;; 0xfb26   alt mem-sofit
        (->decomp_C  0x5e8,     0,     0)   ;; 0xfb27   alt resh
        (->decomp_C  0x5ea,     0,     0)   ;; 0xfb28   alt tav
        (->decomp_C (int \+),   0,     0)   ;; 0xfb29   alt plus
        (->decomp_C  0x5e9, 0x5c1,     0)   ;; 0xfb2a   shin+shin-dot
        (->decomp_C  0x5e9, 0x5c2,     0)   ;; 0xfb2b   shin+sin-dot
        (->decomp_C  0x5e9, 0x5c1, 0x5bc)   ;; 0xfb2c   shin+shin-dot+dagesh
        (->decomp_C  0x5e9, 0x5c2, 0x5bc)   ;; 0xfb2d   shin+sin-dot+dagesh
        (->decomp_C  0x5d0, 0x5b7,     0)   ;; 0xfb2e   alef+patah
        (->decomp_C  0x5d0, 0x5b8,     0)   ;; 0xfb2f   alef+qamats
        (->decomp_C  0x5d0, 0x5b4,     0)   ;; 0xfb30   alef+hiriq
        (->decomp_C  0x5d1, 0x5bc,     0)   ;; 0xfb31   bet+dagesh
        (->decomp_C  0x5d2, 0x5bc,     0)   ;; 0xfb32   gimel+dagesh
        (->decomp_C  0x5d3, 0x5bc,     0)   ;; 0xfb33   dalet+dagesh
        (->decomp_C  0x5d4, 0x5bc,     0)   ;; 0xfb34   he+dagesh
        (->decomp_C  0x5d5, 0x5bc,     0)   ;; 0xfb35   vav+dagesh
        (->decomp_C  0x5d6, 0x5bc,     0)   ;; 0xfb36   zayin+dagesh
        (->decomp_C 0xfb37,     0,     0)   ;; 0xfb37 - UNUSED
        (->decomp_C  0x5d8, 0x5bc,     0)   ;; 0xfb38   tet+dagesh
        (->decomp_C  0x5d9, 0x5bc,     0)   ;; 0xfb39   yud+dagesh
        (->decomp_C  0x5da, 0x5bc,     0)   ;; 0xfb3a   kaf sofit+dagesh
        (->decomp_C  0x5db, 0x5bc,     0)   ;; 0xfb3b   kaf+dagesh
        (->decomp_C  0x5dc, 0x5bc,     0)   ;; 0xfb3c   lamed+dagesh
        (->decomp_C 0xfb3d,     0,     0)   ;; 0xfb3d - UNUSED
        (->decomp_C  0x5de, 0x5bc,     0)   ;; 0xfb3e   mem+dagesh
        (->decomp_C 0xfb3f,     0,     0)   ;; 0xfb3f - UNUSED
        (->decomp_C  0x5e0, 0x5bc,     0)   ;; 0xfb40   nun+dagesh
        (->decomp_C  0x5e1, 0x5bc,     0)   ;; 0xfb41   samech+dagesh
        (->decomp_C 0xfb42,     0,     0)   ;; 0xfb42 - UNUSED
        (->decomp_C  0x5e3, 0x5bc,     0)   ;; 0xfb43   pe sofit+dagesh
        (->decomp_C  0x5e4, 0x5bc,     0)   ;; 0xfb44   pe+dagesh
        (->decomp_C 0xfb45,     0,     0)   ;; 0xfb45 - UNUSED
        (->decomp_C  0x5e6, 0x5bc,     0)   ;; 0xfb46   tsadi+dagesh
        (->decomp_C  0x5e7, 0x5bc,     0)   ;; 0xfb47   qof+dagesh
        (->decomp_C  0x5e8, 0x5bc,     0)   ;; 0xfb48   resh+dagesh
        (->decomp_C  0x5e9, 0x5bc,     0)   ;; 0xfb49   shin+dagesh
        (->decomp_C  0x5ea, 0x5bc,     0)   ;; 0xfb4a   tav+dagesh
        (->decomp_C  0x5d5, 0x5b9,     0)   ;; 0xfb4b   vav+holam
        (->decomp_C  0x5d1, 0x5bf,     0)   ;; 0xfb4c   bet+rafe
        (->decomp_C  0x5db, 0x5bf,     0)   ;; 0xfb4d   kaf+rafe
        (->decomp_C  0x5e4, 0x5bf,     0)   ;; 0xfb4e   pe+rafe
        (->decomp_C  0x5d0, 0x5dc,     0)   ;; 0xfb4f   alef-lamed
    ])

(defn- #_void mb_decompose [#_int c, #_int* c1, #_int* c2, #_int* c3]
    (§
;       if (0xfb20 <= c && c <= 0xfb4f)
;       {
;           decomp_C d = decomp_table[c - 0xfb20];
;           c1[0] = d.a;
;           c2[0] = d.b;
;           c3[0] = d.c;
;       }
;       else
;       {
;           c1[0] = c;
;           c2[0] = c3[0] = 0;
;       }
    ))

;; Compare two strings, ignore case if ireg_ic set.
;; Return 0 if strings match, non-zero otherwise.
;; Correct the length "*n" when composing characters are ignored.

(defn- #_int cstrncmp [#_Bytes s1, #_Bytes s2, #_int* n]
    (§
;       int result;

;       if (!@ireg_ic)
;           result = STRNCMP(s1, s2, n[0]);
;       else
;           result = us_strnicmp(s1, s2, n[0]);

        ;; if it failed and it's utf8 and we want to combineignore
;       if (result != 0 && @ireg_icombine)
;       {
;           Bytes[] str1 = { s1 };
;           Bytes[] str2 = { s2 };
;           int c1 = 0, c2 = 0;

            ;; We have to handle the strcmp() ourselves, since it is necessary
            ;; to deal with the composing characters by ignoring them.
;           while (BDIFF(str1[0], s1) < n[0])
;           {
;               c1 = us_ptr2char_adv(str1, true);
;               c2 = us_ptr2char_adv(str2, true);

                ;; Decompose the character if necessary into 'base' characters,
                ;; because I don't care about Arabic, I will hard-code the Hebrew
                ;; which I *do* care about!  So sue me...
;               if (c1 != c2 && (!@ireg_ic || utf_fold(c1) != utf_fold(c2)))
;               {
;                   int[] c11 = new int[1];
;                   int[] c12 = new int[1];
;                   int[] junk = new int[1];

                    ;; decomposition necessary?
;                   mb_decompose(c1, c11, junk, junk);
;                   mb_decompose(c2, c12, junk, junk);
;                   c1 = c11[0];
;                   c2 = c12[0];
;                   if (c11[0] != c12[0] && (!@ireg_ic || utf_fold(c11[0]) != utf_fold(c12[0])))
;                       break;
;               }
;           }
;           result = c2 - c1;
;           if (result == 0)
;               n[0] = BDIFF(str2[0], s2);
;       }

;       return result;
    ))

;; This function is used a lot for simple searches, keep it fast!

(defn- #_Bytes cstrchr [#_Bytes s, #_int c]
    (§
;       if (!@ireg_ic)
;           return vim_strchr(s, c);

;       int cc;
;       if (0x80 < c)
;           cc = utf_fold(c);
;       else if (utf_isupper(c))
;           cc = utf_tolower(c);
;       else if (utf_islower(c))
;           cc = utf_toupper(c);
;       else
;           return vim_strchr(s, c);

;       for (Bytes p = s; p.at(0) != NUL; p = p.plus(us_ptr2len_cc(p)))
;       {
;           if (0x80 < c)
;           {
;               if (utf_fold(us_ptr2char(p)) == cc)
;                   return p;
;           }
;           else if (p.at(0) == c || p.at(0) == cc)
;               return p;
;       }

;       return null;
    ))

;; regsub stuff

;; We should define ftpr as a pointer to a function returning
;; a pointer to a function returning a pointer to a function ...
;; This is impossible, so we declare a pointer to a function
;; returning a pointer to a function returning void.

(§
;   static abstract class fptr_C
    (§
;       public abstract fptr_C flip(int[] d, int c);
    ))

;   static final fptr_C do_upper = new fptr_C()
;   {
;       public fptr_C flip(int[] d, int c) { d[0] = utf_toupper(c); return null; }
;   };

;   static final fptr_C do_Upper = new fptr_C()
;   {
;       public fptr_C flip(int[] d, int c) { d[0] = utf_toupper(c); return this; }
;   };

;   static final fptr_C do_lower = new fptr_C()
;   {
;       public fptr_C flip(int[] d, int c) { d[0] = utf_tolower(c); return null; }
;   };

;   static final fptr_C do_Lower = new fptr_C()
;   {
;       public fptr_C flip(int[] d, int c) { d[0] = utf_tolower(c); return this; }
;   };

;; regtilde(): Replace tildes in the pattern by the old pattern.
;;
;; Short explanation of the tilde: It stands for the previous replacement pattern.
;; If that previous pattern also contains a ~ we should go back a step further...
;; But we insert the previous pattern into the current one and remember that.
;; This still does not handle the case where "magic" changes.  So require the
;; user to keep his hands off of "magic".
;;
;; The tildes are parsed once before the first call to vim_regsub().

(defn- #_Bytes regtilde [#_Bytes source, #_boolean magic]
    (§
;       Bytes newsub = source;

;       for (Bytes p = newsub; p.at(0) != NUL; p = p.plus(1))
;       {
;           if ((p.at(0) == (byte)'~' && magic) || (p.at(0) == (byte)'\\' && p.at(1) == (byte)'~' && !magic))
;           {
;               if (@reg_prev_sub != null)
;               {
                    ;; length = len(newsub) - 1 + len(prev_sub) + 1
;                   int prevlen = STRLEN(@reg_prev_sub);
;                   Bytes tmpsub = new Bytes(STRLEN(newsub) + prevlen);

                    ;; copy prefix
;                   int len = BDIFF(p, newsub);            ;; not including ~
;                   BCOPY(tmpsub, newsub, len);
                    ;; interpret tilde
;                   BCOPY(tmpsub, len, @reg_prev_sub, 0, prevlen);
                    ;; copy postfix
;                   if (!magic)
;                       p = p.plus(1);                                ;; back off \
;                   STRCPY(tmpsub.plus(len + prevlen), p.plus(1));

;                   newsub = tmpsub;
;                   p = newsub.plus(len + prevlen);
;               }
;               else if (magic)
;                   BCOPY(p, 0, p, 1, STRLEN(p, 1) + 1);   ;; remove '~'
;               else
;                   BCOPY(p, 0, p, 2, STRLEN(p, 2) + 1);   ;; remove '\~'
;               p = p.minus(1);
;           }
;           else
;           {
;               if (p.at(0) == (byte)'\\' && p.at(1) != NUL)        ;; skip escaped characters
;                   p = p.plus(1);
;               p = p.plus(us_ptr2len_cc(p) - 1);
;           }
;       }

;       if (BNE(newsub, source))                       ;; "newsub" was allocated, just keep it
;           @reg_prev_sub = newsub;
;       else                                        ;; no ~ found, need to save "newsub"
;           @reg_prev_sub = STRDUP(newsub);

;       return newsub;
    ))

(atom! boolean can_f_submatch)          ;; true when submatch() can be used

;; These pointers are used instead of reg_match and reg_mmatch for reg_submatch().
;; Needed when the substitution string is an expression
;; that contains a call to substitute() and submatch().

(atom! regmatch_C       submatch_match)
(atom! regmmatch_C      submatch_mmatch)
(atom! long             submatch_firstlnum)
(atom! long             submatch_maxline)
(atom! boolean          submatch_line_lbr)

;; vim_regsub() - perform substitutions after a vim_regexec() or vim_regexec_multi() match.
;;
;; If "copy" is true really copy into "dest".
;; If "copy" is false nothing is copied, this is just to find out the length of the result.
;;
;; If "backslash" is true, a backslash will be removed later, need to double them to keep them,
;; and insert a backslash before a CR to avoid it being replaced with a line break later.
;;
;; Note: The matched text must not change between the call of vim_regexec()/vim_regexec_multi()
;; and vim_regsub()!  It would make the back references invalid!
;;
;; Returns the size of the replacement, including terminating NUL.

(defn- #_int vim_regsub [#_regmatch_C rmp, #_Bytes source, #_Bytes dest, #_boolean copy, #_boolean magic, #_boolean backslash]
    (§
;       @reg_match = rmp;
;       @reg_mmatch = null;
;       @reg_maxline = 0;
;       @reg_buf = @curbuf;
;       @reg_line_lbr = true;
;       return vim_regsub_both(source, dest, copy, magic, backslash);
    ))

(defn- #_int vim_regsub_multi [#_regmmatch_C rmp, #_long lnum, #_Bytes source, #_Bytes dest, #_boolean copy, #_boolean magic, #_boolean backslash]
    (§
;       @reg_match = null;
;       @reg_mmatch = rmp;
;       @reg_buf = @curbuf;           ;; always works on the current buffer!
;       @reg_firstlnum = lnum;
;       @reg_maxline = @curbuf.b_ml.ml_line_count - lnum;
;       @reg_line_lbr = false;
;       return vim_regsub_both(source, dest, copy, magic, backslash);
    ))

(atom! Bytes eval_result)

(defn- #_int vim_regsub_both [#_Bytes source, #_Bytes dest, #_boolean copy, #_boolean magic, #_boolean backslash]
    (§
        ;; Be paranoid...
;       if (source == null || dest == null)
;       {
;           emsg(e_null);
;           return 0;
;       }
;       if (prog_magic_wrong())
;           return 0;

;       Bytes dst = dest;

        ;; When the substitute part starts with "\=" evaluate it as an expression.

;       if (source.at(0) == (byte)'\\' && source.at(1) == (byte)'=' && !@can_f_submatch)   ;; can't do this recursively
;       {
            ;; To make sure that the length doesn't change between checking the length
            ;; and copying the string, and to speed up things, the resulting string is saved
            ;; from the call with "copy" == false to the call with "copy" == true.
;           if (copy)
;           {
;               if (@eval_result != null)
;               {
;                   STRCPY(dest, @eval_result);
;                   dst = dst.plus(STRLEN(@eval_result));
;                   @eval_result = null;
;               }
;           }
;           else
;           {
                ;; The expression may contain substitute(), which calls us recursively.
                ;; Make sure submatch() gets the text from the first level.
                ;; Don't need to save "reg_buf", because vim_regexec_multi() can't be called recursively.

;               @submatch_match = @reg_match;
;               @submatch_mmatch = @reg_mmatch;
;               @submatch_firstlnum = @reg_firstlnum;
;               @submatch_maxline = @reg_maxline;
;               @submatch_line_lbr = @reg_line_lbr;

;               window_C save_reg_win = @reg_win;
;               boolean save_ireg_ic = @ireg_ic;
;               @can_f_submatch = true;

;               @eval_result = eval_to_string(source.plus(2), null, true);
;               if (@eval_result != null)
;               {
;                   boolean had_backslash = false;

;                   for (Bytes s = @eval_result; s.at(0) != NUL; s = s.plus(us_ptr2len_cc(s)))
;                   {
                        ;; Change NL to CR, so that it becomes a line break,
                        ;; unless called from vim_regexec_nl().
                        ;; Skip over a backslashed character.
;                       if (s.at(0) == NL && !@submatch_line_lbr)
;                           s.be(0, CAR);
;                       else if (s.at(0) == (byte)'\\' && s.at(1) != NUL)
;                       {
;                           s = s.plus(1);
                            ;; Change NL to CR here too, so that this works:
                            ;; :s/abc\\\ndef/\="aaa\\\nbbb"/  on text:
                            ;;   abc\
                            ;;   def
                            ;; Not when called from vim_regexec_nl().

;                           if (s.at(0) == NL && !@submatch_line_lbr)
;                               s.be(0, CAR);
;                           had_backslash = true;
;                       }
;                   }
;                   if (had_backslash && backslash)
;                   {
                        ;; Backslashes will be consumed, need to double them.
;                       @eval_result = vim_strsave_escaped(@eval_result, u8("\\"));
;                   }

;                   dst = dst.plus(STRLEN(@eval_result));
;               }

;               @reg_match = @submatch_match;
;               @reg_mmatch = @submatch_mmatch;
;               @reg_firstlnum = @submatch_firstlnum;
;               @reg_maxline = @submatch_maxline;
;               @reg_line_lbr = @submatch_line_lbr;
;               @reg_win = save_reg_win;
;               @ireg_ic = save_ireg_ic;
;               @can_f_submatch = false;
;           }
;       }
;       else
;       {
;           fptr_C func_one = null;
;           fptr_C func_all = null;

;           int no = -1;
;           long clnum = 0;
;           int len = 0;

;           Bytes src = source;

;           for (byte b; (b = (src = src.plus(1)).at(-1)) != NUL; )
;           {
;               if (b == '&' && magic)
;                   no = 0;
;               else if (b == '\\' && src.at(0) != NUL)
;               {
;                   if (src.at(0) == (byte)'&' && !magic)
;                   {
;                       src = src.plus(1);
;                       no = 0;
;                   }
;                   else if ('0' <= src.at(0) && src.at(0) <= '9')
;                   {
;                       no = (src = src.plus(1)).at(-1) - '0';
;                   }
;                   else if (vim_strbyte(u8("uUlLeE"), src.at(0)) != null)
;                   {
;                       switch ((src = src.plus(1)).at(-1))
;                       {
;                           case 'u':   func_one = do_upper;
;                                       continue;
;                           case 'U':   func_all = do_Upper;
;                                       continue;
;                           case 'l':   func_one = do_lower;
;                                       continue;
;                           case 'L':   func_all = do_Lower;
;                                       continue;
;                           case 'e':
;                           case 'E':   func_one = func_all = null;
;                                       continue;
;                       }
;                   }
;               }
;               if (no < 0)             ;; Ordinary character.
;               {
;                   if (b == KB_SPECIAL && src.at(0) != NUL && src.at(1) != NUL)
;                   {
                        ;; Copy a special key as-is.
;                       if (copy)
;                       {
;                           (dst = dst.plus(1)).be(-1, b);
;                           (dst = dst.plus(1)).be(-1, (src = src.plus(1)).at(-1));
;                           (dst = dst.plus(1)).be(-1, (src = src.plus(1)).at(-1));
;                       }
;                       else
;                       {
;                           dst = dst.plus(3);
;                           src = src.plus(2);
;                       }
;                       continue;
;                   }

;                   int c;
;                   if (b == '\\' && src.at(0) != NUL)
;                   {
                        ;; Check for abbreviations.
;                       switch (src.at(0))
;                       {
;                           case 'r': b = CAR;    src = src.plus(1); break;
;                           case 'n': b = NL;     src = src.plus(1); break;
;                           case 't': b = TAB;    src = src.plus(1); break;
                         ;; Oh no!  \e already has meaning in subst pat :-(
                         ;; case 'e': b = ESC;    src = src.plus(1); break;
;                           case 'b': b = Ctrl_H; src = src.plus(1); break;

                            ;; If "backslash" is true the backslash will be removed later.
                            ;; Used to insert a literal CR.
;                           default: if (backslash)
;                                    {
;                                        if (copy)
;                                            dst.be(0, (byte)'\\');
;                                        dst = dst.plus(1);
;                                    }
;                                    b = (src = src.plus(1)).at(-1);
;                       }
;                       c = char_u(b);
;                   }
;                   else
;                       c = us_ptr2char(src.minus(1));

                    ;; Write to buffer, if copy is set.
;                   int[] cc = new int[1];
;                   if (func_one != null)
;                       func_one = func_one.flip(cc, c);
;                   else if (func_all != null)
;                       func_all = func_all.flip(cc, c);
;                   else ;; just copy
;                       cc[0] = c;

;                   int totlen = us_ptr2len_cc(src.minus(1));

;                   if (copy)
;                       utf_char2bytes(cc[0], dst);
;                   dst = dst.plus(utf_char2len(cc[0]) - 1);

;                   int clen = us_ptr2len(src.minus(1));

                    ;; If the character length is shorter than "totlen",
                    ;; there are composing characters; copy them as-is.
;                   if (clen < totlen)
;                   {
;                       if (copy)
;                           BCOPY(dst, 1, src, -1 + clen, totlen - clen);
;                       dst = dst.plus(totlen - clen);
;                   }

;                   src = src.plus(totlen - 1);

;                   dst = dst.plus(1);
;               }
;               else
;               {
;                   Bytes s;
;                   if (@reg_match == null)
;                   {
;                       clnum = @reg_mmatch.startpos[no].lnum;
;                       if (clnum < 0 || @reg_mmatch.endpos[no].lnum < 0)
;                           s = null;
;                       else
;                       {
;                           s = reg_getline(clnum).plus(@reg_mmatch.startpos[no].col);
;                           if (@reg_mmatch.endpos[no].lnum == clnum)
;                               len = @reg_mmatch.endpos[no].col - @reg_mmatch.startpos[no].col;
;                           else
;                               len = STRLEN(s);
;                       }
;                   }
;                   else
;                   {
;                       s = @reg_match.startp[no];
;                       if (@reg_match.endp[no] == null)
;                           s = null;
;                       else
;                           len = BDIFF(@reg_match.endp[no], s);
;                   }
;                   if (s != null)
;                   {
;                       for ( ; ; )
;                       {
;                           if (len == 0)
;                           {
;                               if (@reg_match == null)
;                               {
;                                   if (@reg_mmatch.endpos[no].lnum == clnum)
;                                       break;
;                                   if (copy)
;                                       dst.be(0, CAR);
;                                   dst = dst.plus(1);
;                                   s = reg_getline(++clnum);
;                                   if (@reg_mmatch.endpos[no].lnum == clnum)
;                                       len = @reg_mmatch.endpos[no].col;
;                                   else
;                                       len = STRLEN(s);
;                               }
;                               else
;                                   break;
;                           }
;                           else if (s.at(0) == NUL)
;                           {
;                               if (copy)
;                                   emsg(e_re_damg);
;                               return BDIFF(dst, dest) + 1;
;                           }
;                           else
;                           {
;                               if (backslash && (s.at(0) == CAR || s.at(0) == (byte)'\\'))
;                               {
                                    ;; Insert a backslash in front of a CR,
                                    ;; otherwise it will be replaced by a line break.
                                    ;; Number of backslashes will be halved later, double them here.

;                                   if (copy)
;                                   {
;                                       dst.be(0, (byte)'\\');
;                                       dst.be(1, s.at(0));
;                                   }
;                                   dst = dst.plus(2);
;                               }
;                               else
;                               {
;                                   int c = us_ptr2char(s);

;                                   int[] cc = new int[1];
;                                   if (func_one != null)
;                                       func_one = func_one.flip(cc, c);
;                                   else if (func_all != null)
;                                       func_all = func_all.flip(cc, c);
;                                   else ;; just copy
;                                       cc[0] = c;

                                    ;; Copy composing characters separately, one at a time.
;                                   int l = us_ptr2len(s) - 1;

;                                   s = s.plus(l);
;                                   len -= l;
;                                   if (copy)
;                                       utf_char2bytes(cc[0], dst);
;                                   dst = dst.plus(utf_char2len(cc[0]) - 1);

;                                   dst = dst.plus(1);
;                               }

;                               s = s.plus(1);
;                               --len;
;                           }
;                       }
;                   }
;                   no = -1;
;               }
;           }
;       }

;       if (copy)
;           dst.be(0, NUL);

;       return BDIFF(dst, dest) + 1;
    ))

;;; ============================================================================================== VimO

;; NFA regular expression implementation.

;; Added to NFA_ANY - NFA_NUPPER_IC to include a NL.
(final int NFA_ADD_NL 31)

(final int
    NFA_SPLIT -1024,
    NFA_MATCH -1023,
    NFA_EMPTY -1022,                      ;; matches 0-length

    NFA_START_COLL -1021,                 ;; [abc] start
    NFA_END_COLL -1020,                   ;; [abc] end
    NFA_START_NEG_COLL -1019,             ;; [^abc] start
    NFA_END_NEG_COLL -1018,               ;; [^abc] end (postfix only)
    NFA_RANGE -1017,                      ;; range of the two previous items (postfix only)
    NFA_RANGE_MIN -1016,                  ;; low end of a range
    NFA_RANGE_MAX -1015,                  ;; high end of a range

    NFA_CONCAT -1014,                     ;; concatenate two previous items (postfix only)
    NFA_OR -1013,                         ;; \| (postfix only)
    NFA_STAR -1012,                       ;; greedy * (posfix only)
    NFA_STAR_NONGREEDY -1011,             ;; non-greedy * (postfix only)
    NFA_QUEST -1010,                      ;; greedy \? (postfix only)
    NFA_QUEST_NONGREEDY -1009,            ;; non-greedy \? (postfix only)

    NFA_BOL -1008,                        ;; ^    Begin line
    NFA_EOL -1007,                        ;; $    End line
    NFA_BOW -1006,                        ;; \<   Begin word
    NFA_EOW -1005,                        ;; \>   End word
    NFA_BOF -1004,                        ;; \%^  Begin file
    NFA_EOF -1003,                        ;; \%$  End file
    NFA_NEWL -1002,
    NFA_ZSTART -1001,                     ;; Used for \zs
    NFA_ZEND -1000,                       ;; Used for \ze
    NFA_NOPEN -999,                       ;; Start of subexpression marked with \%(
    NFA_NCLOSE -998,                      ;; End of subexpr. marked with \%( ... \)
    NFA_START_INVISIBLE -997,
    NFA_START_INVISIBLE_FIRST -996,
    NFA_START_INVISIBLE_NEG -995,
    NFA_START_INVISIBLE_NEG_FIRST -994,
    NFA_START_INVISIBLE_BEFORE -993,
    NFA_START_INVISIBLE_BEFORE_FIRST -992,
    NFA_START_INVISIBLE_BEFORE_NEG -991,
    NFA_START_INVISIBLE_BEFORE_NEG_FIRST -990,
    NFA_START_PATTERN -989,
    NFA_END_INVISIBLE -988,
    NFA_END_INVISIBLE_NEG -987,
    NFA_END_PATTERN -986,
    NFA_COMPOSING -985,                   ;; Next nodes in NFA are part of the composing multibyte char
    NFA_END_COMPOSING -984,               ;; End of a composing char in the NFA
    NFA_ANY_COMPOSING -983,               ;; \%C: Any composing characters.
    NFA_OPT_CHARS -982,                   ;; \%[abc]

        ;; The following are used only in the postfix form, not in the NFA.
    NFA_PREV_ATOM_NO_WIDTH -981,          ;; Used for \@=
    NFA_PREV_ATOM_NO_WIDTH_NEG -980,      ;; Used for \@!
    NFA_PREV_ATOM_JUST_BEFORE -979,       ;; Used for \@<=
    NFA_PREV_ATOM_JUST_BEFORE_NEG -978,   ;; Used for \@<!
    NFA_PREV_ATOM_LIKE_PATTERN -977,      ;; Used for \@>

    NFA_BACKREF1 -976,                    ;; \1
    NFA_BACKREF2 -975,                    ;; \2
    NFA_BACKREF3 -974,                    ;; \3
    NFA_BACKREF4 -973,                    ;; \4
    NFA_BACKREF5 -972,                    ;; \5
    NFA_BACKREF6 -971,                    ;; \6
    NFA_BACKREF7 -970,                    ;; \7
    NFA_BACKREF8 -969,                    ;; \8
    NFA_BACKREF9 -968,                    ;; \9
    NFA_ZREF1 -967,                       ;; \z1
    NFA_ZREF2 -966,                       ;; \z2
    NFA_ZREF3 -965,                       ;; \z3
    NFA_ZREF4 -964,                       ;; \z4
    NFA_ZREF5 -963,                       ;; \z5
    NFA_ZREF6 -962,                       ;; \z6
    NFA_ZREF7 -961,                       ;; \z7
    NFA_ZREF8 -960,                       ;; \z8
    NFA_ZREF9 -959,                       ;; \z9
    NFA_SKIP -958,                        ;; Skip characters

    NFA_MOPEN -957,
    NFA_MOPEN1 -956,
    NFA_MOPEN2 -955,
    NFA_MOPEN3 -954,
    NFA_MOPEN4 -953,
    NFA_MOPEN5 -952,
    NFA_MOPEN6 -951,
    NFA_MOPEN7 -950,
    NFA_MOPEN8 -949,
    NFA_MOPEN9 -948,

    NFA_MCLOSE -947,
    NFA_MCLOSE1 -946,
    NFA_MCLOSE2 -945,
    NFA_MCLOSE3 -944,
    NFA_MCLOSE4 -943,
    NFA_MCLOSE5 -942,
    NFA_MCLOSE6 -941,
    NFA_MCLOSE7 -940,
    NFA_MCLOSE8 -939,
    NFA_MCLOSE9 -938,

    NFA_ZOPEN -937,
    NFA_ZOPEN1 -936,
    NFA_ZOPEN2 -935,
    NFA_ZOPEN3 -934,
    NFA_ZOPEN4 -933,
    NFA_ZOPEN5 -932,
    NFA_ZOPEN6 -931,
    NFA_ZOPEN7 -930,
    NFA_ZOPEN8 -929,
    NFA_ZOPEN9 -928,

    NFA_ZCLOSE -927,
    NFA_ZCLOSE1 -926,
    NFA_ZCLOSE2 -925,
    NFA_ZCLOSE3 -924,
    NFA_ZCLOSE4 -923,
    NFA_ZCLOSE5 -922,
    NFA_ZCLOSE6 -921,
    NFA_ZCLOSE7 -920,
    NFA_ZCLOSE8 -919,
    NFA_ZCLOSE9 -918,

        ;; NFA_FIRST_NL
    NFA_ANY -917,                        ;; Match any one character.
    NFA_IDENT -916,                      ;; Match identifier char
    NFA_SIDENT -915,                     ;; Match identifier char but no digit
    NFA_KWORD -914,                      ;; Match keyword char
    NFA_SKWORD -913,                     ;; Match word char but no digit
    NFA_FNAME -912,                      ;; Match file name char
    NFA_SFNAME -911,                     ;; Match file name char but no digit
    NFA_PRINT -910,                      ;; Match printable char
    NFA_SPRINT -909,                     ;; Match printable char but no digit
    NFA_WHITE -908,                      ;; Match whitespace char
    NFA_NWHITE -907,                     ;; Match non-whitespace char
    NFA_DIGIT -906,                      ;; Match digit char
    NFA_NDIGIT -905,                     ;; Match non-digit char
    NFA_HEX -904,                        ;; Match hex char
    NFA_NHEX -903,                       ;; Match non-hex char
    NFA_OCTAL -902,                      ;; Match octal char
    NFA_NOCTAL -901,                     ;; Match non-octal char
    NFA_WORD -900,                       ;; Match word char
    NFA_NWORD -899,                      ;; Match non-word char
    NFA_HEAD -898,                       ;; Match head char
    NFA_NHEAD -897,                      ;; Match non-head char
    NFA_ALPHA -896,                      ;; Match alpha char
    NFA_NALPHA -895,                     ;; Match non-alpha char
    NFA_LOWER -894,                      ;; Match lowercase char
    NFA_NLOWER -893,                     ;; Match non-lowercase char
    NFA_UPPER -892,                      ;; Match uppercase char
    NFA_NUPPER -891,                     ;; Match non-uppercase char
    NFA_LOWER_IC -890,                   ;; Match [a-z]
    NFA_NLOWER_IC -889,                  ;; Match [^a-z]
    NFA_UPPER_IC -888,                   ;; Match [A-Z]
    NFA_NUPPER_IC -887,                  ;; Match [^A-Z]

    NFA_FIRST_NL (+ NFA_ANY NFA_ADD_NL),
    NFA_LAST_NL (+ NFA_NUPPER_IC NFA_ADD_NL),

    NFA_CURSOR -855,                     ;; Match cursor pos
    NFA_LNUM -854,                       ;; Match line number
    NFA_LNUM_GT -853,                    ;; Match > line number
    NFA_LNUM_LT -852,                    ;; Match < line number
    NFA_COL -851,                        ;; Match cursor column
    NFA_COL_GT -850,                     ;; Match > cursor column
    NFA_COL_LT -849,                     ;; Match < cursor column
    NFA_VCOL -848,                       ;; Match cursor virtual column
    NFA_VCOL_GT -847,                    ;; Match > cursor virtual column
    NFA_VCOL_LT -846,                    ;; Match < cursor virtual column
    NFA_MARK -845,                       ;; Match mark
    NFA_MARK_GT -844,                    ;; Match > mark
    NFA_MARK_LT -843,                    ;; Match < mark
    NFA_VISUAL -842,                     ;; Match Visual area

        ;; Character classes [:alnum:] etc.
    NFA_CLASS_ALNUM -841,
    NFA_CLASS_ALPHA -840,
    NFA_CLASS_BLANK -839,
    NFA_CLASS_CNTRL -838,
    NFA_CLASS_DIGIT -837,
    NFA_CLASS_GRAPH -836,
    NFA_CLASS_LOWER -835,
    NFA_CLASS_PRINT -834,
    NFA_CLASS_PUNCT -833,
    NFA_CLASS_SPACE -832,
    NFA_CLASS_UPPER -831,
    NFA_CLASS_XDIGIT -830,
    NFA_CLASS_TAB -829,
    NFA_CLASS_RETURN -828,
    NFA_CLASS_BACKSPACE -827,
    NFA_CLASS_ESCAPE -826)

;; Keep in sync with "classchars".
(final int* nfa_classcodes
    [
        NFA_ANY, NFA_IDENT, NFA_SIDENT, NFA_KWORD, NFA_SKWORD,
        NFA_FNAME, NFA_SFNAME, NFA_PRINT, NFA_SPRINT,
        NFA_WHITE, NFA_NWHITE, NFA_DIGIT, NFA_NDIGIT,
        NFA_HEX, NFA_NHEX, NFA_OCTAL, NFA_NOCTAL,
        NFA_WORD, NFA_NWORD, NFA_HEAD, NFA_NHEAD,
        NFA_ALPHA, NFA_NALPHA, NFA_LOWER, NFA_NLOWER,
        NFA_UPPER, NFA_NUPPER
    ])

(final Bytes e_nul_found       (u8 "E865: (NFA) Regexp end encountered prematurely"))
(final Bytes e_misplaced       (u8 "E866: (NFA regexp) Misplaced %c"))
(final Bytes e_ill_char_class  (u8 "E877: (NFA regexp) Invalid character class: %ld"))

;; re_flags passed to nfa_regcomp()
(atom! int nfa_re_flags)

;; NFA regexp \ze operator encountered.
(atom! boolean nfa_has_zend)

;; NFA regexp \1 .. \9 encountered.
(atom! boolean nfa_has_backref)

;; NFA regexp has \z( ), set zsubexpr.
(atom! boolean nfa_has_zsubexpr)

;; Number of sub expressions actually being used during execution.
;; 1 if only the whole match (subexpr 0) is used.

(atom! int nfa_nsubexpr)

(atom! int* post_array)    ;; holds the postfix form of r.e.
(atom! int post_index)

;; If not null match must end at this position.
(atom! save_se_C nfa_endp)

;; 'listid' is global, so that it increases on recursive calls to nfa_regmatch(),
;; which means we don't have to clear the lastlist field of all the states.

(atom! int nfa_listid)
(atom! int nfa_alt_listid)

;; 0 for first call to nfa_regmatch(), 1 for recursive call.
(atom! int nfa_ll_index)

;; Initialize internal variables before NFA compilation.
;; Return true on success, false otherwise.

(defn- #_void nfa_regcomp_start [#_Bytes expr, #_int re_flags]
    ;; re_flags: see vim_regcomp()
    (§
        ;; A reasonable estimation for maximum size.
;       int nstate_max = (STRLEN(expr) + 1) * 25;

        ;; Some items blow up in size, such as [A-z].  Add more space for that.
        ;; When it is still not enough grow_post_array() will be used.
;       nstate_max += 1000;

;       @post_array = new int[nstate_max];
;       @post_index = 0;

;       @nfa_has_zend = false;
;       @nfa_has_backref = false;

        ;; shared with BT engine
;       regcomp_start(expr, re_flags);
    ))

;; Figure out if the NFA state list starts with an anchor, must match at start of the line.

(defn- #_boolean nfa_get_reganch [#_nfa_state_C start, #_int depth]
    (§
;       if (4 < depth)
;           return false;

;       for (nfa_state_C p = start; p != null; )
;       {
;           switch (p.c)
;           {
;               case NFA_BOL:
;               case NFA_BOF:
;                   return true; ;; yes!

;               case NFA_ZSTART:
;               case NFA_ZEND:
;               case NFA_CURSOR:
;               case NFA_VISUAL:

;               case NFA_MOPEN:
;               case NFA_MOPEN1:
;               case NFA_MOPEN2:
;               case NFA_MOPEN3:
;               case NFA_MOPEN4:
;               case NFA_MOPEN5:
;               case NFA_MOPEN6:
;               case NFA_MOPEN7:
;               case NFA_MOPEN8:
;               case NFA_MOPEN9:
;               case NFA_NOPEN:
;               case NFA_ZOPEN:
;               case NFA_ZOPEN1:
;               case NFA_ZOPEN2:
;               case NFA_ZOPEN3:
;               case NFA_ZOPEN4:
;               case NFA_ZOPEN5:
;               case NFA_ZOPEN6:
;               case NFA_ZOPEN7:
;               case NFA_ZOPEN8:
;               case NFA_ZOPEN9:
;                   p = p.out0();
;                   break;

;               case NFA_SPLIT:
;                   return nfa_get_reganch(p.out0(), depth + 1) && nfa_get_reganch(p.out1(), depth + 1);

;               default:
;                   return false; ;; noooo!
;           }
;       }

;       return false;
    ))

;; Figure out if the NFA state list starts with a character which must match at start of the match.

(defn- #_int nfa_get_regstart [#_nfa_state_C start, #_int depth]
    (§
;       if (4 < depth)
;           return 0;

;       for (nfa_state_C p = start; p != null; )
;       {
;           switch (p.c)
;           {
                ;; all kinds of zero-width matches
;               case NFA_BOL:
;               case NFA_BOF:
;               case NFA_BOW:
;               case NFA_EOW:
;               case NFA_ZSTART:
;               case NFA_ZEND:
;               case NFA_CURSOR:
;               case NFA_VISUAL:
;               case NFA_LNUM:
;               case NFA_LNUM_GT:
;               case NFA_LNUM_LT:
;               case NFA_COL:
;               case NFA_COL_GT:
;               case NFA_COL_LT:
;               case NFA_VCOL:
;               case NFA_VCOL_GT:
;               case NFA_VCOL_LT:
;               case NFA_MARK:
;               case NFA_MARK_GT:
;               case NFA_MARK_LT:

;               case NFA_MOPEN:
;               case NFA_MOPEN1:
;               case NFA_MOPEN2:
;               case NFA_MOPEN3:
;               case NFA_MOPEN4:
;               case NFA_MOPEN5:
;               case NFA_MOPEN6:
;               case NFA_MOPEN7:
;               case NFA_MOPEN8:
;               case NFA_MOPEN9:
;               case NFA_NOPEN:
;               case NFA_ZOPEN:
;               case NFA_ZOPEN1:
;               case NFA_ZOPEN2:
;               case NFA_ZOPEN3:
;               case NFA_ZOPEN4:
;               case NFA_ZOPEN5:
;               case NFA_ZOPEN6:
;               case NFA_ZOPEN7:
;               case NFA_ZOPEN8:
;               case NFA_ZOPEN9:
;                   p = p.out0();
;                   break;

;               case NFA_SPLIT:
;               {
;                   int c1 = nfa_get_regstart(p.out0(), depth + 1);
;                   int c2 = nfa_get_regstart(p.out1(), depth + 1);

;                   if (c1 == c2)
;                       return c1;      ;; yes!

;                   return 0;
;               }

;               default:
;                   if (0 < p.c)
;                       return p.c;     ;; yes!

;                   return 0;
;           }
;       }

;       return 0;
    ))

;; Figure out if the NFA state list contains just literal text and nothing else.
;; If so return a string in allocated memory with what must match after regstart.
;; Otherwise return null.

(defn- #_Bytes nfa_get_match_text [#_nfa_state_C start]
    (§
;       nfa_state_C p = start;
;       if (p.c != NFA_MOPEN)
;           return null;                ;; just in case
;       p = p.out0();

;       int len = 0;
;       while (0 < p.c)
;       {
;           len += utf_char2len(p.c);
;           p = p.out0();
;       }

;       if (p.c != NFA_MCLOSE || p.out0().c != NFA_MATCH)
;           return null;

;       Bytes ret = new Bytes(len);

;       p = start.out0().out0();    ;; skip first char, it goes into regstart
;       Bytes s = ret;
;       while (0 < p.c)
;       {
;           s = s.plus(utf_char2bytes(p.c, s));
;           p = p.out0();
;       }
;       s.be(0, NUL);

;       return ret;
    ))

;; Allocate more space for post_array.
;; Called when running above the estimated number of states.

(defn- #_void grow_post_array [#_int more]
    (§
;       @post_array = Arrays.copyOf(@post_array, @post_array.length + more);
    ))

;; Search between "start" and "end" and try to recognize a character class in expanded form.
;; For example [0-9].
;; On success, return the id the character class to be emitted.
;; On failure, return 0 (=false).
;; Start points to the first char of the range, while end should point to the closing brace.
;; Keep in mind that 'ignorecase' applies at execution time,
;; thus [a-z] may need to be interpreted as [a-zA-Z].

(defn- #_int nfa_recognize_char_class [#_Bytes start, #_Bytes end, #_boolean newl]
    (§
;       final int
;           CLASS_not        = 0x80,
;           CLASS_af         = 0x40,
;           CLASS_AF         = 0x20,
;           CLASS_az         = 0x10,
;           CLASS_AZ         = 0x08,
;           CLASS_o7         = 0x04,
;           CLASS_o9         = 0x02,
;           CLASS_underscore = 0x01;

;       int config = 0;

;       if (end.at(0) != (byte)']')
;           return 0;

;       Bytes p = start;
;       if (p.at(0) == (byte)'^')
;       {
;           config |= CLASS_not;
;           p = p.plus(1);
;       }

;       while (BLT(p, end))
;       {
;           if (BLT(p.plus(2), end) && p.at(1) == (byte)'-')
;           {
;               switch (p.at(0))
;               {
;                   case '0':
;                       if (p.at(2) == (byte)'9')
;                       {
;                           config |= CLASS_o9;
;                           break;
;                       }
;                       else if (p.at(2) == (byte)'7')
;                       {
;                           config |= CLASS_o7;
;                           break;
;                       }
;                   case 'a':
;                       if (p.at(2) == (byte)'z')
;                       {
;                           config |= CLASS_az;
;                           break;
;                       }
;                       else if (p.at(2) == (byte)'f')
;                       {
;                           config |= CLASS_af;
;                           break;
;                       }
;                   case 'A':
;                       if (p.at(2) == (byte)'Z')
;                       {
;                           config |= CLASS_AZ;
;                           break;
;                       }
;                       else if (p.at(2) == (byte)'F')
;                       {
;                           config |= CLASS_AF;
;                           break;
;                       }
                    ;; FALLTHROUGH
;                   default:
;                       return 0;
;               }
;               p = p.plus(3);
;           }
;           else if (BLT(p.plus(1), end) && p.at(0) == (byte)'\\' && p.at(1) == (byte)'n')
;           {
;               newl = true;
;               p = p.plus(2);
;           }
;           else if (p.at(0) == (byte)'_')
;           {
;               config |= CLASS_underscore;
;               p = p.plus(1);
;           }
;           else if (p.at(0) == (byte)'\n')
;           {
;               newl = true;
;               p = p.plus(1);
;           }
;           else
;               return 0;
;       }

;       if (BNE(p, end))
;           return 0;

;       int nfa_add_nl = (newl) ? NFA_ADD_NL : 0;

;       switch (config)
;       {
;           case CLASS_o9:
;               return nfa_add_nl + NFA_DIGIT;
;           case CLASS_not | CLASS_o9:
;               return nfa_add_nl + NFA_NDIGIT;
;           case CLASS_af | CLASS_AF | CLASS_o9:
;               return nfa_add_nl + NFA_HEX;
;           case CLASS_not | CLASS_af | CLASS_AF | CLASS_o9:
;               return nfa_add_nl + NFA_NHEX;
;           case CLASS_o7:
;               return nfa_add_nl + NFA_OCTAL;
;           case CLASS_not | CLASS_o7:
;               return nfa_add_nl + NFA_NOCTAL;
;           case CLASS_az | CLASS_AZ | CLASS_o9 | CLASS_underscore:
;               return nfa_add_nl + NFA_WORD;
;           case CLASS_not | CLASS_az | CLASS_AZ | CLASS_o9 | CLASS_underscore:
;               return nfa_add_nl + NFA_NWORD;
;           case CLASS_az | CLASS_AZ | CLASS_underscore:
;               return nfa_add_nl + NFA_HEAD;
;           case CLASS_not | CLASS_az | CLASS_AZ | CLASS_underscore:
;               return nfa_add_nl + NFA_NHEAD;
;           case CLASS_az | CLASS_AZ:
;               return nfa_add_nl + NFA_ALPHA;
;           case CLASS_not | CLASS_az | CLASS_AZ:
;               return nfa_add_nl + NFA_NALPHA;
;           case CLASS_az:
;               return nfa_add_nl + NFA_LOWER_IC;
;           case CLASS_not | CLASS_az:
;               return nfa_add_nl + NFA_NLOWER_IC;
;           case CLASS_AZ:
;               return nfa_add_nl + NFA_UPPER_IC;
;           case CLASS_not | CLASS_AZ:
;               return nfa_add_nl + NFA_NUPPER_IC;
;       }

;       return 0;
    ))

;; helper functions used when doing re2post() ... regatom() parsing

(defn- #_boolean emc1 [#_int c]
    (§
;       if (@post_array.length <= @post_index)
;           grow_post_array(1000);

;       @post_array[@post_index++] = c;

;       return true;
    ))

(defn- #_boolean emc2 [#_int c]
    (§
;       return emc1(c) && emc1(NFA_CONCAT);
    ))

;; Produce the bytes for equivalence class "c".
;; Currently only handles latin1, latin9 and utf-8.
;; Emits bytes in postfix notation: 'a,b,NFA_OR,c,NFA_OR' is equivalent to 'a OR b OR c'.
;;
;; NOTE! When changing this function, also update reg_equi_class()

(defn- #_boolean nfa_emit_equi_class [#_int c]
    (§
;       switch (c)
;       {
;           case 'A':
;           case 0xc0: case 0xc1: case 0xc2:
;           case 0xc3: case 0xc4: case 0xc5:
;           case 0x100: case 0x102: case 0x104:
;           case 0x1cd: case 0x1de: case 0x1e0:
;           case 0x1ea2:
;           {
;               return emc2('A')
;                   && emc2(0xc0) && emc2(0xc1) && emc2(0xc2)
;                   && emc2(0xc3) && emc2(0xc4) && emc2(0xc5)
;                   && emc2(0x100) && emc2(0x102) && emc2(0x104)
;                   && emc2(0x1cd) && emc2(0x1de) && emc2(0x1e0)
;                   && emc2(0x1ea2);
;           }
;           case 'a':
;           case 0xe0: case 0xe1: case 0xe2:
;           case 0xe3: case 0xe4: case 0xe5:
;           case 0x101: case 0x103: case 0x105:
;           case 0x1ce: case 0x1df: case 0x1e1:
;           case 0x1ea3:
;           {
;               return emc2('a')
;                   && emc2(0xe0) && emc2(0xe1) && emc2(0xe2)
;                   && emc2(0xe3) && emc2(0xe4) && emc2(0xe5)
;                   && emc2(0x101) && emc2(0x103) && emc2(0x105)
;                   && emc2(0x1ce) && emc2(0x1df) && emc2(0x1e1)
;                   && emc2(0x1ea3);
;           }

;           case 'B':
;           case 0x1e02: case 0x1e06:
;           {
;               return emc2('B')
;                   && emc2(0x1e02) && emc2(0x1e06);
;           }
;           case 'b':
;           case 0x1e03: case 0x1e07:
;           {
;               return emc2('b')
;                   && emc2(0x1e03) && emc2(0x1e07);
;           }

;           case 'C':
;           case 0xc7:
;           case 0x106: case 0x108: case 0x10a: case 0x10c:
;           {
;               return emc2('C')
;                   && emc2(0xc7)
;                   && emc2(0x106) && emc2(0x108) && emc2(0x10a) && emc2(0x10c);
;           }
;           case 'c':
;           case 0xe7:
;           case 0x107: case 0x109: case 0x10b: case 0x10d:
;           {
;               return emc2('c')
;                   && emc2(0xe7)
;                   && emc2(0x107) && emc2(0x109) && emc2(0x10b) && emc2(0x10d);
;           }

;           case 'D':
;           case 0x10e: case 0x110:
;           case 0x1e0a: case 0x1e0c: case 0x1e0e: case 0x1e10: case 0x1e12:
;           {
;               return emc2('D')
;                   && emc2(0x10e) && emc2(0x110)
;                   && emc2(0x1e0a) && emc2(0x1e0c) && emc2(0x1e0e) && emc2(0x1e10) && emc2(0x1e12);
;           }
;           case 'd':
;           case 0x10f: case 0x111:
;           case 0x1e0b: case 0x1e0d: case 0x1e0f: case 0x1e11: case 0x1e13:
;           {
;               return emc2('d')
;                   && emc2(0x10f) && emc2(0x111)
;                   && emc2(0x1e0b) && emc2(0x1e0d) && emc2(0x1e0f) && emc2(0x1e11) && emc2(0x1e13);
;           }

;           case 'E':
;           case 0xc8: case 0xc9: case 0xca: case 0xcb:
;           case 0x112: case 0x114: case 0x116: case 0x118: case 0x11a:
;           case 0x1eba: case 0x1ebc:
;           {
;               return emc2('E')
;                   && emc2(0xc8) && emc2(0xc9) && emc2(0xca) && emc2(0xcb)
;                   && emc2(0x112) && emc2(0x114) && emc2(0x116) && emc2(0x118) && emc2(0x11a)
;                   && emc2(0x1eba) && emc2(0x1ebc);
;           }
;           case 'e':
;           case 0xe8: case 0xe9: case 0xea: case 0xeb:
;           case 0x113: case 0x115: case 0x117: case 0x119: case 0x11b:
;           case 0x1ebb: case 0x1ebd:
;           {
;               return emc2('e')
;                   && emc2(0xe8) && emc2(0xe9) && emc2(0xea) && emc2(0xeb)
;                   && emc2(0x113) && emc2(0x115) && emc2(0x117) && emc2(0x119) && emc2(0x11b)
;                   && emc2(0x1ebb) && emc2(0x1ebd);
;           }

;           case 'F':
;           case 0x1e1e:
;           {
;               return emc2('F')
;                   && emc2(0x1e1e);
;           }
;           case 'f':
;           case 0x1e1f:
;           {
;               return emc2('f')
;                   && emc2(0x1e1f);
;           }

;           case 'G':
;           case 0x11c: case 0x11e: case 0x120: case 0x122:
;           case 0x1e4: case 0x1e6: case 0x1f4:
;           case 0x1e20:
;           {
;               return emc2('G')
;                   && emc2(0x11c) && emc2(0x11e) && emc2(0x120) && emc2(0x122)
;                   && emc2(0x1e4) && emc2(0x1e6) && emc2(0x1f4)
;                   && emc2(0x1e20);
;           }
;           case 'g':
;           case 0x11d: case 0x11f: case 0x121: case 0x123:
;           case 0x1e5: case 0x1e7: case 0x1f5:
;           case 0x1e21:
;           {
;               return emc2('g')
;                   && emc2(0x11d) && emc2(0x11f) && emc2(0x121) && emc2(0x123)
;                   && emc2(0x1e5) && emc2(0x1e7) && emc2(0x1f5)
;                   && emc2(0x1e21);
;           }

;           case 'H':
;           case 0x124: case 0x126:
;           case 0x1e22: case 0x1e26: case 0x1e28:
;           {
;               return emc2('H')
;                   && emc2(0x124) && emc2(0x126)
;                   && emc2(0x1e22) && emc2(0x1e26) && emc2(0x1e28);
;           }
;           case 'h':
;           case 0x125: case 0x127:
;           case 0x1e23: case 0x1e27: case 0x1e29: case 0x1e96:
;           {
;               return emc2('h')
;                   && emc2(0x125) && emc2(0x127)
;                   && emc2(0x1e23) && emc2(0x1e27) && emc2(0x1e29) && emc2(0x1e96);
;           }

;           case 'I':
;           case 0xcc: case 0xcd: case 0xce: case 0xcf:
;           case 0x128: case 0x12a: case 0x12c: case 0x12e: case 0x130:
;           case 0x1cf:
;           case 0x1ec8:
;           {
;               return emc2('I')
;                   && emc2(0xcc) && emc2(0xcd) && emc2(0xce) && emc2(0xcf)
;                   && emc2(0x128) && emc2(0x12a) && emc2(0x12c) && emc2(0x12e) && emc2(0x130)
;                   && emc2(0x1cf)
;                   && emc2(0x1ec8);
;           }
;           case 'i':
;           case 0xec: case 0xed: case 0xee: case 0xef:
;           case 0x129: case 0x12b: case 0x12d: case 0x12f: case 0x131:
;           case 0x1d0:
;           case 0x1ec9:
;           {
;               return emc2('i')
;                   && emc2(0xec) && emc2(0xed) && emc2(0xee) && emc2(0xef)
;                   && emc2(0x129) && emc2(0x12b) && emc2(0x12d) && emc2(0x12f) && emc2(0x131)
;                   && emc2(0x1d0)
;                   && emc2(0x1ec9);
;           }

;           case 'J':
;           case 0x134:
;           {
;               return emc2('J')
;                   && emc2(0x134);
;           }
;           case 'j':
;           case 0x135: case 0x1f0:
;           {
;               return emc2('j')
;                   && emc2(0x135) && emc2(0x1f0);
;           }

;           case 'K':
;           case 0x136: case 0x1e8:
;           case 0x1e30: case 0x1e34:
;           {
;               return emc2('K')
;                   && emc2(0x136) && emc2(0x1e8)
;                   && emc2(0x1e30) && emc2(0x1e34);
;           }
;           case 'k':
;           case 0x137: case 0x1e9:
;           case 0x1e31: case 0x1e35:
;           {
;               return emc2('k')
;                   && emc2(0x137) && emc2(0x1e9)
;                   && emc2(0x1e31) && emc2(0x1e35);
;           }

;           case 'L':
;           case 0x139: case 0x13b: case 0x13d: case 0x13f: case 0x141:
;           case 0x1e3a:
;           {
;               return emc2('L')
;                   && emc2(0x139) && emc2(0x13b) && emc2(0x13d) && emc2(0x13f) && emc2(0x141)
;                   && emc2(0x1e3a);
;           }
;           case 'l':
;           case 0x13a: case 0x13c: case 0x13e: case 0x140: case 0x142:
;           case 0x1e3b:
;           {
;               return emc2('l')
;                   && emc2(0x13a) && emc2(0x13c) && emc2(0x13e) && emc2(0x140) && emc2(0x142)
;                   && emc2(0x1e3b);
;           }

;           case 'M':
;           case 0x1e3e: case 0x1e40:
;           {
;               return emc2('M')
;                   && emc2(0x1e3e) && emc2(0x1e40);
;           }
;           case 'm':
;           case 0x1e3f: case 0x1e41:
;           {
;               return emc2('m')
;                   && emc2(0x1e3f) && emc2(0x1e41);
;           }

;           case 'N':
;           case 0xd1:
;           case 0x143: case 0x145: case 0x147:
;           case 0x1e44: case 0x1e48:
;           {
;               return emc2('N')
;                   && emc2(0xd1)
;                   && emc2(0x143) && emc2(0x145) && emc2(0x147)
;                   && emc2(0x1e44) && emc2(0x1e48);
;           }
;           case 'n':
;           case 0xf1:
;           case 0x144: case 0x146: case 0x148: case 0x149:
;           case 0x1e45: case 0x1e49:
;           {
;               return emc2('n')
;                   && emc2(0xf1)
;                   && emc2(0x144) && emc2(0x146) && emc2(0x148) && emc2(0x149)
;                   && emc2(0x1e45) && emc2(0x1e49);
;           }

;           case 'O':
;           case 0xd2: case 0xd3: case 0xd4:
;           case 0xd5: case 0xd6: case 0xd8:
;           case 0x14c: case 0x14e: case 0x150:
;           case 0x1a0: case 0x1d1: case 0x1ea: case 0x1ec:
;           case 0x1ece:
;           {
;               return emc2('O')
;                   && emc2(0xd2) && emc2(0xd3) && emc2(0xd4)
;                   && emc2(0xd5) && emc2(0xd6) && emc2(0xd8)
;                   && emc2(0x14c) && emc2(0x14e) && emc2(0x150)
;                   && emc2(0x1a0) && emc2(0x1d1) && emc2(0x1ea) && emc2(0x1ec)
;                   && emc2(0x1ece);
;           }
;           case 'o':
;           case 0xf2: case 0xf3: case 0xf4:
;           case 0xf5: case 0xf6: case 0xf8:
;           case 0x14d: case 0x14f: case 0x151:
;           case 0x1a1: case 0x1d2: case 0x1eb: case 0x1ed:
;           case 0x1ecf:
;           {
;               return emc2('o')
;                   && emc2(0xf2) && emc2(0xf3) && emc2(0xf4)
;                   && emc2(0xf5) && emc2(0xf6) && emc2(0xf8)
;                   && emc2(0x14d) && emc2(0x14f) && emc2(0x151)
;                   && emc2(0x1a1) && emc2(0x1d2) && emc2(0x1eb) && emc2(0x1ed)
;                   && emc2(0x1ecf);
;           }

;           case 'P':
;           case 0x1e54: case 0x1e56:
;           {
;               return emc2('P')
;                   && emc2(0x1e54) && emc2(0x1e56);
;           }
;           case 'p':
;           case 0x1e55: case 0x1e57:
;           {
;               return emc2('p')
;                   && emc2(0x1e55) && emc2(0x1e57);
;           }

;           case 'R':
;           case 0x154: case 0x156: case 0x158:
;           case 0x1e58: case 0x1e5e:
;           {
;               return emc2('R')
;                   && emc2(0x154) && emc2(0x156) && emc2(0x158)
;                   && emc2(0x1e58) && emc2(0x1e5e);
;           }
;           case 'r':
;           case 0x155: case 0x157: case 0x159:
;           case 0x1e59: case 0x1e5f:
;           {
;               return emc2('r')
;                   && emc2(0x155) && emc2(0x157) && emc2(0x159)
;                   && emc2(0x1e59) && emc2(0x1e5f);
;           }

;           case 'S':
;           case 0x15a: case 0x15c: case 0x15e: case 0x160:
;           case 0x1e60:
;           {
;               return emc2('S')
;                   && emc2(0x15a) && emc2(0x15c) && emc2(0x15e) && emc2(0x160)
;                   && emc2(0x1e60);
;           }
;           case 's':
;           case 0x15b: case 0x15d: case 0x15f: case 0x161:
;           case 0x1e61:
;           {
;               return emc2('s')
;                   && emc2(0x15b) && emc2(0x15d) && emc2(0x15f) && emc2(0x161)
;                   && emc2(0x1e61);
;           }

;           case 'T':
;           case 0x162: case 0x164: case 0x166:
;           case 0x1e6a: case 0x1e6e:
;           {
;               return emc2('T')
;                   && emc2(0x162) && emc2(0x164) && emc2(0x166)
;                   && emc2(0x1e6a) && emc2(0x1e6e);
;           }
;           case 't':
;           case 0x163: case 0x165: case 0x167:
;           case 0x1e6b: case 0x1e6f: case 0x1e97:
;           {
;               return emc2('t')
;                   && emc2(0x163) && emc2(0x165) && emc2(0x167)
;                   && emc2(0x1e6b) && emc2(0x1e6f) && emc2(0x1e97);
;           }

;           case 'U':
;           case 0xd9: case 0xda: case 0xdb: case 0xdc:
;           case 0x168: case 0x16a: case 0x16c: case 0x16e:
;           case 0x170: case 0x172: case 0x1af: case 0x1d3:
;           case 0x1ee6:
;           {
;               return emc2('U')
;                   && emc2(0xd9) && emc2(0xda) && emc2(0xdb) && emc2(0xdc)
;                   && emc2(0x168) && emc2(0x16a) && emc2(0x16c) && emc2(0x16e)
;                   && emc2(0x170) && emc2(0x172) && emc2(0x1af) && emc2(0x1d3)
;                   && emc2(0x1ee6);
;           }
;           case 'u':
;           case 0xf9: case 0xfa: case 0xfb: case 0xfc:
;           case 0x169: case 0x16b: case 0x16d: case 0x16f:
;           case 0x171: case 0x173: case 0x1b0: case 0x1d4:
;           case 0x1ee7:
;           {
;               return emc2('u')
;                   && emc2(0xf9) && emc2(0xfa) && emc2(0xfb) && emc2(0xfc)
;                   && emc2(0x169) && emc2(0x16b) && emc2(0x16d) && emc2(0x16f)
;                   && emc2(0x171) && emc2(0x173) && emc2(0x1b0) && emc2(0x1d4)
;                   && emc2(0x1ee7);
;           }

;           case 'V':
;           case 0x1e7c:
;           {
;               return emc2('V')
;                   && emc2(0x1e7c);
;           }
;           case 'v':
;           case 0x1e7d:
;           {
;               return emc2('v')
;                   && emc2(0x1e7d);
;           }

;           case 'W':
;           case 0x174:
;           case 0x1e80: case 0x1e82: case 0x1e84: case 0x1e86:
;           {
;               return emc2('W')
;                   && emc2(0x174)
;                   && emc2(0x1e80) && emc2(0x1e82) && emc2(0x1e84) && emc2(0x1e86);
;           }
;           case 'w':
;           case 0x175:
;           case 0x1e81: case 0x1e83: case 0x1e85: case 0x1e87: case 0x1e98:
;           {
;               return emc2('w')
;                   && emc2(0x175)
;                   && emc2(0x1e81) && emc2(0x1e83) && emc2(0x1e85) && emc2(0x1e87) && emc2(0x1e98);
;           }

;           case 'X':
;           case 0x1e8a: case 0x1e8c:
;           {
;               return emc2('X')
;                   && emc2(0x1e8a) && emc2(0x1e8c);
;           }
;           case 'x':
;           case 0x1e8b: case 0x1e8d:
;           {
;               return emc2('x')
;                   && emc2(0x1e8b) && emc2(0x1e8d);
;           }

;           case 'Y':
;           case 0xdd:
;           case 0x176: case 0x178:
;           case 0x1e8e: case 0x1ef2: case 0x1ef6: case 0x1ef8:
;           {
;               return emc2('Y')
;                   && emc2(0xdd)
;                   && emc2(0x176) && emc2(0x178)
;                   && emc2(0x1e8e) && emc2(0x1ef2) && emc2(0x1ef6) && emc2(0x1ef8);
;           }
;           case 'y':
;           case 0xfd: case 0xff:
;           case 0x177:
;           case 0x1e8f: case 0x1e99: case 0x1ef3: case 0x1ef7: case 0x1ef9:
;           {
;               return emc2('y')
;                   && emc2(0xfd) && emc2(0xff)
;                   && emc2(0x177)
;                   && emc2(0x1e8f) && emc2(0x1e99) && emc2(0x1ef3) && emc2(0x1ef7) && emc2(0x1ef9);
;           }

;           case 'Z':
;           case 0x179: case 0x17b: case 0x17d: case 0x1b5:
;           case 0x1e90: case 0x1e94:
;           {
;               return emc2('Z')
;                   && emc2(0x179) && emc2(0x17b) && emc2(0x17d) && emc2(0x1b5)
;                   && emc2(0x1e90) && emc2(0x1e94);
;           }
;           case 'z':
;           case 0x17a: case 0x17c: case 0x17e: case 0x1b6:
;           case 0x1e91: case 0x1e95:
;           {
;               return emc2('z')
;                   && emc2(0x17a) && emc2(0x17c) && emc2(0x17e) && emc2(0x1b6)
;                   && emc2(0x1e91) && emc2(0x1e95);
;           }

            ;; default: character itself
;       }

;       return emc2(c);
    ))

;; Code to parse regular expression.
;;
;; We try to reuse parsing functions in regexp.c to
;; minimize surprise and keep the syntax consistent.

;; Parse the lowest level.
;;
;; An atom can be one of a long list of items.  Many atoms match one character
;; in the text.  It is often an ordinary character or a character class.
;; Braces can be used to make a pattern into an atom.  The "\z(\)" construct
;; is only for syntax highlighting.
;;
;; atom    ::=     ordinary-atom
;;     or  \( pattern \)
;;     or  \%( pattern \)
;;     or  \z( pattern \)

(defn- #_boolean nfa_regatom []
    (§
;       Bytes old_regparse = @regparse;
;       int extra = 0;
;       int startc = -1;
;       int endc = -1;
;       int oldstartc = -1;

;       int c = getchr();

;       collection:
;       {
;           switch (c)
;           {
;               case NUL:
;                   emsg(e_nul_found);
;                   @rc_did_emsg = true;
;                   return false;

;               case -162: // case Magic('^'):
;                   emc1(NFA_BOL);
;                   break;

;               case -220: // case Magic('$'):
;                   emc1(NFA_EOL);
;                   @had_eol = true;
;                   break;

;               case -196: // case Magic('<'):
;                   emc1(NFA_BOW);
;                   break;

;               case -194: // case Magic('>'):
;                   emc1(NFA_EOW);
;                   break;

;               case -161: // case Magic('_'):
;               {
;                   c = no_Magic(getchr());
;                   if (c == NUL)
;                   {
;                       emsg(e_nul_found);
;                       @rc_did_emsg = true;
;                       return false;
;                   }

;                   if (c == '^')       ;; "\_^" is start-of-line
;                   {
;                       emc1(NFA_BOL);
;                       break;
;                   }
;                   if (c == '$')       ;; "\_$" is end-of-line
;                   {
;                       emc1(NFA_EOL);
;                       @had_eol = true;
;                       break;
;                   }

;                   extra = NFA_ADD_NL;

                    ;; "\_[" is collection plus newline
;                   if (c == '[')
;                       break collection;

                    ;; "\_x" is character class plus newline
                    ;; FALLTHROUGH
;               }

                ;; Character classes.

;               case -210: // case Magic('.'):
;               case -151: // case Magic('i'):
;               case -183: // case Magic('I'):
;               case -149: // case Magic('k'):
;               case -181: // case Magic('K'):
;               case -154: // case Magic('f'):
;               case -186: // case Magic('F'):
;               case -144: // case Magic('p'):
;               case -176: // case Magic('P'):
;               case -141: // case Magic('s'):
;               case -173: // case Magic('S'):
;               case -156: // case Magic('d'):
;               case -188: // case Magic('D'):
;               case -136: // case Magic('x'):
;               case -168: // case Magic('X'):
;               case -145: // case Magic('o'):
;               case -177: // case Magic('O'):
;               case -137: // case Magic('w'):
;               case -169: // case Magic('W'):
;               case -152: // case Magic('h'):
;               case -184: // case Magic('H'):
;               case -159: // case Magic('a'):
;               case -191: // case Magic('A'):
;               case -148: // case Magic('l'):
;               case -180: // case Magic('L'):
;               case -139: // case Magic('u'):
;               case -171: // case Magic('U'):
;               {
;                   Bytes p = vim_strchr(classchars, no_Magic(c));
;                   if (p == null)
;                   {
;                       if (extra == NFA_ADD_NL)
;                       {
;                           emsgn(e_ill_char_class, (long)c);
;                           @rc_did_emsg = true;
;                           return false;
;                       }
;                       emsgn(u8("INTERNAL: Unknown character class char: %ld"), (long)c);
;                       return false;
;                   }
                    ;; When '.' is followed by a composing char ignore the dot,
                    ;; so that the composing char is matched here.
;                   if (c == Magic('.') && utf_iscomposing(peekchr()))
;                   {
;                       old_regparse = @regparse;
;                       c = getchr();
;                       return nfa_do_multibyte(c, old_regparse);
;                   }
;                   emc1(nfa_classcodes[BDIFF(p, classchars)]);
;                   if (extra == NFA_ADD_NL)
;                   {
;                       emc1(NFA_NEWL);
;                       emc1(NFA_OR);
;                       @regflags |= RF_HASNL;
;                   }
;                   break;
;               }

;               case -146: // case Magic('n'):
;               {
;                   if (@reg_string)
                        ;; In a string "\n" matches a newline character.
;                       emc1(NL);
;                   else
;                   {
                        ;; In buffer text "\n" matches the end of a line.
;                       emc1(NFA_NEWL);
;                       @regflags |= RF_HASNL;
;                   }
;                   break;
;               }

;               case -216: // case Magic('('):
;                   if (nfa_reg(REG_PAREN) == false)
;                       return false;           ;; cascaded error
;                   break;

;               case -132: // case Magic('|'):
;               case -218: // case Magic('&'):
;               case -215: // case Magic(')'):
;                   emsgn(e_misplaced, (long)no_Magic(c));
;                   return false;

;               case -195: // case Magic('='):
;               case -193: // case Magic('?'):
;               case -213: // case Magic('+'):
;               case -192: // case Magic('@'):
;               case -214: // case Magic('*'):
;               case -133: // case Magic('{'):
                    ;; these should follow an atom, not form an atom
;                   emsgn(e_misplaced, (long)no_Magic(c));
;                   return false;

;               case -130: // case Magic('~'):
;               {
                    ;; Previous substitute pattern.
                    ;; Generated as "\%(pattern\)".
;                   if (@reg_prev_sub == null)
;                   {
;                       emsg(e_nopresub);
;                       return false;
;                   }
;                   for (Bytes lp = @reg_prev_sub; lp.at(0) != NUL; lp = lp.plus(us_ptr2len(lp)))
;                   {
;                       emc1(us_ptr2char(lp));
;                       if (BNE(lp, @reg_prev_sub))
;                           emc1(NFA_CONCAT);
;                   }
;                   emc1(NFA_NOPEN);
;                   break;
;               }

;               case -207: // case Magic('1'):
;               case -206: // case Magic('2'):
;               case -205: // case Magic('3'):
;               case -204: // case Magic('4'):
;               case -203: // case Magic('5'):
;               case -202: // case Magic('6'):
;               case -201: // case Magic('7'):
;               case -200: // case Magic('8'):
;               case -199: // case Magic('9'):
;                   emc1(NFA_BACKREF1 + (no_Magic(c) - '1'));
;                   @nfa_has_backref = true;
;                   break;

;               case -134: // case Magic('z'):
;               {
;                   c = no_Magic(getchr());
;                   switch (c)
;                   {
;                       case 's':
;                           emc1(NFA_ZSTART);
;                           if (re_mult_next(u8("\\zs")) == false)
;                               return false;
;                           break;

;                       case 'e':
;                           emc1(NFA_ZEND);
;                           @nfa_has_zend = true;
;                           if (re_mult_next(u8("\\ze")) == false)
;                               return false;
;                           break;

;                       case '1':
;                       case '2':
;                       case '3':
;                       case '4':
;                       case '5':
;                       case '6':
;                       case '7':
;                       case '8':
;                       case '9':
;                       {
                            ;; \z1...\z9
;                           if (@reg_do_extmatch != REX_USE)
;                           {
;                               emsg(e_z1_not_allowed);
;                               @rc_did_emsg = true;
;                               return false;
;                           }
;                           emc1(NFA_ZREF1 + (no_Magic(c) - '1'));
                            ;; No need to set nfa_has_backref, the sub-matches
                            ;; don't change when \z1 .. \z9 matches or not.
;                           @re_has_z = REX_USE;
;                           break;
;                       }

;                       case '(':
;                       {
                            ;; \z(
;                           if (@reg_do_extmatch != REX_SET)
;                           {
;                               emsg(e_z_not_allowed);
;                               @rc_did_emsg = true;
;                               return false;
;                           }
;                           if (nfa_reg(REG_ZPAREN) == false)
;                               return false;           ;; cascaded error
;                           @re_has_z = REX_SET;
;                           break;
;                       }

;                       default:
;                           emsgn(u8("E867: (NFA) Unknown operator '\\z%c'"), (long)no_Magic(c));
;                           return false;
;                   }
;                   break;
;               }

;               case -219: // case Magic('%'):
;               {
;                   c = no_Magic(getchr());
;                   switch (c)
;                   {
                        ;; () without a back reference
;                       case '(':
;                           if (nfa_reg(REG_NPAREN) == false)
;                               return false;
;                           emc1(NFA_NOPEN);
;                           break;

;                       case 'd':   ;; %d123 decimal
;                       case 'o':   ;; %o123 octal
;                       case 'x':   ;; %xab hex 2
;                       case 'u':   ;; %uabcd hex 4
;                       case 'U':   ;; %U1234abcd hex 8
;                       {
;                           int nr;

;                           switch (c)
;                           {
;                               case 'd': nr = getdecchrs(); break;
;                               case 'o': nr = getoctchrs(); break;
;                               case 'x': nr = gethexchrs(2); break;
;                               case 'u': nr = gethexchrs(4); break;
;                               case 'U': nr = gethexchrs(8); break;
;                               default:  nr = -1; break;
;                           }

;                           if (nr < 0)
;                           {
;                               emsg2(u8("E678: Invalid character after %s%%[dxouU]"), (@reg_magic == MAGIC_ALL) ? u8("") : u8("\\"));
;                               @rc_did_emsg = true;
;                               return false;
;                           }
                            ;; A NUL is stored in the text as NL.
                            ;; TODO: what if a composing character follows?
;                           emc1(nr == 0 ? 0x0a : nr);
;                           break;
;                       }

                        ;; Catch \%^ and \%$ regardless of where they appear in the
                        ;; pattern -- regardless of whether or not it makes sense.
;                       case '^':
;                           emc1(NFA_BOF);
;                           break;

;                       case '$':
;                           emc1(NFA_EOF);
;                           break;

;                       case '#':
;                           emc1(NFA_CURSOR);
;                           break;

;                       case 'V':
;                           emc1(NFA_VISUAL);
;                           break;

;                       case 'C':
;                           emc1(NFA_ANY_COMPOSING);
;                           break;

;                       case '[':
;                       {
;                           int n;

                            ;; \%[abc]
;                           for (n = 0; (c = peekchr()) != ']'; n++)
;                           {
;                               if (c == NUL)
;                               {
;                                   emsg2(e_missing_sb, (@reg_magic == MAGIC_ALL) ? u8("") : u8("\\"));
;                                   @rc_did_emsg = true;
;                                   return false;
;                               }
                                ;; recursive call!
;                               if (nfa_regatom() == false)
;                                   return false;
;                           }
;                           getchr();       ;; get the ]
;                           if (n == 0)
;                           {
;                               emsg2(e_empty_sb, (@reg_magic == MAGIC_ALL) ? u8("") : u8("\\"));
;                               @rc_did_emsg = true;
;                               return false;
;                           }
;                           emc1(NFA_OPT_CHARS);
;                           emc1(n);

                            ;; Emit as "\%(\%[abc]\)" to be able to handle "\%[abc]*" which would
                            ;; cause the empty string to be matched an unlimited number of times.
                            ;; NFA_NOPEN is added only once at a position, while NFA_SPLIT is added
                            ;; multiple times.  This is more efficient than not allowing NFA_SPLIT
                            ;; multiple times, it is used a lot.

;                           emc1(NFA_NOPEN);
;                           break;
;                       }

;                       default:
;                       {
;                           int n = 0;
;                           int cmp = c;

;                           if (c == '<' || c == '>')
;                               c = getchr();
;                           while (asc_isdigit(c))
;                           {
;                               n = n * 10 + (c - '0');
;                               c = getchr();
;                           }
;                           if (c == 'l' || c == 'c' || c == 'v')
;                           {
;                               if (c == 'l')
                                    ;; \%{n}l  \%{n}<l  \%{n}>l
;                                   emc1(cmp == '<' ? NFA_LNUM_LT : cmp == '>' ? NFA_LNUM_GT : NFA_LNUM);
;                               else if (c == 'c')
                                    ;; \%{n}c  \%{n}<c  \%{n}>c
;                                   emc1(cmp == '<' ? NFA_COL_LT : cmp == '>' ? NFA_COL_GT : NFA_COL);
;                               else
                                    ;; \%{n}v  \%{n}<v  \%{n}>v
;                                   emc1(cmp == '<' ? NFA_VCOL_LT : cmp == '>' ? NFA_VCOL_GT : NFA_VCOL);
;                               emc1(n);
;                               break;
;                           }
;                           else if (c == '\'' && n == 0)
;                           {
                                ;; \%'m  \%<'m  \%>'m
;                               emc1(cmp == '<' ? NFA_MARK_LT : cmp == '>' ? NFA_MARK_GT : NFA_MARK);
;                               emc1(getchr());
;                               break;
;                           }
;                           emsgn(u8("E867: (NFA) Unknown operator '\\%%%c'"), (long)no_Magic(c));
;                           return false;
;                       }
;                   }
;                   break;
;               }

;               case -165: // case Magic('['):
;                   break collection;

;               default:
;                   return nfa_do_multibyte(c, old_regparse);
;           }

;           return true;
;       }

        ;; [abc]  uses NFA_START_COLL - NFA_END_COLL
        ;; [^abc] uses NFA_START_NEG_COLL - NFA_END_NEG_COLL
        ;; Each character is produced as a regular state,
        ;; using NFA_CONCAT to bind them together.
        ;; Besides normal characters there can be:
        ;; - character classes  NFA_CLASS_*
        ;; - ranges, two characters followed by NFA_RANGE.

;       Bytes p = @regparse;
;       Bytes endp = skip_anyof(p);

;       if (endp.at(0) == (byte)']')
;       {
            ;; Try to reverse engineer character classes.  For example,
            ;; recognize that [0-9] stands for \d and [A-Za-z_] for \h,
            ;; and perform the necessary substitutions in the NFA.

;           int result = nfa_recognize_char_class(@regparse, endp, extra == NFA_ADD_NL);
;           if (result != 0)
;           {
;               if (NFA_FIRST_NL <= result && result <= NFA_LAST_NL)
;               {
;                   emc1(result - NFA_ADD_NL);
;                   emc1(NFA_NEWL);
;                   emc1(NFA_OR);
;               }
;               else
;                   emc1(result);
;               @regparse = endp;
;               @regparse = @regparse.plus(us_ptr2len_cc(@regparse));
;               return true;
;           }

            ;; Failed to recognize a character class.
            ;; Use the simple version that turns [abc] into 'a' OR 'b' OR 'c'.

;           startc = endc = oldstartc = -1;
;           boolean negated = false;
;           if (@regparse.at(0) == (byte)'^')                   ;; negated range
;           {
;               negated = true;
;               @regparse = @regparse.plus(us_ptr2len_cc(@regparse));
;               emc1(NFA_START_NEG_COLL);
;           }
;           else
;               emc1(NFA_START_COLL);
;           if (@regparse.at(0) == (byte)'-')
;           {
;               startc = '-';
;               emc1(startc);
;               emc1(NFA_CONCAT);
;               @regparse = @regparse.plus(us_ptr2len_cc(@regparse));
;           }
            ;; Emit the OR branches for each character in the [].
;           boolean emit_range = false;
;           while (BLT(@regparse, endp))
;           {
;               oldstartc = startc;
;               startc = -1;
;               boolean got_coll_char = false;
;               if (@regparse.at(0) == (byte)'[')
;               {
                    ;; Check for [: :], [= =], [. .].
;                   int charclass, equiclass = 0, collclass = 0;
;                   { Bytes[] __ = { @regparse }; charclass = get_char_class(__); @regparse = __[0]; }
;                   if (charclass == CLASS_NONE)
;                   {
;                       { Bytes[] __ = { @regparse }; equiclass = get_equi_class(__); @regparse = __[0]; }
;                       if (equiclass == 0)
;                       {
;                           { Bytes[] __ = { @regparse }; collclass = get_coll_element(__); @regparse = __[0]; }
;                       }
;                   }

                    ;; Character class like [:alpha:].
;                   if (charclass != CLASS_NONE)
;                   {
;                       switch (charclass)
;                       {
;                           case CLASS_ALNUM:
;                               emc1(NFA_CLASS_ALNUM);
;                               break;
;                           case CLASS_ALPHA:
;                               emc1(NFA_CLASS_ALPHA);
;                               break;
;                           case CLASS_BLANK:
;                               emc1(NFA_CLASS_BLANK);
;                               break;
;                           case CLASS_CNTRL:
;                               emc1(NFA_CLASS_CNTRL);
;                               break;
;                           case CLASS_DIGIT:
;                               emc1(NFA_CLASS_DIGIT);
;                               break;
;                           case CLASS_GRAPH:
;                               emc1(NFA_CLASS_GRAPH);
;                               break;
;                           case CLASS_LOWER:
;                               emc1(NFA_CLASS_LOWER);
;                               break;
;                           case CLASS_PRINT:
;                               emc1(NFA_CLASS_PRINT);
;                               break;
;                           case CLASS_PUNCT:
;                               emc1(NFA_CLASS_PUNCT);
;                               break;
;                           case CLASS_SPACE:
;                               emc1(NFA_CLASS_SPACE);
;                               break;
;                           case CLASS_UPPER:
;                               emc1(NFA_CLASS_UPPER);
;                               break;
;                           case CLASS_XDIGIT:
;                               emc1(NFA_CLASS_XDIGIT);
;                               break;
;                           case CLASS_TAB:
;                               emc1(NFA_CLASS_TAB);
;                               break;
;                           case CLASS_RETURN:
;                               emc1(NFA_CLASS_RETURN);
;                               break;
;                           case CLASS_BACKSPACE:
;                               emc1(NFA_CLASS_BACKSPACE);
;                               break;
;                           case CLASS_ESCAPE:
;                               emc1(NFA_CLASS_ESCAPE);
;                               break;
;                       }
;                       emc1(NFA_CONCAT);
;                       continue;
;                   }
                    ;; Try equivalence class [=a=] and the like.
;                   if (equiclass != 0)
;                   {
;                       if (nfa_emit_equi_class(equiclass) == false)
;                       {
                            ;; should never happen
;                           emsg(u8("E868: Error building NFA with equivalence class!"));
;                           @rc_did_emsg = true;
;                           return false;
;                       }
;                       continue;
;                   }
                    ;; Try collating class like [. .].
;                   if (collclass != 0)
;                   {
;                       startc = collclass;     ;; allow [.a.]-x as a range
                        ;; Will emit the proper atom at the end of the while loop.
;                   }
;               }
                ;; Try a range like 'a-x' or '\t-z'.  Also allows '-' as a start character.
;               if (@regparse.at(0) == (byte)'-' && oldstartc != -1)
;               {
;                   emit_range = true;
;                   startc = oldstartc;
;                   @regparse = @regparse.plus(us_ptr2len_cc(@regparse));
;                   continue;           ;; reading the end of the range
;               }

                ;; Now handle simple and escaped characters.
                ;; Only "\]", "\^", "\]" and "\\" are special in Vi.
                ;; Vim accepts "\t", "\e", etc., but only when the 'l' flag in 'cpoptions' is not included.
                ;; Posix doesn't recognize backslash at all.

;               if (@regparse.at(0) == (byte)'\\'
;                       && !@reg_cpo_bsl
;                       && BLE(@regparse.plus(1), endp)
;                       && (vim_strchr(REGEXP_INRANGE, @regparse.at(1)) != null
;                           || (!@reg_cpo_lit && vim_strchr(REGEXP_ABBR, @regparse.at(1)) != null)))
;               {
;                   @regparse = @regparse.plus(us_ptr2len_cc(@regparse));

;                   if (@regparse.at(0) == (byte)'n')
;                       startc = @reg_string ? NL : NFA_NEWL;
;                   else if (@regparse.at(0) == (byte)'d'
;                         || @regparse.at(0) == (byte)'o'
;                         || @regparse.at(0) == (byte)'x'
;                         || @regparse.at(0) == (byte)'u'
;                         || @regparse.at(0) == (byte)'U')
;                   {
                        ;; TODO(RE) This needs more testing.
;                       startc = coll_get_char();
;                       got_coll_char = true;
;                       @regparse = @regparse.minus(us_ptr_back(old_regparse, @regparse));
;                   }
;                   else
;                   {
                        ;; \r,\t,\e,\b
;                       startc = backslash_trans(@regparse.at(0));
;                   }
;               }

                ;; Normal printable char.
;               if (startc == -1)
;                   startc = us_ptr2char(@regparse);

                ;; Previous char was '-', so this char is end of range.
;               if (emit_range)
;               {
;                   endc = startc;
;                   startc = oldstartc;
;                   if (endc < startc)
;                   {
;                       emsg(e_invrange);
;                       @rc_did_emsg = true;
;                       return false;
;                   }

;                   if (startc + 2 < endc)
;                   {
                        ;; Emit a range instead of the sequence of individual characters.
;                       if (startc == 0)
                            ;; \x00 is translated to \x0a, start at \x01.
;                           emc1(1);
;                       else
;                           --@post_index; ;; remove NFA_CONCAT
;                       emc1(endc);
;                       emc1(NFA_RANGE);
;                       emc1(NFA_CONCAT);
;                   }
;                   else if (1 < utf_char2len(startc) || 1 < utf_char2len(endc))
;                   {
                        ;; Emit the characters in the range.
                        ;; "startc" was already emitted, so skip it.

;                       for (c = startc + 1; c <= endc; c++)
;                       {
;                           emc1(c);
;                           emc1(NFA_CONCAT);
;                       }
;                   }
;                   else
;                   {
                        ;; Emit the range. "startc" was already emitted, so skip it.
;                       for (c = startc + 1; c <= endc; c++)
;                       {
;                           emc1(c);
;                           emc1(NFA_CONCAT);
;                       }
;                   }
;                   emit_range = false;
;                   startc = -1;
;               }
;               else
;               {
                    ;; This char (startc) is not part of a range.  Just emit it.
                    ;; Normally, simply emit startc.  But if we get char
                    ;; code=0 from a collating char, then replace it with 0x0a.
                    ;; This is needed to completely mimic the behaviour of
                    ;; the backtracking engine.
;                   if (startc == NFA_NEWL)
;                   {
                        ;; Line break can't be matched as part of the collection,
                        ;; add an OR below.  But not for negated range.
;                       if (!negated)
;                           extra = NFA_ADD_NL;
;                   }
;                   else
;                   {
;                       if (got_coll_char == true && startc == 0)
;                           emc1(0x0a);
;                       else
;                           emc1(startc);
;                       emc1(NFA_CONCAT);
;                   }
;               }

;               @regparse = @regparse.plus(us_ptr2len_cc(@regparse));
;           }

;           @regparse = @regparse.minus(us_ptr_back(old_regparse, @regparse));
;           if (@regparse.at(0) == (byte)'-')       ;; if last, '-' is just a char
;           {
;               emc1('-');
;               emc1(NFA_CONCAT);
;           }

            ;; skip the trailing ]
;           @regparse = endp;
;           @regparse = @regparse.plus(us_ptr2len_cc(@regparse));

            ;; Mark end of the collection.
;           if (negated == true)
;               emc1(NFA_END_NEG_COLL);
;           else
;               emc1(NFA_END_COLL);

            ;; \_[] also matches \n but it's not negated
;           if (extra == NFA_ADD_NL)
;           {
;               emc1(@reg_string ? NL : NFA_NEWL);
;               emc1(NFA_OR);
;           }

;           return true;
;       }

;       if (@reg_strict)
;       {
;           emsg(e_missingbracket);
;           @rc_did_emsg = true;
;           return false;
;       }

;       return nfa_do_multibyte(c, old_regparse);
    ))

(defn- #_final #_boolean nfa_do_multibyte [#_int c, #_Bytes old_regparse]
    (§
;       int plen;

        ;; plen is length of current char with composing chars
;       if (utf_char2len(c) != (plen = us_ptr2len_cc(old_regparse)) || utf_iscomposing(c))
;       {
;           int i = 0;

            ;; A base character plus composing characters, or just one or more
            ;; composing characters.  This requires creating a separate atom
            ;; as if enclosing the characters in (), where NFA_COMPOSING is
            ;; the ( and NFA_END_COMPOSING is the ).
            ;; Note that right now we are building the postfix form, not the
            ;; NFA itself; a composing char could be: a, b, c, NFA_COMPOSING
            ;; where 'b' and 'c' are chars with codes > 256.
;           for ( ; ; )
;           {
;               emc1(c);
;               if (0 < i)
;                   emc1(NFA_CONCAT);
;               if (plen <= (i += utf_char2len(c)))
;                   break;
;               c = us_ptr2char(old_regparse.plus(i));
;           }
;           emc1(NFA_COMPOSING);
;           @regparse = old_regparse.plus(plen);
;       }
;       else
;       {
;           c = no_Magic(c);
;           emc1(c);
;       }

;       return true;
    ))

;; Parse something followed by possible [*+=].
;;
;; A piece is an atom, possibly followed by a multi, an indication of how many
;; times the atom can be matched.  Example: "a*" matches any sequence of "a"
;; characters: "", "a", "aa", etc.
;;
;; piece   ::=      atom
;;      or  atom  multi

(defn- #_boolean nfa_regpiece []
    (§
        ;; Save the current parse state, so that we can use it if <atom>{m,n} is next.
;       parse_state_C old_state = §_parse_state_C();
;       save_parse_state(old_state);

        ;; store current pos in the postfix form, for \{m,n} involving 0s
;       int my_post_start = @post_index;

;       boolean ret = nfa_regatom();
;       if (ret == false)
;           return false;           ;; cascaded error

;       int op = peekchr();
;       if (re_multi_type(op) == NOT_MULTI)
;           return true;

;       skipchr();
;       switch (op)
;       {
;           case -214: // case Magic('*'):
;           {
;               emc1(NFA_STAR);
;               break;
;           }

;           case -213: // case Magic('+'):
;           {
                ;; Trick: Normally, (a*)\+ would match the whole input "aaa".  The first and
                ;; only submatch would be "aaa".  But the backtracking engine interprets the
                ;; plus as "try matching one more time", and a* matches a second time at the
                ;; end of the input, the empty string.  The submatch will be the empty string.
                ;;
                ;; In order to be consistent with the old engine,
                ;; we replace <atom>+ with <atom><atom>*

;               restore_parse_state(old_state);
;               @curchr = -1;
;               if (nfa_regatom() == false)
;                   return false;
;               emc1(NFA_STAR);
;               emc1(NFA_CONCAT);
;               skipchr();          ;; skip the \+
;               break;
;           }

;           case -192: // case Magic('@'):
;           {
;               int c2 = getdecchrs();
;               op = no_Magic(getchr());
;               int i = 0;
;               switch (op)
;               {
;                   case '=':
                        ;; \@=
;                       i = NFA_PREV_ATOM_NO_WIDTH;
;                       break;
;                   case '!':
                        ;; \@!
;                       i = NFA_PREV_ATOM_NO_WIDTH_NEG;
;                       break;
;                   case '<':
;                       op = no_Magic(getchr());
;                       if (op == '=')
                            ;; \@<=
;                           i = NFA_PREV_ATOM_JUST_BEFORE;
;                       else if (op == '!')
                            ;; \@<!
;                           i = NFA_PREV_ATOM_JUST_BEFORE_NEG;
;                       break;
;                   case '>':
                        ;; \@>
;                       i = NFA_PREV_ATOM_LIKE_PATTERN;
;                       break;
;               }
;               if (i == 0)
;               {
;                   emsgn(u8("E869: (NFA) Unknown operator '\\@%c'"), (long)op);
;                   return false;
;               }
;               emc1(i);
;               if (i == NFA_PREV_ATOM_JUST_BEFORE || i == NFA_PREV_ATOM_JUST_BEFORE_NEG)
;                   emc1(c2);
;               break;
;           }

;           case -193: // case Magic('?'):
;           case -195: // case Magic('='):
;           {
;               emc1(NFA_QUEST);
;               break;
;           }

;           case -133: // case Magic('{'):
;           {
                ;; a{2,5} will expand to 'aaa?a?a?'
                ;; a{-1,3} will expand to 'aa??a??', where ?? is the nongreedy version of '?'
                ;; \v(ab){2,3} will expand to '(ab)(ab)(ab)?', where all the parenthesis have the same id

;               boolean greedy = true;      ;; Braces are prefixed with '-' ?
;               int c2 = peekchr();
;               if (c2 == '-' || c2 == Magic('-'))
;               {
;                   skipchr();
;                   greedy = false;
;               }
;               long[] minval = new long[1];
;               long[] maxval = new long[1];
;               if (!read_limits(minval, maxval))
;               {
;                   emsg(u8("E870: (NFA regexp) Error reading repetition limits"));
;                   @rc_did_emsg = true;
;                   return false;
;               }

                ;;  <atom>{0,inf}, <atom>{0,} and <atom>{}  are equivalent to <atom>*
;               if (minval[0] == 0 && maxval[0] == MAX_LIMIT)
;               {
;                   if (greedy)             ;; { { (match the braces)
                        ;; \{}, \{0,}
;                       emc1(NFA_STAR);
;                   else                    ;; { { (match the braces)
                        ;; \{-}, \{-0,}
;                       emc1(NFA_STAR_NONGREEDY);
;                   break;
;               }

                ;; Special case: x{0} or x{-0}.
;               if (maxval[0] == 0)
;               {
                    ;; Ignore result of previous call to nfa_regatom().
;                   @post_index = my_post_start;
                    ;; NFA_EMPTY is 0-length and works everywhere.
;                   emc1(NFA_EMPTY);
;                   return true;
;               }

                ;; The engine is very inefficient (uses too many states) when the
                ;; maximum is much larger than the minimum and when the maximum is
                ;; large.  Bail out if we can use the other engine.
;               if ((@nfa_re_flags & RE_AUTO) != 0 && (minval[0] + 200 < maxval[0] || 500 < maxval[0]))
;                   return false;

                ;; Ignore previous call to nfa_regatom().
;               @post_index = my_post_start;
                ;; Save parse state after the repeated atom and the \{}.
;               parse_state_C new_state = §_parse_state_C();
;               save_parse_state(new_state);

;               int quest = (greedy == true) ? NFA_QUEST : NFA_QUEST_NONGREEDY;
;               for (int i = 0; i < maxval[0]; i++)
;               {
                    ;; Goto beginning of the repeated atom.
;                   restore_parse_state(old_state);
;                   int old_post_pos = @post_index;
;                   if (nfa_regatom() == false)
;                       return false;

                    ;; after "minval" times, atoms are optional
;                   if (minval[0] < i + 1)
;                   {
;                       if (maxval[0] == MAX_LIMIT)
;                       {
;                           if (greedy)
;                               emc1(NFA_STAR);
;                           else
;                               emc1(NFA_STAR_NONGREEDY);
;                       }
;                       else
;                           emc1(quest);
;                   }
;                   if (old_post_pos != my_post_start)
;                       emc1(NFA_CONCAT);
;                   if (minval[0] < i + 1 && maxval[0] == MAX_LIMIT)
;                       break;
;               }

                ;; Go to just after the repeated atom and the \{}.
;               restore_parse_state(new_state);
;               @curchr = -1;
;               break;
;           }

;           default:
;               break;
;       }

;       if (re_multi_type(peekchr()) != NOT_MULTI)
;       {
;           emsg(u8("E871: (NFA regexp) Can't have a multi follow a multi !"));
;           @rc_did_emsg = true;
;           return false;
;       }

;       return true;
    ))

;; Parse one or more pieces, concatenated.  It matches a match for the
;; first piece, followed by a match for the second piece, etc.  Example:
;; "f[0-9]b", first matches "f", then a digit and then "b".
;;
;; concat  ::=      piece
;;      or  piece piece
;;      or  piece piece piece
;;      etc.

(defn- #_boolean nfa_regconcat []
    (§
;       boolean cont = true;
;       boolean first = true;

;       while (cont)
;       {
;           switch (peekchr())
;           {
;               case NUL:
;               case -132: // case Magic('|'):
;               case -218: // case Magic('&'):
;               case -215: // case Magic(')'):
;                   cont = false;
;                   break;

;               case -166: // case Magic('Z'):
;                   @regflags |= RF_ICOMBINE;
;                   skipchr_keepstart();
;                   break;

;               case -157: // case Magic('c'):
;                   @regflags |= RF_ICASE;
;                   skipchr_keepstart();
;                   break;

;               case -189: // case Magic('C'):
;                   @regflags |= RF_NOICASE;
;                   skipchr_keepstart();
;                   break;

;               case -138: // case Magic('v'):
;                   @reg_magic = MAGIC_ALL;
;                   skipchr_keepstart();
;                   @curchr = -1;
;                   break;

;               case -147: // case Magic('m'):
;                   @reg_magic = MAGIC_ON;
;                   skipchr_keepstart();
;                   @curchr = -1;
;                   break;

;               case -179: // case Magic('M'):
;                   @reg_magic = MAGIC_OFF;
;                   skipchr_keepstart();
;                   @curchr = -1;
;                   break;

;               case -170: // case Magic('V'):
;                   @reg_magic = MAGIC_NONE;
;                   skipchr_keepstart();
;                   @curchr = -1;
;                   break;

;               default:
;                   if (nfa_regpiece() == false)
;                       return false;
;                   if (first == false)
;                       emc1(NFA_CONCAT);
;                   else
;                       first = false;
;                   break;
;           }
;       }

;       return true;
    ))

;; Parse a branch, one or more concats, separated by "\&".  It matches the
;; last concat, but only if all the preceding concats also match at the same
;; position.  Examples:
;;      "foobeep\&..." matches "foo" in "foobeep".
;;      ".*Peter\&.*Bob" matches in a line containing both "Peter" and "Bob"
;;
;; branch ::=       concat
;;              or  concat \& concat
;;              or  concat \& concat \& concat
;;              etc.

(defn- #_boolean nfa_regbranch []
    (§
;       int old_post_pos = @post_index;

        ;; First branch, possibly the only one.
;       if (nfa_regconcat() == false)
;           return false;

;       int ch = peekchr();
        ;; Try next concats.
;       while (ch == Magic('&'))
;       {
;           skipchr();
;           emc1(NFA_NOPEN);
;           emc1(NFA_PREV_ATOM_NO_WIDTH);
;           old_post_pos = @post_index;
;           if (nfa_regconcat() == false)
;               return false;
            ;; if concat is empty do emit a node
;           if (old_post_pos == @post_index)
;               emc1(NFA_EMPTY);
;           emc1(NFA_CONCAT);
;           ch = peekchr();
;       }

        ;; if a branch is empty, emit one node for it
;       if (old_post_pos == @post_index)
;           emc1(NFA_EMPTY);

;       return true;
    ))

;; Parse a pattern, one or more branches, separated by "\|".
;; It matches anything that matches one of the branches.
;; Example: "foo\|beep" matches "foo" and matches "beep".
;; If more than one branch matches, the first one is used.
;;
;; pattern ::=     branch
;;     or  branch \| branch
;;     or  branch \| branch \| branch
;;     etc.

(defn- #_boolean nfa_reg [#_int paren]
    ;; paren: REG_NOPAREN, REG_PAREN, REG_NPAREN or REG_ZPAREN
    (§
;       int parno = 0;

;       if (paren == REG_PAREN)
;       {
;           if (NSUBEXP <= @regnpar)
;           {
;               emsg(u8("E872: (NFA regexp) Too many '('"));
;               @rc_did_emsg = true;
;               return false;
;           }
;           parno = @regnpar++;
;       }
;       else if (paren == REG_ZPAREN)
;       {
            ;; Make a ZOPEN node.
;           if (NSUBEXP <= @regnzpar)
;           {
;               emsg(u8("E879: (NFA regexp) Too many \\z("));
;               @rc_did_emsg = true;
;               return false;
;           }
;           parno = @regnzpar++;
;       }

;       if (nfa_regbranch() == false)
;           return false;                   ;; cascaded error

;       while (peekchr() == Magic('|'))
;       {
;           skipchr();
;           if (nfa_regbranch() == false)
;               return false;               ;; cascaded error
;           emc1(NFA_OR);
;       }

        ;; Check for proper termination.
;       if (paren != REG_NOPAREN && getchr() != Magic(')'))
;       {
;           if (paren == REG_NPAREN)
;               emsg2(e_unmatchedpp, (@reg_magic == MAGIC_ALL) ? u8("") : u8("\\"));
;           else
;               emsg2(e_unmatchedp, (@reg_magic == MAGIC_ALL) ? u8("") : u8("\\"));
;           @rc_did_emsg = true;
;           return false;
;       }
;       else if (paren == REG_NOPAREN && peekchr() != NUL)
;       {
;           if (peekchr() == Magic(')'))
;               emsg2(e_unmatchedpar, (@reg_magic == MAGIC_ALL) ? u8("") : u8("\\"));
;           else
;               emsg(u8("E873: (NFA regexp) proper termination error"));
;           @rc_did_emsg = true;
;           return false;
;       }

        ;; Here we set the flag allowing back references to this set of parentheses.

;       if (paren == REG_PAREN)
;       {
;           @had_endbrace[parno] = true;     ;; have seen the close paren
;           emc1(NFA_MOPEN + parno);
;       }
;       else if (paren == REG_ZPAREN)
;           emc1(NFA_ZOPEN + parno);

;       return true;
    ))

;; Parse r.e. @expr and convert it into postfix form.
;; Return the postfix string on success, null otherwise.

(defn- #_int* re2post []
    (§
;       if (nfa_reg(REG_NOPAREN) == false)
;           return null;

;       emc1(NFA_MOPEN);
;       return @post_array;
    ))

;; Represents an NFA state plus zero or one or two arrows exiting.
;; if c == MATCH, no arrows out; matching state.
;; If c == SPLIT, unlabeled arrows to out0 and out1 (if != null).
;; If c < 256, labeled arrow with character c to out0.

(atom! nfa_state_C* nfa_states) ;; points to nfa_prog.states

;; Allocate and initialize nfa_state_C.

(defn- #_nfa_state_C alloc_state [#_nfa_regprog_C prog, #_int c, #_nfa_state_C out0, #_nfa_state_C out1]
    (§
;       if (prog.nstate <= prog.istate)
;           return null;

;       nfa_state_C state = @nfa_states[prog.istate++] = §_nfa_state_C();

;       state.c = c;
;       state.out0(out0);
;       state.out1(out1);
;       state.val = 0;

;       state.id = prog.istate;
;       state.lastlist[0] = 0;
;       state.lastlist[1] = 0;

;       return state;
    ))

;; Estimate the maximum byte length of anything matching "state".
;; When unknown or unlimited return -1.

(defn- #_int nfa_max_width [#_nfa_state_C startstate, #_int depth]
    (§
        ;; detect looping in a NFA_SPLIT
;       if (4 < depth)
;           return -1;

;       int len = 0;

;       for (nfa_state_C state = startstate; state != null; )
;       {
;           switch (state.c)
;           {
;               case NFA_END_INVISIBLE:
;               case NFA_END_INVISIBLE_NEG:
                    ;; the end, return what we have
;                   return len;

;               case NFA_SPLIT:
;               {
                    ;; two alternatives, use the maximum
;                   int l = nfa_max_width(state.out0(), depth + 1);
;                   int r = nfa_max_width(state.out1(), depth + 1);
;                   if (l < 0 || r < 0)
;                       return -1;

;                   return len + (r < l ? l : r);
;               }

;               case NFA_ANY:
;               case NFA_START_COLL:
;               case NFA_START_NEG_COLL:
                    ;; matches some character, including composing chars
;                   len += MB_MAXBYTES;
;                   if (state.c != NFA_ANY)
;                   {
                        ;; skip over the characters
;                       state = state.out1().out0();
;                       continue;
;                   }
;                   break;

;               case NFA_DIGIT:
;               case NFA_WHITE:
;               case NFA_HEX:
;               case NFA_OCTAL:
                    ;; ascii
;                   len++;
;                   break;

;               case NFA_IDENT:
;               case NFA_SIDENT:
;               case NFA_KWORD:
;               case NFA_SKWORD:
;               case NFA_FNAME:
;               case NFA_SFNAME:
;               case NFA_PRINT:
;               case NFA_SPRINT:
;               case NFA_NWHITE:
;               case NFA_NDIGIT:
;               case NFA_NHEX:
;               case NFA_NOCTAL:
;               case NFA_WORD:
;               case NFA_NWORD:
;               case NFA_HEAD:
;               case NFA_NHEAD:
;               case NFA_ALPHA:
;               case NFA_NALPHA:
;               case NFA_LOWER:
;               case NFA_NLOWER:
;               case NFA_UPPER:
;               case NFA_NUPPER:
;               case NFA_LOWER_IC:
;               case NFA_NLOWER_IC:
;               case NFA_UPPER_IC:
;               case NFA_NUPPER_IC:
;               case NFA_ANY_COMPOSING:
                    ;; possibly non-ascii
;                   len += 3;
;                   break;

;               case NFA_START_INVISIBLE:
;               case NFA_START_INVISIBLE_NEG:
;               case NFA_START_INVISIBLE_BEFORE:
;               case NFA_START_INVISIBLE_BEFORE_NEG:
                    ;; zero-width, out1 points to the END state
;                   state = state.out1().out0();
;                   continue;

;               case NFA_BACKREF1:
;               case NFA_BACKREF2:
;               case NFA_BACKREF3:
;               case NFA_BACKREF4:
;               case NFA_BACKREF5:
;               case NFA_BACKREF6:
;               case NFA_BACKREF7:
;               case NFA_BACKREF8:
;               case NFA_BACKREF9:
;               case NFA_ZREF1:
;               case NFA_ZREF2:
;               case NFA_ZREF3:
;               case NFA_ZREF4:
;               case NFA_ZREF5:
;               case NFA_ZREF6:
;               case NFA_ZREF7:
;               case NFA_ZREF8:
;               case NFA_ZREF9:
;               case NFA_NEWL:
;               case NFA_SKIP:
                    ;; unknown width
;                   return -1;

;               case NFA_BOL:
;               case NFA_EOL:
;               case NFA_BOF:
;               case NFA_EOF:
;               case NFA_BOW:
;               case NFA_EOW:
;               case NFA_MOPEN:
;               case NFA_MOPEN1:
;               case NFA_MOPEN2:
;               case NFA_MOPEN3:
;               case NFA_MOPEN4:
;               case NFA_MOPEN5:
;               case NFA_MOPEN6:
;               case NFA_MOPEN7:
;               case NFA_MOPEN8:
;               case NFA_MOPEN9:
;               case NFA_ZOPEN:
;               case NFA_ZOPEN1:
;               case NFA_ZOPEN2:
;               case NFA_ZOPEN3:
;               case NFA_ZOPEN4:
;               case NFA_ZOPEN5:
;               case NFA_ZOPEN6:
;               case NFA_ZOPEN7:
;               case NFA_ZOPEN8:
;               case NFA_ZOPEN9:
;               case NFA_ZCLOSE:
;               case NFA_ZCLOSE1:
;               case NFA_ZCLOSE2:
;               case NFA_ZCLOSE3:
;               case NFA_ZCLOSE4:
;               case NFA_ZCLOSE5:
;               case NFA_ZCLOSE6:
;               case NFA_ZCLOSE7:
;               case NFA_ZCLOSE8:
;               case NFA_ZCLOSE9:
;               case NFA_MCLOSE:
;               case NFA_MCLOSE1:
;               case NFA_MCLOSE2:
;               case NFA_MCLOSE3:
;               case NFA_MCLOSE4:
;               case NFA_MCLOSE5:
;               case NFA_MCLOSE6:
;               case NFA_MCLOSE7:
;               case NFA_MCLOSE8:
;               case NFA_MCLOSE9:
;               case NFA_NOPEN:
;               case NFA_NCLOSE:

;               case NFA_LNUM_GT:
;               case NFA_LNUM_LT:
;               case NFA_COL_GT:
;               case NFA_COL_LT:
;               case NFA_VCOL_GT:
;               case NFA_VCOL_LT:
;               case NFA_MARK_GT:
;               case NFA_MARK_LT:
;               case NFA_VISUAL:
;               case NFA_LNUM:
;               case NFA_CURSOR:
;               case NFA_COL:
;               case NFA_VCOL:
;               case NFA_MARK:

;               case NFA_ZSTART:
;               case NFA_ZEND:
;               case NFA_OPT_CHARS:
;               case NFA_EMPTY:
;               case NFA_START_PATTERN:
;               case NFA_END_PATTERN:
;               case NFA_COMPOSING:
;               case NFA_END_COMPOSING:
                    ;; zero-width
;                   break;

;               default:
;                   if (state.c < 0)
                        ;; don't know what this is
;                       return -1;
                    ;; normal character
;                   len += utf_char2len(state.c);
;                   break;
;           }

            ;; normal way to continue
;           state = state.out0();
;       }

        ;; unrecognized, "cannot happen"
;       return -1;
    ))

;; A partially built NFA without the matching state filled in.
;; frag_C.fr_start points at the start state.
;; frag_C.fr_out is a list of places that need to be set to the next state for this fragment.

;; Since the out pointers in the list are always uninitialized,
;; we use the pointers themselves as storage for the fragnode_C.

(class! #_final fragnode_C
    [
        (field #_"/*fragnode_C*/"Object     fn_next)
    ])

(class! #_final frag_C
    [
        (field nfa_state_C  fr_start)
        (field fragnode_C   fr_out)
    ])

(defn- #_void COPY_frag [#_frag_C fr1, #_frag_C fr0]
    (§
;       fr1.fr_start = fr0.fr_start;
;       fr1.fr_out = fr0.fr_out;
    ))

;; Initialize a frag_C struct and return it.

(defn- #_frag_C alloc_frag [#_nfa_state_C start, #_fragnode_C out]
    (§
;       frag_C frag = §_frag_C();

;       frag.fr_start = start;
;       frag.fr_out = out;

;       return frag;
    ))

;; Create singleton list containing just outp.

(defn- #_fragnode_C fr_single [#_fragnode_C node]
    (§
;       node.fn_next = null;
;       return node;
    ))

;; Patch the list of states at out to point to start.

(defn- #_void fr_patch [#_fragnode_C node, #_nfa_state_C start]
    (§
;       for (fragnode_C next; node != null; node = next)
;       {
;           next = (fragnode_C)node.fn_next;
;           node.fn_next = start;
;       }
    ))

;; Join the two lists returning the concatenation.

(defn- #_fragnode_C fr_append [#_fragnode_C head, #_fragnode_C tail]
    (§
;       fragnode_C list = head;

;       while (head.fn_next != null)
;           head = (fragnode_C)head.fn_next;
;       head.fn_next = tail;

;       return list;
    ))

;; Stack used for transforming postfix form into NFA.

(class! #_final nfa_stack_C
    [
        (field frag_C*      st_base)
        (field int          st_next)
        (field int          st_over)
    ])

(defn- #_nfa_stack_C new_nfa_stack [#_int n]
    (->nfa_stack_C (frag_C* n) 0 n))

;; Push an item onto the stack.

(defn- #_boolean st_push [#_nfa_stack_C stack, #_frag_C frag]
    (§
;       if (stack.st_next < stack.st_over)
;       {
;           stack.st_base[stack.st_next++] = frag;
;           return true;
;       }

;       return false;
    ))

;; Pop an item from the stack.

(defn- #_frag_C st_pop [#_nfa_stack_C stack]
    (§
;       if (--stack.st_next < 0)
;           return null;

;       frag_C frag = stack.st_base[stack.st_next];
;       stack.st_base[stack.st_next] = null;
;       return frag;
    ))

(defn- #_nfa_state_C st_error [#_int* _postfix, #_int _i, #_int _over]
    (§
;       emsg(u8("E874: (NFA) Could not pop the stack !"));
;       return null;
    ))

;; Convert a postfix form into its equivalent NFA.
;; Return the NFA start state on success, null otherwise.

(defn- #_nfa_state_C post2nfa [#_int* postfix, #_int over, #_nfa_regprog_C prog, #_boolean nfa_calc_size]
    (§
;       if (postfix == null)
;           return null;

;       nfa_stack_C stack = (nfa_calc_size) ? null : new_nfa_stack(prog.nstate + 1);

;       int i;
;       for (i = 0; i < over; i++)
;       {
;           switch (postfix[i])
;           {
;               case NFA_CONCAT:
;               {
                    ;; Concatenation.
                    ;; Pay attention: this operator does not exist in the r.e. itself (it is implicit, really).
                    ;; It is added when r.e. is translated to postfix form in re2post().
;                   if (nfa_calc_size)
;                   {
                        ;; prog.nstate += 0;
;                       break;
;                   }

;                   frag_C e2 = st_pop(stack);
;                   if (e2 == null)
;                       return st_error(postfix, i, over);
;                   frag_C e1 = st_pop(stack);
;                   if (e1 == null)
;                       return st_error(postfix, i, over);
;                   fr_patch(e1.fr_out, e2.fr_start);
;                   st_push(stack, alloc_frag(e1.fr_start, e2.fr_out));
;                   break;
;               }

;               case NFA_OR:
;               {
                    ;; Alternation.
;                   if (nfa_calc_size)
;                   {
;                       prog.nstate++;
;                       break;
;                   }

;                   frag_C e2 = st_pop(stack);
;                   if (e2 == null)
;                       return st_error(postfix, i, over);
;                   frag_C e1 = st_pop(stack);
;                   if (e1 == null)
;                       return st_error(postfix, i, over);
;                   nfa_state_C s0 = alloc_state(prog, NFA_SPLIT, e1.fr_start, e2.fr_start);
;                   if (s0 == null)
;                       return null;
;                   st_push(stack, alloc_frag(s0, fr_append(e1.fr_out, e2.fr_out)));
;                   break;
;               }

;               case NFA_STAR:
;               {
                    ;; Zero or more, prefer more.
;                   if (nfa_calc_size)
;                   {
;                       prog.nstate++;
;                       break;
;                   }

;                   frag_C e0 = st_pop(stack);
;                   if (e0 == null)
;                       return st_error(postfix, i, over);
;                   nfa_state_C s0 = alloc_state(prog, NFA_SPLIT, e0.fr_start, null);
;                   if (s0 == null)
;                       return null;
;                   fr_patch(e0.fr_out, s0);
;                   st_push(stack, alloc_frag(s0, fr_single(s0.out1)));
;                   break;
;               }

;               case NFA_STAR_NONGREEDY:
;               {
                    ;; Zero or more, prefer zero.
;                   if (nfa_calc_size)
;                   {
;                       prog.nstate++;
;                       break;
;                   }

;                   frag_C e0 = st_pop(stack);
;                   if (e0 == null)
;                       return st_error(postfix, i, over);
;                   nfa_state_C s0 = alloc_state(prog, NFA_SPLIT, null, e0.fr_start);
;                   if (s0 == null)
;                       return null;
;                   fr_patch(e0.fr_out, s0);
;                   st_push(stack, alloc_frag(s0, fr_single(s0.out0)));
;                   break;
;               }

;               case NFA_QUEST:
;               {
                    ;; one or zero atoms=> greedy match
;                   if (nfa_calc_size)
;                   {
;                       prog.nstate++;
;                       break;
;                   }

;                   frag_C e0 = st_pop(stack);
;                   if (e0 == null)
;                       return st_error(postfix, i, over);
;                   nfa_state_C s0 = alloc_state(prog, NFA_SPLIT, e0.fr_start, null);
;                   if (s0 == null)
;                       return null;
;                   st_push(stack, alloc_frag(s0, fr_append(e0.fr_out, fr_single(s0.out1))));
;                   break;
;               }

;               case NFA_QUEST_NONGREEDY:
;               {
                    ;; zero or one atoms => non-greedy match
;                   if (nfa_calc_size)
;                   {
;                       prog.nstate++;
;                       break;
;                   }

;                   frag_C e0 = st_pop(stack);
;                   if (e0 == null)
;                       return st_error(postfix, i, over);
;                   nfa_state_C s0 = alloc_state(prog, NFA_SPLIT, null, e0.fr_start);
;                   if (s0 == null)
;                       return null;
;                   st_push(stack, alloc_frag(s0, fr_append(e0.fr_out, fr_single(s0.out0))));
;                   break;
;               }

;               case NFA_END_COLL:
;               case NFA_END_NEG_COLL:
;               {
                    ;; On the stack is the sequence starting with NFA_START_COLL or
                    ;; NFA_START_NEG_COLL and all possible characters.  Patch it to
                    ;; add the output to the start.
;                   if (nfa_calc_size)
;                   {
;                       prog.nstate++;
;                       break;
;                   }

;                   frag_C e0 = st_pop(stack);
;                   if (e0 == null)
;                       return st_error(postfix, i, over);
;                   nfa_state_C s0 = alloc_state(prog, NFA_END_COLL, null, null);
;                   if (s0 == null)
;                       return null;
;                   fr_patch(e0.fr_out, s0);
;                   e0.fr_start.out1(s0);
;                   st_push(stack, alloc_frag(e0.fr_start, fr_single(s0.out0)));
;                   break;
;               }

;               case NFA_RANGE:
;               {
                    ;; Before this are two characters, the low and high end of a range.
                    ;; Turn them into two states with MIN and MAX.
;                   if (nfa_calc_size)
;                   {
                        ;; prog.nstate += 0;
;                       break;
;                   }

;                   frag_C e2 = st_pop(stack);
;                   if (e2 == null)
;                       return st_error(postfix, i, over);
;                   frag_C e1 = st_pop(stack);
;                   if (e1 == null)
;                       return st_error(postfix, i, over);
;                   e2.fr_start.val = e2.fr_start.c;
;                   e2.fr_start.c = NFA_RANGE_MAX;
;                   e1.fr_start.val = e1.fr_start.c;
;                   e1.fr_start.c = NFA_RANGE_MIN;
;                   fr_patch(e1.fr_out, e2.fr_start);
;                   st_push(stack, alloc_frag(e1.fr_start, e2.fr_out));
;                   break;
;               }

;               case NFA_EMPTY:
;               {
                    ;; 0-length, used in a repetition with max/min count of 0
;                   if (nfa_calc_size)
;                   {
;                       prog.nstate++;
;                       break;
;                   }

;                   nfa_state_C s0 = alloc_state(prog, NFA_EMPTY, null, null);
;                   if (s0 == null)
;                       return null;
;                   st_push(stack, alloc_frag(s0, fr_single(s0.out0)));
;                   break;
;               }

;               case NFA_OPT_CHARS:
;               {
                    ;; \%[abc] implemented as:
                    ;;    NFA_SPLIT
                    ;;    +-CHAR(a)
                    ;;    | +-NFA_SPLIT
                    ;;    |   +-CHAR(b)
                    ;;    |   | +-NFA_SPLIT
                    ;;    |   |   +-CHAR(c)
                    ;;    |   |   | +-next
                    ;;    |   |   +- next
                    ;;    |   +- next
                    ;;    +- next

;                   int n = postfix[++i];                           ;; get number of characters
;                   if (nfa_calc_size)
;                   {
;                       prog.nstate += n;
;                       break;
;                   }

;                   frag_C e1 = alloc_frag(null, null);     ;; e1.fr_out: stores list with out1's
;                   nfa_state_C s0 = null;
;                   for (nfa_state_C s1 = null; 0 < n--; s1 = s0)  ;; s1: previous NFA_SPLIT to connect to
;                   {
;                       frag_C e0 = st_pop(stack);          ;; get character
;                       if (e0 == null)
;                           return st_error(postfix, i, over);
;                       s0 = alloc_state(prog, NFA_SPLIT, e0.fr_start, null);
;                       if (s0 == null)
;                           return null;
;                       if (e1.fr_out == null)
;                           COPY_frag(e1, e0);
;                       fr_patch(e0.fr_out, s1);
;                       fr_append(e1.fr_out, fr_single(s0.out1));
;                   }
;                   st_push(stack, alloc_frag(s0, e1.fr_out));
;                   break;
;               }

;               case NFA_PREV_ATOM_NO_WIDTH:
;               case NFA_PREV_ATOM_NO_WIDTH_NEG:
;               case NFA_PREV_ATOM_JUST_BEFORE:
;               case NFA_PREV_ATOM_JUST_BEFORE_NEG:
;               case NFA_PREV_ATOM_LIKE_PATTERN:
;               {
;                   boolean before = (postfix[i] == NFA_PREV_ATOM_JUST_BEFORE
;                                  || postfix[i] == NFA_PREV_ATOM_JUST_BEFORE_NEG);
;                   boolean pattern = (postfix[i] == NFA_PREV_ATOM_LIKE_PATTERN);

;                   int start_state, end_state;
;                   switch (postfix[i])
;                   {
;                       case NFA_PREV_ATOM_NO_WIDTH:
;                           start_state = NFA_START_INVISIBLE;
;                           end_state = NFA_END_INVISIBLE;
;                           break;
;                       case NFA_PREV_ATOM_NO_WIDTH_NEG:
;                           start_state = NFA_START_INVISIBLE_NEG;
;                           end_state = NFA_END_INVISIBLE_NEG;
;                           break;
;                       case NFA_PREV_ATOM_JUST_BEFORE:
;                           start_state = NFA_START_INVISIBLE_BEFORE;
;                           end_state = NFA_END_INVISIBLE;
;                           break;
;                       case NFA_PREV_ATOM_JUST_BEFORE_NEG:
;                           start_state = NFA_START_INVISIBLE_BEFORE_NEG;
;                           end_state = NFA_END_INVISIBLE_NEG;
;                           break;
;                       default: ;; NFA_PREV_ATOM_LIKE_PATTERN:
;                           start_state = NFA_START_PATTERN;
;                           end_state = NFA_END_PATTERN;
;                           break;
;                   }

;                   int n = (before) ? postfix[++i] : 0;    ;; get the count

                    ;; The \@= operator: match the preceding atom with zero width.
                    ;; The \@! operator: no match for the preceding atom.
                    ;; The \@<= operator: match for the preceding atom.
                    ;; The \@<! operator: no match for the preceding atom.
                    ;; Surrounds the preceding atom with START_INVISIBLE and END_INVISIBLE, similarly to MOPEN.

;                   if (nfa_calc_size)
;                   {
;                       prog.nstate += pattern ? 4 : 2;
;                       break;
;                   }

;                   frag_C e0 = st_pop(stack);
;                   if (e0 == null)
;                       return st_error(postfix, i, over);

;                   nfa_state_C s1 = alloc_state(prog, end_state, null, null);
;                   if (s1 == null)
;                       return null;

;                   nfa_state_C s0 = alloc_state(prog, start_state, e0.fr_start, s1);
;                   if (s0 == null)
;                       return null;

;                   if (pattern)
;                   {
                        ;; NFA_ZEND -> NFA_END_PATTERN -> NFA_SKIP -> what follows.
;                       nfa_state_C skip = alloc_state(prog, NFA_SKIP, null, null);
;                       nfa_state_C zend = alloc_state(prog, NFA_ZEND, s1, null);
;                       s1.out0(skip);
;                       fr_patch(e0.fr_out, zend);
;                       st_push(stack, alloc_frag(s0, fr_single(skip.out0)));
;                   }
;                   else
;                   {
;                       fr_patch(e0.fr_out, s1);
;                       st_push(stack, alloc_frag(s0, fr_single(s1.out0)));
;                       if (before)
;                       {
                            ;; See if we can guess the maximum width, it avoids a lot of pointless tries.
;                           if (n <= 0)
;                               n = nfa_max_width(e0.fr_start, 0);
;                           s0.val = n; ;; store the count
;                       }
;                   }
;                   break;
;               }

;               case NFA_COMPOSING:     ;; char with composing char
;                   if ((@regflags & RF_ICOMBINE) != 0)
;                   {
                        ;; TODO: use the base character only
;                   }
                    ;; FALLTHROUGH

;               case NFA_MOPEN: ;; \( \) Submatch
;               case NFA_MOPEN1:
;               case NFA_MOPEN2:
;               case NFA_MOPEN3:
;               case NFA_MOPEN4:
;               case NFA_MOPEN5:
;               case NFA_MOPEN6:
;               case NFA_MOPEN7:
;               case NFA_MOPEN8:
;               case NFA_MOPEN9:
;               case NFA_ZOPEN: ;; \z( \) Submatch
;               case NFA_ZOPEN1:
;               case NFA_ZOPEN2:
;               case NFA_ZOPEN3:
;               case NFA_ZOPEN4:
;               case NFA_ZOPEN5:
;               case NFA_ZOPEN6:
;               case NFA_ZOPEN7:
;               case NFA_ZOPEN8:
;               case NFA_ZOPEN9:
;               case NFA_NOPEN: ;; \%( \) "Invisible Submatch"
;               {
;                   if (nfa_calc_size)
;                   {
;                       prog.nstate += 2;
;                       break;
;                   }

;                   int mopen = postfix[i], mclose;
;                   switch (postfix[i])
;                   {
;                       case NFA_NOPEN: mclose = NFA_NCLOSE; break;
;                       case NFA_ZOPEN: mclose = NFA_ZCLOSE; break;
;                       case NFA_ZOPEN1: mclose = NFA_ZCLOSE1; break;
;                       case NFA_ZOPEN2: mclose = NFA_ZCLOSE2; break;
;                       case NFA_ZOPEN3: mclose = NFA_ZCLOSE3; break;
;                       case NFA_ZOPEN4: mclose = NFA_ZCLOSE4; break;
;                       case NFA_ZOPEN5: mclose = NFA_ZCLOSE5; break;
;                       case NFA_ZOPEN6: mclose = NFA_ZCLOSE6; break;
;                       case NFA_ZOPEN7: mclose = NFA_ZCLOSE7; break;
;                       case NFA_ZOPEN8: mclose = NFA_ZCLOSE8; break;
;                       case NFA_ZOPEN9: mclose = NFA_ZCLOSE9; break;
;                       case NFA_COMPOSING: mclose = NFA_END_COMPOSING; break;
;                       default:
                            ;; NFA_MOPEN, NFA_MOPEN1 .. NFA_MOPEN9
;                           mclose = postfix[i] + NSUBEXP;
;                           break;
;                   }

                    ;; Allow "NFA_MOPEN" as a valid postfix representation for the empty regexp "".
                    ;; In this case, the NFA will be NFA_MOPEN -> NFA_MCLOSE.  Note that this also
                    ;; allows empty groups of parenthesis, and empty mbyte chars.
;                   if (stack.st_next == 0)
;                   {
;                       nfa_state_C s0 = alloc_state(prog, mopen, null, null);
;                       if (s0 == null)
;                           return null;
;                       nfa_state_C s1 = alloc_state(prog, mclose, null, null);
;                       if (s1 == null)
;                           return null;
;                       fr_patch(fr_single(s0.out0), s1);
;                       st_push(stack, alloc_frag(s0, fr_single(s1.out0)));
;                       break;
;                   }

                    ;; At least one node was emitted before NFA_MOPEN, so
                    ;; at least one node will be between NFA_MOPEN and NFA_MCLOSE.
;                   frag_C e0 = st_pop(stack);
;                   if (e0 == null)
;                       return st_error(postfix, i, over);
;                   nfa_state_C s0 = alloc_state(prog, mopen, e0.fr_start, null);   ;; `('
;                   if (s0 == null)
;                       return null;

;                   nfa_state_C s1 = alloc_state(prog, mclose, null, null);         ;; `)'
;                   if (s1 == null)
;                       return null;
;                   fr_patch(e0.fr_out, s1);

;                   if (mopen == NFA_COMPOSING)
                        ;; COMPOSING.out1 = END_COMPOSING
;                       fr_patch(fr_single(s0.out1), s1);

;                   st_push(stack, alloc_frag(s0, fr_single(s1.out0)));
;                   break;
;               }

;               case NFA_BACKREF1:
;               case NFA_BACKREF2:
;               case NFA_BACKREF3:
;               case NFA_BACKREF4:
;               case NFA_BACKREF5:
;               case NFA_BACKREF6:
;               case NFA_BACKREF7:
;               case NFA_BACKREF8:
;               case NFA_BACKREF9:
;               case NFA_ZREF1:
;               case NFA_ZREF2:
;               case NFA_ZREF3:
;               case NFA_ZREF4:
;               case NFA_ZREF5:
;               case NFA_ZREF6:
;               case NFA_ZREF7:
;               case NFA_ZREF8:
;               case NFA_ZREF9:
;               {
;                   if (nfa_calc_size)
;                   {
;                       prog.nstate += 2;
;                       break;
;                   }

;                   nfa_state_C s0 = alloc_state(prog, postfix[i], null, null);
;                   if (s0 == null)
;                       return null;
;                   nfa_state_C s1 = alloc_state(prog, NFA_SKIP, null, null);
;                   if (s1 == null)
;                       return null;
;                   fr_patch(fr_single(s0.out0), s1);
;                   st_push(stack, alloc_frag(s0, fr_single(s1.out0)));
;                   break;
;               }

;               case NFA_LNUM:
;               case NFA_LNUM_GT:
;               case NFA_LNUM_LT:
;               case NFA_VCOL:
;               case NFA_VCOL_GT:
;               case NFA_VCOL_LT:
;               case NFA_COL:
;               case NFA_COL_GT:
;               case NFA_COL_LT:
;               case NFA_MARK:
;               case NFA_MARK_GT:
;               case NFA_MARK_LT:
;               {
;                   int n = postfix[++i]; ;; lnum, col or mark name

;                   if (nfa_calc_size)
;                   {
;                       prog.nstate += 1;
;                       break;
;                   }

;                   nfa_state_C s0 = alloc_state(prog, postfix[i - 1], null, null);
;                   if (s0 == null)
;                       return null;
;                   s0.val = n;
;                   st_push(stack, alloc_frag(s0, fr_single(s0.out0)));
;                   break;
;               }

;               case NFA_ZSTART:
;               case NFA_ZEND:
;               default:
;               {
                    ;; Operands.
;                   if (nfa_calc_size)
;                   {
;                       prog.nstate++;
;                       break;
;                   }

;                   nfa_state_C s0 = alloc_state(prog, postfix[i], null, null);
;                   if (s0 == null)
;                       return null;
;                   st_push(stack, alloc_frag(s0, fr_single(s0.out0)));
;                   break;
;               }
;           }
;       }

;       if (nfa_calc_size)
;       {
;           prog.nstate++;
;           return null;  ;; Return value when counting size is ignored anyway.
;       }

;       frag_C e0 = st_pop(stack);
;       if (e0 == null)
;           return st_error(postfix, i, over);
;       if (0 < stack.st_next)
;       {
;           emsg(u8("E875: (NFA regexp) (While converting from postfix to NFA), too many states left on stack"));
;           @rc_did_emsg = true;
;           return null;
;       }

;       if (prog.nstate <= prog.istate)
;       {
;           emsg(u8("E876: (NFA regexp) Not enough space to store the whole NFA"));
;           @rc_did_emsg = true;
;           return null;
;       }

;       nfa_state_C state = @nfa_states[prog.istate++] = §_nfa_state_C();
;       state.c = NFA_MATCH;
;       state.out0(null);
;       state.out1(null);
;       state.id = 0;

;       fr_patch(e0.fr_out, state);
;       return e0.fr_start;
    ))

;; After building the NFA program, inspect it to add optimization hints.

(defn- #_void nfa_postprocess [#_nfa_regprog_C prog]
    (§
;       for (int i = 0; i < prog.nstate; i++)
;       {
;           nfa_state_C state = prog.states[i];
;           if (state == null)
;               continue;

;           int c = state.c;
;           if (c == NFA_START_INVISIBLE
;            || c == NFA_START_INVISIBLE_NEG
;            || c == NFA_START_INVISIBLE_BEFORE
;            || c == NFA_START_INVISIBLE_BEFORE_NEG)
;           {
;               boolean directly;

                ;; Do it directly when what follows is possibly the end of the match.
;               if (match_follows(state.out1().out0(), 0))
;                   directly = true;
;               else
;               {
;                   int ch_invisible = failure_chance(state.out0(), 0);
;                   int ch_follows = failure_chance(state.out1().out0(), 0);

                    ;; Postpone when the invisible match is expensive or has a lower chance of failing.
;                   if (c == NFA_START_INVISIBLE_BEFORE || c == NFA_START_INVISIBLE_BEFORE_NEG)
;                   {
                        ;; "before" matches are very expensive when unbounded,
                        ;; always prefer what follows then, unless what follows will always match.
                        ;; Otherwise strongly prefer what follows.
;                       if (state.val <= 0 && 0 < ch_follows)
;                           directly = false;
;                       else
;                           directly = (ch_follows * 10 < ch_invisible);
;                   }
;                   else
;                   {
                        ;; normal invisible, first do the one with the highest failure chance
;                       directly = (ch_follows < ch_invisible);
;                   }
;               }
;               if (directly)
                    ;; switch to the _FIRST state
;                   state.c++;
;           }
;       }
    ))

;; NFA execution code.

(class! #_final multipos_C
    [
        (field long         start_lnum)
        (field long         end_lnum)
        (field int          start_col)
        (field int          end_col)
    ])

(defn- #_void MIN1_multipos [#_multipos_C mp]
    (§
;       mp.start_lnum = -1;
;       mp.end_lnum = -1;
;       mp.start_col = -1;
;       mp.end_col = -1;
    ))

(defn- #_void COPY_multipos [#_multipos_C mp1, #_multipos_C mp0]
    (§
;       mp1.start_lnum = mp0.start_lnum;
;       mp1.end_lnum = mp0.end_lnum;
;       mp1.start_col = mp0.start_col;
;       mp1.end_col = mp0.end_col;
    ))

(defn- #_multipos_C* ARRAY_multipos [#_int n]
    (vec (repeatedly n §_multipos_C)))

(defn- #_void COPY__multipos [#_multipos_C* a1, #_multipos_C* a0, #_int n]
    (§
;       for (int i = 0; i < n; i++)
;           COPY_multipos(a1[i], a0[i]);
    ))

(class! #_final linepos_C
    [
        (field Bytes        start)
        (field Bytes        end)
    ])

(defn- #_void ZER0_linepos [#_linepos_C lp]
    (§
;       lp.start = null;
;       lp.end = null;
    ))

(defn- #_void COPY_linepos [#_linepos_C lp1, #_linepos_C lp0]
    (§
;       lp1.start = lp0.start;
;       lp1.end = lp0.end;
    ))

(defn- #_linepos_C* ARRAY_linepos [#_int n]
    (vec (repeatedly n §_linepos_C)))

(defn- #_void COPY__linepos [#_linepos_C* a1, #_linepos_C* a0, #_int n]
    (§
;       for (int i = 0; i < n; i++)
;           COPY_linepos(a1[i], a0[i]);
    ))

(class! #_final regsub_C
    [
        (field int          in_use)         ;; number of subexpr with useful info

        (field multipos_C*  rs_multi    (ARRAY_multipos NSUBEXP))   ;; union: when reg_match == null
        (field linepos_C*   rs_line     (ARRAY_linepos NSUBEXP))    ;; union: when reg_match != null
    ])

(defn- #_void COPY_regsub [#_regsub_C rs1, #_regsub_C rs0]
    (§
;       rs1.in_use = rs0.in_use;

;       COPY__multipos(rs1.rs_multi, rs0.rs_multi, NSUBEXP);
;       COPY__linepos(rs1.rs_line, rs0.rs_line, NSUBEXP);
    ))

(class! #_final regsubs_C
    [
        (field regsub_C     rs_norm     (§_regsub_C))   ;; \( .. \) matches
        (field regsub_C     rs_synt     (§_regsub_C))   ;; \z( .. \) matches
    ])

(defn- #_void COPY_regsubs [#_regsubs_C rs1, #_regsubs_C rs0]
    (§
;       COPY_regsub(rs1.rs_norm, rs0.rs_norm);
;       COPY_regsub(rs1.rs_synt, rs0.rs_synt);
    ))

;; nfa_pim_C stores a Postponed Invisible Match.
(class! #_final nfa_pim_C
    [
        (field int          result)         ;; NFA_PIM_*, see below
        (field nfa_state_C  state)          ;; the invisible match start state
        (field regsubs_C    np_subs     (§_regsubs_C))  ;; submatch info, only party used

        (field lpos_C       end_pos     (§_lpos_C))     ;; union upon reg_match: where the match must end
        (field Bytes        end_ptr)        ;; union upon reg_match: where the match must end
    ])

(defn- #_void COPY_nfa_pim [#_nfa_pim_C np1, #_nfa_pim_C np0]
    (§
;       np1.result = np0.result;
;       np1.state = np0.state;
;       COPY_regsubs(np1.np_subs, np0.np_subs);

;       COPY_lpos(np1.end_pos, np0.end_pos);
;       np1.end_ptr = np0.end_ptr;
    ))

;; Values for done in nfa_pim_C.
(final int NFA_PIM_UNUSED   0)      ;; pim not used
(final int NFA_PIM_TODO     1)      ;; pim not done yet
(final int NFA_PIM_MATCH    2)      ;; pim executed, matches
(final int NFA_PIM_NOMATCH  3)      ;; pim executed, no match

;; nfa_thread_C contains execution information of a NFA state
(class! #_final nfa_thread_C
    [
        (field nfa_state_C  state)
        (field int          count)
        (field nfa_pim_C    th_pim      (§_nfa_pim_C))  ;; if pim.result != NFA_PIM_UNUSED: postponed invisible match
        (field regsubs_C    th_subs     (§_regsubs_C))  ;; submatch info, only party used
    ])

(defn- #_void COPY_nfa_thread [#_nfa_thread_C th1, #_nfa_thread_C th0]
    (§
;       th1.state = th0.state;
;       th1.count = th0.count;
;       COPY_nfa_pim(th1.th_pim, th0.th_pim);
;       COPY_regsubs(th1.th_subs, th0.th_subs);
    ))

(defn- #_nfa_thread_C* ARRAY_nfa_thread [#_int n]
    (vec (repeatedly n §_nfa_thread_C)))

;; nfa_list_C contains the alternative NFA execution states.
(class! #_final nfa_list_C
    [
        (field nfa_thread_C*    threads)        ;; allocated array of states
        (field int              n)              ;; nr of states currently in "t"
        (field int              len)            ;; max nr of states in "t"
        (field int              id)             ;; ID of the list
        (field boolean          has_pim)        ;; true when any state has a PIM
    ])

(defn- #_nfa_list_C* ARRAY_nfa_list [#_int n]
    (vec (repeatedly n §_nfa_list_C)))

;; Used during execution: whether a match has been found.
(atom! int nfa_match)
(atom! timeval_C nfa_time_limit)
(atom! int nfa_time_count)

;; Copy postponed invisible match info from "from" to "to".

(defn- #_void copy_pim [#_nfa_pim_C to, #_nfa_pim_C from]
    (§
;       to.result = from.result;
;       to.state = from.state;
;       copy_sub(to.np_subs.rs_norm, from.np_subs.rs_norm);
;       if (@nfa_has_zsubexpr)
;           copy_sub(to.np_subs.rs_synt, from.np_subs.rs_synt);
;       COPY_lpos(to.end_pos, from.end_pos);
;       to.end_ptr = from.end_ptr;
    ))

(defn- #_void clear_sub [#_regsub_C sub]
    (§
;       if (@reg_match == null)
;       {
            ;; Use 0xff to set lnum to -1.
;           for (int i = 0; i < @nfa_nsubexpr; i++)
;               MIN1_multipos(sub.rs_multi[i]);
;       }
;       else
;       {
;           for (int i = 0; i < @nfa_nsubexpr; i++)
;               ZER0_linepos(sub.rs_line[i]);
;       }
;       sub.in_use = 0;
    ))

;; Copy the submatches from "from" to "to".

(defn- #_void copy_sub [#_regsub_C to, #_regsub_C from]
    (§
;       to.in_use = from.in_use;
;       if (0 < from.in_use)
;       {
            ;; Copy the match start and end positions.
;           if (@reg_match == null)
;           {
;               for (int i = 0; i < from.in_use; i++)
;                   COPY_multipos(to.rs_multi[i], from.rs_multi[i]);
;           }
;           else
;           {
;               for (int i = 0; i < from.in_use; i++)
;                   COPY_linepos(to.rs_line[i], from.rs_line[i]);
;           }
;       }
    ))

;; Like copy_sub() but exclude the main match.

(defn- #_void copy_sub_off [#_regsub_C to, #_regsub_C from]
    (§
;       if (to.in_use < from.in_use)
;           to.in_use = from.in_use;
;       if (1 < from.in_use)
;       {
            ;; Copy the match start and end positions.
;           if (@reg_match == null)
;           {
;               for (int i = 1; i < from.in_use; i++)
;                   COPY_multipos(to.rs_multi[i], from.rs_multi[i]);
;           }
;           else
;           {
;               for (int i = 1; i < from.in_use; i++)
;                   COPY_linepos(to.rs_line[i], from.rs_line[i]);
;           }
;       }
    ))

;; Like copy_sub() but only do the end of the main match if \ze is present.

(defn- #_void copy_ze_off [#_regsub_C to, #_regsub_C from]
    (§
;       if (@nfa_has_zend)
;       {
;           if (@reg_match == null)
;           {
;               if (0 <= from.rs_multi[0].end_lnum)
;               {
;                   to.rs_multi[0].end_lnum = from.rs_multi[0].end_lnum;
;                   to.rs_multi[0].end_col = from.rs_multi[0].end_col;
;               }
;           }
;           else
;           {
;               if (from.rs_line[0].end != null)
;                   to.rs_line[0].end = from.rs_line[0].end;
;           }
;       }
    ))

;; Return true if "sub1" and "sub2" have the same start positions.
;; When using back-references also check the end position.

(defn- #_boolean sub_equal [#_regsub_C sub1, #_regsub_C sub2]
    (§
;       int todo = (sub2.in_use < sub1.in_use) ? sub1.in_use : sub2.in_use;

;       if (@reg_match == null)
;       {
;           for (int i = 0; i < todo; i++)
;           {
;               long s1, s2;

;               if (i < sub1.in_use)
;                   s1 = sub1.rs_multi[i].start_lnum;
;               else
;                   s1 = -1;
;               if (i < sub2.in_use)
;                   s2 = sub2.rs_multi[i].start_lnum;
;               else
;                   s2 = -1;
;               if (s1 != s2)
;                   return false;
;               if (s1 != -1 && sub1.rs_multi[i].start_col != sub2.rs_multi[i].start_col)
;                   return false;

;               if (@nfa_has_backref)
;               {
;                   if (i < sub1.in_use)
;                       s1 = sub1.rs_multi[i].end_lnum;
;                   else
;                       s1 = -1;
;                   if (i < sub2.in_use)
;                       s2 = sub2.rs_multi[i].end_lnum;
;                   else
;                       s2 = -1;
;                   if (s1 != s2)
;                       return false;
;                   if (s1 != -1 && sub1.rs_multi[i].end_col != sub2.rs_multi[i].end_col)
;                       return false;
;               }
;           }
;       }
;       else
;       {
;           for (int i = 0; i < todo; i++)
;           {
;               Bytes sp1, sp2;

;               if (i < sub1.in_use)
;                   sp1 = sub1.rs_line[i].start;
;               else
;                   sp1 = null;
;               if (i < sub2.in_use)
;                   sp2 = sub2.rs_line[i].start;
;               else
;                   sp2 = null;
;               if (BNE(sp1, sp2))
;                   return false;
;               if (@nfa_has_backref)
;               {
;                   if (i < sub1.in_use)
;                       sp1 = sub1.rs_line[i].end;
;                   else
;                       sp1 = null;
;                   if (i < sub2.in_use)
;                       sp2 = sub2.rs_line[i].end;
;                   else
;                       sp2 = null;
;                   if (BNE(sp1, sp2))
;                       return false;
;               }
;           }
;       }

;       return true;
    ))

;; Return true if the same state is already in list "nfl" with the same positions as "subs".

(defn- #_boolean has_state_with_pos [#_nfa_list_C nfl, #_nfa_state_C state, #_regsubs_C subs, #_nfa_pim_C pim]
    ;; nfl: runtime state list
    ;; state: state to update
    ;; subs: pointers to subexpressions
    ;; pim: postponed match or null
    (§
;       for (int i = 0; i < nfl.n; i++)
;       {
;           nfa_thread_C thread = nfl.threads[i];

;           if (thread.state.id == state.id
;                   && sub_equal(thread.th_subs.rs_norm, subs.rs_norm)
;                   && (!@nfa_has_zsubexpr || sub_equal(thread.th_subs.rs_synt, subs.rs_synt))
;                   && pim_equal(thread.th_pim, pim))
;               return true;
;       }

;       return false;
    ))

;; Return true if "one" and "two" are equal.  That includes when both are not set.

(defn- #_boolean pim_equal [#_nfa_pim_C one, #_nfa_pim_C two]
    (§
;       boolean one_unused = (one == null || one.result == NFA_PIM_UNUSED);
;       boolean two_unused = (two == null || two.result == NFA_PIM_UNUSED);

;       if (one_unused)
            ;; one is unused: equal when two is also unused
;           return two_unused;
;       if (two_unused)
            ;; one is used and two is not: not equal
;           return false;
        ;; compare the state id
;       if (one.state.id != two.state.id)
;           return false;
        ;; compare the position
;       if (@reg_match == null)
;           return (one.end_pos.lnum == two.end_pos.lnum && one.end_pos.col == two.end_pos.col);

;       return BEQ(one.end_ptr, two.end_ptr);
    ))

;; Return true if "state" leads to a NFA_MATCH without advancing the input.

(defn- #_boolean match_follows [#_nfa_state_C startstate, #_int depth]
    (§
        ;; avoid too much recursion
;       if (10 < depth)
;           return false;

;       for (nfa_state_C state = startstate; state != null; )
;       {
;           switch (state.c)
;           {
;               case NFA_MATCH:
;               case NFA_MCLOSE:
;               case NFA_END_INVISIBLE:
;               case NFA_END_INVISIBLE_NEG:
;               case NFA_END_PATTERN:
;                   return true;

;               case NFA_SPLIT:
;                   return match_follows(state.out0(), depth + 1) || match_follows(state.out1(), depth + 1);

;               case NFA_START_INVISIBLE:
;               case NFA_START_INVISIBLE_FIRST:
;               case NFA_START_INVISIBLE_BEFORE:
;               case NFA_START_INVISIBLE_BEFORE_FIRST:
;               case NFA_START_INVISIBLE_NEG:
;               case NFA_START_INVISIBLE_NEG_FIRST:
;               case NFA_START_INVISIBLE_BEFORE_NEG:
;               case NFA_START_INVISIBLE_BEFORE_NEG_FIRST:
;               case NFA_COMPOSING:
                    ;; skip ahead to next state
;                   state = state.out1().out0();
;                   continue;

;               case NFA_ANY:
;               case NFA_ANY_COMPOSING:
;               case NFA_IDENT:
;               case NFA_SIDENT:
;               case NFA_KWORD:
;               case NFA_SKWORD:
;               case NFA_FNAME:
;               case NFA_SFNAME:
;               case NFA_PRINT:
;               case NFA_SPRINT:
;               case NFA_WHITE:
;               case NFA_NWHITE:
;               case NFA_DIGIT:
;               case NFA_NDIGIT:
;               case NFA_HEX:
;               case NFA_NHEX:
;               case NFA_OCTAL:
;               case NFA_NOCTAL:
;               case NFA_WORD:
;               case NFA_NWORD:
;               case NFA_HEAD:
;               case NFA_NHEAD:
;               case NFA_ALPHA:
;               case NFA_NALPHA:
;               case NFA_LOWER:
;               case NFA_NLOWER:
;               case NFA_UPPER:
;               case NFA_NUPPER:
;               case NFA_LOWER_IC:
;               case NFA_NLOWER_IC:
;               case NFA_UPPER_IC:
;               case NFA_NUPPER_IC:
;               case NFA_START_COLL:
;               case NFA_START_NEG_COLL:
;               case NFA_NEWL:
                    ;; state will advance input
;                   return false;

;               default:
;                   if (0 < state.c)
                        ;; state will advance input
;                       return false;

                    ;; Others: zero-width or possibly zero-width,
                    ;; might still find a match at the same position, keep looking.
;                   break;
;           }
;           state = state.out0();
;       }

;       return false;
    ))

;; Return true if "state" is already in list "nfl".

(defn- #_boolean state_in_list [#_nfa_list_C nfl, #_nfa_state_C state, #_regsubs_C subs]
    ;; nfl: runtime state list
    ;; state: state to update
    ;; subs: pointers to subexpressions
    (§
;       if (state.lastlist[@nfa_ll_index] == nfl.id)
;           if (!@nfa_has_backref || has_state_with_pos(nfl, state, subs, null))
;               return true;

;       return false;
    ))

(atom! regsubs_C temp_subs  (§_regsubs_C))

;; Add "state" and possibly what follows to state list ".".
;; Returns "subs_arg", possibly copied into temp_subs.

(defn- #_regsubs_C addstate [#_nfa_list_C nfl, #_nfa_state_C state, #_regsubs_C subs_arg, #_nfa_pim_C pim, #_int off]
    ;; nfl: runtime state list
    ;; state: state to update
    ;; subs_arg: pointers to subexpressions
    ;; pim: postponed look-behind match
    ;; off: byte offset, when -1 go to next line
    (§
;       regsubs_C subs = subs_arg;

;       switch (state.c)
;       {
;           case NFA_NCLOSE:
;           case NFA_MCLOSE:
;           case NFA_MCLOSE1:
;           case NFA_MCLOSE2:
;           case NFA_MCLOSE3:
;           case NFA_MCLOSE4:
;           case NFA_MCLOSE5:
;           case NFA_MCLOSE6:
;           case NFA_MCLOSE7:
;           case NFA_MCLOSE8:
;           case NFA_MCLOSE9:
;           case NFA_ZCLOSE:
;           case NFA_ZCLOSE1:
;           case NFA_ZCLOSE2:
;           case NFA_ZCLOSE3:
;           case NFA_ZCLOSE4:
;           case NFA_ZCLOSE5:
;           case NFA_ZCLOSE6:
;           case NFA_ZCLOSE7:
;           case NFA_ZCLOSE8:
;           case NFA_ZCLOSE9:
;           case NFA_MOPEN:
;           case NFA_ZEND:
;           case NFA_SPLIT:
;           case NFA_EMPTY:
                ;; These nodes are not added themselves
                ;; but their "out0" and/or "out1" may be added below.
;               break;

;           case NFA_BOL:
;           case NFA_BOF:
                ;; "^" won't match past end-of-line, don't bother trying.
                ;; Except when at the end of the line, or when we are going
                ;; to the next line for a look-behind match.
;               if (BLT(@regline, @reginput)
;                       && @reginput.at(0) != NUL
;                       && (@nfa_endp == null || !(@reg_match == null) || @reglnum == @nfa_endp.se_pos.lnum))
;                   return subs;
                ;; FALLTHROUGH

;           case NFA_MOPEN1:
;           case NFA_MOPEN2:
;           case NFA_MOPEN3:
;           case NFA_MOPEN4:
;           case NFA_MOPEN5:
;           case NFA_MOPEN6:
;           case NFA_MOPEN7:
;           case NFA_MOPEN8:
;           case NFA_MOPEN9:
;           case NFA_ZOPEN:
;           case NFA_ZOPEN1:
;           case NFA_ZOPEN2:
;           case NFA_ZOPEN3:
;           case NFA_ZOPEN4:
;           case NFA_ZOPEN5:
;           case NFA_ZOPEN6:
;           case NFA_ZOPEN7:
;           case NFA_ZOPEN8:
;           case NFA_ZOPEN9:
;           case NFA_NOPEN:
;           case NFA_ZSTART:
                ;; These nodes need to be added so that we can bail out
                ;; when it was added to this list before at the same
                ;; position to avoid an endless loop for "\(\)*"

;           default:
;           {
;               if (state.lastlist[@nfa_ll_index] == nfl.id && state.c != NFA_SKIP)
;               {
                    ;; This state is already in the list, don't add it again,
                    ;; unless it is an MOPEN that is used for a backreference or
                    ;; when there is a PIM.  For NFA_MATCH check the position,
                    ;; lower position is preferred.
;                   if (!@nfa_has_backref && pim == null && !nfl.has_pim && state.c != NFA_MATCH)
;                       return subs;

                    ;; Do not add the state again when it exists with the same positions.
;                   if (has_state_with_pos(nfl, state, subs, pim))
;                       return subs;
;               }

                ;; When there are backreferences or PIMs,
                ;; the number of states may be (a lot) bigger than anticipated.
;               if (nfl.n == nfl.len)
;               {
;                   if (subs != @temp_subs)
;                   {
                        ;; "subs" may point into the current array,
                        ;; need to make a copy before it becomes invalid.
;                       copy_sub(@temp_subs.rs_norm, subs.rs_norm);
;                       if (@nfa_has_zsubexpr)
;                           copy_sub(@temp_subs.rs_synt, subs.rs_synt);
;                       subs = @temp_subs;
;                   }

;                   int newlen = nfl.len * 3 / 2 + 50;
;                   nfa_thread_C[] a = ARRAY_nfa_thread(newlen);
;                   for (int i = 0; i < nfl.n; i++)
;                       COPY_nfa_thread(a[i], nfl.threads[i]);
;                   nfl.threads = a;
;                   nfl.len = newlen;
;               }

                ;; add the state to the list
;               state.lastlist[@nfa_ll_index] = nfl.id;
;               nfa_thread_C thread = nfl.threads[nfl.n++];
;               thread.state = state;
;               if (pim == null)
;                   thread.th_pim.result = NFA_PIM_UNUSED;
;               else
;               {
;                   copy_pim(thread.th_pim, pim);
;                   nfl.has_pim = true;
;               }
;               copy_sub(thread.th_subs.rs_norm, subs.rs_norm);
;               if (@nfa_has_zsubexpr)
;                   copy_sub(thread.th_subs.rs_synt, subs.rs_synt);

;               break;
;           }
;       }

;       switch (state.c)
;       {
;           case NFA_MATCH:
;               break;

;           case NFA_SPLIT:
                ;; order matters here
;               subs = addstate(nfl, state.out0(), subs, pim, off);
;               subs = addstate(nfl, state.out1(), subs, pim, off);
;               break;

;           case NFA_EMPTY:
;           case NFA_NOPEN:
;           case NFA_NCLOSE:
;               subs = addstate(nfl, state.out0(), subs, pim, off);
;               break;

;           case NFA_MOPEN:
;           case NFA_MOPEN1:
;           case NFA_MOPEN2:
;           case NFA_MOPEN3:
;           case NFA_MOPEN4:
;           case NFA_MOPEN5:
;           case NFA_MOPEN6:
;           case NFA_MOPEN7:
;           case NFA_MOPEN8:
;           case NFA_MOPEN9:
;           case NFA_ZOPEN:
;           case NFA_ZOPEN1:
;           case NFA_ZOPEN2:
;           case NFA_ZOPEN3:
;           case NFA_ZOPEN4:
;           case NFA_ZOPEN5:
;           case NFA_ZOPEN6:
;           case NFA_ZOPEN7:
;           case NFA_ZOPEN8:
;           case NFA_ZOPEN9:
;           case NFA_ZSTART:
;           {
;               int subidx;
;               regsub_C sub;
;               if (state.c == NFA_ZSTART)
;               {
;                   subidx = 0;
;                   sub = subs.rs_norm;
;               }
;               else if (NFA_ZOPEN <= state.c && state.c <= NFA_ZOPEN9)
;               {
;                   subidx = state.c - NFA_ZOPEN;
;                   sub = subs.rs_synt;
;               }
;               else
;               {
;                   subidx = state.c - NFA_MOPEN;
;                   sub = subs.rs_norm;
;               }

;               lpos_C save_lpos = §_lpos_C();
;               save_lpos.lnum = 0;
;               save_lpos.col = 0;
;               Bytes save_ptr = null;

;               int save_in_use;
                ;; Set the position (with "off" added) in the subexpression.
                ;; Save and restore it when it was in use.
                ;; Otherwise fill any gap.
;               if (@reg_match == null)
;               {
;                   if (subidx < sub.in_use)
;                   {
;                       save_lpos.lnum = sub.rs_multi[subidx].start_lnum;
;                       save_lpos.col = sub.rs_multi[subidx].start_col;
;                       save_in_use = -1;
;                   }
;                   else
;                   {
;                       save_in_use = sub.in_use;
;                       for (int i = sub.in_use; i < subidx; i++)
;                       {
;                           sub.rs_multi[i].start_lnum = -1;
;                           sub.rs_multi[i].end_lnum = -1;
;                       }
;                       sub.in_use = subidx + 1;
;                   }
;                   if (off == -1)
;                   {
;                       sub.rs_multi[subidx].start_lnum = @reglnum + 1;
;                       sub.rs_multi[subidx].start_col = 0;
;                   }
;                   else
;                   {
;                       sub.rs_multi[subidx].start_lnum = @reglnum;
;                       sub.rs_multi[subidx].start_col = BDIFF(@reginput, @regline) + off;
;                   }
;               }
;               else
;               {
;                   if (subidx < sub.in_use)
;                   {
;                       save_ptr = sub.rs_line[subidx].start;
;                       save_in_use = -1;
;                   }
;                   else
;                   {
;                       save_in_use = sub.in_use;
;                       for (int i = sub.in_use; i < subidx; i++)
;                       {
;                           sub.rs_line[i].start = null;
;                           sub.rs_line[i].end = null;
;                       }
;                       sub.in_use = subidx + 1;
;                   }
;                   sub.rs_line[subidx].start = @reginput.plus(off);
;               }

;               subs = addstate(nfl, state.out0(), subs, pim, off);
                ;; "subs" may have changed, need to set "sub" again
;               if (NFA_ZOPEN <= state.c && state.c <= NFA_ZOPEN9)
;                   sub = subs.rs_synt;
;               else
;                   sub = subs.rs_norm;

;               if (save_in_use == -1)
;               {
;                   if (@reg_match == null)
;                   {
;                       sub.rs_multi[subidx].start_lnum = save_lpos.lnum;
;                       sub.rs_multi[subidx].start_col = save_lpos.col;
;                   }
;                   else
;                       sub.rs_line[subidx].start = save_ptr;
;               }
;               else
;                   sub.in_use = save_in_use;

;               break;
;           }

;           case NFA_MCLOSE:
;               if (@nfa_has_zend && ((@reg_match == null)
;                           ? 0 <= subs.rs_norm.rs_multi[0].end_lnum
;                           : subs.rs_norm.rs_line[0].end != null))
;               {
                    ;; Do not overwrite the position set by \ze.
;                   subs = addstate(nfl, state.out0(), subs, pim, off);
;                   break;
;               }
;           case NFA_MCLOSE1:
;           case NFA_MCLOSE2:
;           case NFA_MCLOSE3:
;           case NFA_MCLOSE4:
;           case NFA_MCLOSE5:
;           case NFA_MCLOSE6:
;           case NFA_MCLOSE7:
;           case NFA_MCLOSE8:
;           case NFA_MCLOSE9:
;           case NFA_ZCLOSE:
;           case NFA_ZCLOSE1:
;           case NFA_ZCLOSE2:
;           case NFA_ZCLOSE3:
;           case NFA_ZCLOSE4:
;           case NFA_ZCLOSE5:
;           case NFA_ZCLOSE6:
;           case NFA_ZCLOSE7:
;           case NFA_ZCLOSE8:
;           case NFA_ZCLOSE9:
;           case NFA_ZEND:
;           {
;               int subidx;
;               regsub_C sub;
;               if (state.c == NFA_ZEND)
;               {
;                   subidx = 0;
;                   sub = subs.rs_norm;
;               }
;               else if (NFA_ZCLOSE <= state.c && state.c <= NFA_ZCLOSE9)
;               {
;                   subidx = state.c - NFA_ZCLOSE;
;                   sub = subs.rs_synt;
;               }
;               else
;               {
;                   subidx = state.c - NFA_MCLOSE;
;                   sub = subs.rs_norm;
;               }

;               lpos_C save_lpos = §_lpos_C();
;               Bytes save_ptr;

                ;; We don't fill in gaps here, there must have been an MOPEN that has done that.
;               int save_in_use = sub.in_use;
;               if (sub.in_use <= subidx)
;                   sub.in_use = subidx + 1;
;               if (@reg_match == null)
;               {
;                   save_lpos.lnum = sub.rs_multi[subidx].end_lnum;
;                   save_lpos.col = sub.rs_multi[subidx].end_col;
;                   if (off == -1)
;                   {
;                       sub.rs_multi[subidx].end_lnum = @reglnum + 1;
;                       sub.rs_multi[subidx].end_col = 0;
;                   }
;                   else
;                   {
;                       sub.rs_multi[subidx].end_lnum = @reglnum;
;                       sub.rs_multi[subidx].end_col = BDIFF(@reginput, @regline) + off;
;                   }
;                   save_ptr = null;
;               }
;               else
;               {
;                   save_ptr = sub.rs_line[subidx].end;
;                   sub.rs_line[subidx].end = @reginput.plus(off);

;                   save_lpos.lnum = 0;
;                   save_lpos.col = 0;
;               }

;               subs = addstate(nfl, state.out0(), subs, pim, off);
                ;; "subs" may have changed, need to set "sub" again
;               if (NFA_ZCLOSE <= state.c && state.c <= NFA_ZCLOSE9)
;                   sub = subs.rs_synt;
;               else
;                   sub = subs.rs_norm;

;               if (@reg_match == null)
;               {
;                   sub.rs_multi[subidx].end_lnum = save_lpos.lnum;
;                   sub.rs_multi[subidx].end_col = save_lpos.col;
;               }
;               else
;                   sub.rs_line[subidx].end = save_ptr;
;               sub.in_use = save_in_use;

;               break;
;           }
;       }

;       return subs;
    ))

;; Like addstate(), but the new state(s) are put at position "*ip".
;; Used for zero-width matches, next state to use is the added one.
;; This makes sure the order of states to be tried does not change,
;; which matters for alternatives.

(defn- #_void addstate_here [#_nfa_list_C nfl, #_nfa_state_C state, #_regsubs_C subs, #_nfa_pim_C pim, #_int* ip]
    ;; nfl: runtime state list
    ;; state: state to update
    ;; subs: pointers to subexpressions
    ;; pim: postponed look-behind match
    (§
;       int tlen = nfl.n;
;       int lidx = ip[0];

        ;; first add the state(s) at the end, so that we know how many there are
;       addstate(nfl, state, subs, pim, 0);

        ;; when "*ip" was at the end of the list, nothing to do
;       if (lidx + 1 == tlen)
;           return;

        ;; re-order to put the new state at the current position
;       int count = nfl.n - tlen;
;       if (count == 0)
;           return; ;; no state got added

;       if (count == 1)
;       {
            ;; overwrite the current state
;           COPY_nfa_thread(nfl.threads[lidx], nfl.threads[nfl.n - 1]);
;       }
;       else if (1 < count)
;       {
;           if (nfl.len <= nfl.n + count - 1)
;           {
                ;; not enough space to move the new states,
                ;; reallocate the list and move the states to the right position
;               int newlen = nfl.len * 3 / 2 + 50;
;               nfa_thread_C[] a = ARRAY_nfa_thread(newlen);
;               for (int i = 0; i < lidx; i++)
;                   COPY_nfa_thread(a[i], nfl.threads[i]);
;               for (int i = 0; i < count; i++)
;                   COPY_nfa_thread(a[lidx + i], nfl.threads[nfl.n - count + i]);
;               for (int i = 0; i < nfl.n - count - lidx - 1; i++)
;                   COPY_nfa_thread(a[lidx + count + i], nfl.threads[lidx + 1 + i]);
;               nfl.threads = a;
;               nfl.len = newlen;
;           }
;           else
;           {
                ;; make space for new states, then move them from the end to the current position
;               for (int i = nfl.n; lidx + 1 <= --i; )
;                   COPY_nfa_thread(nfl.threads[i + count - 1], nfl.threads[i]);
;               for (int i = 0; i < count; i++)
;                   COPY_nfa_thread(nfl.threads[lidx + i], nfl.threads[nfl.n - 1 + i]);
;           }
;       }

;       --nfl.n;
;       ip[0] = lidx - 1;
    ))

;; Check character class "class" against current character c.

(defn- #_boolean check_char_class [#_int klass, #_int c]
    (§
;       switch (klass)
;       {
;           case NFA_CLASS_ALNUM:
;               if (1 <= c && c <= 255 && asc_isalnum(c))
;                   return true;
;               break;

;           case NFA_CLASS_ALPHA:
;               if (1 <= c && c <= 255 && asc_isalpha(c))
;                   return true;
;               break;

;           case NFA_CLASS_BLANK:
;               if (c == ' ' || c == '\t')
;                   return true;
;               break;

;           case NFA_CLASS_CNTRL:
;               if (1 <= c && c <= 255 && asc_iscntrl(c))
;                   return true;
;               break;

;           case NFA_CLASS_DIGIT:
;               if (asc_isdigit(c))
;                   return true;
;               break;

;           case NFA_CLASS_GRAPH:
;               if (1 <= c && c <= 255 && asc_isgraph(c))
;                   return true;
;               break;

;           case NFA_CLASS_LOWER:
;               if (utf_islower(c))
;                   return true;
;               break;

;           case NFA_CLASS_PRINT:
;               if (vim_isprintc(c))
;                   return true;
;               break;

;           case NFA_CLASS_PUNCT:
;               if (1 <= c && c <= 255 && asc_ispunct(c))
;                   return true;
;               break;

;           case NFA_CLASS_SPACE:
;               if ((9 <= c && c <= 13) || (c == ' '))
;                   return true;
;               break;

;           case NFA_CLASS_UPPER:
;               if (utf_isupper(c))
;                   return true;
;               break;

;           case NFA_CLASS_XDIGIT:
;               if (asc_isxdigit(c))
;                   return true;
;               break;

;           case NFA_CLASS_TAB:
;               if (c == '\t')
;                   return true;
;               break;

;           case NFA_CLASS_RETURN:
;               if (c == '\r')
;                   return true;
;               break;

;           case NFA_CLASS_BACKSPACE:
;               if (c == '\b')
;                   return true;
;               break;

;           case NFA_CLASS_ESCAPE:
;               if (c == '\033')
;                   return true;
;               break;

;           default:
                ;; should not be here :P
;               emsgn(e_ill_char_class, (long)klass);
;               return false;
;       }

;       return false;
    ))

;; Check for a match with subexpression "subidx".
;; Return true if it matches.

(defn- #_boolean match_backref [#_regsub_C sub, #_int subidx, #_int* bytelen]
    ;; sub: pointers to subexpressions
    ;; bytelen: out: length of match in bytes
    (§
;       if (sub.in_use <= subidx)
;       {
            ;; backref was not set, match an empty string
;           bytelen[0] = 0;
;           return true;
;       }

;       if (@reg_match == null)
;       {
;           if (sub.rs_multi[subidx].start_lnum < 0 || sub.rs_multi[subidx].end_lnum < 0)
;           {
                ;; backref was not set, match an empty string
;               bytelen[0] = 0;
;               return true;
;           }
;           if (sub.rs_multi[subidx].start_lnum == @reglnum && sub.rs_multi[subidx].end_lnum == @reglnum)
;           {
;               int[] len = { sub.rs_multi[subidx].end_col - sub.rs_multi[subidx].start_col };
;               if (cstrncmp(@regline.plus(sub.rs_multi[subidx].start_col), @reginput, len) == 0)
;               {
;                   bytelen[0] = len[0];
;                   return true;
;               }
;           }
;           else
;           {
;               if (match_with_backref(
;                           sub.rs_multi[subidx].start_lnum,
;                           sub.rs_multi[subidx].start_col,
;                           sub.rs_multi[subidx].end_lnum,
;                           sub.rs_multi[subidx].end_col,
;                           bytelen) == RA_MATCH)
;                   return true;
;           }
;       }
;       else
;       {
;           if (sub.rs_line[subidx].start == null || sub.rs_line[subidx].end == null)
;           {
                ;; backref was not set, match an empty string
;               bytelen[0] = 0;
;               return true;
;           }
;           int[] len = { BDIFF(sub.rs_line[subidx].end, sub.rs_line[subidx].start) };
;           if (cstrncmp(sub.rs_line[subidx].start, @reginput, len) == 0)
;           {
;               bytelen[0] = len[0];
;               return true;
;           }
;       }

;       return false;
    ))

;; Check for a match with \z subexpression "subidx".
;; Return true if it matches.

(defn- #_boolean match_zref [#_int subidx, #_int* bytelen]
    ;; bytelen: out: length of match in bytes
    (§
;       cleanup_zsubexpr();

;       if (@re_extmatch_in == null || @re_extmatch_in.matches[subidx] == null)
;       {
            ;; backref was not set, match an empty string
;           bytelen[0] = 0;
;           return true;
;       }

;       int[] len = { STRLEN(@re_extmatch_in.matches[subidx]) };
;       if (cstrncmp(@re_extmatch_in.matches[subidx], @reginput, len) == 0)
;       {
;           bytelen[0] = len[0];
;           return true;
;       }

;       return false;
    ))

;; Save list IDs for all NFA states of "prog" into "list".
;; Also reset the IDs to zero.
;; Only used for the recursive value lastlist[1].

(defn- #_void nfa_save_listids [#_nfa_regprog_C prog, #_int* list]
    (§
        ;; Order in the list is reverse, it's a bit faster that way.
;       for (int i = 0, n = prog.nstate; 0 <= --n; i++)
;       {
;           nfa_state_C state = prog.states[i];
;           if (state == null)
;           {
;               list[n] = 0;
;               continue;
;           }

;           list[n] = state.lastlist[1];
;           state.lastlist[1] = 0;
;       }
    ))

;; Restore list IDs from "list" to all NFA states.

(defn- #_void nfa_restore_listids [#_nfa_regprog_C prog, #_int* list]
    (§
;       for (int i = 0, n = prog.nstate; 0 <= --n; i++)
;       {
;           nfa_state_C state = prog.states[i];
;           if (state == null)
;               continue;

;           state.lastlist[1] = list[n];
;       }
    ))

(defn- #_boolean nfa_re_num_cmp [#_long val, #_int op, #_long pos]
    (§
;       if (op == 1)
;           return (val < pos);
;       if (op == 2)
;           return (pos < val);

;       return (val == pos);
    ))

;; Recursively call nfa_regmatch()
;; "pim" is null or contains info about a Postponed Invisible Match (start position).

(defn- #_int recursive_regmatch [#_nfa_state_C state, #_nfa_pim_C pim, #_nfa_regprog_C prog, #_regsubs_C submatch, #_regsubs_C m, #_int** listids]
    (§
;       int save_reginput_col = BDIFF(@reginput, @regline);
;       long save_reglnum = @reglnum;
;       int save_nfa_match = @nfa_match;
;       int save_nfa_listid = @nfa_listid;
;       save_se_C save_nfa_endp = @nfa_endp;
;       save_se_C endpos = §_save_se_C();
;       save_se_C endposp = null;
;       boolean need_restore = false;

;       if (pim != null)
;       {
            ;; start at the position where the postponed match was
;           if (@reg_match == null)
;               @reginput = @regline.plus(pim.end_pos.col);
;           else
;               @reginput = pim.end_ptr;
;       }

;       if (state.c == NFA_START_INVISIBLE_BEFORE
;        || state.c == NFA_START_INVISIBLE_BEFORE_FIRST
;        || state.c == NFA_START_INVISIBLE_BEFORE_NEG
;        || state.c == NFA_START_INVISIBLE_BEFORE_NEG_FIRST)
;       {
            ;; The recursive match must end at the current position.
            ;; When "pim" is not null it specifies the current position.
;           endposp = endpos;
;           if (@reg_match == null)
;           {
;               if (pim == null)
;               {
;                   endpos.se_pos.col = BDIFF(@reginput, @regline);
;                   endpos.se_pos.lnum = @reglnum;
;               }
;               else
;                   COPY_lpos(endpos.se_pos, pim.end_pos);
;           }
;           else
;           {
;               if (pim == null)
;                   endpos.se_ptr = @reginput;
;               else
;                   endpos.se_ptr = pim.end_ptr;
;           }

            ;; Go back the specified number of bytes, or as far as the start of
            ;; the previous line, to try matching "\@<=" or not matching "\@<!".
            ;; This is very inefficient, limit the number of bytes if possible.

;           if (state.val <= 0)
;           {
;               if (@reg_match == null)
;               {
;                   @regline = reg_getline(--@reglnum);
;                   if (@regline == null)
                        ;; can't go before the first line
;                       @regline = reg_getline(++@reglnum);
;               }
;               @reginput = @regline;
;           }
;           else
;           {
;               if (@reg_match == null && BDIFF(@reginput, @regline) < state.val)
;               {
                    ;; Not enough bytes in this line, go to end of previous line.
;                   @regline = reg_getline(--@reglnum);
;                   if (@regline == null)
;                   {
                        ;; can't go before the first line
;                       @regline = reg_getline(++@reglnum);
;                       @reginput = @regline;
;                   }
;                   else
;                       @reginput = @regline.plus(STRLEN(@regline));
;               }
;               if (state.val <= BDIFF(@reginput, @regline))
;               {
;                   @reginput = @reginput.minus(state.val);
;                   @reginput = @reginput.minus(us_head_off(@regline, @reginput));
;               }
;               else
;                   @reginput = @regline;
;           }
;       }

        ;; Have to clear the lastlist field of the NFA nodes, so that
        ;; nfa_regmatch() and addstate() can run properly after recursion.
;       if (@nfa_ll_index == 1)
;       {
            ;; Already calling nfa_regmatch() recursively.
            ;; Save the lastlist[1] values and clear them.
;           if (listids[0] == null)
;               listids[0] = new int[prog.nstate];
;           nfa_save_listids(prog, listids[0]);
;           need_restore = true;
            ;; any value of nfa_listid will do
;       }
;       else
;       {
            ;; First recursive nfa_regmatch() call, switch to the second lastlist entry.
            ;; Make sure nfa_listid is different from a previous recursive call,
            ;; because some states may still have this ID.
;           @nfa_ll_index++;
;           if (@nfa_listid <= @nfa_alt_listid)
;               @nfa_listid = @nfa_alt_listid;
;       }

        ;; Call nfa_regmatch() to check if the current concat matches at this position.
        ;; The concat ends with the node NFA_END_INVISIBLE.
;       @nfa_endp = endposp;
;       int result = nfa_regmatch(prog, state.out0(), submatch, m);

;       if (need_restore)
;           nfa_restore_listids(prog, listids[0]);
;       else
;       {
;           --@nfa_ll_index;
;           @nfa_alt_listid = @nfa_listid;
;       }

        ;; restore position in input text
;       @reglnum = save_reglnum;
;       if (@reg_match == null)
;           @regline = reg_getline(@reglnum);
;       @reginput = @regline.plus(save_reginput_col);
;       @nfa_match = save_nfa_match;
;       @nfa_endp = save_nfa_endp;
;       @nfa_listid = save_nfa_listid;

;       return result;
    ))

;; Estimate the chance of a match with "state" failing.
;; empty match: 0
;; NFA_ANY: 1
;; specific character: 99

(defn- #_int failure_chance [#_nfa_state_C state, #_int depth]
    (§
        ;; detect looping
;       if (4 < depth)
;           return 1;

;       int c = state.c;

;       switch (c)
;       {
;           case NFA_SPLIT:
;           {
;               if (state.out0().c == NFA_SPLIT || state.out1().c == NFA_SPLIT)
                    ;; avoid recursive stuff
;                   return 1;

                ;; two alternatives, use the lowest failure chance
;               int l = failure_chance(state.out0(), depth + 1);
;               int r = failure_chance(state.out1(), depth + 1);
;               return (l < r) ? l : r;
;           }

;           case NFA_ANY:
                ;; matches anything, unlikely to fail
;               return 1;

;           case NFA_MATCH:
;           case NFA_MCLOSE:
;           case NFA_ANY_COMPOSING:
                ;; empty match works always
;               return 0;

;           case NFA_START_INVISIBLE:
;           case NFA_START_INVISIBLE_FIRST:
;           case NFA_START_INVISIBLE_NEG:
;           case NFA_START_INVISIBLE_NEG_FIRST:
;           case NFA_START_INVISIBLE_BEFORE:
;           case NFA_START_INVISIBLE_BEFORE_FIRST:
;           case NFA_START_INVISIBLE_BEFORE_NEG:
;           case NFA_START_INVISIBLE_BEFORE_NEG_FIRST:
;           case NFA_START_PATTERN:
                ;; recursive regmatch is expensive, use low failure chance
;               return 5;

;           case NFA_BOL:
;           case NFA_EOL:
;           case NFA_BOF:
;           case NFA_EOF:
;           case NFA_NEWL:
;               return 99;

;           case NFA_BOW:
;           case NFA_EOW:
;               return 90;

;           case NFA_MOPEN:
;           case NFA_MOPEN1:
;           case NFA_MOPEN2:
;           case NFA_MOPEN3:
;           case NFA_MOPEN4:
;           case NFA_MOPEN5:
;           case NFA_MOPEN6:
;           case NFA_MOPEN7:
;           case NFA_MOPEN8:
;           case NFA_MOPEN9:
;           case NFA_ZOPEN:
;           case NFA_ZOPEN1:
;           case NFA_ZOPEN2:
;           case NFA_ZOPEN3:
;           case NFA_ZOPEN4:
;           case NFA_ZOPEN5:
;           case NFA_ZOPEN6:
;           case NFA_ZOPEN7:
;           case NFA_ZOPEN8:
;           case NFA_ZOPEN9:
;           case NFA_ZCLOSE:
;           case NFA_ZCLOSE1:
;           case NFA_ZCLOSE2:
;           case NFA_ZCLOSE3:
;           case NFA_ZCLOSE4:
;           case NFA_ZCLOSE5:
;           case NFA_ZCLOSE6:
;           case NFA_ZCLOSE7:
;           case NFA_ZCLOSE8:
;           case NFA_ZCLOSE9:
;           case NFA_NOPEN:
;           case NFA_MCLOSE1:
;           case NFA_MCLOSE2:
;           case NFA_MCLOSE3:
;           case NFA_MCLOSE4:
;           case NFA_MCLOSE5:
;           case NFA_MCLOSE6:
;           case NFA_MCLOSE7:
;           case NFA_MCLOSE8:
;           case NFA_MCLOSE9:
;           case NFA_NCLOSE:
;               return failure_chance(state.out0(), depth + 1);

;           case NFA_BACKREF1:
;           case NFA_BACKREF2:
;           case NFA_BACKREF3:
;           case NFA_BACKREF4:
;           case NFA_BACKREF5:
;           case NFA_BACKREF6:
;           case NFA_BACKREF7:
;           case NFA_BACKREF8:
;           case NFA_BACKREF9:
;           case NFA_ZREF1:
;           case NFA_ZREF2:
;           case NFA_ZREF3:
;           case NFA_ZREF4:
;           case NFA_ZREF5:
;           case NFA_ZREF6:
;           case NFA_ZREF7:
;           case NFA_ZREF8:
;           case NFA_ZREF9:
                ;; backreferences don't match in many places
;               return 94;

;           case NFA_LNUM_GT:
;           case NFA_LNUM_LT:
;           case NFA_COL_GT:
;           case NFA_COL_LT:
;           case NFA_VCOL_GT:
;           case NFA_VCOL_LT:
;           case NFA_MARK_GT:
;           case NFA_MARK_LT:
;           case NFA_VISUAL:
                ;; before/after positions don't match very often
;               return 85;

;           case NFA_LNUM:
;               return 90;

;           case NFA_CURSOR:
;           case NFA_COL:
;           case NFA_VCOL:
;           case NFA_MARK:
                ;; specific positions rarely match
;               return 98;

;           case NFA_COMPOSING:
;               return 95;

;           default:
;               if (0 < c)
                    ;; character match fails often
;                   return 95;
;       }

        ;; something else, includes character classes
;       return 50;
    ))

;; Skip until the char "c" we know a match must start with.

(defn- #_boolean skip_to_start [#_int c, #_int* colp]
    (§
        ;; Used often, do some work to avoid call overhead.
;       Bytes s = cstrchr(@regline.plus(colp[0]), c);
;       if (s == null)
;           return false;

;       colp[0] = BDIFF(s, @regline);
;       return true;
    ))

;; Check for a match with match_text.
;; Called after skip_to_start() has found regstart.
;; Returns zero for no match, 1 for a match.

(defn- #_long find_match_text [#_int startcol, #_int regstart, #_Bytes match_text]
    (§
;       for (int[] col = { startcol }; ; )
;       {
;           boolean match = true;
;           int len2 = utf_char2len(regstart);                      ;; skip regstart

;           int c1, c2;
;           for (int len1 = 0; match_text.at(len1) != NUL; len1 += utf_char2len(c1))
;           {
;               c1 = us_ptr2char(match_text.plus(len1));
;               c2 = us_ptr2char(@regline.plus(col[0] + len2));
;               if (c1 != c2 && (!@ireg_ic || utf_tolower(c1) != utf_tolower(c2)))
;               {
;                   match = false;
;                   break;
;               }
;               len2 += utf_char2len(c2);
;           }

            ;; check that no composing char follows
;           if (match && !utf_iscomposing(us_ptr2char(@regline.plus(col[0] + len2))))
;           {
;               cleanup_subexpr();
;               if (@reg_match == null)
;               {
;                   @reg_startpos[0].lnum = @reglnum;
;                   @reg_startpos[0].col = col[0];
;                   @reg_endpos[0].lnum = @reglnum;
;                   @reg_endpos[0].col = col[0] + len2;
;               }
;               else
;               {
;                   @reg_startp[0] = @regline.plus(col[0]);
;                   @reg_endp[0] = @regline.plus(col[0] + len2);
;               }
;               return 1L;
;           }

            ;; Try finding regstart after the current match.
;           col[0] += utf_char2len(regstart);                          ;; skip regstart
;           if (skip_to_start(regstart, col) == false)
;               break;
;       }

;       return 0L;
    ))

;; Main matching routine.
;;
;; Run NFA to determine whether it matches reginput.
;;
;; When "nfa_endp" is not null it is a required end-of-match position.
;;
;; Return true if there is a match, false otherwise.
;; When there is a match "submatch" contains the positions.
;; Note: Caller must ensure that: start != null.

(defn- #_int nfa_regmatch [#_nfa_regprog_C prog, #_nfa_state_C start, #_regsubs_C submatch, #_regsubs_C m]
    (§
;       boolean toplevel = (start.c == NFA_MOPEN);

        ;; Some patterns may take a long time to match, especially when using recursive_regmatch().
        ;; Allow interrupting them with CTRL-C.
;       fast_breakcheck();
;       if (@got_int)
;           return FALSE;
;       if (@nfa_time_limit != null && profile_passed_limit(@nfa_time_limit))
;           return FALSE;

;       @nfa_match = FALSE;

;       nfa_list_C[] list = ARRAY_nfa_list(2);
;       list[0].threads = ARRAY_nfa_thread(list[0].len = prog.nstate + 1);
;       list[1].threads = ARRAY_nfa_thread(list[1].len = prog.nstate + 1);

;       nfa_list_C thislist = list[0];
;       thislist.n = 0;
;       thislist.has_pim = false;
;       nfa_list_C nextlist = list[1];
;       nextlist.n = 0;
;       nextlist.has_pim = false;
;       thislist.id = @nfa_listid + 1;

        ;; Inline optimized code for addstate(thislist, start, m, 0) if we know it's the first MOPEN.
;       if (toplevel)
;       {
;           if (@reg_match == null)
;           {
;               m.rs_norm.rs_multi[0].start_lnum = @reglnum;
;               m.rs_norm.rs_multi[0].start_col = BDIFF(@reginput, @regline);
;           }
;           else
;               m.rs_norm.rs_line[0].start = @reginput;
;           m.rs_norm.in_use = 1;
;           addstate(thislist, start.out0(), m, null, 0);
;       }
;       else
;           addstate(thislist, start, m, null, 0);

;       boolean go_to_nextline = false;
;       int flag = 0;
;       int[][] listids = { null };
;       int add_off = 0;

        ;; Run for each character.

;       for ( ; ; )
;       {
;           int curc = us_ptr2char(@reginput);
;           int clen = us_ptr2len_cc(@reginput);
;           if (curc == NUL)
;           {
;               clen = 0;
;               go_to_nextline = false;
;           }

            ;; swap lists
;           thislist = list[flag];
;           nextlist = list[flag ^= 1];
;           nextlist.n = 0;                 ;; clear nextlist
;           nextlist.has_pim = false;
;           @nfa_listid++;
;           if (prog.re_engine == AUTOMATIC_ENGINE && NFA_MAX_STATES <= @nfa_listid)
;           {
                ;; too many states, retry with old engine
;               @nfa_match = NFA_TOO_EXPENSIVE;
;               return @nfa_match;
;           }

;           thislist.id = @nfa_listid;
;           nextlist.id = @nfa_listid + 1;

            ;; If the state lists are empty we can stop.

;           if (thislist.n == 0)
;               break;

;           nextchar:
;           {
                ;; compute nextlist
;               for (int[] lidx = { 0 }; lidx[0] < thislist.n; lidx[0]++)
;               {
;                   nfa_thread_C thread = thislist.threads[lidx[0]];

                    ;; Handle the possible codes of the current state.
                    ;; The most important is NFA_MATCH.

;                   nfa_state_C add_state = null;
;                   boolean add_here = false;
;                   int add_count = 0;

;                   switch (thread.state.c)
;                   {
;                       case NFA_MATCH:
;                       {
                            ;; If the match ends before a composing characters and
                            ;; ireg_icombine is not set, that is not really a match.
;                           if (!@ireg_icombine && utf_iscomposing(curc))
;                               break;
;                           @nfa_match = TRUE;
;                           copy_sub(submatch.rs_norm, thread.th_subs.rs_norm);
;                           if (@nfa_has_zsubexpr)
;                               copy_sub(submatch.rs_synt, thread.th_subs.rs_synt);
                            ;; Found the left-most longest match, do not look at any other states
                            ;; at this position.  When the list of states is going to be empty
                            ;; quit without advancing, so that "reginput" is correct.
;                           if (nextlist.n == 0)
;                               clen = 0;
;                           break nextchar;
;                       }

;                       case NFA_END_INVISIBLE:
;                       case NFA_END_INVISIBLE_NEG:
;                       case NFA_END_PATTERN:
;                       {
                            ;; This is only encountered after a NFA_START_INVISIBLE or
                            ;; NFA_START_INVISIBLE_BEFORE node.
                            ;; They surround a zero-width group, used with "\@=", "\&",
                            ;; "\@!", "\@<=" and "\@<!".
                            ;; If we got here, it means that the current "invisible" group
                            ;; finished successfully, so return control to the parent
                            ;; nfa_regmatch().  For a look-behind match only when it ends
                            ;; in the position in "nfa_endp".
                            ;; Submatches are stored in *m, and used in the parent call.

                            ;; If "nfa_endp" is set it's only a match if it ends at "nfa_endp".
;                           if (@nfa_endp != null && ((@reg_match == null)
;                                   ? (@reglnum != @nfa_endp.se_pos.lnum
;                                       || BDIFF(@reginput, @regline) != @nfa_endp.se_pos.col)
;                                   : BNE(@reginput, @nfa_endp.se_ptr)))
;                               break;

                            ;; do not set submatches for \@!
;                           if (thread.state.c != NFA_END_INVISIBLE_NEG)
;                           {
;                               copy_sub(m.rs_norm, thread.th_subs.rs_norm);
;                               if (@nfa_has_zsubexpr)
;                                   copy_sub(m.rs_synt, thread.th_subs.rs_synt);
;                           }
;                           @nfa_match = TRUE;
                            ;; See comment above at "goto nextchar".
;                           if (nextlist.n == 0)
;                               clen = 0;
;                           break nextchar;
;                       }

;                       case NFA_START_INVISIBLE:
;                       case NFA_START_INVISIBLE_FIRST:
;                       case NFA_START_INVISIBLE_NEG:
;                       case NFA_START_INVISIBLE_NEG_FIRST:
;                       case NFA_START_INVISIBLE_BEFORE:
;                       case NFA_START_INVISIBLE_BEFORE_FIRST:
;                       case NFA_START_INVISIBLE_BEFORE_NEG:
;                       case NFA_START_INVISIBLE_BEFORE_NEG_FIRST:
;                       {
                            ;; Do it directly if there already is a PIM or when
                            ;; nfa_postprocess() detected it will work better.
;                           if (thread.th_pim.result != NFA_PIM_UNUSED
;                               || thread.state.c == NFA_START_INVISIBLE_FIRST
;                               || thread.state.c == NFA_START_INVISIBLE_NEG_FIRST
;                               || thread.state.c == NFA_START_INVISIBLE_BEFORE_FIRST
;                               || thread.state.c == NFA_START_INVISIBLE_BEFORE_NEG_FIRST)
;                           {
;                               int in_use = m.rs_norm.in_use;

                                ;; Copy submatch info for the recursive call,
                                ;; opposite of what happens on success below.
;                               copy_sub_off(m.rs_norm, thread.th_subs.rs_norm);
;                               if (@nfa_has_zsubexpr)
;                                   copy_sub_off(m.rs_synt, thread.th_subs.rs_synt);

                                ;; First try matching the invisible match, then what follows.

;                               int result = recursive_regmatch(thread.state, null, prog, submatch, m, listids);
;                               if (result == NFA_TOO_EXPENSIVE)
;                               {
;                                   @nfa_match = result;
;                                   return @nfa_match;
;                               }

                                ;; for \@! and \@<! it is a match when the result is false
;                               if ((result != FALSE) != (thread.state.c == NFA_START_INVISIBLE_NEG
;                                   || thread.state.c == NFA_START_INVISIBLE_NEG_FIRST
;                                   || thread.state.c == NFA_START_INVISIBLE_BEFORE_NEG
;                                   || thread.state.c == NFA_START_INVISIBLE_BEFORE_NEG_FIRST))
;                               {
                                    ;; Copy submatch info from the recursive call.
;                                   copy_sub_off(thread.th_subs.rs_norm, m.rs_norm);
;                                   if (@nfa_has_zsubexpr)
;                                       copy_sub_off(thread.th_subs.rs_synt, m.rs_synt);
                                    ;; If the pattern has \ze and it matched in the sub pattern, use it.
;                                   copy_ze_off(thread.th_subs.rs_norm, m.rs_norm);

                                    ;; thread.state.out1 is the corresponding END_INVISIBLE node.
                                    ;; Add its out0 to the current list (zero-width match).
;                                   add_here = true;
;                                   add_state = thread.state.out1().out0();
;                               }
;                               m.rs_norm.in_use = in_use;
;                           }
;                           else
;                           {
;                               nfa_pim_C pim = §_nfa_pim_C();

                                ;; First try matching what follows.  Only if a match
                                ;; is found verify the invisible match matches.  Add a
                                ;; nfa_pim_C to the following states, it contains info
                                ;; about the invisible match.

;                               pim.state = thread.state;
;                               pim.result = NFA_PIM_TODO;
;                               pim.np_subs.rs_norm.in_use = 0;
;                               pim.np_subs.rs_synt.in_use = 0;
;                               if (@reg_match == null)
;                               {
;                                   pim.end_pos.col = BDIFF(@reginput, @regline);
;                                   pim.end_pos.lnum = @reglnum;
;                               }
;                               else
;                                   pim.end_ptr = @reginput;

                                ;; thread.state.out1 is the corresponding END_INVISIBLE node.
                                ;; Add its out0 to the current list (zero-width match).
;                               addstate_here(thislist, thread.state.out1().out0(), thread.th_subs, pim, lidx);
;                           }
;                           break;
;                       }

;                       case NFA_START_PATTERN:
;                       {
;                           nfa_state_C skip = null;

                            ;; There is no point in trying to match the pattern
                            ;; if the output state is not going to be added to the list.
;                           if (state_in_list(nextlist, thread.state.out1().out0(), thread.th_subs))
;                           {
;                               skip = thread.state.out1().out0();
;                           }
;                           else if (state_in_list(nextlist, thread.state.out1().out0().out0(), thread.th_subs))
;                           {
;                               skip = thread.state.out1().out0().out0();
;                           }
;                           else if (state_in_list(thislist, thread.state.out1().out0().out0(), thread.th_subs))
;                           {
;                               skip = thread.state.out1().out0().out0();
;                           }

;                           if (skip != null)
;                               break;

                            ;; Copy submatch info to the recursive call, opposite of what happens afterwards.
;                           copy_sub_off(m.rs_norm, thread.th_subs.rs_norm);
;                           if (@nfa_has_zsubexpr)
;                               copy_sub_off(m.rs_synt, thread.th_subs.rs_synt);

                            ;; First try matching the pattern.
;                           int result = recursive_regmatch(thread.state, null, prog, submatch, m, listids);
;                           if (result == NFA_TOO_EXPENSIVE)
;                           {
;                               @nfa_match = result;
;                               return @nfa_match;
;                           }
;                           if (result != FALSE)
;                           {
;                               int bytelen;

                                ;; Copy submatch info from the recursive call.
;                               copy_sub_off(thread.th_subs.rs_norm, m.rs_norm);
;                               if (@nfa_has_zsubexpr)
;                                   copy_sub_off(thread.th_subs.rs_synt, m.rs_synt);
                                ;; Now we need to skip over the matched text and
                                ;; then continue with what follows.
;                               if (@reg_match == null)
                                    ;; TODO: multi-line match
;                                   bytelen = m.rs_norm.rs_multi[0].end_col - BDIFF(@reginput, @regline);
;                               else
;                                   bytelen = BDIFF(m.rs_norm.rs_line[0].end, @reginput);

;                               if (bytelen == 0)
;                               {
                                    ;; Empty match: output of corresponding NFA_END_PATTERN/NFA_SKIP
                                    ;; to be used at current position.
;                                   add_here = true;
;                                   add_state = thread.state.out1().out0().out0();
;                               }
;                               else if (bytelen <= clen)
;                               {
                                    ;; Match current character, output of corresponding
                                    ;; NFA_END_PATTERN to be used at next position.
;                                   add_state = thread.state.out1().out0().out0();
;                                   add_off = clen;
;                               }
;                               else
;                               {
                                    ;; Skip over the matched characters, set character count in NFA_SKIP.
;                                   add_state = thread.state.out1().out0();
;                                   add_off = bytelen;
;                                   add_count = bytelen - clen;
;                               }
;                           }
;                           break;
;                       }

;                       case NFA_BOL:
;                           if (BEQ(@reginput, @regline))
;                           {
;                               add_here = true;
;                               add_state = thread.state.out0();
;                           }
;                           break;

;                       case NFA_EOL:
;                           if (curc == NUL)
;                           {
;                               add_here = true;
;                               add_state = thread.state.out0();
;                           }
;                           break;

;                       case NFA_BOW:
;                       {
;                           boolean result = true;
;                           if (curc == NUL)
;                               result = false;
;                           else
;                           {
;                               int this_class;

                                ;; Get class of current and previous char (if it exists).
;                               this_class = us_get_class(@reginput, @reg_buf);
;                               if (this_class <= 1)
;                                   result = false;
;                               else if (reg_prev_class() == this_class)
;                                   result = false;
;                           }
;                           if (result)
;                           {
;                               add_here = true;
;                               add_state = thread.state.out0();
;                           }
;                           break;
;                       }

;                       case NFA_EOW:
;                       {
;                           boolean result = true;
;                           if (BEQ(@reginput, @regline))
;                               result = false;
;                           else
;                           {
;                               int this_class, prev_class;

                                ;; Get class of current and previous char (if it exists).
;                               this_class = us_get_class(@reginput, @reg_buf);
;                               prev_class = reg_prev_class();
;                               if (this_class == prev_class || prev_class == 0 || prev_class == 1)
;                                   result = false;
;                           }
;                           if (result)
;                           {
;                               add_here = true;
;                               add_state = thread.state.out0();
;                           }
;                           break;
;                       }

;                       case NFA_BOF:
;                           if (@reglnum == 0 && BEQ(@reginput, @regline) && (@reg_match != null || @reg_firstlnum == 1))
;                           {
;                               add_here = true;
;                               add_state = thread.state.out0();
;                           }
;                           break;

;                       case NFA_EOF:
;                           if (@reglnum == @reg_maxline && curc == NUL)
;                           {
;                               add_here = true;
;                               add_state = thread.state.out0();
;                           }
;                           break;

;                       case NFA_COMPOSING:
;                       {
;                           int mc = curc;
;                           int[] cchars = new int[MAX_MCO];
;                           int ccount = 0;

;                           nfa_state_C sta = thread.state.out0();
;                           int len = 0;
;                           if (utf_iscomposing(sta.c))
;                           {
                                ;; Only match composing character(s), ignore base character.
                                ;; Used for ".{composing}" and "{composing}" (no preceding character).
;                               len += utf_char2len(mc);
;                           }

;                           boolean result;
;                           if (@ireg_icombine && len == 0)
;                           {
                                ;; If \Z was present, then ignore composing characters.
                                ;; When ignoring the base character this always matches.
;                               if (len == 0 && sta.c != curc)
;                                   result = false;
;                               else
;                                   result = true;
;                               while (sta.c != NFA_END_COMPOSING)
;                                   sta = sta.out0();
;                           }
                            ;; Check base character matches first, unless ignored.
;                           else if (0 < len || mc == sta.c)
;                           {
;                               if (len == 0)
;                               {
;                                   len += utf_char2len(mc);
;                                   sta = sta.out0();
;                               }

                                ;; We don't care about the order of composing characters.
                                ;; Get them into cchars[] first.
;                               while (len < clen)
;                               {
;                                   mc = us_ptr2char(@reginput.plus(len));
;                                   cchars[ccount++] = mc;
;                                   len += utf_char2len(mc);
;                                   if (ccount == MAX_MCO)
;                                       break;
;                               }

                                ;; Check that each composing char in the pattern matches
                                ;; a composing char in the text.
                                ;; We do not check if all composing chars are matched.
;                               result = true;
;                               while (sta.c != NFA_END_COMPOSING)
;                               {
;                                   int j;
;                                   for (j = 0; j < ccount; j++)
;                                       if (cchars[j] == sta.c)
;                                           break;
;                                   if (j == ccount)
;                                   {
;                                       result = false;
;                                       break;
;                                   }
;                                   sta = sta.out0();
;                               }
;                           }
;                           else
;                               result = false;

;                           nfa_state_C end = thread.state.out1();    ;; NFA_END_COMPOSING

;                           if (result)
;                           {
;                               add_state = end.out0();
;                               add_off = clen;
;                           }
;                           break;
;                       }

;                       case NFA_NEWL:
;                       {
;                           if (curc == NUL && !@reg_line_lbr && @reg_match == null && @reglnum <= @reg_maxline)
;                           {
;                               go_to_nextline = true;
                                ;; Pass -1 for the offset, which means
                                ;; taking the position at the start of the next line.
;                               add_state = thread.state.out0();
;                               add_off = -1;
;                           }
;                           else if (curc == '\n' && @reg_line_lbr)
;                           {
                                ;; match \n as if it is an ordinary character
;                               add_state = thread.state.out0();
;                               add_off = 1;
;                           }
;                           break;
;                       }

;                       case NFA_START_COLL:
;                       case NFA_START_NEG_COLL:
;                       {
                            ;; What follows is a list of characters, until NFA_END_COLL.
                            ;; One of them must match or none of them must match.

                            ;; Never match EOL.
                            ;; If it's part of the collection it is added as a separate state with an OR.
;                           if (curc == NUL)
;                               break;

;                           boolean result_if_matched = (thread.state.c == NFA_START_COLL);

;                           boolean result = false;	// %% anno dunno
;                           for (nfa_state_C state = thread.state.out0(); ; state = state.out0())
;                           {
;                               if (state.c == NFA_END_COLL)
;                               {
;                                   result = !result_if_matched;
;                                   break;
;                               }
;                               if (state.c == NFA_RANGE_MIN)
;                               {
;                                   int c1 = state.val;
;                                   state = state.out0(); ;; advance to NFA_RANGE_MAX
;                                   int c2 = state.val;
;                                   if (c1 <= curc && curc <= c2)
;                                   {
;                                       result = result_if_matched;
;                                       break;
;                                   }
;                                   if (@ireg_ic)
;                                   {
;                                       int curc_low = utf_tolower(curc);
;                                       boolean done = false;

;                                       for ( ; c1 <= c2; ++c1)
;                                           if (utf_tolower(c1) == curc_low)
;                                           {
;                                               result = result_if_matched;
;                                               done = true;
;                                               break;
;                                           }
;                                       if (done)
;                                           break;
;                                   }
;                               }
;                               else if (state.c < 0 ? check_char_class(state.c, curc) : (curc == state.c || (@ireg_ic && utf_tolower(curc) == utf_tolower(state.c))))
;                               {
;                                   result = result_if_matched;
;                                   break;
;                               }
;                           }
;                           if (result)
;                           {
                                ;; next state is in out of the NFA_END_COLL,
                                ;; out1 of START points to the END state
;                               add_state = thread.state.out1().out0();
;                               add_off = clen;
;                           }
;                           break;
;                       }

;                       case NFA_ANY:
                            ;; Any char except NUL, (end of input) does not match.
;                           if (0 < curc)
;                           {
;                               add_state = thread.state.out0();
;                               add_off = clen;
;                           }
;                           break;

;                       case NFA_ANY_COMPOSING:
                            ;; On a composing character skip over it.
                            ;; Otherwise do nothing.
                            ;; Always matches.
;                           if (utf_iscomposing(curc))
;                           {
;                               add_off = clen;
;                           }
;                           else
;                           {
;                               add_here = true;
;                               add_off = 0;
;                           }
;                           add_state = thread.state.out0();
;                           break;

                        ;; Character classes like \a for alpha, \d for digit etc.

;                       case NFA_IDENT:     ;;  \i
;                       {
;                           boolean result = vim_isIDc(curc);
;                           if (result)
;                           {
;                               add_state = thread.state.out0();
;                               add_off = clen;
;                           }
;                           break;
;                       }

;                       case NFA_SIDENT:    ;;  \I
;                       {
;                           boolean result = !asc_isdigit(curc) && vim_isIDc(curc);
;                           if (result)
;                           {
;                               add_state = thread.state.out0();
;                               add_off = clen;
;                           }
;                           break;
;                       }

;                       case NFA_KWORD:     ;;  \k
;                       {
;                           boolean result = us_iswordp(@reginput, @reg_buf);
;                           if (result)
;                           {
;                               add_state = thread.state.out0();
;                               add_off = clen;
;                           }
;                           break;
;                       }

;                       case NFA_SKWORD:    ;;  \K
;                       {
;                           boolean result = !asc_isdigit(curc) && us_iswordp(@reginput, @reg_buf);
;                           if (result)
;                           {
;                               add_state = thread.state.out0();
;                               add_off = clen;
;                           }
;                           break;
;                       }

;                       case NFA_FNAME:     ;;  \f
;                       {
;                           boolean result = vim_isfilec(curc);
;                           if (result)
;                           {
;                               add_state = thread.state.out0();
;                               add_off = clen;
;                           }
;                           break;
;                       }

;                       case NFA_SFNAME:    ;;  \F
;                       {
;                           boolean result = !asc_isdigit(curc) && vim_isfilec(curc);
;                           if (result)
;                           {
;                               add_state = thread.state.out0();
;                               add_off = clen;
;                           }
;                           break;
;                       }

;                       case NFA_PRINT:     ;;  \p
;                       {
;                           boolean result = vim_isprintc(us_ptr2char(@reginput));
;                           if (result)
;                           {
;                               add_state = thread.state.out0();
;                               add_off = clen;
;                           }
;                           break;
;                       }

;                       case NFA_SPRINT:    ;;  \P
;                       {
;                           boolean result = !asc_isdigit(curc) && vim_isprintc(us_ptr2char(@reginput));
;                           if (result)
;                           {
;                               add_state = thread.state.out0();
;                               add_off = clen;
;                           }
;                           break;
;                       }

;                       case NFA_WHITE:     ;;  \s
;                       {
;                           boolean result = vim_iswhite(curc);
;                           if (result)
;                           {
;                               add_state = thread.state.out0();
;                               add_off = clen;
;                           }
;                           break;
;                       }

;                       case NFA_NWHITE:    ;;  \S
;                       {
;                           boolean result = (curc != NUL) && !vim_iswhite(curc);
;                           if (result)
;                           {
;                               add_state = thread.state.out0();
;                               add_off = clen;
;                           }
;                           break;
;                       }

;                       case NFA_DIGIT:     ;;  \d
;                       {
;                           boolean result = ri_digit(curc);
;                           if (result)
;                           {
;                               add_state = thread.state.out0();
;                               add_off = clen;
;                           }
;                           break;
;                       }

;                       case NFA_NDIGIT:    ;;  \D
;                       {
;                           boolean result = (curc != NUL) && !ri_digit(curc);
;                           if (result)
;                           {
;                               add_state = thread.state.out0();
;                               add_off = clen;
;                           }
;                           break;
;                       }

;                       case NFA_HEX:       ;;  \x
;                       {
;                           boolean result = ri_hex(curc);
;                           if (result)
;                           {
;                               add_state = thread.state.out0();
;                               add_off = clen;
;                           }
;                           break;
;                       }

;                       case NFA_NHEX:      ;;  \X
;                       {
;                           boolean result = (curc != NUL) && !ri_hex(curc);
;                           if (result)
;                           {
;                               add_state = thread.state.out0();
;                               add_off = clen;
;                           }
;                           break;
;                       }

;                       case NFA_OCTAL:     ;;  \o
;                       {
;                           boolean result = ri_octal(curc);
;                           if (result)
;                           {
;                               add_state = thread.state.out0();
;                               add_off = clen;
;                           }
;                           break;
;                       }

;                       case NFA_NOCTAL:    ;;  \O
;                       {
;                           boolean result = (curc != NUL) && !ri_octal(curc);
;                           if (result)
;                           {
;                               add_state = thread.state.out0();
;                               add_off = clen;
;                           }
;                           break;
;                       }

;                       case NFA_WORD:      ;;  \w
;                       {
;                           boolean result = ri_word(curc);
;                           if (result)
;                           {
;                               add_state = thread.state.out0();
;                               add_off = clen;
;                           }
;                           break;
;                       }

;                       case NFA_NWORD:     ;;  \W
;                       {
;                           boolean result = (curc != NUL) && !ri_word(curc);
;                           if (result)
;                           {
;                               add_state = thread.state.out0();
;                               add_off = clen;
;                           }
;                           break;
;                       }

;                       case NFA_HEAD:      ;;  \h
;                       {
;                           boolean result = ri_head(curc);
;                           if (result)
;                           {
;                               add_state = thread.state.out0();
;                               add_off = clen;
;                           }
;                           break;
;                       }

;                       case NFA_NHEAD:     ;;  \H
;                       {
;                           boolean result = (curc != NUL) && !ri_head(curc);
;                           if (result)
;                           {
;                               add_state = thread.state.out0();
;                               add_off = clen;
;                           }
;                           break;
;                       }

;                       case NFA_ALPHA:     ;;  \a
;                       {
;                           boolean result = ri_alpha(curc);
;                           if (result)
;                           {
;                               add_state = thread.state.out0();
;                               add_off = clen;
;                           }
;                           break;
;                       }

;                       case NFA_NALPHA:    ;;  \A
;                       {
;                           boolean result = (curc != NUL) && !ri_alpha(curc);
;                           if (result)
;                           {
;                               add_state = thread.state.out0();
;                               add_off = clen;
;                           }
;                           break;
;                       }

;                       case NFA_LOWER:     ;;  \l
;                       {
;                           boolean result = ri_lower(curc);
;                           if (result)
;                           {
;                               add_state = thread.state.out0();
;                               add_off = clen;
;                           }
;                           break;
;                       }

;                       case NFA_NLOWER:    ;;  \L
;                       {
;                           boolean result = (curc != NUL) && !ri_lower(curc);
;                           if (result)
;                           {
;                               add_state = thread.state.out0();
;                               add_off = clen;
;                           }
;                           break;
;                       }

;                       case NFA_UPPER:     ;;  \\u (sic!)
;                       {
;                           boolean result = ri_upper(curc);
;                           if (result)
;                           {
;                               add_state = thread.state.out0();
;                               add_off = clen;
;                           }
;                           break;
;                       }

;                       case NFA_NUPPER:    ;;  \U
;                       {
;                           boolean result = (curc != NUL) && !ri_upper(curc);
;                           if (result)
;                           {
;                               add_state = thread.state.out0();
;                               add_off = clen;
;                           }
;                           break;
;                       }

;                       case NFA_LOWER_IC:  ;; [a-z]
;                       {
;                           boolean result = ri_lower(curc) || (@ireg_ic && ri_upper(curc));
;                           if (result)
;                           {
;                               add_state = thread.state.out0();
;                               add_off = clen;
;                           }
;                           break;
;                       }

;                       case NFA_NLOWER_IC: ;; [^a-z]
;                       {
;                           boolean result = (curc != NUL) && !(ri_lower(curc) || (@ireg_ic && ri_upper(curc)));
;                           if (result)
;                           {
;                               add_state = thread.state.out0();
;                               add_off = clen;
;                           }
;                           break;
;                       }

;                       case NFA_UPPER_IC:  ;; [A-Z]
;                       {
;                           boolean result = ri_upper(curc) || (@ireg_ic && ri_lower(curc));
;                           if (result)
;                           {
;                               add_state = thread.state.out0();
;                               add_off = clen;
;                           }
;                           break;
;                       }

;                       case NFA_NUPPER_IC: ;; ^[A-Z]
;                       {
;                           boolean result = (curc != NUL) && !(ri_upper(curc) || (@ireg_ic && ri_lower(curc)));
;                           if (result)
;                           {
;                               add_state = thread.state.out0();
;                               add_off = clen;
;                           }
;                           break;
;                       }

;                       case NFA_BACKREF1:
;                       case NFA_BACKREF2:
;                       case NFA_BACKREF3:
;                       case NFA_BACKREF4:
;                       case NFA_BACKREF5:
;                       case NFA_BACKREF6:
;                       case NFA_BACKREF7:
;                       case NFA_BACKREF8:
;                       case NFA_BACKREF9:
;                       case NFA_ZREF1:
;                       case NFA_ZREF2:
;                       case NFA_ZREF3:
;                       case NFA_ZREF4:
;                       case NFA_ZREF5:
;                       case NFA_ZREF6:
;                       case NFA_ZREF7:
;                       case NFA_ZREF8:
;                       case NFA_ZREF9: ;; \1 .. \9  \z1 .. \z9
;                       {
;                           int subidx;
;                           int[] bytelen = new int[1];

;                           boolean result;
;                           if (thread.state.c <= NFA_BACKREF9)
;                           {
;                               subidx = thread.state.c - NFA_BACKREF1 + 1;
;                               result = match_backref(thread.th_subs.rs_norm, subidx, bytelen);
;                           }
;                           else
;                           {
;                               subidx = thread.state.c - NFA_ZREF1 + 1;
;                               result = match_zref(subidx, bytelen);
;                           }

;                           if (result)
;                           {
;                               if (bytelen[0] == 0)
;                               {
                                    ;; Empty match always works, output of NFA_SKIP to be used next.
;                                   add_here = true;
;                                   add_state = thread.state.out0().out0();
;                               }
;                               else if (bytelen[0] <= clen)
;                               {
                                    ;; Match current character, jump ahead to out of NFA_SKIP.
;                                   add_state = thread.state.out0().out0();
;                                   add_off = clen;
;                               }
;                               else
;                               {
                                    ;; Skip over the matched characters, set character count in NFA_SKIP.
;                                   add_state = thread.state.out0();
;                                   add_off = bytelen[0];
;                                   add_count = bytelen[0] - clen;
;                               }
;                           }
;                           break;
;                       }

;                       case NFA_SKIP:
;                       {
                            ;; character of previous matching \1 .. \9  or \@>
;                           if (thread.count - clen <= 0)
;                           {
                                ;; end of match, go to what follows
;                               add_state = thread.state.out0();
;                               add_off = clen;
;                           }
;                           else
;                           {
                                ;; add state again with decremented count
;                               add_state = thread.state;
;                               add_off = 0;
;                               add_count = thread.count - clen;
;                           }
;                           break;
;                       }

;                       case NFA_LNUM:
;                       case NFA_LNUM_GT:
;                       case NFA_LNUM_LT:
;                       {
;                           boolean result = (@reg_match == null
;                               && nfa_re_num_cmp(thread.state.val, thread.state.c - NFA_LNUM,
;                                           @reglnum + @reg_firstlnum));
;                           if (result)
;                           {
;                               add_here = true;
;                               add_state = thread.state.out0();
;                           }
;                           break;
;                       }

;                       case NFA_COL:
;                       case NFA_COL_GT:
;                       case NFA_COL_LT:
;                       {
;                           boolean result = nfa_re_num_cmp(thread.state.val, thread.state.c - NFA_COL,
;                                                   BDIFF(@reginput, @regline) + 1);
;                           if (result)
;                           {
;                               add_here = true;
;                               add_state = thread.state.out0();
;                           }
;                           break;
;                       }

;                       case NFA_VCOL:
;                       case NFA_VCOL_GT:
;                       case NFA_VCOL_LT:
;                       {
;                           int op = thread.state.c - NFA_VCOL;
;                           int col = BDIFF(@reginput, @regline);
;                           window_C wp = (@reg_win == null) ? @curwin : @reg_win;

                            ;; Bail out quickly when there can't be a match,
                            ;; avoid the overhead of win_linetabsize() on long lines.
;                           if (op != 1 && thread.state.val * MB_MAXBYTES < col)
;                               break;

;                           boolean result = false;
;                           if (op == 1 && thread.state.val < col - 1 && 100 < col)
;                           {
;                               int ts = (int)wp.w_buffer.@b_p_ts;

                                ;; Guess that a character won't use more columns than 'tabstop',
                                ;; with a minimum of 4.
;                               if (ts < 4)
;                                   ts = 4;
;                               result = (thread.state.val * ts < col);
;                           }
;                           if (!result)
;                               result = nfa_re_num_cmp(thread.state.val, op, (long)win_linetabsize(wp, @regline, col) + 1);
;                           if (result)
;                           {
;                               add_here = true;
;                               add_state = thread.state.out0();
;                           }
;                           break;
;                       }

;                       case NFA_MARK:
;                       case NFA_MARK_GT:
;                       case NFA_MARK_LT:
;                       {
;                           pos_C pos = getmark_buf(@reg_buf, thread.state.val, false);

                            ;; Compare the mark position to the match position.
;                           boolean result = (pos != null           ;; mark doesn't exist
;                                   && 0 < pos.lnum                 ;; mark isn't set in reg_buf
;                                   && (pos.lnum == @reglnum + @reg_firstlnum
;                                           ? (pos.col == BDIFF(@reginput, @regline)
;                                               ? thread.state.c == NFA_MARK
;                                               : (pos.col < BDIFF(@reginput, @regline)
;                                                   ? thread.state.c == NFA_MARK_GT
;                                                   : thread.state.c == NFA_MARK_LT))
;                                           : (pos.lnum < @reglnum + @reg_firstlnum
;                                               ? thread.state.c == NFA_MARK_GT
;                                               : thread.state.c == NFA_MARK_LT)));
;                           if (result)
;                           {
;                               add_here = true;
;                               add_state = thread.state.out0();
;                           }
;                           break;
;                       }

;                       case NFA_CURSOR:
;                       {
;                           boolean result = (@reg_win != null
;                                   && @reglnum + @reg_firstlnum == @reg_win.w_cursor.lnum
;                                   && BDIFF(@reginput, @regline) == @reg_win.w_cursor.col);
;                           if (result)
;                           {
;                               add_here = true;
;                               add_state = thread.state.out0();
;                           }
;                           break;
;                       }

;                       case NFA_VISUAL:
;                       {
;                           boolean result = reg_match_visual();
;                           if (result)
;                           {
;                               add_here = true;
;                               add_state = thread.state.out0();
;                           }
;                           break;
;                       }

;                       case NFA_MOPEN1:
;                       case NFA_MOPEN2:
;                       case NFA_MOPEN3:
;                       case NFA_MOPEN4:
;                       case NFA_MOPEN5:
;                       case NFA_MOPEN6:
;                       case NFA_MOPEN7:
;                       case NFA_MOPEN8:
;                       case NFA_MOPEN9:
;                       case NFA_ZOPEN:
;                       case NFA_ZOPEN1:
;                       case NFA_ZOPEN2:
;                       case NFA_ZOPEN3:
;                       case NFA_ZOPEN4:
;                       case NFA_ZOPEN5:
;                       case NFA_ZOPEN6:
;                       case NFA_ZOPEN7:
;                       case NFA_ZOPEN8:
;                       case NFA_ZOPEN9:
;                       case NFA_NOPEN:
;                       case NFA_ZSTART:
                            ;; These states are only added to be able to bail out when
                            ;; they are added again, nothing is to be done.
;                           break;

;                       default:    ;; regular character
;                       {
;                           int c = thread.state.c;

;                           boolean result = (c == curc);
;                           if (!result && @ireg_ic)
;                               result = (utf_tolower(c) == utf_tolower(curc));

                            ;; If ireg_icombine is not set only skip over the character itself.
                            ;; When it is set skip over composing characters.
;                           if (result && !@ireg_icombine)
;                               clen = utf_char2len(curc);

;                           if (result)
;                           {
;                               add_state = thread.state.out0();
;                               add_off = clen;
;                           }
;                           break;
;                       }
;                   }

;                   if (add_state != null)
;                   {
;                       nfa_pim_C pim = (thread.th_pim.result != NFA_PIM_UNUSED) ? thread.th_pim : null;

                        ;; Handle the postponed invisible match if the match might end
                        ;; without advancing and before the end of the line.
;                       if (pim != null && (clen == 0 || match_follows(add_state, 0)))
;                       {
;                           int result;
;                           if (pim.result == NFA_PIM_TODO)
;                           {
;                               result = recursive_regmatch(pim.state, pim, prog, submatch, m, listids);
;                               pim.result = (result != FALSE) ? NFA_PIM_MATCH : NFA_PIM_NOMATCH;
                                ;; for \@! and \@<! it is a match when the result is false
;                               if ((result != FALSE) != (pim.state.c == NFA_START_INVISIBLE_NEG
;                                           || pim.state.c == NFA_START_INVISIBLE_NEG_FIRST
;                                           || pim.state.c == NFA_START_INVISIBLE_BEFORE_NEG
;                                           || pim.state.c == NFA_START_INVISIBLE_BEFORE_NEG_FIRST))
;                               {
                                    ;; Copy submatch info from the recursive call.
;                                   copy_sub_off(pim.np_subs.rs_norm, m.rs_norm);
;                                   if (@nfa_has_zsubexpr)
;                                       copy_sub_off(pim.np_subs.rs_synt, m.rs_synt);
;                               }
;                           }
;                           else
;                           {
;                               result = (pim.result == NFA_PIM_MATCH) ? TRUE : FALSE;
;                           }

                            ;; for \@! and \@<! it is a match when result is false
;                           if ((result != FALSE) != (pim.state.c == NFA_START_INVISIBLE_NEG
;                                       || pim.state.c == NFA_START_INVISIBLE_NEG_FIRST
;                                       || pim.state.c == NFA_START_INVISIBLE_BEFORE_NEG
;                                       || pim.state.c == NFA_START_INVISIBLE_BEFORE_NEG_FIRST))
;                           {
                                ;; Copy submatch info from the recursive call.
;                               copy_sub_off(thread.th_subs.rs_norm, pim.np_subs.rs_norm);
;                               if (@nfa_has_zsubexpr)
;                                   copy_sub_off(thread.th_subs.rs_synt, pim.np_subs.rs_synt);
;                           }
;                           else
;                           {
                                ;; look-behind match failed, don't add the state
;                               continue;
;                           }

                            ;; Postponed invisible match was handled, don't add it to following states.
;                           pim = null;
;                       }

;                       nfa_pim_C pim_copy = §_nfa_pim_C();

                        ;; If "pim" points into nfl.threads,
                        ;; it will become invalid when adding the state causes the list to be reallocated.
                        ;; Make a local copy to avoid that.
;                       if (pim == thread.th_pim)
;                       {
;                           copy_pim(pim_copy, pim);
;                           pim = pim_copy;
;                       }

;                       if (add_here)
;                           addstate_here(thislist, add_state, thread.th_subs, pim, lidx);
;                       else
;                       {
;                           addstate(nextlist, add_state, thread.th_subs, pim, add_off);
;                           if (0 < add_count)
;                               nextlist.threads[nextlist.n - 1].count = add_count;
;                       }
;                   }
;               }

                ;; Look for the start of a match in the current position
                ;; by adding the start state to the list of states.
                ;; The first found match is the leftmost one, thus the order of states matters!
                ;; Do not add the start state in recursive calls of nfa_regmatch(),
                ;; because recursive calls should only start in the first position.
                ;; Unless "nfa_endp" is not null, then we match the end position.
                ;; Also don't start a match past the first line.
;               if (@nfa_match == FALSE
;                       && ((toplevel
;                               && @reglnum == 0
;                               && clen != 0
;                               && (@ireg_maxcol == 0 || BDIFF(@reginput, @regline) < @ireg_maxcol))
;                           || (@nfa_endp != null
;                               && ((@reg_match == null)
;                                   ? (@reglnum < @nfa_endp.se_pos.lnum
;                                   || (@reglnum == @nfa_endp.se_pos.lnum
;                                       && BDIFF(@reginput, @regline) < @nfa_endp.se_pos.col))
;                                   : BLT(@reginput, @nfa_endp.se_ptr)))))
;               {
                    ;; Inline optimized code for addstate() if we know the state is the first MOPEN.
;                   if (toplevel)
;                   {
;                       boolean add = true;

;                       if (prog.regstart != NUL && clen != 0)
;                       {
;                           if (nextlist.n == 0)
;                           {
;                               int[] col = { BDIFF(@reginput, @regline) + clen };

                                ;; Nextlist is empty, we can skip ahead to the
                                ;; character that must appear at the start.
;                               if (skip_to_start(prog.regstart, col) == false)
;                                   break;
;                               @reginput = @regline.plus(col[0] - clen);
;                           }
;                           else
;                           {
                                ;; Checking if the required start character matches is
                                ;; cheaper than adding a state that won't match.
;                               int c = us_ptr2char(@reginput.plus(clen));
;                               if (c != prog.regstart
;                                   && (!@ireg_ic || utf_tolower(c) != utf_tolower(prog.regstart)))
;                               {
;                                   add = false;
;                               }
;                           }
;                       }

;                       if (add)
;                       {
;                           if (@reg_match == null)
;                               m.rs_norm.rs_multi[0].start_col = BDIFF(@reginput, @regline) + clen;
;                           else
;                               m.rs_norm.rs_line[0].start = @reginput.plus(clen);
;                           addstate(nextlist, start.out0(), m, null, clen);
;                       }
;                   }
;                   else
;                       addstate(nextlist, start, m, null, clen);
;               }
;           }

            ;; Advance to the next character, or advance to the next line, or finish.
;           if (clen != 0)
;               @reginput = @reginput.plus(clen);
;           else if (go_to_nextline || (@nfa_endp != null && @reg_match == null && @reglnum < @nfa_endp.se_pos.lnum))
;               reg_nextline();
;           else
;               break;

            ;; Allow interrupting with CTRL-C.
;           line_breakcheck();
;           if (@got_int)
;               break;

            ;; Check for timeout once in a twenty times to avoid overhead.
;           if (@nfa_time_limit != null && ++@nfa_time_count == 20)
;           {
;               @nfa_time_count = 0;
;               if (profile_passed_limit(@nfa_time_limit))
;                   break;
;           }
;       }

;       return @nfa_match;
    ))

;; Try match of "prog" with at regline[col].
;; Returns <= 0 for failure, number of lines contained in the match otherwise.

(defn- #_long nfa_regtry [#_nfa_regprog_C prog, #_int col, #_timeval_C tm]
    ;; tm: timeout limit or null
    (§
;       regsubs_C subs = §_regsubs_C();
;       regsubs_C m = §_regsubs_C();
;       nfa_state_C start = prog.start;

;       @reginput = @regline.plus(col);
;       @nfa_time_limit = tm;
;       @nfa_time_count = 0;

;       clear_sub(subs.rs_norm);
;       clear_sub(m.rs_norm);
;       clear_sub(subs.rs_synt);
;       clear_sub(m.rs_synt);

;       int result = nfa_regmatch(prog, start, subs, m);
;       if (result == FALSE)
;           return 0;
;       else if (result == NFA_TOO_EXPENSIVE)
;           return result;

;       cleanup_subexpr();
;       if (@reg_match == null)
;       {
;           for (int i = 0; i < subs.rs_norm.in_use; i++)
;           {
;               @reg_startpos[i].lnum = subs.rs_norm.rs_multi[i].start_lnum;
;               @reg_startpos[i].col = subs.rs_norm.rs_multi[i].start_col;

;               @reg_endpos[i].lnum = subs.rs_norm.rs_multi[i].end_lnum;
;               @reg_endpos[i].col = subs.rs_norm.rs_multi[i].end_col;
;           }

;           if (@reg_startpos[0].lnum < 0)
;           {
;               @reg_startpos[0].lnum = 0;
;               @reg_startpos[0].col = col;
;           }
;           if (@reg_endpos[0].lnum < 0)
;           {
                ;; pattern has a \ze but it didn't match, use current end
;               @reg_endpos[0].lnum = @reglnum;
;               @reg_endpos[0].col = BDIFF(@reginput, @regline);
;           }
;           else
                ;; Use line number of "\ze".
;               @reglnum = @reg_endpos[0].lnum;
;       }
;       else
;       {
;           for (int i = 0; i < subs.rs_norm.in_use; i++)
;           {
;               @reg_startp[i] = subs.rs_norm.rs_line[i].start;
;               @reg_endp[i] = subs.rs_norm.rs_line[i].end;
;           }

;           if (@reg_startp[0] == null)
;               @reg_startp[0] = @regline.plus(col);
;           if (@reg_endp[0] == null)
;               @reg_endp[0] = @reginput;
;       }

        ;; Package any found \z(...\) matches for export.  Default is none.
;       @re_extmatch_out = null;

;       if (prog.reghasz == REX_SET)
;       {
;           cleanup_zsubexpr();
;           @re_extmatch_out = make_extmatch();
;           for (int i = 0; i < subs.rs_synt.in_use; i++)
;           {
;               if (@reg_match == null)
;               {
;                   multipos_C mp = subs.rs_synt.rs_multi[i];

                    ;; Only accept single line matches that are valid.
;                   if (0 <= mp.start_lnum && mp.start_lnum == mp.end_lnum && mp.start_col <= mp.end_col)
;                       @re_extmatch_out.matches[i] = STRNDUP(reg_getline(mp.start_lnum).plus(mp.start_col), mp.end_col - mp.start_col);
;               }
;               else
;               {
;                   linepos_C lp = subs.rs_synt.rs_line[i];

;                   if (lp.start != null && lp.end != null)
;                       @re_extmatch_out.matches[i] = STRNDUP(lp.start, BDIFF(lp.end, lp.start));
;               }
;           }
;       }

;       return 1 + @reglnum;
    ))

;; Match a regexp against
;;  a string ("line" points to the string)
;;  or multiple lines ("line" is null, use reg_getline()).
;;
;; Returns <= 0 for failure, number of lines contained in the match otherwise.

(defn- #_long nfa_regexec_both [#_Bytes line, #_int startcol, #_timeval_C tm]
    ;; startcol: column to start looking for match
    ;; tm: timeout limit or null
    (§
;       int[] col = { startcol };

;       nfa_regprog_C prog;
;       if (@reg_match == null)
;       {
;           prog = (nfa_regprog_C)@reg_mmatch.regprog;
;           line = reg_getline(0);              ;; relative to the cursor
;           @reg_startpos = @reg_mmatch.startpos;
;           @reg_endpos = @reg_mmatch.endpos;
;       }
;       else
;       {
;           prog = (nfa_regprog_C)@reg_match.regprog;
;           @reg_startp = @reg_match.startp;
;           @reg_endp = @reg_match.endp;
;       }

        ;; Be paranoid...
;       if (prog == null || line == null)
;       {
;           emsg(e_null);
;           return 0L;
;       }

        ;; If pattern contains "\c" or "\C": overrule value of ireg_ic.
;       if ((prog.regflags & RF_ICASE) != 0)
;           @ireg_ic = true;
;       else if ((prog.regflags & RF_NOICASE) != 0)
;           @ireg_ic = false;

        ;; If pattern contains "\Z" overrule value of ireg_icombine.
;       if ((prog.regflags & RF_ICOMBINE) != 0)
;           @ireg_icombine = true;

;       @regline = line;
;       @reglnum = 0;    ;; relative to line

;       @nfa_has_zend = prog.has_zend;
;       @nfa_has_backref = prog.has_backref;
;       @nfa_nsubexpr = prog.nsubexp;
;       @nfa_listid = 1;
;       @nfa_alt_listid = 2;
;       nfa_regengine.expr = prog.pattern;

;       if (prog.reganch != 0 && 0 < col[0])
;           return 0L;

;       @need_clear_subexpr = true;
        ;; Clear the external match subpointers if necessary.
;       if (prog.reghasz == REX_SET)
;       {
;           @nfa_has_zsubexpr = true;
;           @need_clear_zsubexpr = true;
;       }
;       else
;           @nfa_has_zsubexpr = false;

;       if (prog.regstart != NUL)
;       {
            ;; Skip ahead until a character we know the match must start with.
            ;; When there is none there is no match.
;           if (skip_to_start(prog.regstart, col) == false)
;               return 0L;

            ;; If match_text is set, it contains the full text that must match.
            ;; Nothing else to try.  Doesn't handle combining chars well.
;           if (prog.match_text != null && !@ireg_icombine)
;               return find_match_text(col[0], prog.regstart, prog.match_text);
;       }

        ;; If the start column is past the maximum column: no need to try.
;       if (0 < @ireg_maxcol && @ireg_maxcol <= col[0])
;           return 0L;

;       for (int i = 0; i < prog.nstate; i++)
;       {
;           nfa_state_C state = prog.states[i];
;           if (state == null)
;               continue;

;           state.id = i;
;           state.lastlist[0] = 0;
;           state.lastlist[1] = 0;
;       }

;       long retval = nfa_regtry(prog, col[0], tm);

;       nfa_regengine.expr = null;

;       return retval;
    ))

;; Compile a regular expression into internal code for the NFA matcher.
;; Returns the program in allocated space.  Returns null for an error.

(defn- #_regprog_C nfa_regcomp [#_Bytes expr, #_int re_flags]
    (§
;       if (expr == null)
;           return null;

;       nfa_regprog_C prog;

;       nfa_regengine.expr = expr;
;       @nfa_re_flags = re_flags;

;       init_class_tab();

;       nfa_regcomp_start(expr, re_flags);

;       theend:
;       {
;           fail:
;           {
                ;; Build postfix form of the regexp.  Needed to build the NFA (and count its size).
;               int[] postfix = re2post();
;               if (postfix == null)
;               {
                    ;; TODO: only give this error for debugging?
;                   if (@post_array.length <= @post_index)
;                       emsgn(u8("Internal error: estimated max number of states insufficient: %d"), @post_array.length);
;                   break fail;         ;; cascaded (syntax?) error
;               }

                ;; In order to build the NFA, we parse the input regexp twice:
                ;; 1. first pass to count size (so we can allocate space)
                ;; 2. second to emit code

;               prog = new nfa_regprog_C();
;               prog.nstate = 0;

                ;; PASS 1
                ;; Count number of NFA states in "prog.nstate".  Do not build the NFA.

;               post2nfa(postfix, @post_index, prog, true);

                ;; allocate space for the compiled regexp
;               @nfa_states = prog.states = new nfa_state_C[prog.nstate];
;               prog.istate = 0;

                ;; PASS 2
                ;; Build the NFA

;               prog.start = post2nfa(postfix, @post_index, prog, false);
;               if (prog.start == null)
;                   break fail;

;               prog.regflags = @regflags;
;               prog.engine = nfa_regengine;
;               prog.has_zend = @nfa_has_zend;
;               prog.has_backref = @nfa_has_backref;
;               prog.nsubexp = @regnpar;

;               nfa_postprocess(prog);

;               prog.reganch = nfa_get_reganch(prog.start, 0) ? 1 : 0;
;               prog.regstart = nfa_get_regstart(prog.start, 0);
;               prog.match_text = nfa_get_match_text(prog.start);

                ;; Remember whether this pattern has any \z specials in it.
;               prog.reghasz = @re_has_z;
;               prog.pattern = STRDUP(expr);
;               nfa_regengine.expr = null;
;               break theend;
;           }

;           prog = null;
;           nfa_regengine.expr = null;
;       }

;       @post_array = null;
;       @post_index = 0;
;       @nfa_states = null;

;       return (regprog_C)prog;
    ))

;; Match a regexp against a string.
;; "rmp.regprog" is a compiled regexp as returned by nfa_regcomp().
;; Uses curbuf for line count and 'iskeyword'.
;; If "line_lbr" is true, consider a "\n" in "line" to be a line break.
;;
;; Returns <= 0 for failure, number of lines contained in the match otherwise.

(defn- #_long nfa_regexec_nl [#_regmatch_C rmp, #_Bytes line, #_int col, #_boolean line_lbr]
    ;; line: string to match against
    ;; col: column to start looking for match
    (§
;       @reg_match = rmp;
;       @reg_mmatch = null;
;       @reg_maxline = 0;
;       @reg_line_lbr = line_lbr;
;       @reg_buf = @curbuf;
;       @reg_win = null;
;       @ireg_ic = rmp.rm_ic;
;       @ireg_icombine = false;
;       @ireg_maxcol = 0;

;       return nfa_regexec_both(line, col, null);
    ))

;; Match a regexp against multiple lines.
;; "rmp.regprog" is a compiled regexp as returned by vim_regcomp().
;; Uses curbuf for line count and 'iskeyword'.
;;
;; Return <= 0 if there is no match.  Return number of lines contained in the match otherwise.
;;
;; Note: the body is the same as bt_regexec() except for nfa_regexec_both()
;;
;; ! Also NOTE : match may actually be in another line. e.g.:
;; when r.e. is \nc, cursor is at 'a' and the text buffer looks like
;;
;; +-------------------------+
;; |a                        |
;; |b                        |
;; |c                        |
;; |                         |
;; +-------------------------+
;;
;; then nfa_regexec_multi() returns 3. while the original
;; vim_regexec_multi() returns 0 and a second call at line 2 will return 2.
;;
;; FIXME if this behavior is not compatible.

(defn- #_long nfa_regexec_multi [#_regmmatch_C rmp, #_window_C win, #_buffer_C buf, #_long lnum, #_int col, #_timeval_C tm]
    ;; win: window in which to search or null
    ;; buf: buffer in which to search
    ;; lnum: nr of line to start looking for match
    ;; col: column to start looking for match
    ;; tm: timeout limit or null
    (§
;       @reg_match = null;
;       @reg_mmatch = rmp;
;       @reg_buf = buf;
;       @reg_win = win;
;       @reg_firstlnum = lnum;
;       @reg_maxline = @reg_buf.b_ml.ml_line_count - lnum;
;       @reg_line_lbr = false;
;       @ireg_ic = rmp.rmm_ic;
;       @ireg_icombine = false;
;       @ireg_maxcol = rmp.rmm_maxcol;

;       return nfa_regexec_both(null, col, tm);
    ))

;; ----------------------------------------------------------------------- ;;

;; Which regexp engine to use?  Needed for vim_regcomp().
;; Must match with 'regexpengine'.

(atom! int regexp_engine)

;; Compile a regular expression into internal code.
;; Returns the program in allocated memory.
;; Returns null for an error.

(defn- #_regprog_C vim_regcomp [#_Bytes expr_arg, #_int re_flags]
    (§
;       regprog_C prog = null;
;       Bytes expr = expr_arg;

;       @regexp_engine = (int)@p_re;

        ;; Check for prefix "\%#=", that sets the regexp engine.
;       if (STRNCMP(expr, u8("\\%#="), 4) == 0)
;       {
;           int newengine = expr.at(4) - '0';

;           if (newengine == AUTOMATIC_ENGINE || newengine == BACKTRACKING_ENGINE || newengine == NFA_ENGINE)
;           {
;               @regexp_engine = expr.at(4) - '0';
;               expr = expr.plus(5);
;           }
;           else
;           {
;               emsg(u8("E864: \\%#= can only be followed by 0, 1, or 2. The automatic engine will be used."));
;               @regexp_engine = AUTOMATIC_ENGINE;
;           }
;       }

;       bt_regengine.expr = expr;
;       nfa_regengine.expr = expr;

        ;; First try the NFA engine, unless backtracking was requested.

;       if (@regexp_engine != BACKTRACKING_ENGINE)
;           prog = nfa_regengine.regcomp(expr, re_flags + (@regexp_engine == AUTOMATIC_ENGINE ? RE_AUTO : 0));
;       else
;           prog = bt_regengine.regcomp(expr, re_flags);

        ;; Check for error compiling regexp with initial engine.
;       if (prog == null)
;       {
            ;; If the NFA engine failed, try the backtracking engine.
            ;; The NFA engine also fails for patterns that it can't handle well
            ;; but are still valid patterns, thus a retry should work.

;           if (@regexp_engine == AUTOMATIC_ENGINE)
;           {
;               @regexp_engine = BACKTRACKING_ENGINE;
;               prog = bt_regengine.regcomp(expr, re_flags);
;           }
;       }

;       if (prog != null)
;       {
            ;; Store the info needed to call regcomp() again when
            ;; the engine turns out to be very slow executing it.
;           prog.re_engine = @regexp_engine;
;           prog.re_flags  = re_flags;
;       }

;       return prog;
    ))

(defn- #_void report_re_switch [#_Bytes pat]
    (§
;       if (0 < @p_verbose)
;       {
;           msg_puts(u8("Switching to backtracking RE engine for pattern: "));
;           msg_puts(pat);
;       }
    ))

;; Match a regexp against a string.
;; "rmp.regprog" is a compiled regexp as returned by vim_regcomp().
;; Note: "rmp.regprog" may be freed and changed.
;; Uses curbuf for line count and 'iskeyword'.
;; When "nl" is true, consider a "\n" in "line" to be a line break.
;;
;; Return true if there is a match, false if not.

(defn- #_boolean vim_regexec_both [#_regmatch_C rmp, #_Bytes line, #_int col, #_boolean nl]
    ;; line: string to match against
    ;; col: column to start looking for match
    (§
;       long result = rmp.regprog.engine.regexec_nl(rmp, line, col, nl);

        ;; NFA engine aborted because it's very slow.
;       if (rmp.regprog.re_engine == AUTOMATIC_ENGINE && result == NFA_TOO_EXPENSIVE)
;       {
;           long save_p_re = @p_re;
;           int re_flags = rmp.regprog.re_flags;
;           Bytes pat = STRDUP(((nfa_regprog_C)rmp.regprog).pattern);

;           @p_re = BACKTRACKING_ENGINE;
;           rmp.regprog = null;
;           if (pat != null)
;           {
;               report_re_switch(pat);
;               rmp.regprog = vim_regcomp(pat, re_flags);
;               if (rmp.regprog != null)
;                   result = rmp.regprog.engine.regexec_nl(rmp, line, col, nl);
;           }
;           @p_re = save_p_re;
;       }

;       return (0 < result);
    ))

;; Note: "*prog" may be freed and changed.
;; Return true if there is a match, false if not.

(defn- #_boolean vim_regexec_prog [#_regprog_C* prog, #_boolean ignore_case, #_Bytes line, #_int col]
    (§
;       regmatch_C regmatch = §_regmatch_C();
;       regmatch.regprog = prog[0];
;       regmatch.rm_ic = ignore_case;

;       boolean r = vim_regexec_both(regmatch, line, col, false);

;       prog[0] = regmatch.regprog;
;       return r;
    ))

;; Note: "rmp.regprog" may be freed and changed.
;; Return true if there is a match, false if not.

(defn- #_boolean vim_regexec [#_regmatch_C rmp, #_Bytes line, #_int col]
    (§
;       return vim_regexec_both(rmp, line, col, false);
    ))

;; Like vim_regexec(), but consider a "\n" in "line" to be a line break.
;; Note: "rmp.regprog" may be freed and changed.
;; Return true if there is a match, false if not.

(defn- #_boolean vim_regexec_nl [#_regmatch_C rmp, #_Bytes line, #_int col]
    (§
;       return vim_regexec_both(rmp, line, col, true);
    ))

;; Match a regexp against multiple lines.
;; "rmp.regprog" is a compiled regexp as returned by vim_regcomp().
;; Note: "rmp.regprog" may be freed and changed.
;; Uses curbuf for line count and 'iskeyword'.
;;
;; Return zero if there is no match.  Return number of lines contained in the match otherwise.

(defn- #_long vim_regexec_multi [#_regmmatch_C rmp, #_window_C win, #_buffer_C buf, #_long lnum, #_int col, #_timeval_C tm]
    ;; win: window in which to search or null
    ;; buf: buffer in which to search
    ;; lnum: nr of line to start looking for match
    ;; col: column to start looking for match
    ;; tm: timeout limit or null
    (§
;       long result = rmp.regprog.engine.regexec_multi(rmp, win, buf, lnum, col, tm);

        ;; NFA engine aborted because it's very slow.
;       if (rmp.regprog.re_engine == AUTOMATIC_ENGINE && result == NFA_TOO_EXPENSIVE)
;       {
;           long save_p_re = @p_re;
;           int re_flags = rmp.regprog.re_flags;
;           Bytes pat = STRDUP(((nfa_regprog_C)rmp.regprog).pattern);

;           @p_re = BACKTRACKING_ENGINE;
;           rmp.regprog = null;
;           if (pat != null)
;           {
;               report_re_switch(pat);
;               rmp.regprog = vim_regcomp(pat, re_flags);
;               if (rmp.regprog != null)
;                   result = rmp.regprog.engine.regexec_multi(rmp, win, buf, lnum, col, tm);
;           }
;           @p_re = save_p_re;
;       }

;       return Math.max(0, result);
    ))

;;; ============================================================================================== VimP

;; search.c: code for normal mode searching commands ----------------------------------------------

;; This file contains various searching-related routines.  These fall into
;; three groups:
;; 1. string searches (for /, ?, n, and N)
;; 2. character searches within a single line (for f, F, t, T, etc)
;; 3. "other" kinds of searches like the '%' command, and 'word' searches.

;; String searches
;;
;; The string search functions are divided into two levels:
;; lowest:  searchit(); uses an pos_C for starting position and found match.
;; Highest: do_search(); uses curwin.w_cursor; calls searchit().
;;
;; The last search pattern is remembered for repeating the same search.
;; This pattern is shared between the :g, :s, ? and / commands.
;; This is in search_regcomp().
;;
;; The actual string matching is done using a heavily modified version of
;; Henry Spencer's regular expression library.  See regexp.c.

;; The offset for a search command is store in a soff struct.
;; Note: only spats[0].sp_off is really used.
(class! #_final soffset_C
    [
        (field byte         dir)            ;; search direction, '/' or '?'
        (field boolean      line)           ;; search has line offset
        (field boolean      end)            ;; search set cursor at end
        (field long         off)            ;; line or char offset
    ])

(defn- #_void COPY_soffset [#_soffset_C so1, #_soffset_C so0]
    (§
;       so1.dir = so0.dir;
;       so1.line = so0.line;
;       so1.end = so0.end;
;       so1.off = so0.off;
    ))

;; A search pattern and its attributes are stored in a spat struct.
(class! #_final spat_C
    [
        (field Bytes        pat)            ;; the pattern (in allocated memory) or null
        (field boolean      magic)          ;; magicness of the pattern
        (field boolean      no_scs)         ;; no smartcase for this pattern
        (field soffset_C    sp_off      (§_soffset_C))
    ])

(defn- #_spat_C new_spat []
    (§
;       spat_C sp = §_spat_C();

;       sp.magic = true;
;       sp.sp_off.dir = '/';

;       return sp;
    ))

;; Two search patterns are remembered: one for the :substitute command and one for other searches.
;; last_idx points to the one that was used the last time.

(atom! spat_C* #_"/*[2]*/" spats
    [
        new_spat(),                     ;; last used search pat
        new_spat()                      ;; last used substitute pat
    ])
(atom! int last_idx)        ;; index in spats[] for RE_LAST

(atom! Bytes mr_pattern)   ;; pattern used by search_regcomp()

;; translate search pattern for vim_regcomp()
;;
;; pat_save == RE_SEARCH: save pat in spats[RE_SEARCH].pat (normal search cmd)
;; pat_save == RE_SUBST: save pat in spats[RE_SUBST].pat (:substitute command)
;; pat_save == RE_BOTH: save pat in both patterns (:global command)
;; pat_use  == RE_SEARCH: use previous search pattern if "pat" is null
;; pat_use  == RE_SUBST: use previous substitute pattern if "pat" is null
;; pat_use  == RE_LAST: use last used pattern if "pat" is null
;; options & SEARCH_HIS: put search string in history
;; options & SEARCH_KEEP: keep previous search pattern
;;
;; returns false if failed, true otherwise.

(defn- #_boolean search_regcomp [#_Bytes pat, #_int pat_save, #_int pat_use, #_int options, #_regmmatch_C regmatch]
    ;; regmatch: return: pattern and ignore-case flag
    (§
;       @rc_did_emsg = false;
;       boolean magic = @p_magic;

        ;; If no pattern given, use a previously defined pattern.

;       if (pat == null || pat.at(0) == NUL)
;       {
;           int i;
;           if (pat_use == RE_LAST)
;               i = @last_idx;
;           else
;               i = pat_use;
;           if (@spats[i].pat == null)           ;; pattern was never defined
;           {
;               if (pat_use == RE_SUBST)
;                   emsg(e_nopresub);
;               else
;                   emsg(e_noprevre);
;               @rc_did_emsg = true;
;               return false;
;           }
;           pat = @spats[i].pat;
;           magic = @spats[i].magic;
;           @no_smartcase = @spats[i].no_scs;
;       }
;       else if ((options & SEARCH_HIS) != 0)   ;; put new pattern in history
;           add_to_history(HIST_SEARCH, pat, true, NUL);

;       if (@curwin.w_onebuf_opt.@wo_rl && @curwin.w_onebuf_opt.@wo_rlc.at(0) == (byte)'s')
;           @mr_pattern = reverse_text(pat);
;       else
;           @mr_pattern = pat;

        ;; Save the currently used pattern in the appropriate place,
        ;; unless the pattern should not be remembered.

;       if ((options & SEARCH_KEEP) == 0 && !@cmdmod.keeppatterns)
;       {
            ;; search or global command
;           if (pat_save == RE_SEARCH || pat_save == RE_BOTH)
;               save_re_pat(RE_SEARCH, pat, magic);
            ;; substitute or global command
;           if (pat_save == RE_SUBST || pat_save == RE_BOTH)
;               save_re_pat(RE_SUBST, pat, magic);
;       }

;       regmatch.rmm_ic = ignorecase(pat);
;       regmatch.rmm_maxcol = 0;
;       regmatch.regprog = vim_regcomp(pat, magic ? RE_MAGIC : 0);

;       return (regmatch.regprog != null);
    ))

;; Get search pattern used by search_regcomp().

(defn- #_Bytes get_search_pat []
    (§
;       return @mr_pattern;
    ))

;; Reverse text into allocated memory.

(defn- #_Bytes reverse_text [#_Bytes s]
    (§
        ;; Reverse the pattern.

;       int len = STRLEN(s);
;       Bytes rev = new Bytes(len + 1);

;       int j = len;
;       for (int i = 0; i < len; i++)
;       {
;           int mb_len = us_ptr2len_cc(s.plus(i));
;           j -= mb_len;
;           BCOPY(rev, j, s, i, mb_len);
;           i += mb_len - 1;
;       }
;       rev.be(len, NUL);

;       return rev;
    ))

(defn- #_void save_re_pat [#_int idx, #_Bytes pat, #_boolean magic]
    (§
;       if (BNE(@spats[idx].pat, pat))
;       {
;           @spats[idx].pat = STRDUP(pat);
;           @spats[idx].magic = magic;
;           @spats[idx].no_scs = @no_smartcase;
;           @last_idx = idx;
            ;; If 'hlsearch' set and search 'pat' changed: need redraw.
;           if (@p_hls)
;               redraw_all_later(SOME_VALID);
;           @no_hlsearch = false;
;       }
    ))

;; Return true when case should be ignored for search pattern "pat".
;; Uses the 'ignorecase' and 'smartcase' options.

(defn- #_boolean ignorecase [#_Bytes pat]
    (§
;       boolean ic = @p_ic;

;       if (ic && !@no_smartcase && @p_scs)
;           ic = !pat_has_uppercase(pat);
;       @no_smartcase = false;

;       return ic;
    ))

;; Return true if patter "pat" has an uppercase character.

(defn- #_boolean pat_has_uppercase [#_Bytes pat]
    (§
;       Bytes p = pat;

;       while (p.at(0) != NUL)
;       {
;           int len = us_ptr2len_cc(p);
;           if (1 < len)
;           {
;               if (utf_isupper(us_ptr2char(p)))
;                   return true;
;               p = p.plus(len);
;           }
;           else if (p.at(0) == (byte)'\\')
;           {
;               if (p.at(1) == (byte)'_' && p.at(2) != NUL)         ;; skip "\_X"
;                   p = p.plus(3);
;               else if (p.at(1) == (byte)'%' && p.at(2) != NUL)    ;; skip "\%X"
;                   p = p.plus(3);
;               else if (p.at(1) != NUL)                   ;; skip "\X"
;                   p = p.plus(2);
;               else
;                   p = p.plus(1);
;           }
;           else if (utf_isupper(p.at(0)))
;               return true;
;           else
;               p = p.plus(1);
;       }
;       return false;
    ))

(defn- #_Bytes last_search_pat []
    (§
;       return @spats[@last_idx].pat;
    ))

;; Reset search direction to forward.  For "gd" and "gD" commands.

(defn- #_void reset_search_dir []
    (§
;       @spats[0].sp_off.dir = '/';
    ))

;; Set the last search pattern.  For ":let @/ =" and viminfo.
;; Also set the saved search pattern, so that this works in an autocommand.

(defn- #_void set_last_search_pat [#_Bytes s, #_int idx, #_boolean magic, #_boolean setlast]
    (§
        ;; An empty string means that nothing should be matched.
;       @spats[idx].pat = (s.at(0) == NUL) ? null : STRDUP(s);
;       @spats[idx].magic = magic;
;       @spats[idx].no_scs = false;
;       @spats[idx].sp_off.dir = '/';
;       @spats[idx].sp_off.line = false;
;       @spats[idx].sp_off.end = false;
;       @spats[idx].sp_off.off = 0;

;       if (setlast)
;           @last_idx = idx;

        ;; If 'hlsearch' set and search pat changed: need redraw.
;       if (@p_hls && idx == @last_idx && !@no_hlsearch)
;           redraw_all_later(SOME_VALID);
    ))

;; Get a regexp program for the last used search pattern.
;; This is used for highlighting all matches in a window.
;; Values returned in regmatch.regprog and regmatch.rmm_ic.

(defn- #_void last_pat_prog [#_regmmatch_C regmatch]
    (§
;       if (@spats[@last_idx].pat == null)
;       {
;           regmatch.regprog = null;
;           return;
;       }

;       @emsg_off++;         ;; So it doesn't beep if bad expr
;       search_regcomp(u8(""), 0, @last_idx, SEARCH_KEEP, regmatch);
;       --@emsg_off;
    ))

(final Bytes top_bot_msg (u8 "search hit TOP, continuing at BOTTOM"))
(final Bytes bot_top_msg (u8 "search hit BOTTOM, continuing at TOP"))

;; Lowest level search function.
;; Search for 'count'th occurrence of pattern 'pat' in direction 'dir'.
;; Start at position 'pos' and return the found position in 'pos'.
;;
;; if (options & SEARCH_MSG) == 0 don't give any messages
;; if (options & SEARCH_MSG) == SEARCH_NFMSG don't give 'notfound' messages
;; if (options & SEARCH_MSG) == SEARCH_MSG give all messages
;; if (options & SEARCH_HIS) put search pattern in history
;; if (options & SEARCH_END) return position at end of match
;; if (options & SEARCH_START) accept match at pos itself
;; if (options & SEARCH_KEEP) keep previous search pattern
;; if (options & SEARCH_FOLD) match only once in a closed fold
;; if (options & SEARCH_PEEK) check for typed char, cancel search
;;
;; Return false (zero) for failure, non-zero for success.
;; When FEAT_EVAL is defined, returns the index of the first matching
;; subpattern plus one; one if there was none.

(defn- #_int searchit [#_window_C win, #_buffer_C buf, #_pos_C pos, #_int dir, #_Bytes pat, #_long count, #_int options, #_int pat_use, #_long stop_lnum, #_timeval_C tm]
    ;; win: window to search in; can be null for a buffer without a window!
    ;; pat_use: which pattern to use when "pat" is empty
    ;; stop_lnum: stop after this line number when != 0
    ;; tm: timeout limit or null
    (§
;       int submatch = 0;

;       boolean first_match = true;
;       boolean save_called_emsg = @called_emsg;
;       boolean break_loop = false;

;       regmmatch_C regmatch = §_regmmatch_C();
;       if (search_regcomp(pat, RE_SEARCH, pat_use, (options & (SEARCH_HIS + SEARCH_KEEP)), regmatch) == false)
;       {
;           if ((options & SEARCH_MSG) != 0 && !@rc_did_emsg)
;               emsg2(u8("E383: Invalid search string: %s"), @mr_pattern);
;           return 0;
;       }

;       boolean found;
;       long lnum;

;       pos_C start_pos = §_pos_C();
;       lpos_C matchpos = §_lpos_C();
;       lpos_C endpos = §_lpos_C();

        ;; find the string

;       @called_emsg = false;
;       do  ;; loop for count
;       {
            ;; When not accepting a match at the start position, set "extra_col" to a non-zero value.
            ;; Don't do that when starting at MAXCOL, since MAXCOL + 1 is zero.
;           int extra_col;
;           if ((options & SEARCH_START) != 0 || pos.col == MAXCOL)
;               extra_col = 0;
            ;; Watch out for the "col" being MAXCOL - 2, used in a closed fold.
;           else if (dir != BACKWARD
;               && 1 <= pos.lnum && pos.lnum <= buf.b_ml.ml_line_count && pos.col < MAXCOL - 2)
;           {
;               Bytes ptr = ml_get_buf(buf, pos.lnum, false).plus(pos.col);
;               if (ptr.at(0) == NUL)
;                   extra_col = 1;
;               else
;                   extra_col = us_ptr2len_cc(ptr);
;           }
;           else
;               extra_col = 1;

;           COPY_pos(start_pos, pos);       ;; remember start pos for detecting no match
;           found = false;                  ;; default: not found
;           boolean at_first_line = true;   ;; default: start in first line
;           if (pos.lnum == 0)              ;; correct lnum for when starting in line 0
;           {
;               pos.lnum = 1;
;               pos.col = 0;
;               at_first_line = false;      ;; not in first line now
;           }

            ;; Start searching in current line, unless searching backwards and we're in column 0.
            ;; If we are searching backwards, in column 0, and not including the
            ;; current position, gain some efficiency by skipping back a line.
            ;; Otherwise begin the search in the current line.

;           if (dir == BACKWARD && start_pos.col == 0 && (options & SEARCH_START) == 0)
;           {
;               lnum = pos.lnum - 1;
;               at_first_line = false;
;           }
;           else
;               lnum = pos.lnum;

;           for (int loop = 0; loop <= 1; loop++)   ;; loop twice if 'wrapscan' set
;           {
;               for ( ; 0 < lnum && lnum <= buf.b_ml.ml_line_count; lnum += dir, at_first_line = false)
;               {
                    ;; Stop after checking "stop_lnum", if it's set.
;                   if (stop_lnum != 0 && (dir == FORWARD ? stop_lnum < lnum : lnum < stop_lnum))
;                       break;
                    ;; Stop after passing the "tm" time limit.
;                   if (tm != null && profile_passed_limit(tm))
;                       break;

                    ;; Look for a match somewhere in line "lnum".

;                   long nmatched = vim_regexec_multi(regmatch, win, buf, lnum, 0, tm);
                    ;; Abort searching on an error (e.g., out of stack).
;                   if (@called_emsg)
;                       break;
;                   if (0 < nmatched)
;                   {
                        ;; match may actually be in another line when using \zs
;                       COPY_lpos(matchpos, regmatch.startpos[0]);
;                       COPY_lpos(endpos, regmatch.endpos[0]);
;                       submatch = first_submatch(regmatch);
                        ;; "lnum" may be past end of buffer for "\n\zs".
;                       Bytes ptr;
;                       if (buf.b_ml.ml_line_count < lnum + matchpos.lnum)
;                           ptr = u8("");
;                       else
;                           ptr = ml_get_buf(buf, lnum + matchpos.lnum, false);

                        ;; Forward search in the first line: match should be after
                        ;; the start position.  If not, continue at the end of the
                        ;; match (this is vi compatible) or on the next char.

;                       if (dir == FORWARD && at_first_line)
;                       {
;                           boolean match_ok = true;

                            ;; When the match starts in a next line it's certainly
                            ;; past the start position.
                            ;; When match lands on a NUL the cursor will be put
                            ;; one back afterwards, compare with that position,
                            ;; otherwise "/$" will get stuck on end of line.

;                           while (matchpos.lnum == 0
;                                   && ((options & SEARCH_END) != 0 && first_match
;                                       ? (nmatched == 1 && endpos.col - 1 < start_pos.col + extra_col)
;                                       : (matchpos.col - (ptr.at(matchpos.col) == NUL ? 1 : 0) < start_pos.col + extra_col)))
;                           {
                                ;; If vi-compatible searching, continue at the end
                                ;; of the match, otherwise continue one position forward.

;                               int matchcol;
;                               if (vim_strbyte(@p_cpo, CPO_SEARCH) != null)
;                               {
;                                   if (1 < nmatched)
;                                   {
                                        ;; end is in next line, thus no match in this line
;                                       match_ok = false;
;                                       break;
;                                   }
;                                   matchcol = endpos.col;
                                    ;; for empty match: advance one char
;                                   if (matchcol == matchpos.col && ptr.at(matchcol) != NUL)
;                                       matchcol += us_ptr2len_cc(ptr.plus(matchcol));
;                               }
;                               else
;                               {
;                                   matchcol = matchpos.col;
;                                   if (ptr.at(matchcol) != NUL)
;                                       matchcol += us_ptr2len_cc(ptr.plus(matchcol));
;                               }
;                               if (matchcol == 0 && (options & SEARCH_START) != 0)
;                                   break;
;                               if (ptr.at(matchcol) == NUL
;                                       || (nmatched = vim_regexec_multi(regmatch,
;                                                 win, buf, lnum + matchpos.lnum, matchcol, tm)) == 0)
;                               {
;                                   match_ok = false;
;                                   break;
;                               }
;                               COPY_lpos(matchpos, regmatch.startpos[0]);
;                               COPY_lpos(endpos, regmatch.endpos[0]);
;                               submatch = first_submatch(regmatch);

                                ;; Need to get the line pointer again,
                                ;; a multi-line search may have made it invalid.
;                               ptr = ml_get_buf(buf, lnum + matchpos.lnum, false);
;                           }
;                           if (!match_ok)
;                               continue;
;                       }
;                       if (dir == BACKWARD)
;                       {
                            ;; Now, if there are multiple matches on this line,
                            ;; we have to get the last one.  Or the last one before
                            ;; the cursor, if we're on that line.
                            ;; When putting the new cursor at the end, compare
                            ;; relative to the end of the match.

;                           boolean match_ok = false;
;                           for ( ; ; )
;                           {
                                ;; Remember a position that is before the start
                                ;; position, we use it if it's the last match in
                                ;; the line.  Always accept a position after
                                ;; wrapping around.
;                               if (loop != 0
;                                   || ((options & SEARCH_END) != 0
;                                       ? (lnum + regmatch.endpos[0].lnum < start_pos.lnum
;                                           || (lnum + regmatch.endpos[0].lnum == start_pos.lnum
;                                                && regmatch.endpos[0].col - 1 + extra_col <= start_pos.col))
;                                       : (lnum + regmatch.startpos[0].lnum < start_pos.lnum
;                                           || (lnum + regmatch.startpos[0].lnum == start_pos.lnum
;                                                && regmatch.startpos[0].col + extra_col <= start_pos.col))))
;                               {
;                                   match_ok = true;
;                                   COPY_lpos(matchpos, regmatch.startpos[0]);
;                                   COPY_lpos(endpos, regmatch.endpos[0]);
;                                   submatch = first_submatch(regmatch);
;                               }
;                               else
;                                   break;

                                ;; We found a valid match, now check if there is another one after it.
                                ;; If vi-compatible searching, continue at the end of the match,
                                ;; otherwise continue one position forward.

;                               int matchcol;
;                               if (vim_strbyte(@p_cpo, CPO_SEARCH) != null)
;                               {
;                                   if (1 < nmatched)
;                                       break;
;                                   matchcol = endpos.col;
                                    ;; for empty match: advance one char
;                                   if (matchcol == matchpos.col && ptr.at(matchcol) != NUL)
;                                       matchcol += us_ptr2len_cc(ptr.plus(matchcol));
;                               }
;                               else
;                               {
                                    ;; Stop when the match is in a next line.
;                                   if (0 < matchpos.lnum)
;                                       break;
;                                   matchcol = matchpos.col;
;                                   if (ptr.at(matchcol) != NUL)
;                                       matchcol += us_ptr2len_cc(ptr.plus(matchcol));
;                               }
;                               if (ptr.at(matchcol) == NUL
;                                       || (nmatched = vim_regexec_multi(regmatch,
;                                                 win, buf, lnum + matchpos.lnum, matchcol, tm)) == 0)
;                                   break;

                                ;; Need to get the line pointer again,
                                ;; a multi-line search may have made it invalid.
;                               ptr = ml_get_buf(buf, lnum + matchpos.lnum, false);
;                           }

                            ;; If there is only a match after the cursor, skip this match.

;                           if (!match_ok)
;                               continue;
;                       }

                        ;; With the SEARCH_END option move to the last character of the match.
                        ;; Don't do it for an empty match, end should be same as start then.
;                       if ((options & SEARCH_END) != 0 && (options & SEARCH_NOOF) == 0
;                               && (matchpos.lnum != endpos.lnum || matchpos.col != endpos.col))
;                       {
                            ;; For a match in the first column,
                            ;; set the position on the NUL in the previous line.
;                           pos.lnum = lnum + endpos.lnum;
;                           pos.col = endpos.col;
;                           if (endpos.col == 0)
;                           {
;                               if (1 < pos.lnum)   ;; just in case
;                               {
;                                   --pos.lnum;
;                                   pos.col = STRLEN(ml_get_buf(buf, pos.lnum, false));
;                               }
;                           }
;                           else
;                           {
;                               --pos.col;
;                               if (pos.lnum <= buf.b_ml.ml_line_count)
;                               {
;                                   ptr = ml_get_buf(buf, pos.lnum, false);
;                                   pos.col -= us_head_off(ptr, ptr.plus(pos.col));
;                               }
;                           }
;                       }
;                       else
;                       {
;                           pos.lnum = lnum + matchpos.lnum;
;                           pos.col = matchpos.col;
;                       }
;                       pos.coladd = 0;
;                       found = true;
;                       first_match = false;

                        ;; Set variables used for 'incsearch' highlighting.
;                       @search_match_lines = endpos.lnum - matchpos.lnum;
;                       @search_match_endcol = endpos.col;
;                       break;
;                   }
;                   line_breakcheck();      ;; stop if ctrl-C typed
;                   if (@got_int)
;                       break;

                    ;; Cancel searching if a character was typed.  Used for 'incsearch'.
                    ;; Don't check too often, that would slowdown searching too much.
;                   if ((options & SEARCH_PEEK) != 0 && ((lnum - pos.lnum) & 0x3f) == 0 && char_avail())
;                   {
;                       break_loop = true;
;                       break;
;                   }

;                   if (loop != 0 && lnum == start_pos.lnum)
;                       break;              ;; if second loop, stop where started
;               }
;               at_first_line = false;

                ;; Stop the search if wrapscan isn't set, "stop_lnum" is specified,
                ;; after an interrupt, after a match and after looping twice.

;               if (!@p_ws || stop_lnum != 0 || @got_int || @called_emsg || break_loop || found || loop != 0)
;                   break;

                ;; If 'wrapscan' is set we continue at the other end of the file.
                ;; If 'shortmess' does not contain 's', we give a message.
                ;; This message is also remembered in "keep_msg" for when the screen is redrawn.
                ;; The "keep_msg" is cleared whenever another message is written.

;               if (dir == BACKWARD)    ;; start second loop at the other end
;                   lnum = buf.b_ml.ml_line_count;
;               else
;                   lnum = 1;
;               if (!shortmess(SHM_SEARCH) && (options & SEARCH_MSG) != 0)
;                   give_warning((dir == BACKWARD) ? top_bot_msg : bot_top_msg, true);
;           }
;           if (@got_int || @called_emsg || break_loop)
;               break;
;       } while (0 < --count && found);     ;; stop after count matches or no match

;       @called_emsg |= save_called_emsg;

;       if (!found)             ;; did not find it
;       {
;           if (@got_int)
;               emsg(e_interr);
;           else if ((options & SEARCH_MSG) == SEARCH_MSG)
;           {
;               if (@p_ws)
;                   emsg2(e_patnotf2, @mr_pattern);
;               else if (lnum == 0)
;                   emsg2(u8("E384: search hit TOP without match for: %s"), @mr_pattern);
;               else
;                   emsg2(u8("E385: search hit BOTTOM without match for: %s"), @mr_pattern);
;           }
;           return 0;
;       }

        ;; A pattern like "\n\zs" may go past the last line.
;       if (pos.lnum > buf.b_ml.ml_line_count)
;       {
;           pos.lnum = buf.b_ml.ml_line_count;
;           pos.col = STRLEN(ml_get_buf(buf, pos.lnum, false));
;           if (0 < pos.col)
;               --pos.col;
;       }

;       return 1 + submatch;
    ))

(defn- #_void set_search_direction [#_byte dirc]
    (§
;       @spats[0].sp_off.dir = dirc;
    ))

;; Return the number of the first subpat that matched.

(defn- #_int first_submatch [#_regmmatch_C rp]
    (§
;       int submatch;

;       for (submatch = 1; ; submatch++)
;       {
;           if (0 <= rp.startpos[submatch].lnum)
;               break;
;           if (submatch == 9)
;           {
;               submatch = 0;
;               break;
;           }
;       }

;       return submatch;
    ))

;; Highest level string search function.
;; Search for the 'count'th occurrence of pattern 'pat' in direction 'dirc'
;;                If 'dirc' is 0: use previous dir.
;;    If 'pat' is null or empty : use previous string.
;;    If 'options & SEARCH_REV' : go in reverse of previous dir.
;;    If 'options & SEARCH_ECHO': echo the search command and handle options
;;    If 'options & SEARCH_MSG' : may give error message
;;    If 'options & SEARCH_OPT' : interpret optional flags
;;    If 'options & SEARCH_HIS' : put search pattern in history
;;    If 'options & SEARCH_NOOF': don't add offset to position
;;    If 'options & SEARCH_MARK': set previous context mark
;;    If 'options & SEARCH_KEEP': keep previous search pattern
;;    If 'options & SEARCH_START': accept match at curpos itself
;;    If 'options & SEARCH_PEEK': check for typed char, cancel search
;;
;; Careful: If spats[0].sp_off.line == true and spats[0].sp_off.off == 0,
;; this makes the movement linewise without moving the match position.
;;
;; Return 0 for failure, 1 for found, 2 for found and line offset added.

(defn- #_int do_search [#_oparg_C oap, #_byte dirc, #_Bytes pat, #_long count, #_int options, #_timeval_C tm]
    ;; oap: can be null
    ;; dirc: '/' or '?'
    ;; tm: timeout limit or null
    (§
;       int retval;

        ;; A line offset is not remembered, this is vi compatible.

;       if (@spats[0].sp_off.line && vim_strbyte(@p_cpo, CPO_LINEOFF) != null)
;       {
;           @spats[0].sp_off.line = false;
;           @spats[0].sp_off.off = 0;
;       }

        ;; Save the values for when (options & SEARCH_KEEP) is used.
        ;; (there is no "if ()" around this because gcc wants them initialized)

;       soffset_C old_off = §_soffset_C();
;       COPY_soffset(old_off, @spats[0].sp_off);

        ;; position of the last match
;       pos_C pos = §_pos_C();
;       COPY_pos(pos, @curwin.w_cursor); ;; start searching at the cursor position

        ;; Find out the direction of the search.

;       if (dirc == 0)
;           dirc = @spats[0].sp_off.dir;
;       else
;           @spats[0].sp_off.dir = dirc;

;       if ((options & SEARCH_REV) != 0)
;       {
;           if (dirc == '/')
;               dirc = '?';
;           else
;               dirc = '/';
;       }

        ;; Turn 'hlsearch' highlighting back on.

;       if (@no_hlsearch && (options & SEARCH_KEEP) == 0)
;       {
;           redraw_all_later(SOME_VALID);
;           @no_hlsearch = false;
;       }

;       end_do_search:
;       {
;           Bytes[] strcopy = { null };

            ;; Repeat the search when pattern followed by ';', e.g. "/foo/;?bar".

;           for ( ; ; )
;           {
;               Bytes searchstr = pat;                     ;; use previous pattern
;               Bytes dircp = null;

;               if (pat == null || pat.at(0) == NUL || pat.at(0) == dirc)
;               {
;                   if (@spats[RE_SEARCH].pat == null)       ;; no previous pattern
;                   {
;                       pat = @spats[RE_SUBST].pat;
;                       if (pat == null)
;                       {
;                           emsg(e_noprevre);
;                           retval = 0;
;                           break end_do_search;
;                       }
;                       searchstr = pat;
;                   }
;                   else
;                   {
                        ;; make search_regcomp() use spats[RE_SEARCH].pat
;                       searchstr = u8("");
;                   }
;               }

;               if (pat != null && pat.at(0) != NUL)            ;; look for (new) offset
;               {
                    ;; Find end of regular expression.
                    ;; If there is a matching '/' or '?', toss it.

;                   Bytes ps = strcopy[0];
;                   Bytes p = skip_regexp(pat, dirc, @p_magic, strcopy);
;                   if (BNE(strcopy[0], ps))
;                   {
                        ;; made a copy of "pat" to change "\?" to "?"
;                       @searchcmdlen += STRLEN(pat) - STRLEN(strcopy[0]);
;                       pat = strcopy[0];
;                       searchstr = strcopy[0];
;                   }
;                   if (p.at(0) == dirc)
;                   {
;                       dircp = p;                  ;; remember where we put the NUL
;                       (p = p.plus(1)).be(-1, NUL);
;                   }
;                   @spats[0].sp_off.line = false;
;                   @spats[0].sp_off.end = false;
;                   @spats[0].sp_off.off = 0;

                    ;; Check for a line offset or a character offset.
                    ;; For get_address (echo off) we don't check for a character offset,
                    ;; because it is meaningless and the 's' could be a substitute command.

;                   if (p.at(0) == (byte)'+' || p.at(0) == (byte)'-' || asc_isdigit(p.at(0)))
;                       @spats[0].sp_off.line = true;
;                   else if ((options & SEARCH_OPT) != 0 && (p.at(0) == (byte)'e' || p.at(0) == (byte)'s' || p.at(0) == (byte)'b'))
;                   {
;                       if (p.at(0) == (byte)'e')                           ;; end
;                           @spats[0].sp_off.end = (SEARCH_END != 0);
;                       p = p.plus(1);
;                   }
;                   if (asc_isdigit(p.at(0)) || p.at(0) == (byte)'+' || p.at(0) == (byte)'-')      ;; got an offset
;                   {
;                       if (asc_isdigit(p.at(0)) || asc_isdigit(p.at(1)))   ;; 'nr' or '+nr' or '-nr'
;                           @spats[0].sp_off.off = libC.atol(p);
;                       else if (p.at(0) == (byte)'-')                      ;; single '-'
;                           @spats[0].sp_off.off = -1;
;                       else                                                ;; single '+'
;                           @spats[0].sp_off.off = 1;
;                       p = p.plus(1);
;                       while (asc_isdigit(p.at(0)))                        ;; skip number
;                           p = p.plus(1);
;                   }

                    ;; compute length of search command for get_address()
;                   @searchcmdlen += BDIFF(p, pat);

;                   pat = p;                        ;; put "pat" after search command
;               }

;               if ((options & SEARCH_ECHO) != 0 && messaging() && !@cmd_silent && @msg_silent == 0)
;               {
;                   Bytes p;
;                   if (searchstr.at(0) == NUL)
;                       p = @spats[@last_idx].pat;
;                   else
;                       p = searchstr;

;                   Bytes msgbuf = new Bytes(STRLEN(p) + 40);

;                   msgbuf.be(0, dirc);
;                   if (utf_iscomposing(us_ptr2char(p)))
;                   {
                        ;; Use a space to draw the composing char on.
;                       msgbuf.be(1, (byte)' ');
;                       STRCPY(msgbuf.plus(2), p);
;                   }
;                   else
;                       STRCPY(msgbuf.plus(1), p);

;                   if (@spats[0].sp_off.line || @spats[0].sp_off.end || @spats[0].sp_off.off != 0)
;                   {
;                       p = msgbuf.plus(STRLEN(msgbuf));
;                       (p = p.plus(1)).be(-1, dirc);
;                       if (@spats[0].sp_off.end)
;                           (p = p.plus(1)).be(-1, (byte)'e');
;                       else if (!@spats[0].sp_off.line)
;                           (p = p.plus(1)).be(-1, (byte)'s');
;                       if (0 < @spats[0].sp_off.off || @spats[0].sp_off.line)
;                           (p = p.plus(1)).be(-1, (byte)'+');
;                       if (@spats[0].sp_off.off != 0 || @spats[0].sp_off.line)
;                           libC.sprintf(p, u8("%ld"), @spats[0].sp_off.off);
;                       else
;                           p.be(0, NUL);
;                   }

;                   msg_start();
;                   Bytes trunc = msg_strtrunc(msgbuf, false);

                    ;; The search pattern could be shown on the right in rightleft mode, but
                    ;; the 'ruler' and 'showcmd' area use it too, thus it would be blanked out
                    ;; again very soon.  Show it on the left, but do reverse the text.
;                   if (@curwin.w_onebuf_opt.@wo_rl && @curwin.w_onebuf_opt.@wo_rlc.at(0) == (byte)'s')
;                       trunc = reverse_text(trunc != null ? trunc : msgbuf);
;                   if (trunc != null)
;                       msg_outtrans(trunc);
;                   else
;                       msg_outtrans(msgbuf);
;                   msg_clr_eos();
;                   msg_check();

;                   gotocmdline(false);
;                   out_flush();
;                   @msg_nowait = true;              ;; don't wait for this message
;               }

                ;; If there is a character offset, subtract it from the current
                ;; position, so we don't get stuck at "?pat?e+2" or "/pat/s-2".
                ;; Skip this if pos.col is near MAXCOL (closed fold).
                ;; This is not done for a line offset, because then we would not be vi compatible.

;               if (!@spats[0].sp_off.line && @spats[0].sp_off.off != 0 && pos.col < MAXCOL - 2)
;               {
;                   if (0 < @spats[0].sp_off.off)
;                   {
;                       long c;
;                       for (c = @spats[0].sp_off.off; c != 0; --c)
;                           if (decl(pos) == -1)
;                               break;
;                       if (c != 0)                 ;; at start of buffer
;                       {
;                           pos.lnum = 0;           ;; allow lnum == 0 here
;                           pos.col = MAXCOL;
;                       }
;                   }
;                   else
;                   {
;                       long c;
;                       for (c = @spats[0].sp_off.off; c != 0; c++)
;                           if (incl(pos) == -1)
;                               break;
;                       if (c != 0)                 ;; at end of buffer
;                       {
;                           pos.lnum = @curbuf.b_ml.ml_line_count + 1;
;                           pos.col = 0;
;                       }
;                   }
;               }

;               int i = searchit(@curwin, @curbuf, pos, (dirc == '/') ? FORWARD : BACKWARD, searchstr, count,
;                           (@spats[0].sp_off.end ? SEARCH_REV : 0)
;                               + (options & (SEARCH_KEEP + SEARCH_PEEK + SEARCH_HIS + SEARCH_MSG + SEARCH_START
;                                   + ((pat != null && pat.at(0) == (byte)';') ? 0 : SEARCH_NOOF))),
;                                       RE_LAST, 0, tm);

;               if (dircp != null)
;                   dircp.be(0, dirc);          ;; restore second '/' or '?' for normal_cmd()
;               if (i == 0)
;               {
;                   retval = 0;
;                   break end_do_search;
;               }
;               if (@spats[0].sp_off.end && oap != null)
;                   oap.inclusive = true;           ;; 'e' includes last character

;               retval = 1;                         ;; pattern found

                ;; Add character and/or line offset

;               if ((options & SEARCH_NOOF) == 0 || (pat != null && pat.at(0) == (byte)';'))
;               {
;                   if (@spats[0].sp_off.line)       ;; add the offset to the line number
;                   {
;                       long c = pos.lnum + @spats[0].sp_off.off;
;                       if (c < 1)
;                           pos.lnum = 1;
;                       else if (@curbuf.b_ml.ml_line_count < c)
;                           pos.lnum = @curbuf.b_ml.ml_line_count;
;                       else
;                           pos.lnum = c;
;                       pos.col = 0;

;                       retval = 2;                 ;; pattern found, line offset added
;                   }
;                   else if (pos.col < MAXCOL - 2) ;; just in case
;                   {
;                       long c = @spats[0].sp_off.off;
;                       if (0 < c)                  ;; to the right, check for end of file
;                       {
;                           while (0 < c--)
;                               if (incl(pos) == -1)
;                                   break;
;                       }
;                       else                        ;; to the left, check for start of file
;                       {
;                           while (c++ < 0)
;                               if (decl(pos) == -1)
;                                   break;
;                       }
;                   }
;               }

                ;; The search command can be followed by a ';' to do another search.
                ;; For example: "/pat/;/foo/+3;?bar"
                ;; This is like doing another search command, except:
                ;; - The remembered direction '/' or '?' is from the first search.
                ;; - When an error happens the cursor isn't moved at all.
                ;; Don't do this when called by get_address() (it handles ';' itself).

;               if ((options & SEARCH_OPT) == 0 || pat == null || pat.at(0) != (byte)';')
;                   break;

;               dirc = (pat = pat.plus(1)).at(0);
;               if (dirc != '?' && dirc != '/')
;               {
;                   retval = 0;
;                   emsg(u8("E386: Expected '?' or '/'  after ';'"));
;                   break end_do_search;
;               }
;               pat = pat.plus(1);
;           }

;           if ((options & SEARCH_MARK) != 0)
;               setpcmark();
;           COPY_pos(@curwin.w_cursor, pos);
;           @curwin.w_set_curswant = true;
;       }

;       if ((options & SEARCH_KEEP) != 0 || @cmdmod.keeppatterns)
;           COPY_soffset(@spats[0].sp_off, old_off);

;       return retval;
    ))

;; Character Searches

(atom! int sc__lastc NUL)         ;; last character searched for
(atom! int sc__lastcdir)            ;; last direction of character search
(atom! boolean sc__last_t_cmd)      ;; last search t_cmd

(final Bytes sc__bytes (Bytes. (inc MB_MAXBYTES)))
(atom! int sc__bytelen 1)         ;; >1 for multi-byte char

;; Search for a character in a line.  If "t_cmd" is false, move to the
;; position of the character, otherwise move to just before the char.
;; Do this "cap.count1" times.
;; Return false or true.

(defn- #_boolean searchc [#_cmdarg_C cap, #_boolean t_cmd]
    (§
;       int c = cap.@nchar;                      ;; char to search for
;       int dir = cap.arg;                      ;; true for searching forward
;       long count = cap.count1;                ;; repeat count

;       boolean stop = true;

;       if (c != NUL)                           ;; normal search: remember args for repeat
;       {
;           if (!@keyStuffed)                    ;; don't remember when redoing
;           {
;               @sc__lastc = c;
;               @sc__lastcdir = dir;
;               @sc__last_t_cmd = t_cmd;
;               @sc__bytelen = utf_char2bytes(c, sc__bytes);
;               if (cap.ncharC1 != 0)
;               {
;                   @sc__bytelen += utf_char2bytes(cap.ncharC1, sc__bytes.plus(@sc__bytelen));
;                   if (cap.ncharC2 != 0)
;                       @sc__bytelen += utf_char2bytes(cap.ncharC2, sc__bytes.plus(@sc__bytelen));
;               }
;           }
;       }
;       else                                    ;; repeat previous search
;       {
;           if (@sc__lastc == NUL)
;               return false;
;           if (dir != 0)                       ;; repeat in opposite direction
;               dir = -@sc__lastcdir;
;           else
;               dir = @sc__lastcdir;
;           t_cmd = @sc__last_t_cmd;
;           c = @sc__lastc;

            ;; For multi-byte re-use last sc__bytes[] and sc__bytelen.

            ;; Force a move of at least one char, so ";" and "," will move the cursor,
            ;; even if the cursor is right in front of char we are looking at.
;           if (vim_strbyte(@p_cpo, CPO_SCOLON) == null && count == 1 && t_cmd)
;               stop = false;
;       }

;       if (dir == BACKWARD)
;           cap.oap.inclusive = false;
;       else
;           cap.oap.inclusive = true;

;       Bytes p = ml_get_curline();
;       int col = @curwin.w_cursor.col;
;       int len = STRLEN(p);

;       while (0 < count--)
;       {
;           for ( ; ; )
;           {
;               if (0 < dir)
;               {
;                   col += us_ptr2len_cc(p.plus(col));
;                   if (len <= col)
;                       return false;
;               }
;               else
;               {
;                   if (col == 0)
;                       return false;
;                   col -= us_head_off(p, p.plus(col - 1)) + 1;
;               }
;               if (@sc__bytelen == 1)
;               {
;                   if (p.at(col) == c && stop)
;                       break;
;               }
;               else
;               {
;                   if (MEMCMP(p.plus(col), sc__bytes, @sc__bytelen) == 0 && stop)
;                       break;
;               }
;               stop = true;
;           }
;       }

;       if (t_cmd)
;       {
            ;; backup to before the character (possibly double-byte)
;           col -= dir;

;           if (dir < 0)
                ;; Landed on the search char which is sc__bytelen long.
;               col += @sc__bytelen - 1;
;           else
                ;; To previous char, which may be multi-byte.
;               col -= us_head_off(p, p.plus(col));
;       }
;       @curwin.w_cursor.col = col;

;       return true;
    ))

;; "Other" Searches

;; findmatch - find the matching paren or brace
;;
;; Improvement over vi: Braces inside quotes are ignored.

(defn- #_pos_C findmatch [#_oparg_C oap, #_int initc]
    (§
;       return findmatchlimit(oap, initc, 0, 0);
    ))

;; Return true if the character before "linep[col]" equals "ch".
;; Return false if "col" is zero.
;; Update "*prevcol" to the column of the previous character, unless "prevcol" is null.
;; Handles multibyte string correctly.

(defn- #_boolean check_prevcol [#_Bytes linep, #_int col, #_int ch, #_int* prevcol]
    (§
;       --col;
;       if (0 < col)
;           col -= us_head_off(linep, linep.plus(col));
;       if (prevcol != null)
;           prevcol[0] = col;
;       return (0 <= col && linep.at(col) == ch);
    ))

(atom! pos_C _2_pos (§_pos_C)) ;; current search position

;; findmatchlimit -- find the matching paren or brace, if it exists within
;; maxtravel lines of here.  A maxtravel of 0 means search until falling off
;; the edge of the file.
;;
;; "initc" is the character to find a match for.  NUL means to find the
;; character at or after the cursor.
;;
;; flags: FM_BACKWARD   search backwards (when initc is '/', '*' or '#')
;;        FM_FORWARD    search forwards (when initc is '/', '*' or '#')
;;        FM_BLOCKSTOP  stop at start/end of block ({ or } in column 0)
;;        FM_SKIPCOMM   skip comments (not implemented yet!)
;;
;; "oap" is only used to set oap.motion_type for a linewise motion, it be null

(defn- #_pos_C findmatchlimit [#_oparg_C oap, #_int _initc, #_int flags, #_int maxtravel]
    (§
;       int[] initc = { _initc };
;       int[] findc = { 0 };                    ;; matching brace
;       int count = 0;                          ;; cumulative number of braces
;       boolean[] backwards = { false };
;       boolean inquote = false;                ;; true when inside quotes
;       int hash_dir = 0;                       ;; Direction searched for # things
;       int comment_dir = 0;                    ;; Direction searched for comments
;       int traveled = 0;                       ;; how far we've searched so far
;       boolean ignore_cend = false;            ;; ignore comment end
;       int match_escaped = 0;                  ;; search for escaped match
;       int comment_col = MAXCOL;               ;; start of / / comment
;       boolean lispcomm = false;               ;; inside of Lisp-style comment
;       boolean lisp = @curbuf.@b_p_lisp;      ;; engage Lisp-specific hacks ;)

;       COPY_pos(@_2_pos, @curwin.w_cursor);
;       @_2_pos.coladd = 0;
;       Bytes linep = ml_get(@_2_pos.lnum); ;; pointer to current line

;       boolean cpo_match = (vim_strbyte(@p_cpo, CPO_MATCH) != null);    ;; vi compatible matching
;       boolean cpo_bsl = (vim_strbyte(@p_cpo, CPO_MATCHBSL) != null);   ;; don't recognize backslashes

        ;; Direction to search when initc is '/', '*' or '#'.
;       int dir;
;       if ((flags & FM_BACKWARD) != 0)
;           dir = BACKWARD;
;       else if ((flags & FM_FORWARD) != 0)
;           dir = FORWARD;
;       else
;           dir = 0;

        ;; if initc given, look in the table for the matching character
        ;; '/' and '*' are special cases: look for start or end of comment.
        ;; When '/' is used, we ignore running backwards into an star-slash,
        ;; for "[*" command, we just want to find any comment.

;       if (initc[0] == '/' || initc[0] == '*')
;       {
;           comment_dir = dir;
;           if (initc[0] == '/')
;               ignore_cend = true;
;           backwards[0] = (dir != FORWARD);
;           initc[0] = NUL;
;       }
;       else if (initc[0] != '#' && initc[0] != NUL)
;       {
;           find_mps_values(initc, findc, backwards, true);
;           if (findc[0] == NUL)
;               return null;
;       }

        ;; Either initc is '#', or no initc was given and we need to look under the cursor.

;       else
;       {
;           if (initc[0] == '#')
;           {
;               hash_dir = dir;
;           }
;           else
;           {
                ;; initc was not given, must look for something to match under or near the cursor.
                ;; Only check for special things when 'cpo' doesn't have '%'.

;               if (!cpo_match)
;               {
                    ;; Are we before or at #if, #else etc.?
;                   Bytes p = skipwhite(linep);
;                   if (p.at(0) == (byte)'#' && @_2_pos.col <= BDIFF(p, linep))
;                   {
;                       p = skipwhite(p.plus(1));
;                       if (STRNCMP(p, u8("if"), 2) == 0 || STRNCMP(p, u8("endif"), 5) == 0 || STRNCMP(p, u8("el"), 2) == 0)
;                           hash_dir = 1;
;                   }

                    ;; Are we on a comment?
;                   else if (linep.at(@_2_pos.col) == (byte)'/')
;                   {
;                       if (linep.at(@_2_pos.col + 1) == (byte)'*')
;                       {
;                           comment_dir = FORWARD;
;                           backwards[0] = false;
;                           @_2_pos.col++;
;                       }
;                       else if (0 < @_2_pos.col && linep.at(@_2_pos.col - 1) == (byte)'*')
;                       {
;                           comment_dir = BACKWARD;
;                           backwards[0] = true;
;                           @_2_pos.col--;
;                       }
;                   }
;                   else if (linep.at(@_2_pos.col) == (byte)'*')
;                   {
;                       if (linep.at(@_2_pos.col + 1) == (byte)'/')
;                       {
;                           comment_dir = BACKWARD;
;                           backwards[0] = true;
;                       }
;                       else if (0 < @_2_pos.col && linep.at(@_2_pos.col - 1) == (byte)'/')
;                       {
;                           comment_dir = FORWARD;
;                           backwards[0] = false;
;                       }
;                   }
;               }

                ;; If we are not on a comment or the # at the start of a line,
                ;; then look for brace anywhere on this line after the cursor.

;               if (hash_dir == 0 && comment_dir == 0)
;               {
                    ;; Find the brace under or after the cursor.
                    ;; If beyond the end of the line, use the last character in the line.

;                   if (linep.at(@_2_pos.col) == NUL && @_2_pos.col != 0)
;                       --@_2_pos.col;
;                   for ( ; ; )
;                   {
;                       initc[0] = us_ptr2char(linep.plus(@_2_pos.col));
;                       if (initc[0] == NUL)
;                           break;

;                       find_mps_values(initc, findc, backwards, false);
;                       if (findc[0] != NUL)
;                           break;
;                       @_2_pos.col += us_ptr2len_cc(linep.plus(@_2_pos.col));
;                   }
;                   if (findc[0] == NUL)
;                   {
                        ;; no brace in the line, maybe use "  #if" then
;                       if (!cpo_match && skipwhite(linep).at(0) == (byte)'#')
;                           hash_dir = 1;
;                       else
;                           return null;
;                   }
;                   else if (!cpo_bsl)
;                   {
;                       int bslcnt = 0;

                        ;; Set "match_escaped" if there are an odd number of backslashes.
;                       for (int[] col = { @_2_pos.col }; check_prevcol(linep, col[0], '\\', col); )
;                           bslcnt++;
;                       match_escaped = (bslcnt & 1);
;                   }
;               }
;           }

;           if (hash_dir != 0)
;           {
                ;; Look for matching #if, #else, #elif, or #endif

;               if (oap != null)
;                   oap.motion_type = MLINE;    ;; linewise for this case only
;               if (initc[0] != '#')
;               {
;                   Bytes p = skipwhite(skipwhite(linep).plus(1));
;                   if (STRNCMP(p, u8("if"), 2) == 0 || STRNCMP(p, u8("el"), 2) == 0)
;                       hash_dir = 1;
;                   else if (STRNCMP(p, u8("endif"), 5) == 0)
;                       hash_dir = -1;
;                   else
;                       return null;
;               }
;               @_2_pos.col = 0;
;               while (!@got_int)
;               {
;                   if (0 < hash_dir)
;                   {
;                       if (@_2_pos.lnum == @curbuf.b_ml.ml_line_count)
;                           break;
;                   }
;                   else if (@_2_pos.lnum == 1)
;                       break;
;                   @_2_pos.lnum += hash_dir;
;                   linep = ml_get(@_2_pos.lnum);
;                   line_breakcheck();          ;; check for CTRL-C typed
;                   Bytes p = skipwhite(linep);
;                   if (p.at(0) != (byte)'#')
;                       continue;
;                   @_2_pos.col = BDIFF(p, linep);
;                   p = skipwhite(p.plus(1));
;                   if (0 < hash_dir)
;                   {
;                       if (STRNCMP(p, u8("if"), 2) == 0)
;                           count++;
;                       else if (STRNCMP(p, u8("el"), 2) == 0)
;                       {
;                           if (count == 0)
;                               return @_2_pos;
;                       }
;                       else if (STRNCMP(p, u8("endif"), 5) == 0)
;                       {
;                           if (count == 0)
;                               return @_2_pos;
;                           count--;
;                       }
;                   }
;                   else
;                   {
;                       if (STRNCMP(p, u8("if"), 2) == 0)
;                       {
;                           if (count == 0)
;                               return @_2_pos;
;                           count--;
;                       }
;                       else if (initc[0] == '#' && STRNCMP(p, u8("el"), 2) == 0)
;                       {
;                           if (count == 0)
;                               return @_2_pos;
;                       }
;                       else if (STRNCMP(p, u8("endif"), 5) == 0)
;                           count++;
;                   }
;               }
;               return null;
;           }
;       }

        ;; This is just guessing: when 'rightleft' is set,
        ;; search for a matching paren/brace in the other direction.
;       if (@curwin.w_onebuf_opt.@wo_rl && vim_strchr(u8("()[]{}<>"), initc[0]) != null)
;           backwards[0] = !backwards[0];

;       int do_quotes = -1;                 ;; check for quotes in current line
;       maybean start_in_quotes = MAYBE;    ;; start position is in quotes
;       pos_C match_pos = §_pos_C();      ;; where last slash-star was found

        ;; backward search: Check if this line contains a single-line comment
;       if ((backwards[0] && comment_dir != 0) || lisp)
;           comment_col = check_linecomment(linep);
;       if (lisp && comment_col != MAXCOL && comment_col < @_2_pos.col)
;           lispcomm = true;                ;; find match inside this comment
;       while (!@got_int)
;       {
            ;; Go to the next position, forward or backward.
            ;; We could use incp() and decp() here, but that is much slower.

;           if (backwards[0])
;           {
                ;; char to match is inside of comment, don't search outside
;               if (lispcomm && @_2_pos.col < comment_col)
;                   break;
;               if (@_2_pos.col == 0)                    ;; at start of line, go to prev. one
;               {
;                   if (@_2_pos.lnum == 1)               ;; start of file
;                       break;
;                   --@_2_pos.lnum;

;                   if (0 < maxtravel && maxtravel < ++traveled)
;                       break;

;                   linep = ml_get(@_2_pos.lnum);
;                   @_2_pos.col = STRLEN(linep);    ;; _2_pos.col on trailing NUL
;                   do_quotes = -1;
;                   line_breakcheck();

                    ;; Check if this line contains a single-line comment.
;                   if (comment_dir != 0 || lisp)
;                       comment_col = check_linecomment(linep);
                    ;; skip comment
;                   if (lisp && comment_col != MAXCOL)
;                       @_2_pos.col = comment_col;
;               }
;               else
;               {
;                   --@_2_pos.col;
;                   @_2_pos.col -= us_head_off(linep, linep.plus(@_2_pos.col));
;               }
;           }
;           else                            ;; forward search
;           {
;               if (linep.at(@_2_pos.col) == NUL
                        ;; at end of line, go to next one, don't search for match in comment
;                       || (lisp && comment_col != MAXCOL && @_2_pos.col == comment_col))
;               {
;                   if (@_2_pos.lnum == @curbuf.b_ml.ml_line_count    ;; end of file
                            ;; line is exhausted and comment with it, don't search for match in code
;                           || lispcomm)
;                       break;
;                   @_2_pos.lnum++;

;                   if (maxtravel != 0 && maxtravel < traveled++)
;                       break;

;                   linep = ml_get(@_2_pos.lnum);
;                   @_2_pos.col = 0;
;                   do_quotes = -1;
;                   line_breakcheck();
;                   if (lisp)   ;; find comment pos in new line
;                       comment_col = check_linecomment(linep);
;               }
;               else
;                   @_2_pos.col += us_ptr2len_cc(linep.plus(@_2_pos.col));
;           }

            ;; If FM_BLOCKSTOP given, stop at a '{' or '}' in column 0.

;           if (@_2_pos.col == 0 && (flags & FM_BLOCKSTOP) != 0 && (linep.at(0) == (byte)'{' || linep.at(0) == (byte)'}'))
;           {
;               if (linep.at(0) == findc[0] && count == 0)        ;; match!
;                   return @_2_pos;
;               break;                                      ;; out of scope
;           }

;           if (comment_dir != 0)
;           {
                ;; Note: comments do not nest, and we ignore quotes in them.
                ;; TODO: ignore comment brackets inside strings.
;               if (comment_dir == FORWARD)
;               {
;                   if (linep.at(@_2_pos.col) == (byte)'*' && linep.at(@_2_pos.col + 1) == (byte)'/')
;                   {
;                       @_2_pos.col++;
;                       return @_2_pos;
;                   }
;               }
;               else    ;; searching backwards
;               {
                    ;; A comment may contain / * or / /, it may also start or end
                    ;; with / * /.  Ignore a / * after / /.

;                   if (@_2_pos.col == 0)
;                       continue;
;                   else if (linep.at(@_2_pos.col - 1) == (byte)'/' && linep.at(@_2_pos.col) == (byte)'*' && @_2_pos.col < comment_col)
;                   {
;                       count++;
;                       COPY_pos(match_pos, @_2_pos);
;                       match_pos.col--;
;                   }
;                   else if (linep.at(@_2_pos.col - 1) == (byte)'*' && linep.at(@_2_pos.col) == (byte)'/')
;                   {
;                       if (0 < count)
;                           COPY_pos(@_2_pos, match_pos);
;                       else if (1 < @_2_pos.col && linep.at(@_2_pos.col - 2) == (byte)'/' && @_2_pos.col <= comment_col)
;                           @_2_pos.col -= 2;
;                       else if (ignore_cend)
;                           continue;
;                       else
;                           return null;

;                       return @_2_pos;
;                   }
;               }
;               continue;
;           }

            ;; If smart matching ('cpoptions' does not contain '%'), braces inside
            ;; of quotes are ignored, but only if there is an even number of
            ;; quotes in the line.

;           if (cpo_match)
;               do_quotes = 0;
;           else if (do_quotes == -1)
;           {
                ;; Count the number of quotes in the line, skipping \" and '"'.
                ;; Watch out for "\\".

;               int @at_start = do_quotes;       ;; do_quotes value at start position
;               Bytes p;
;               for (p = linep; p.at(0) != NUL; p = p.plus(1))
;               {
;                   if (BEQ(p, linep.plus(@_2_pos.col + (backwards[0] ? 1 : 0))))
;                       @at_start = (do_quotes & 1);
;                   if (p.at(0) == (byte)'"' && (BEQ(p, linep) || p.at(-1) != (byte)'\'' || p.at(1) != (byte)'\''))
;                       do_quotes++;
;                   if (p.at(0) == (byte)'\\' && p.at(1) != NUL)
;                       p = p.plus(1);
;               }
;               do_quotes &= 1;                 ;; result is 1 with even number of quotes

                ;; If we find an uneven count, check current line and previous one for a '\' at the end.

;               if (do_quotes == 0)
;               {
;                   inquote = false;
;                   if (p.at(-1) == (byte)'\\')
;                   {
;                       do_quotes = 1;
;                       if (start_in_quotes == MAYBE)
;                       {
                            ;; Do we need to use at_start here?
;                           inquote = true;
;                           start_in_quotes = TRUE;
;                       }
;                       else if (backwards[0])
;                           inquote = true;
;                   }
;                   if (1 < @_2_pos.lnum)
;                   {
;                       p = ml_get(@_2_pos.lnum - 1);
;                       if (p.at(0) != NUL && p.at(STRLEN(p) - 1) == '\\')
;                       {
;                           do_quotes = 1;
;                           if (start_in_quotes == MAYBE)
;                           {
;                               inquote = (@at_start != 0);
;                               if (inquote)
;                                   start_in_quotes = TRUE;
;                           }
;                           else if (!backwards[0])
;                               inquote = true;
;                       }

                        ;; ml_get() only keeps one line, need to get "linep" again
;                       linep = ml_get(@_2_pos.lnum);
;                   }
;               }
;           }
;           if (start_in_quotes == MAYBE)
;               start_in_quotes = FALSE;

            ;; If 'smartmatch' is set:
            ;;   Things inside quotes are ignored by setting 'inquote'.
            ;;   If we find a quote without a preceding '\' invert 'inquote'.
            ;;   At the end of a line not ending in '\' we reset 'inquote'.
            ;;
            ;;   In lines with an uneven number of quotes (without preceding '\')
            ;;   we do not know which part to ignore.  Therefore we only set
            ;;   inquote if the number of quotes in a line is even, unless this
            ;;   line or the previous one ends in a '\'.  Complicated, isn't it?

;           int c = us_ptr2char(linep.plus(@_2_pos.col));
;           switch (c)
;           {
;               case NUL:
                    ;; at end of line without trailing backslash, reset inquote
;                   if (@_2_pos.col == 0 || linep.at(@_2_pos.col - 1) != (byte)'\\')
;                   {
;                       inquote = false;
;                       start_in_quotes = FALSE;
;                   }
;                   break;

;               case '"':
                    ;; a quote that is preceded with an odd number of backslashes is ignored
;                   if (do_quotes != 0)
;                   {
;                       int col;

;                       for (col = @_2_pos.col - 1; 0 <= col; --col)
;                           if (linep.at(col) != (byte)'\\')
;                               break;
;                       if (((@_2_pos.col - 1 - col) & 1) == 0)
;                       {
;                           inquote = !inquote;
;                           start_in_quotes = FALSE;
;                       }
;                   }
;                   break;

                ;; If smart matching ('cpoptions' does not contain '%'):
                ;;   Skip things in single quotes: 'x' or '\x'.  Be careful for single
                ;;   single quotes, e.g. jon's.  Things like '\233' or '\x3f' are not
                ;;   skipped, there is never a brace in them.
                ;;   Ignore this when finding matches for `'.

;               case '\'':
;                   if (!cpo_match && initc[0] != '\'' && findc[0] != '\'')
;                   {
;                       if (backwards[0])
;                       {
;                           if (1 < @_2_pos.col)
;                           {
;                               if (linep.at(@_2_pos.col - 2) == (byte)'\'')
;                               {
;                                   @_2_pos.col -= 2;
;                                   break;
;                               }
;                               else if (linep.at(@_2_pos.col - 2) == (byte)'\\' && 2 < @_2_pos.col && linep.at(@_2_pos.col - 3) == (byte)'\'')
;                               {
;                                   @_2_pos.col -= 3;
;                                   break;
;                               }
;                           }
;                       }
;                       else if (linep.at(@_2_pos.col + 1) != NUL) ;; forward search
;                       {
;                           if (linep.at(@_2_pos.col + 1) == (byte)'\\' && linep.at(@_2_pos.col + 2) != NUL && linep.at(@_2_pos.col + 3) == (byte)'\'')
;                           {
;                               @_2_pos.col += 3;
;                               break;
;                           }
;                           else if (linep.at(@_2_pos.col + 2) == (byte)'\'')
;                           {
;                               @_2_pos.col += 2;
;                               break;
;                           }
;                       }
;                   }
                    ;; FALLTHROUGH

;               default:

                    ;; For Lisp skip over backslashed (), {} and [].
                    ;; (actually, we skip #\( et al)

;                   if (@curbuf.@b_p_lisp
;                           && vim_strchr(u8("(){}[]"), c) != null
;                           && 1 < @_2_pos.col
;                           && check_prevcol(linep, @_2_pos.col, '\\', null)
;                           && check_prevcol(linep, @_2_pos.col - 1, '#', null))
;                       break;

                    ;; Check for match outside of quotes, and inside of
                    ;; quotes when the start is also inside of quotes.
;                   if ((!inquote || start_in_quotes == TRUE) && (c == initc[0] || c == findc[0]))
;                   {
;                       int bslcnt = 0;

;                       if (!cpo_bsl)
;                       {
;                           for (int[] col = { @_2_pos.col }; check_prevcol(linep, col[0], '\\', col); )
;                               bslcnt++;
;                       }
                        ;; Only accept a match when 'M' is in 'cpo'
                        ;; or when escaping is what we expect.
;                       if (cpo_bsl || (bslcnt & 1) == match_escaped)
;                       {
;                           if (c == initc[0])
;                               count++;
;                           else
;                           {
;                               if (count == 0)
;                                   return @_2_pos;
;                               count--;
;                           }
;                       }
;                   }
;                   break;
;           }
;       }

;       if (comment_dir == BACKWARD && 0 < count)
;       {
;           COPY_pos(@_2_pos, match_pos);
;           return @_2_pos;
;       }

;       return null;    ;; never found it
    ))

;; Check if line[] contains a / / comment.
;; Return MAXCOL if not, otherwise return the column.
;; TODO: skip strings.

(defn- #_int check_linecomment [#_Bytes line]
    (§
;       Bytes p = line;

        ;; skip Lispish one-line comments
;       if (@curbuf.@b_p_lisp)
;       {
;           if (vim_strchr(p, ';') != null)                     ;; there may be comments
;           {
;               boolean in_str = false;                         ;; inside of string

;               p = line;                                       ;; scan from start
;               while ((p = STRPBRK(p, u8("\";"))) != null)
;               {
;                   if (p.at(0) == (byte)'"')
;                   {
;                       if (in_str)
;                       {
;                           if (p.at(-1) != (byte)'\\')               ;; skip escaped quote
;                               in_str = false;
;                       }
;                       else if (BEQ(p, line) || (2 <= BDIFF(p, line)
                                                                ;; skip #\" form
;                                         && p.at(-1) != (byte)'\\' && p.at(-2) != (byte)'#'))
;                           in_str = true;
;                   }
;                   else if (!in_str && (BDIFF(p, line) < 2 || (p.at(-1) != (byte)'\\' && p.at(-2) != (byte)'#')))
;                       break;                                  ;; found!
;                   p = p.plus(1);
;               }
;           }
;           else
;               p = null;
;       }
;       else
;           while ((p = vim_strchr(p, '/')) != null)
;           {
                ;; Accept a double /, unless it's preceded with * and followed by *,
                ;; because * / / * is an end and start of a C comment.
;               if (p.at(1) == (byte)'/' && (BEQ(p, line) || p.at(-1) != (byte)'*' || p.at(2) != (byte)'*'))
;                   break;
;               p = p.plus(1);
;           }

;       if (p == null)
;           return MAXCOL;

;       return BDIFF(p, line);
    ))

;; Move cursor briefly to character matching the one under the cursor.
;; Used for Insert mode and "r" command.
;; Show the match only if it is visible on the screen.
;; If there isn't a match, then beep.

(defn- #_void showmatch [#_int c]
    ;; c: char to show match for
    (§
        ;; Only show match for chars in the 'matchpairs' option.

        ;; 'matchpairs' is "x:y,x:y"
;       for (Bytes p = @curbuf.@b_p_mps; p.at(0) != NUL; p = p.plus(1))
;       {
;           if (us_ptr2char(p) == c && (@curwin.w_onebuf_opt.@wo_rl ^ @p_ri))
;               break;
;           p = p.plus(us_ptr2len_cc(p) + 1);
;           if (us_ptr2char(p) == c && !(@curwin.w_onebuf_opt.@wo_rl ^ @p_ri))
;               break;
;           p = p.plus(us_ptr2len_cc(p));
;           if (p.at(0) == NUL)
;               return;
;       }

;       pos_C lpos = findmatch(null, NUL);
;       if (lpos == null)                   ;; no match, so beep
;           vim_beep();
;       else if (@curwin.w_topline <= lpos.lnum && lpos.lnum < @curwin.w_botline)
;       {
;           int[] vcol = new int[1];
;           if (!@curwin.w_onebuf_opt.@wo_wrap)
;               getvcol(@curwin, lpos, null, vcol, null);
;           if (@curwin.w_onebuf_opt.@wo_wrap
;               || (@curwin.w_leftcol <= vcol[0] && vcol[0] < @curwin.w_leftcol + @curwin.w_width))
;           {
;               pos_C save_cursor = §_pos_C();
;               pos_C mpos = §_pos_C();

;               COPY_pos(mpos, lpos);               ;; save the pos, update_screen() may change it
;               COPY_pos(save_cursor, @curwin.w_cursor);
;               long save_so = @p_so;
;               long save_siso = @p_siso;
                ;; Handle "$" in 'cpo': If the ')' is typed on top of the "$", stop displaying the "$".
;               if (0 <= @dollar_vcol && @dollar_vcol == @curwin.w_virtcol)
;                   @dollar_vcol = -1;
;               @curwin.w_virtcol++;                 ;; do display ')' just before "$"
;               update_screen(VALID);               ;; show the new char first

;               int save_dollar_vcol = @dollar_vcol;
;               int save_state = @State;
;               @State = SHOWMATCH;
;               ui_cursor_shape();                  ;; may show different cursor shape
;               COPY_pos(@curwin.w_cursor, mpos);    ;; move to matching char
;               @p_so = 0;                        ;; don't use 'scrolloff' here
;               @p_siso = 0;                      ;; don't use 'sidescrolloff' here
;               showruler(false);
;               setcursor();
;               cursor_on();                        ;; make sure that the cursor is shown
;               out_flush();
                ;; Restore dollar_vcol(), because setcursor() may call curs_rows() which resets it
                ;; if the matching position is in a previous line and has a higher column number.
;               @dollar_vcol = save_dollar_vcol;

                ;; brief pause, unless 'm' is present in 'cpo' and a character is available.

;               if (vim_strbyte(@p_cpo, CPO_SHOWMATCH) != null)
;                   ui_delay(@p_mat * 100L, true);
;               else if (!char_avail())
;                   ui_delay(@p_mat * 100L, false);
;               COPY_pos(@curwin.w_cursor, save_cursor); ;; restore cursor position
;               @p_so = save_so;
;               @p_siso = save_siso;
;               @State = save_state;
;               ui_cursor_shape();          ;; may show different cursor shape
;           }
;       }
    ))

;; findsent(dir, count) - Find the start of the next sentence in direction "dir".
;; Sentences are supposed to end in ".", "!" or "?" followed by white space or a line break.
;; Also stop at an empty line.
;; Return true if the next sentence was found.

(defn- #_boolean findsent [#_int dir, #_long count]
    (§
;       boolean noskip = false;     ;; do not skip blanks

;       pos_C pos = §_pos_C();
;       COPY_pos(pos, @curwin.w_cursor);

;       while (0 < count--)
;       {
;           found:
;           {
                ;; If on an empty line, skip upto a non-empty line.

;               if (gchar_pos(pos) == NUL)
;               {
;                   do
;                   {
;                       if (((dir == FORWARD) ? incl(pos) : decl(pos)) == -1)
;                           break;
;                   } while (gchar_pos(pos) == NUL);
;                   if (dir == FORWARD)
;                       break found;
;               }

                ;; If on the start of a paragraph or a section and searching forward, go to the next line.

;               else if (dir == FORWARD && pos.col == 0 && startPS(pos.lnum, NUL, false))
;               {
;                   if (pos.lnum == @curbuf.b_ml.ml_line_count)
;                       return false;
;                   pos.lnum++;
;                   break found;
;               }
;               else if (dir == BACKWARD)
;                   decl(pos);

                ;; go back to the previous non-blank char
;               boolean found_dot = false;
;               for (int c; (c = gchar_pos(pos)) == ' ' || c == '\t' ||
;                   (dir == BACKWARD && vim_strchr(u8(".!?)]\"'"), c) != null); )
;               {
;                   if (vim_strchr(u8(".!?"), c) != null)
;                   {
                        ;; only skip over a '.', '!' and '?' once
;                       if (found_dot)
;                           break;
;                       found_dot = true;
;                   }
;                   if (decl(pos) == -1)
;                       break;
                    ;; when going forward: stop in front of empty line
;                   if (lineempty(pos.lnum) && dir == FORWARD)
;                   {
;                       incl(pos);
;                       break found;
;                   }
;               }

                ;; remember the line where the search started
;               long startlnum = pos.lnum;
;               boolean cpo_J = (vim_strbyte(@p_cpo, CPO_ENDOFSENT) != null);

;               pos_C tpos = §_pos_C();

;               for ( ; ; )                 ;; find end of sentence
;               {
;                   int c = gchar_pos(pos);
;                   if (c == NUL || (pos.col == 0 && startPS(pos.lnum, NUL, false)))
;                   {
;                       if (dir == BACKWARD && pos.lnum != startlnum)
;                           pos.lnum++;
;                       break;
;                   }
;                   if (c == '.' || c == '!' || c == '?')
;                   {
;                       COPY_pos(tpos, pos);
;                       do
;                       {
;                           if ((c = incp(tpos)) == -1)
;                               break;
;                       } while (vim_strchr(u8(")]\"'"), c = gchar_pos(tpos)) != null);
;                       if (c == -1 || (!cpo_J && (c == ' ' || c == '\t')) || c == NUL
;                           || (cpo_J && (c == ' ' && 0 <= incp(tpos) && gchar_pos(tpos) == ' ')))
;                       {
;                           COPY_pos(pos, tpos);
;                           if (gchar_pos(pos) == NUL)
;                               incp(pos);               ;; skip NUL at EOL
;                           break;
;                       }
;                   }
;                   if (((dir == FORWARD) ? incl(pos) : decl(pos)) == -1)
;                   {
;                       if (count != 0)
;                           return false;
;                       noskip = true;
;                       break;
;                   }
;               }
;           }

;           for (int c; !noskip && ((c = gchar_pos(pos)) == ' ' || c == '\t'); )
;               if (incl(pos) == -1)                ;; skip white space
;                   break;
;       }

;       setpcmark();
;       COPY_pos(@curwin.w_cursor, pos);
;       return true;
    ))

;; Find the next paragraph or section in direction 'dir'.
;; Paragraphs are currently supposed to be separated by empty lines.
;; If 'what' is NUL we go to the next paragraph.
;; If 'what' is '{' or '}' we go to the next section.
;; If 'both' is true also stop at '}'.
;; Return true if the next paragraph or section was found.

(defn- #_boolean findpar [#_boolean* pincl, #_int dir, #_long count, #_int what, #_boolean both]
    ;; pincl: Return: true if last char is to be included
    (§
;       boolean posix = (vim_strbyte(@p_cpo, CPO_PARA) != null);

;       long curr = @curwin.w_cursor.lnum;

;       while (0 < count--)
;       {
;           boolean did_skip = false;       ;; true after separating lines have been skipped

;           for (boolean first = true; ; first = false)     ;; true on first line
;           {
;               if (ml_get(curr).at(0) != NUL)
;                   did_skip = true;

                ;; POSIX has it's own ideas of what a paragraph boundary is and
                ;; it doesn't match historical Vi: It also stops at a "{" in the
                ;; first column and at an empty line.
;               if (!first && did_skip && (startPS(curr, what, both)
;                              || (posix && what == NUL && ml_get(curr).at(0) == (byte)'{')))
;                   break;

;               if ((curr += dir) < 1 || @curbuf.b_ml.ml_line_count < curr)
;               {
;                   if (count != 0)
;                       return false;
;                   curr -= dir;
;                   break;
;               }
;           }
;       }
;       setpcmark();
;       if (both && ml_get(curr).at(0) == (byte)'}')   ;; include line with '}'
;           curr++;
;       @curwin.w_cursor.lnum = curr;
;       if (curr == @curbuf.b_ml.ml_line_count && what != '}')
;       {
;           if ((@curwin.w_cursor.col = STRLEN(ml_get(curr))) != 0)
;           {
;               --@curwin.w_cursor.col;
;               pincl[0] = true;
;           }
;       }
;       else
;           @curwin.w_cursor.col = 0;
;       return true;
    ))

;; check if the string 's' is a nroff macro that is in option 'opt'

(defn- #_boolean inmacro [#_Bytes opt, #_Bytes s]
    (§
;       Bytes macro;

;       for (macro = opt; macro.at(0) != NUL; macro = macro.plus(1))
;       {
            ;; Accept two characters in the option being equal to two characters in the line.
            ;; A space in the option matches with a space in the line or the line having ended.

;           if ((macro.at(0) == s.at(0)
;                       || (macro.at(0) == (byte)' '
;                           && (s.at(0) == NUL || s.at(0) == (byte)' ')))
;                   && (macro.at(1) == s.at(1)
;                       || ((macro.at(1) == NUL || macro.at(1) == (byte)' ')
;                           && (s.at(0) == NUL || s.at(1) == NUL || s.at(1) == (byte)' '))))
;               break;
;           macro = macro.plus(1);
;           if (macro.at(0) == NUL)
;               break;
;       }

;       return (macro.at(0) != NUL);
    ))

;; startPS: return true if line 'lnum' is the start of a section or paragraph.
;; If 'para' is '{' or '}' only check for sections.
;; If 'both' is true also stop at '}'.

(defn- #_boolean startPS [#_long lnum, #_int para, #_boolean both]
    (§
;       Bytes s = ml_get(lnum);
;       if (s.at(0) == para || s.at(0) == (byte)'\f' || (both && s.at(0) == (byte)'}'))
;           return true;
;       if (s.at(0) == (byte)'.' && (inmacro(@p_sections, s.plus(1)) || (para == NUL && inmacro(@p_para, s.plus(1)))))
;           return true;

;       return false;
    ))

;; The following routines do the word searches performed
;; by the 'w', 'W', 'b', 'B', 'e', and 'E' commands.

;; To perform these searches, characters are placed into one of three
;; classes, and transitions between classes determine word boundaries.
;;
;; The classes are:
;;
;; 0 - white space
;; 1 - punctuation
;; 2 or higher - keyword characters (letters, digits and underscore)

(atom! boolean cls_bigword)     ;; true for "W", "B" or "E"

;; cls() - returns the class of character at curwin.w_cursor
;;
;; If a 'W', 'B', or 'E' motion is being done (cls_bigword == true),
;; chars from class 2 and higher are reported as class 1 since only
;; white space boundaries are of interest.

(defn- #_int cls []
    (§
;       int c = gchar_cursor();
;       if (c == ' ' || c == '\t' || c == NUL)
;           return 0;

;       c = utf_class(c);
;       if (c != 0 && @cls_bigword)
;           return 1;

;       return c;
    ))

;; fwd_word(count, type, eol) - move forward one word
;;
;; Returns false if the cursor was already at the end of the file.
;; If eol is true, last word stops at end of line (for operators).

(defn- #_boolean fwd_word [#_long count, #_boolean bigword, #_boolean eol]
    ;; bigword: "W", "E" or "B"
    (§
;       @curwin.w_cursor.coladd = 0;
;       @cls_bigword = bigword;

;       while (0 < count--)
;       {
;           int sclass = cls();         ;; starting class

            ;; We always move at least one character,
            ;; unless on the last character in the buffer.

;           boolean last_line = (@curwin.w_cursor.lnum == @curbuf.b_ml.ml_line_count);
;           int i = inc_cursor();
;           if (i == -1 || (1 <= i && last_line))   ;; started at last char in file
;               return false;
;           if (1 <= i && eol && count == 0)        ;; started at last char in line
;               return true;

            ;; Go one char past end of current word (if any).

;           if (sclass != 0)
;               while (cls() == sclass)
;               {
;                   i = inc_cursor();
;                   if (i == -1 || (1 <= i && eol && count == 0))
;                       return true;
;               }

            ;; go to next non-white

;           while (cls() == 0)
;           {
                ;; We'll stop if we land on a blank line

;               if (@curwin.w_cursor.col == 0 && ml_get_curline().at(0) == NUL)
;                   break;

;               i = inc_cursor();
;               if (i == -1 || (1 <= i && eol && count == 0))
;                   return true;
;           }
;       }

;       return true;
    ))

;; bck_word() - move backward 'count' words
;;
;; If stop is true and we are already on the start of a word, move one less.
;;
;; Returns false if top of the file was reached.

(defn- #_boolean bck_word [#_long count, #_boolean bigword, #_boolean stop]
    (§
;       @curwin.w_cursor.coladd = 0;
;       @cls_bigword = bigword;

;       while (0 < count--)
;       {
;           int sclass = cls();             ;; starting class

;           if (dec_cursor() == -1)         ;; started at start of file
;               return false;

;           finished:
;           {
;               if (!stop || sclass == cls() || sclass == 0)
;               {
                    ;; Skip white space before the word.
                    ;; Stop on an empty line.

;                   while (cls() == 0)
;                   {
;                       if (@curwin.w_cursor.col == 0 && lineempty(@curwin.w_cursor.lnum))
;                           break finished;
;                       if (dec_cursor() == -1) ;; hit start of file, stop here
;                           return true;
;                   }

                    ;; Move backward to start of this word.

;                   if (skip_chars(cls(), BACKWARD))
;                       return true;
;               }

;               inc_cursor();                   ;; overshot - forward one
;           }

;           stop = false;
;       }

;       return true;
    ))

;; end_word() - move to the end of the word
;;
;; There is an apparent bug in the 'e' motion of the real vi.  At least on the
;; System V Release 3 version for the 80386.  Unlike 'b' and 'w', the 'e'
;; motion crosses blank lines.  When the real vi crosses a blank line in an
;; 'e' motion, the cursor is placed on the FIRST character of the next
;; non-blank line. The 'E' command, however, works correctly.  Since this
;; appears to be a bug, I have not duplicated it here.
;;
;; Returns false if end of the file was reached.
;;
;; If stop is true and we are already on the end of a word, move one less.
;; If empty is true stop on an empty line.

(defn- #_boolean end_word [#_long count, #_boolean bigword, #_boolean stop, #_boolean empty]
    (§
;       @curwin.w_cursor.coladd = 0;
;       @cls_bigword = bigword;

;       while (0 < count--)
;       {
;           int sclass = cls();         ;; starting class

;           if (inc_cursor() == -1)
;               return false;

;           finished:
;           {
                ;; If we're in the middle of a word, we just have to move to the end of it.

;               if (cls() == sclass && sclass != 0)
;               {
                    ;; Move forward to end of the current word

;                   if (skip_chars(sclass, FORWARD))
;                       return false;
;               }
;               else if (!stop || sclass == 0)
;               {
                    ;; We were at the end of a word.  Go to the end of the next word.
                    ;; First skip white space, if 'empty' is true, stop at empty line.

;                   while (cls() == 0)
;                   {
;                       if (empty && @curwin.w_cursor.col == 0 && lineempty(@curwin.w_cursor.lnum))
;                           break finished;
;                       if (inc_cursor() == -1)     ;; hit end of file, stop here
;                           return false;
;                   }

                    ;; Move forward to the end of this word.

;                   if (skip_chars(cls(), FORWARD))
;                       return false;
;               }
;               dec_cursor();                   ;; overshot - one char backward
;           }

;           stop = false;                   ;; we move only one word less
;       }

;       return true;
    ))

;; Move back to the end of the word.
;;
;; Returns false if start of the file was reached.

(defn- #_boolean bckend_word [#_long count, #_boolean bigword, #_boolean eol]
    ;; bigword: true for "B"
    ;; eol: true: stop at end of line.
    (§
;       @curwin.w_cursor.coladd = 0;
;       @cls_bigword = bigword;

;       while (0 < count--)
;       {
;           int sclass = cls();         ;; starting class

;           int i = dec_cursor();
;           if (i == -1)
;               return false;
;           if (eol && i == 1)
;               return true;

            ;; Move backward to before the start of this word.

;           if (sclass != 0)
;           {
;               while (cls() == sclass)
;                   if ((i = dec_cursor()) == -1 || (eol && i == 1))
;                       return true;
;           }

            ;; Move backward to end of the previous word

;           while (cls() == 0)
;           {
;               if (@curwin.w_cursor.col == 0 && lineempty(@curwin.w_cursor.lnum))
;                   break;
;               if ((i = dec_cursor()) == -1 || (eol && i == 1))
;                   return true;
;           }
;       }

;       return true;
    ))

;; Skip a row of characters of the same class.
;; Return true when end-of-file reached, false otherwise.

(defn- #_boolean skip_chars [#_int cclass, #_int dir]
    (§
;       while (cls() == cclass)
;           if ((dir == FORWARD ? inc_cursor() : dec_cursor()) == -1)
;               return true;

;       return false;
    ))

;; Go back to the start of the word or the start of white space

(defn- #_void back_in_line []
    (§
;       int sclass = cls();                     ;; starting class

;       for ( ; ; )
;       {
;           if (@curwin.w_cursor.col == 0)       ;; stop at start of line
;               break;
;           dec_cursor();
;           if (cls() != sclass)                ;; stop at start of word
;           {
;               inc_cursor();
;               break;
;           }
;       }
    ))

(defn- #_void find_first_blank [#_pos_C posp]
    (§
;       while (decl(posp) != -1)
;       {
;           int c = gchar_pos(posp);
;           if (!vim_iswhite(c))
;           {
;               incl(posp);
;               break;
;           }
;       }
    ))

;; Skip count/2 sentences and count/2 separating white spaces.

(defn- #_void findsent_forward [#_long count, #_boolean at_start_sent]
    ;; at_start_sent: cursor is at start of sentence
    (§
;       while (0 < count--)
;       {
;           findsent(FORWARD, 1L);
;           if (at_start_sent)
;               find_first_blank(@curwin.w_cursor);
;           if (count == 0 || at_start_sent)
;               decl(@curwin.w_cursor);
;           at_start_sent = !at_start_sent;
;       }
    ))

;; Find word under cursor, cursor at end.
;; Used while an operator is pending, and in Visual mode.

(defn- #_boolean current_word [#_oparg_C oap, #_long count, #_boolean include, #_boolean bigword]
    ;; include: true: include word and white space
    ;; bigword: false == word, true == WORD
    (§
;       boolean inclusive = true;
;       boolean include_white = false;

;       @cls_bigword = bigword;

;       pos_C start_pos = §_pos_C();

        ;; Correct cursor when 'selection' is exclusive.
;       if (@VIsual_active && @p_sel.at(0) == (byte)'e' && ltpos(@VIsual, @curwin.w_cursor))
;           dec_cursor();

        ;; When Visual mode is not active, or when the VIsual area is only one
        ;; character, select the word and/or white space under the cursor.

;       if (!@VIsual_active || eqpos(@curwin.w_cursor, @VIsual))
;       {
            ;; Go to start of current word or white space.

;           back_in_line();
;           COPY_pos(start_pos, @curwin.w_cursor);

            ;; If the start is on white space, and white space should be included
            ;; ("   word"), or start is not on white space, and white space should
            ;; not be included ("word"), find end of word.

;           if ((cls() == 0) == include)
;           {
;               if (end_word(1L, bigword, true, true) == false)
;                   return false;
;           }
;           else
;           {
                ;; If the start is not on white space, and white space should be included ("word   "),
                ;; or start is on white space and white space should not be included ("   "),
                ;; find start of word.
                ;; If we end up in the first column of the next line (single char word)
                ;; back up to end of the line.

;               fwd_word(1L, bigword, true);
;               if (@curwin.w_cursor.col == 0)
;                   decl(@curwin.w_cursor);
;               else
;                   oneleft();

;               if (include)
;                   include_white = true;
;           }

;           if (@VIsual_active)
;           {
                ;; should do something when inclusive == false !
;               COPY_pos(@VIsual, start_pos);
;               redraw_curbuf_later(INVERTED);      ;; update the inversion
;           }
;           else
;           {
;               COPY_pos(oap.op_start, start_pos);
;               oap.motion_type = MCHAR;
;           }
;           --count;
;       }

        ;; When count is still > 0, extend with more objects.

;       while (0 < count)
;       {
;           inclusive = true;
;           if (@VIsual_active && ltpos(@curwin.w_cursor, @VIsual))
;           {
                ;; In Visual mode, with cursor at start: move cursor back.

;               if (decl(@curwin.w_cursor) == -1)
;                   return false;

;               if (include != (cls() != 0))
;               {
;                   if (bck_word(1L, bigword, true) == false)
;                       return false;
;               }
;               else
;               {
;                   if (bckend_word(1L, bigword, true) == false)
;                       return false;
;                   incl(@curwin.w_cursor);
;               }
;           }
;           else
;           {
                ;; Move cursor forward one word and/or white area.

;               if (incl(@curwin.w_cursor) == -1)
;                   return false;

;               if (include != (cls() == 0))
;               {
;                   if (fwd_word(1L, bigword, true) == false && 1 < count)
;                       return false;

                    ;; If end is just past a new-line,
                    ;; we don't want to include the first character on the line.
                    ;; Put cursor on last char of white.

;                   if (oneleft() == false)
;                       inclusive = false;
;               }
;               else
;               {
;                   if (end_word(1L, bigword, true, true) == false)
;                       return false;
;               }
;           }
;           --count;
;       }

;       if (include_white && (cls() != 0 || (@curwin.w_cursor.col == 0 && !inclusive)))
;       {
            ;; If we don't include white space at the end, move the start to include
            ;; some white space there.  This makes "daw" work better on the last word in
            ;; a sentence (and "2daw" on last-but-one word).  Also when "2daw" deletes
            ;; "word." at the end of the line (cursor is at start of next line).
            ;; But don't delete white space at start of line (indent).

;           pos_C pos = §_pos_C();
;           COPY_pos(pos, @curwin.w_cursor); ;; save cursor position
;           COPY_pos(@curwin.w_cursor, start_pos);
;           if (oneleft() == true)
;           {
;               back_in_line();
;               if (cls() == 0 && 0 < @curwin.w_cursor.col)
;               {
;                   if (@VIsual_active)
;                       COPY_pos(@VIsual, @curwin.w_cursor);
;                   else
;                       COPY_pos(oap.op_start, @curwin.w_cursor);
;               }
;           }
;           COPY_pos(@curwin.w_cursor, pos); ;; put cursor back at end
;       }

;       if (@VIsual_active)
;       {
;           if (@p_sel.at(0) == (byte)'e' && inclusive && ltoreq(@VIsual, @curwin.w_cursor))
;               inc_cursor();
;           if (@VIsual_mode == 'V')
;           {
;               @VIsual_mode = 'v';
;               @redraw_cmdline = true;              ;; show mode later
;           }
;       }
;       else
;           oap.inclusive = inclusive;

;       return true;
    ))

;; Find sentence(s) under the cursor, cursor at end.
;; When Visual active, extend it by one or more sentences.

(defn- #_boolean current_sent [#_oparg_C oap, #_long count, #_boolean include]
    (§
;       pos_C start_pos = §_pos_C();
;       COPY_pos(start_pos, @curwin.w_cursor);
;       pos_C pos = §_pos_C();
;       COPY_pos(pos, start_pos);
;       findsent(FORWARD, 1L);      ;; Find start of next sentence.

;       extend:
;       {
            ;; When the Visual area is bigger than one character: Extend it.

;           if (@VIsual_active && !eqpos(start_pos, @VIsual))
;               break extend;

            ;; If the cursor started on a blank, check if it is just before
            ;; the start of the next sentence.

;           while (vim_iswhite(gchar_pos(pos)))
;               incl(pos);

;           boolean start_blank;
;           if (eqpos(pos, @curwin.w_cursor))
;           {
;               start_blank = true;
;               find_first_blank(start_pos);    ;; go back to first blank
;           }
;           else
;           {
;               start_blank = false;
;               findsent(BACKWARD, 1L);
;               COPY_pos(start_pos, @curwin.w_cursor);
;           }

;           long ncount;
;           if (include)
;               ncount = count * 2;
;           else
;           {
;               ncount = count;
;               if (start_blank)
;                   --ncount;
;           }
;           if (0 < ncount)
;               findsent_forward(ncount, true);
;           else
;               decl(@curwin.w_cursor);

;           if (include)
;           {
                ;; If the blank in front of the sentence is included, exclude the
                ;; blanks at the end of the sentence, go back to the first blank.
                ;; If there are no trailing blanks, try to include leading blanks.

;               if (start_blank)
;               {
;                   find_first_blank(@curwin.w_cursor);
;                   if (vim_iswhite(gchar_pos(@curwin.w_cursor)))
;                       decl(@curwin.w_cursor);
;               }
;               else
;               {
;                   if (!vim_iswhite(gchar_cursor()))
;                       find_first_blank(start_pos);
;               }
;           }

;           if (@VIsual_active)
;           {
                ;; Avoid getting stuck with "is" on a single space before a sentence.
;               if (eqpos(start_pos, @curwin.w_cursor))
;                   break extend;
;               if (@p_sel.at(0) == (byte)'e')
;                   @curwin.w_cursor.col++;
;               COPY_pos(@VIsual, start_pos);
;               @VIsual_mode = 'v';
;               redraw_curbuf_later(INVERTED);  ;; update the inversion
;           }
;           else
;           {
                ;; include a newline after the sentence, if there is one
;               if (incl(@curwin.w_cursor) == -1)
;                   oap.inclusive = true;
;               else
;                   oap.inclusive = false;
;               COPY_pos(oap.op_start, start_pos);
;               oap.motion_type = MCHAR;
;           }

;           return true;
;       }

;       if (ltpos(start_pos, @VIsual))
;       {
            ;; Cursor at start of Visual area.
            ;; Find out where we are:
            ;; - in the white space before a sentence
            ;; - in a sentence or just after it
            ;; - at the start of a sentence

;           boolean at_start_sent = true;
;           decl(pos);
;           while (ltpos(pos, @curwin.w_cursor))
;           {
;               if (!vim_iswhite(gchar_pos(pos)))
;               {
;                   at_start_sent = false;
;                   break;
;               }
;               incl(pos);
;           }
;           if (!at_start_sent)
;           {
;               findsent(BACKWARD, 1L);
;               if (eqpos(@curwin.w_cursor, start_pos))
;                   at_start_sent = true;   ;; exactly at start of sentence
;               else
                    ;; inside a sentence, go to its end (start of next)
;                   findsent(FORWARD, 1L);
;           }
;           if (include)                    ;; "as" gets twice as much as "is"
;               count *= 2;
;           while (0 < count--)
;           {
;               if (at_start_sent)
;                   find_first_blank(@curwin.w_cursor);
;               if (!at_start_sent || (!include && !vim_iswhite(gchar_cursor())))
;                   findsent(BACKWARD, 1L);
;               at_start_sent = !at_start_sent;
;           }
;       }
;       else
;       {
            ;; Cursor at end of Visual area.
            ;; Find out where we are:
            ;; - just before a sentence
            ;; - just before or in the white space before a sentence
            ;; - in a sentence

;           incl(pos);
;           boolean at_start_sent = true;
;           if (!eqpos(pos, @curwin.w_cursor))   ;; not just before a sentence
;           {
;               at_start_sent = false;
;               while (ltpos(pos, @curwin.w_cursor))
;               {
;                   if (!vim_iswhite(gchar_pos(pos)))
;                   {
;                       at_start_sent = true;
;                       break;
;                   }
;                   incl(pos);
;               }
;               if (at_start_sent)      ;; in the sentence
;                   findsent(BACKWARD, 1L);
;               else            ;; in/before white before a sentence
;                   COPY_pos(@curwin.w_cursor, start_pos);
;           }

;           if (include)        ;; "as" gets twice as much as "is"
;               count *= 2;
;           findsent_forward(count, at_start_sent);
;           if (@p_sel.at(0) == (byte)'e')
;               @curwin.w_cursor.col++;
;       }

;       return true;
    ))

;; Find block under the cursor, cursor at end.
;; "what" and "other" are two matching parenthesis/brace/etc.

(defn- #_boolean current_block [#_oparg_C oap, #_long count, #_boolean include, #_int what, #_int other]
    ;; include: true == include white space
    ;; what: '(', '{', etc.
    ;; other: ')', '}', etc.
    (§
;       pos_C pos = null;
;       pos_C start_pos = §_pos_C();
;       pos_C end_pos;
;       boolean sol = false;                    ;; '{' at start of line

;       pos_C old_pos = §_pos_C();
;       COPY_pos(old_pos, @curwin.w_cursor);
;       pos_C old_end = §_pos_C();
;       COPY_pos(old_end, @curwin.w_cursor);     ;; remember where we started
;       pos_C old_start = §_pos_C();
;       COPY_pos(old_start, old_end);

        ;; If we start on '(', '{', ')', '}', etc., use the whole block inclusive.

;       if (!@VIsual_active || eqpos(@VIsual, @curwin.w_cursor))
;       {
;           setpcmark();
;           if (what == '{')                    ;; ignore indent
;               while (inindent(1))
;                   if (inc_cursor() != 0)
;                       break;
;           if (gchar_cursor() == what)
                ;; cursor on '(' or '{', move cursor just after it
;               @curwin.w_cursor.col++;
;       }
;       else if (ltpos(@VIsual, @curwin.w_cursor))
;       {
;           COPY_pos(old_start, @VIsual);
;           COPY_pos(@curwin.w_cursor, @VIsual); ;; cursor at low end of Visual
;       }
;       else
;           COPY_pos(old_end, @VIsual);

        ;; Search backwards for unclosed '(', '{', etc..
        ;; Put this position in start_pos.
        ;; Ignore quotes here.  Keep the "M" flag in 'cpo', as that is what the user wants.

;       Bytes save_cpo = @p_cpo;
;       @p_cpo = (vim_strbyte(@p_cpo, CPO_MATCHBSL) != null) ? u8("%M") : u8("%");
;       while (0 < count--)
;       {
;           if ((pos = findmatch(null, what)) == null)
;               break;
;           COPY_pos(@curwin.w_cursor, pos);
;           COPY_pos(start_pos, pos); ;; the findmatch for end_pos will overwrite *pos
;       }
;       @p_cpo = save_cpo;

        ;; Search for matching ')', '}', etc.
        ;; Put this position in curwin.w_cursor.

;       if (pos == null || (end_pos = findmatch(null, other)) == null)
;       {
;           COPY_pos(@curwin.w_cursor, old_pos);
;           return false;
;       }
;       COPY_pos(@curwin.w_cursor, end_pos);

        ;; Try to exclude the '(', '{', ')', '}', etc. when "include" is false.
        ;; If the ending '}', ')' or ']' is only preceded by indent, skip that indent.
        ;; But only if the resulting area is not smaller than what we started with.

;       while (!include)
;       {
;           incl(start_pos);
;           sol = (@curwin.w_cursor.col == 0);
;           decl(@curwin.w_cursor);
;           while (inindent(1))
;           {
;               sol = true;
;               if (decl(@curwin.w_cursor) != 0)
;                   break;
;           }

            ;; In Visual mode, when the resulting area is not bigger than what we
            ;; started with, extend it to the next block, and then exclude again.

;           if (!ltpos(start_pos, old_start) && !ltpos(old_end, @curwin.w_cursor) && @VIsual_active)
;           {
;               COPY_pos(@curwin.w_cursor, old_start);
;               decl(@curwin.w_cursor);
;               if ((pos = findmatch(null, what)) == null)
;               {
;                   COPY_pos(@curwin.w_cursor, old_pos);
;                   return false;
;               }
;               COPY_pos(start_pos, pos);
;               COPY_pos(@curwin.w_cursor, pos);
;               if ((end_pos = findmatch(null, other)) == null)
;               {
;                   COPY_pos(@curwin.w_cursor, old_pos);
;                   return false;
;               }
;               COPY_pos(@curwin.w_cursor, end_pos);
;           }
;           else
;               break;
;       }

;       if (@VIsual_active)
;       {
;           if (@p_sel.at(0) == (byte)'e')
;               @curwin.w_cursor.col++;
;           if (sol && gchar_cursor() != NUL)
;               incp(@curwin.w_cursor);               ;; include the line break
;           COPY_pos(@VIsual, start_pos);
;           @VIsual_mode = 'v';
;           redraw_curbuf_later(INVERTED);          ;; update the inversion
;           showmode();
;       }
;       else
;       {
;           COPY_pos(oap.op_start, start_pos);
;           oap.motion_type = MCHAR;
;           oap.inclusive = false;
;           if (sol)
;               incl(@curwin.w_cursor);
;           else if (ltoreq(start_pos, @curwin.w_cursor))
                ;; Include the character under the cursor.
;               oap.inclusive = true;
;           else
                ;; End is before the start (no text in between <>, [], etc.): don't operate on any text.
;               COPY_pos(@curwin.w_cursor, start_pos);
;       }

;       return true;
    ))

;; Return true if the cursor is on a "<aaa>" tag.  Ignore "<aaa/>".
;; When "end_tag" is true return true if the cursor is on "</aaa>".

(defn- #_boolean in_html_tag [#_boolean end_tag]
    (§
;       Bytes line = ml_get_curline();

;       Bytes p = line.plus(@curwin.w_cursor.col);
;       while (BLT(line, p))
;       {
;           if (p.at(0) == (byte)'<')      ;; find '<' under/before cursor
;               break;
;           p = p.minus(us_ptr_back(line, p));
;           if (p.at(0) == (byte)'>')      ;; find '>' before cursor
;               break;
;       }
;       if (p.at(0) != (byte)'<')
;           return false;

;       pos_C pos = §_pos_C();
;       pos.lnum = @curwin.w_cursor.lnum;
;       pos.col = BDIFF(p, line);

;       p = p.plus(us_ptr2len_cc(p));
;       if (end_tag)
;       {
            ;; check that there is a '/' after the '<'
;           return (p.at(0) == (byte)'/');
;       }

        ;; check that there is no '/' after the '<'
;       if (p.at(0) == (byte)'/')
;           return false;

;       byte lc = NUL;

        ;; check that the matching '>' is not preceded by '/'
;       for ( ; ; )
;       {
;           if (incp(pos) < 0)
;               return false;
;           byte c = ml_get_pos(pos).at(0);
;           if (c == '>')
;               break;
;           lc = c;
;       }

;       return (lc != '/');
    ))

(defn- #_boolean current_par [#_oparg_C oap, #_long count, #_boolean include, #_int type]
    ;; include: true == include white space
    ;; type: 'p' for paragraph, 'S' for section
    (§
;       if (type == 'S')        ;; not implemented yet
;           return false;

;       long start_lnum = @curwin.w_cursor.lnum;

;       extend:
;       {
            ;; When visual area is more than one line: extend it.

;           if (@VIsual_active && start_lnum != @VIsual.lnum)
;               break extend;

            ;; First move back to the start_lnum of the paragraph or white lines

;           boolean white_in_front = linewhite(start_lnum);
;           while (1 < start_lnum)
;           {
;               if (white_in_front)         ;; stop at first white line
;               {
;                   if (!linewhite(start_lnum - 1))
;                       break;
;               }
;               else            ;; stop at first non-white line of start of paragraph
;               {
;                   if (linewhite(start_lnum - 1) || startPS(start_lnum, NUL, false))
;                       break;
;               }
;               --start_lnum;
;           }

            ;; Move past the end of any white lines.

;           long end_lnum = start_lnum;
;           while (end_lnum <= @curbuf.b_ml.ml_line_count && linewhite(end_lnum))
;               end_lnum++;

;           boolean do_white = false;

;           --end_lnum;
;           int i = (int)count;
;           if (!include && white_in_front)
;               --i;
;           while (0 < i--)
;           {
;               if (end_lnum == @curbuf.b_ml.ml_line_count)
;                   return false;

;               if (!include)
;                   do_white = linewhite(end_lnum + 1);

;               if (include || !do_white)
;               {
;                   end_lnum++;

                    ;; skip to end of paragraph

;                   while (end_lnum < @curbuf.b_ml.ml_line_count
;                           && !linewhite(end_lnum + 1)
;                           && !startPS(end_lnum + 1, NUL, false))
;                       end_lnum++;
;               }

;               if (i == 0 && white_in_front && include)
;                   break;

                ;; skip to end of white lines after paragraph

;               if (include || do_white)
;                   while (end_lnum < @curbuf.b_ml.ml_line_count && linewhite(end_lnum + 1))
;                       end_lnum++;
;           }

            ;; If there are no empty lines at the end, try to find some empty lines
            ;; at the start (unless that has been already done).

;           if (!white_in_front && !linewhite(end_lnum) && include)
;               while (1 < start_lnum && linewhite(start_lnum - 1))
;                   --start_lnum;

;           if (@VIsual_active)
;           {
                ;; Problem: when doing "Vipipip" nothing happens in a single white line,
                ;; we get stuck there.  Trap this here.
;               if (@VIsual_mode == 'V' && start_lnum == @curwin.w_cursor.lnum)
;                   break extend;
;               @VIsual.lnum = start_lnum;
;               @VIsual_mode = 'V';
;               redraw_curbuf_later(INVERTED);  ;; update the inversion
;               showmode();
;           }
;           else
;           {
;               oap.op_start.lnum = start_lnum;
;               oap.op_start.col = 0;
;               oap.motion_type = MLINE;
;           }

;           @curwin.w_cursor.lnum = end_lnum;
;           @curwin.w_cursor.col = 0;

;           return true;
;       }

;       boolean retval = true;
;       int dir = (start_lnum < @VIsual.lnum) ? BACKWARD : FORWARD;

;       for (int i = (int)count; 0 <= --i; )
;       {
;           if (start_lnum == (dir == BACKWARD ? 1 : @curbuf.b_ml.ml_line_count))
;           {
;               retval = false;
;               break;
;           }

;           int prev_start_is_white = -1;
;           for (int t = 0; t < 2; t++)
;           {
;               start_lnum += dir;
;               boolean start_is_white = linewhite(start_lnum);
;               if (prev_start_is_white == (start_is_white ? 1 : 0))
;               {
;                   start_lnum -= dir;
;                   break;
;               }
;               for ( ; ; )
;               {
;                   if (start_lnum == (dir == BACKWARD ? 1 : @curbuf.b_ml.ml_line_count))
;                       break;
;                   if (start_is_white != linewhite(start_lnum + dir)
;                           || (!start_is_white && startPS(start_lnum + (0 < dir ? 1 : 0), NUL, false)))
;                       break;
;                   start_lnum += dir;
;               }
;               if (!include)
;                   break;
;               if (start_lnum == (dir == BACKWARD ? 1 : @curbuf.b_ml.ml_line_count))
;                   break;
;               prev_start_is_white = start_is_white ? 1 : 0;
;           }
;       }

;       @curwin.w_cursor.lnum = start_lnum;
;       @curwin.w_cursor.col = 0;

;       return retval;
    ))

;; Search quote char from string line[col].
;; Quote character escaped by one of the characters in "escape" is not counted as a quote.
;; Returns column number of "quotechar" or -1 when not found.

(defn- #_int find_next_quote [#_Bytes line, #_int col, #_int quotechar, #_Bytes escape]
    ;; escape: escape characters, can be null
    (§
;       for ( ; ; )
;       {
;           int c = line.at(col);
;           if (c == NUL)
;               return -1;
;           else if (escape != null && vim_strchr(escape, c) != null)
;               col++;
;           else if (c == quotechar)
;               break;
;           col += us_ptr2len_cc(line.plus(col));
;       }
;       return col;
    ))

;; Search backwards in "line" from column "col_start" to find "quotechar".
;; Quote character escaped by one of the characters in "escape" is not counted as a quote.
;; Return the found column or zero.

(defn- #_int find_prev_quote [#_Bytes line, #_int col_start, #_int quotechar, #_Bytes escape]
    ;; escape: escape characters, can be null
    (§
;       int n;

;       while (0 < col_start)
;       {
;           --col_start;
;           col_start -= us_head_off(line, line.plus(col_start));
;           n = 0;
;           if (escape != null)
;               while (0 < col_start - n && vim_strchr(escape, line.at(col_start - n - 1)) != null)
;                   n++;
;           if ((n & 1) != 0)
;               col_start -= n;     ;; uneven number of escape chars, skip it
;           else if (line.at(col_start) == quotechar)
;               break;
;       }
;       return col_start;
    ))

;; Find quote under the cursor, cursor at end.
;; Returns true if found, else false.

(defn- #_boolean current_quote [#_oparg_C oap, #_long count, #_boolean include, #_int quotechar]
    ;; include: true == include quote char
    ;; quotechar: Quote character
    (§
;       Bytes line = ml_get_curline();
;       int col_end;
;       int col_start = @curwin.w_cursor.col;

;       boolean inclusive = false;
;       boolean vis_empty = true;           ;; Visual selection <= 1 char
;       boolean vis_bef_curs = false;       ;; Visual starts before cursor
;       boolean inside_quotes = false;      ;; Looks like "i'" done before
;       boolean selected_quote = false;     ;; Has quote inside selection

        ;; Correct cursor when 'selection' is exclusive.
;       if (@VIsual_active)
;       {
;           vis_bef_curs = ltpos(@VIsual, @curwin.w_cursor);
;           if (@p_sel.at(0) == (byte)'e' && vis_bef_curs)
;               dec_cursor();
;           vis_empty = eqpos(@VIsual, @curwin.w_cursor);
;       }

;       if (!vis_empty)
;       {
;           int i;
            ;; Check if the existing selection exactly spans the text inside quotes.
;           if (vis_bef_curs)
;           {
;               inside_quotes = 0 < @VIsual.col
;                           && line.at(@VIsual.col - 1) == quotechar
;                           && line.at(@curwin.w_cursor.col) != NUL
;                           && line.at(@curwin.w_cursor.col + 1) == quotechar;
;               i = @VIsual.col;
;               col_end = @curwin.w_cursor.col;
;           }
;           else
;           {
;               inside_quotes = 0 < @curwin.w_cursor.col
;                           && line.at(@curwin.w_cursor.col - 1) == quotechar
;                           && line.at(@VIsual.col) != NUL
;                           && line.at(@VIsual.col + 1) == quotechar;
;               i = @curwin.w_cursor.col;
;               col_end = @VIsual.col;
;           }

            ;; Find out if we have a quote in the selection.
;           while (i <= col_end)
;               if (line.at(i++) == quotechar)
;               {
;                   selected_quote = true;
;                   break;
;               }
;       }

;       if (!vis_empty && line.at(col_start) == quotechar)
;       {
            ;; Already selecting something and on a quote character.
            ;; Find the next quoted string.
;           if (vis_bef_curs)
;           {
                ;; Assume we are on a closing quote: move to after the next opening quote.
;               col_start = find_next_quote(line, col_start + 1, quotechar, null);
;               if (col_start < 0)
;                   return false;
;               col_end = find_next_quote(line, col_start + 1, quotechar, @curbuf.@b_p_qe);
;               if (col_end < 0)
;               {
                    ;; We were on a starting quote perhaps?
;                   col_end = col_start;
;                   col_start = @curwin.w_cursor.col;
;               }
;           }
;           else
;           {
;               col_end = find_prev_quote(line, col_start, quotechar, null);
;               if (line.at(col_end) != quotechar)
;                   return false;
;               col_start = find_prev_quote(line, col_end, quotechar, @curbuf.@b_p_qe);
;               if (line.at(col_start) != quotechar)
;               {
                    ;; We were on an ending quote perhaps?
;                   col_start = col_end;
;                   col_end = @curwin.w_cursor.col;
;               }
;           }
;       }
;       else

;       if (line.at(col_start) == quotechar || !vis_empty)
;       {
;           int first_col = col_start;

;           if (!vis_empty)
;           {
;               if (vis_bef_curs)
;                   first_col = find_next_quote(line, col_start, quotechar, null);
;               else
;                   first_col = find_prev_quote(line, col_start, quotechar, null);
;           }

            ;; The cursor is on a quote, we don't know if it's the opening or
            ;; closing quote.  Search from the start of the line to find out.
            ;; Also do this when there is a Visual area, a' may leave the cursor
            ;; in between two strings.
;           col_start = 0;
;           for ( ; ; )
;           {
                ;; Find open quote character.
;               col_start = find_next_quote(line, col_start, quotechar, null);
;               if (col_start < 0 || first_col < col_start)
;                   return false;
                ;; Find close quote character.
;               col_end = find_next_quote(line, col_start + 1, quotechar, @curbuf.@b_p_qe);
;               if (col_end < 0)
;                   return false;
                ;; If is cursor between start and end quote character,
                ;; it is target text object.
;               if (col_start <= first_col && first_col <= col_end)
;                   break;
;               col_start = col_end + 1;
;           }
;       }
;       else
;       {
            ;; Search backward for a starting quote.
;           col_start = find_prev_quote(line, col_start, quotechar, @curbuf.@b_p_qe);
;           if (line.at(col_start) != quotechar)
;           {
                ;; No quote before the cursor, look after the cursor.
;               col_start = find_next_quote(line, col_start, quotechar, null);
;               if (col_start < 0)
;                   return false;
;           }

            ;; Find close quote character.
;           col_end = find_next_quote(line, col_start + 1, quotechar, @curbuf.@b_p_qe);
;           if (col_end < 0)
;               return false;
;       }

        ;; When "include" is true,
        ;; include spaces after closing quote or before the starting quote.
;       if (include)
;       {
;           if (vim_iswhite(line.at(col_end + 1)))
;               while (vim_iswhite(line.at(col_end + 1)))
;                   col_end++;
;           else
;               while (0 < col_start && vim_iswhite(line.at(col_start - 1)))
;                   --col_start;
;       }

        ;; Set start position.  After vi" another i" must include the ".
        ;; For v2i" include the quotes.
;       if (!include && count < 2 && (vis_empty || !inside_quotes))
;           col_start++;
;       @curwin.w_cursor.col = col_start;
;       if (@VIsual_active)
;       {
            ;; Set the start of the Visual area when the Visual area was empty, we
            ;; were just inside quotes or the Visual area didn't start at a quote
            ;; and didn't include a quote.

;           if (vis_empty
;                   || (vis_bef_curs
;                       && !selected_quote
;                       && (inside_quotes
;                           || (line.at(@VIsual.col) != quotechar
;                               && (@VIsual.col == 0
;                                   || line.at(@VIsual.col - 1) != quotechar)))))
;           {
;               COPY_pos(@VIsual, @curwin.w_cursor);
;               redraw_curbuf_later(INVERTED);
;           }
;       }
;       else
;       {
;           COPY_pos(oap.op_start, @curwin.w_cursor);
;           oap.motion_type = MCHAR;
;       }

        ;; Set end position.
;       @curwin.w_cursor.col = col_end;
        ;; After vi" another i" must include the ".
;       if ((include || 1 < count || (!vis_empty && inside_quotes)) && inc_cursor() == 2)
;           inclusive = true;
;       if (@VIsual_active)
;       {
;           if (vis_empty || vis_bef_curs)
;           {
                ;; decrement cursor when 'selection' is not exclusive
;               if (@p_sel.at(0) != (byte)'e')
;                   dec_cursor();
;           }
;           else
;           {
                ;; Cursor is at start of Visual area.  Set the end of the Visual area
                ;; when it was just inside quotes or it didn't end at a quote.
;               if (inside_quotes
;                       || (!selected_quote
;                           && line.at(@VIsual.col) != quotechar
;                           && (line.at(@VIsual.col) == NUL
;                               || line.at(@VIsual.col + 1) != quotechar)))
;               {
;                   dec_cursor();
;                   COPY_pos(@VIsual, @curwin.w_cursor);
;               }
;               @curwin.w_cursor.col = col_start;
;           }
;           if (@VIsual_mode == 'V')
;           {
;               @VIsual_mode = 'v';
;               @redraw_cmdline = true;              ;; show mode later
;           }
;       }
;       else
;       {
            ;; Set inclusive and other oap's flags.
;           oap.inclusive = inclusive;
;       }

;       return true;
    ))

;; Find next search match under cursor, cursor at end.
;; Used while an operator is pending, and in Visual mode.

(defn- #_boolean current_search [#_long count, #_boolean forward]
    ;; forward: move forward or backwards
    (§
;       pos_C save_VIsual = §_pos_C();
;       COPY_pos(save_VIsual, @VIsual);

        ;; wrapping should not occur
;       boolean old_p_ws = @p_ws;
;       @p_ws = false;

        ;; Correct cursor when 'selection' is exclusive.
;       if (@VIsual_active && @p_sel.at(0) == (byte)'e' && ltpos(@VIsual, @curwin.w_cursor))
;           dec_cursor();

;       pos_C orig_pos = §_pos_C();       ;; position of the cursor at beginning
;       COPY_pos(orig_pos, @curwin.w_cursor);
;       pos_C pos = §_pos_C();            ;; position after the pattern
;       COPY_pos(pos, @curwin.w_cursor);
;       pos_C start_pos = §_pos_C();      ;; position before the pattern
;       COPY_pos(start_pos, @curwin.w_cursor);

;       if (@VIsual_active)
;       {
;           COPY_pos(start_pos, @VIsual);

            ;; make sure, searching further will extend the match
;           if (@VIsual_active)
;           {
;               if (forward)
;                   incl(pos);
;               else
;                   decl(pos);
;           }
;       }

        ;; Is the pattern is zero-width?
;       int one_char = is_one_char(@spats[@last_idx].pat, true);
;       if (one_char == -1)
;       {
;           @p_ws = old_p_ws;
;           return false;                   ;; pattern not found
;       }

        ;; The trick is to first search backwards and then search forward again,
        ;; so that a match at the current cursor position will be correctly captured.

;       for (int round = 0; round < 2; round++)
;       {
;           boolean dir = forward ? (round != 0) : (round == 0);

;           int flags = 0;
;           if (!dir && one_char == 0)
;               flags = SEARCH_END;

;           int result = searchit(@curwin, @curbuf, pos, (dir ? FORWARD : BACKWARD),
;                           @spats[@last_idx].pat, (round != 0) ? count : 1,
;                               SEARCH_KEEP | flags, RE_SEARCH, 0, null);

            ;; First search may fail, but then start searching from the beginning of
            ;; the file (cursor might be on the search match) except when Visual mode
            ;; is active, so that extending the visual selection works.
;           if (result == 0)
;           {
;               if (round != 0)     ;; not found, abort
;               {
;                   COPY_pos(@curwin.w_cursor, orig_pos);
;                   if (@VIsual_active)
;                       COPY_pos(@VIsual, save_VIsual);
;                   @p_ws = old_p_ws;
;                   return false;
;               }

;               if (forward)        ;; try again from start of buffer
;               {
;                   clearpos(pos);
;               }
;               else                ;; try again from end of buffer
;               {
                    ;; searching backwards, so set pos to last line and col
;                   pos.lnum = @curwin.w_buffer.b_ml.ml_line_count;
;                   pos.col  = STRLEN(ml_get(@curwin.w_buffer.b_ml.ml_line_count));
;               }
;           }
;           @p_ws = old_p_ws;
;       }

;       COPY_pos(start_pos, pos);
;       int flags = forward ? SEARCH_END : 0;

        ;; Check again from the current cursor position,
        ;; since the next match might actually be only one char wide.
;       one_char = is_one_char(@spats[@last_idx].pat, false);

        ;; Move to match, except for zero-width matches,
        ;; in which case, we are already on the next match.
;       if (one_char == 0)
;           searchit(@curwin, @curbuf, pos, (forward ? FORWARD : BACKWARD),
;               @spats[@last_idx].pat, 0L, flags | SEARCH_KEEP, RE_SEARCH, 0, null);

;       if (!@VIsual_active)
;           COPY_pos(@VIsual, start_pos);

;       COPY_pos(@curwin.w_cursor, pos);
;       @VIsual_active = true;
;       @VIsual_mode = 'v';

;       if (@VIsual_active)
;       {
;           redraw_curbuf_later(INVERTED);  ;; update the inversion
;           if (@p_sel.at(0) == (byte)'e')
;           {
                ;; Correction for exclusive selection depends on the direction.
;               if (forward && ltoreq(@VIsual, @curwin.w_cursor))
;                   inc_cursor();
;               else if (!forward && ltoreq(@curwin.w_cursor, @VIsual))
;                   incp(@VIsual);
;           }
;       }

;       may_start_select('c');
;       setmouse();
        ;; Make sure the clipboard gets updated.  Needed because start and
        ;; end are still the same, and the selection needs to be owned.
;       @clip_star.vmode = NUL;
;       redraw_curbuf_later(INVERTED);
;       showmode();

;       return true;
    ))

;; Check if the pattern is one character or zero-width.
;; If move is true, check from the beginning of the buffer, else from the current cursor position.
;; Returns true, false or -1 for failure.

(defn- #_int is_one_char [#_Bytes pattern, #_boolean move]
    (§
;       int result = -1;

;       boolean save_called_emsg = @called_emsg;

;       regmmatch_C regmatch = §_regmmatch_C();
;       if (search_regcomp(pattern, RE_SEARCH, RE_SEARCH, SEARCH_KEEP, regmatch) == false)
;           return -1;

;       pos_C pos = §_pos_C();
;       int flag = 0;
        ;; move to match
;       if (!move)
;       {
;           COPY_pos(pos, @curwin.w_cursor);
            ;; accept a match at the cursor position
;           flag = SEARCH_START;
;       }

;       if (searchit(@curwin, @curbuf, pos, FORWARD, @spats[@last_idx].pat, 1, SEARCH_KEEP + flag, RE_SEARCH, 0, null) != 0)
;       {
            ;; Zero-width pattern should match somewhere,
            ;; then we can check if start and end are in the same position.
;           @called_emsg = false;
;           long nmatched = vim_regexec_multi(regmatch, @curwin, @curbuf, pos.lnum, 0, null);

;           if (!@called_emsg)
;               result = (nmatched != 0
;                   && regmatch.startpos[0].lnum == regmatch.endpos[0].lnum
;                    && regmatch.startpos[0].col == regmatch.endpos[0].col) ? TRUE : FALSE;

;           if (result == FALSE && 0 <= incp(pos) && pos.col == regmatch.endpos[0].col)
;               result = TRUE;
;       }

;       @called_emsg |= save_called_emsg;

;       return result;
    ))

;; return true if line 'lnum' is empty or has white chars only.

(defn- #_boolean linewhite [#_long lnum]
    (§
;       Bytes p = skipwhite(ml_get(lnum));
;       return (p.at(0) == NUL);
    ))

;; memfile.c: Contains the functions for handling blocks of memory which can
;; be stored in a file.  This is the implementation of a sort of virtual memory.
;;
;; A memfile consists of a sequence of blocks.  The blocks numbered from 0
;; upwards have been assigned a place in the actual file.  The block number
;; is equal to the page number in the file.
;;
;; The blocks with negative numbers are currently in memory only.  They can be
;; assigned a place in the file when too much memory is being used.  At that
;; moment they get a new, positive, number.  A list is used for translation of
;; negative to positive numbers.
;;
;; The size of a block is a multiple of a page size, normally the page size of
;; the device the file is on. Most blocks are 1 page long.  A block of multiple
;; pages is used for a line that does not fit in a single page.
;;
;; Each block can be in memory and/or in a file.  The block stays in memory
;; as long as it is locked.  If it is no longer locked it can be swapped out to
;; the file.  It is only written to the file if it has been changed.
;;
;; Under normal operation the file is created when opening the memory file and
;; deleted when closing the memory file.  Only with recovery an existing memory
;; file is opened.

(final int MEMFILE_PAGE_SIZE 4096)  ;; default page size

;; The functions for using a memfile:
;;
;; mf_open()        open a new or existing memfile
;; mf_close()       close a memfile
;; mf_new()         create a new block in a memfile and lock it
;; mf_get()         get an existing block and lock it
;; mf_put()         unlock a block, may be marked for writing
;; mf_free()        remove a block
;; mf_trans_del()   may translate negative to positive block number

(defn- #_memfile_C mf_open []
    (§
;       memfile_C mfp = §_memfile_C();

;       mfp.mf_used_first = null;       ;; used list is empty
;       mfp.mf_used_last = null;
;       mf_hash_init(mfp.mf_hash);
;       mf_hash_init(mfp.mf_trans);

;       mfp.mf_blocknr_max = 0;         ;; no file or empty file
;       mfp.mf_blocknr_min = -1;
;       mfp.mf_neg_count = 0;

;       return mfp;
    ))

(defn- #_void mf_close [#_memfile_C mfp]
    (§
;       mf_hash_free(mfp.mf_hash);
;       mf_hash_free(mfp.mf_trans);     ;; free hashtable and its items
    ))

;; get a new block
;;
;;   negative: true if negative block number desired (data block)

(defn- #_block_hdr_C mf_new [#_memfile_C mfp, #_boolean negative, #_Object data, #_int page_count]
    (§
;       block_hdr_C hp = mf_alloc_bhdr(mfp, data, page_count);

        ;; Use mf_block_min for a negative number, mf_block_max for a positive number.
;       if (negative)
;       {
;           hp.bh_bnum(mfp.mf_blocknr_min--);
;           mfp.mf_neg_count++;
;       }
;       else
;       {
;           hp.bh_bnum(mfp.mf_blocknr_max);
;           mfp.mf_blocknr_max += page_count;
;       }

;       hp.bh_flags = BH_LOCKED | BH_DIRTY;     ;; new block is always dirty
;       hp.bh_page_count = page_count;
;       mf_ins_used(mfp, hp);
;       mf_ins_hash(mfp, hp);

;       return hp;
    ))

;; Get existing block "nr" with "page_count" pages.
;;
;; Note: The caller should first check a negative nr with mf_trans_del().

(defn- #_block_hdr_C mf_get [#_memfile_C mfp, #_long nr, #_int _page_count]
    (§
;       if (mfp.mf_blocknr_max <= nr || nr <= mfp.mf_blocknr_min)   ;; doesn't exist
;           return null;

;       block_hdr_C hp = mf_find_hash(mfp, nr);
;       if (hp == null)                                 ;; not in the hash list
;           return null;

;       mf_rem_used(mfp, hp);           ;; remove from list, insert in front below
;       mf_rem_hash(mfp, hp);

;       hp.bh_flags |= BH_LOCKED;
;       mf_ins_used(mfp, hp);           ;; put in front of used list
;       mf_ins_hash(mfp, hp);           ;; put in front of hash list

;       return hp;
    ))

;; release the block *hp
;;
;;   dirty: Block must be written to file later
;;   infile: Block should be in file (needed for recovery)

(defn- #_void mf_put [#_memfile_C mfp, #_block_hdr_C hp, #_boolean dirty, #_boolean infile]
    (§
;       byte flags = hp.bh_flags;

;       if ((flags & BH_LOCKED) == 0)
;           emsg(u8("E293: block was not locked"));
;       flags &= ~BH_LOCKED;
;       if (dirty)
;           flags |= BH_DIRTY;
;       hp.bh_flags = flags;
;       if (infile)
;           mf_trans_add(mfp, hp);      ;; may translate negative in positive nr
    ))

;; block *hp is no longer in used, may put it in the free list of memfile *mfp

(defn- #_void mf_free [#_memfile_C mfp, #_block_hdr_C hp]
    (§
;       mf_rem_hash(mfp, hp);       ;; get *hp out of the hash list
;       mf_rem_used(mfp, hp);       ;; get *hp out of the used list
;       if (hp.bh_bnum() < 0)
;           mfp.mf_neg_count--;
    ))

;; insert block *hp in front of hashlist of memfile *mfp

(defn- #_void mf_ins_hash [#_memfile_C mfp, #_block_hdr_C hp]
    (§
;       mf_hash_add_item(mfp.mf_hash, hp.bh_hashitem);
    ))

;; remove block *hp from hashlist of memfile list *mfp

(defn- #_void mf_rem_hash [#_memfile_C mfp, #_block_hdr_C hp]
    (§
;       mf_hash_rem_item(mfp.mf_hash, hp.bh_hashitem);
    ))

;; look in hash lists of memfile *mfp for block header with number 'nr'

(defn- #_block_hdr_C mf_find_hash [#_memfile_C mfp, #_long nr]
    (§
;       mf_hashitem_C mhi = mf_hash_find(mfp.mf_hash, nr);

;       return (mhi != null) ? (block_hdr_C)mhi.mhi_data : null;
    ))

;; insert block *hp in front of used list of memfile *mfp

(defn- #_void mf_ins_used [#_memfile_C mfp, #_block_hdr_C hp]
    (§
;       hp.bh_next = mfp.mf_used_first;
;       mfp.mf_used_first = hp;
;       hp.bh_prev = null;
;       if (hp.bh_next == null)     ;; list was empty, adjust last pointer
;           mfp.mf_used_last = hp;
;       else
;           hp.bh_next.bh_prev = hp;
    ))

;; remove block *hp from used list of memfile *mfp

(defn- #_void mf_rem_used [#_memfile_C mfp, #_block_hdr_C hp]
    (§
;       if (hp.bh_next == null)     ;; last block in used list
;           mfp.mf_used_last = hp.bh_prev;
;       else
;           hp.bh_next.bh_prev = hp.bh_prev;
;       if (hp.bh_prev == null)     ;; first block in used list
;           mfp.mf_used_first = hp.bh_next;
;       else
;           hp.bh_prev.bh_next = hp.bh_next;
    ))

;; Allocate a block header and a block of memory for it.

(defn- #_block_hdr_C mf_alloc_bhdr [#_memfile_C _mfp, #_Object data, #_int page_count]
    (§
;       block_hdr_C hp = §_block_hdr_C();

;       hp.bh_data = data;
;       hp.bh_page_count = page_count;

;       return hp;
    ))

;; Make block number for *hp positive and add it to the translation list.

(defn- #_void mf_trans_add [#_memfile_C mfp, #_block_hdr_C hp]
    (§
;       if (hp.bh_bnum() < 0)
;       {
            ;; Get a new number for the block.
;           long new_bnum = mfp.mf_blocknr_max;
;           mfp.mf_blocknr_max += hp.bh_page_count;

;           nr_trans_C np = §_nr_trans_C();

;           np.nt_old_bnum(hp.bh_bnum());       ;; adjust number
;           np.nt_new_bnum = new_bnum;

;           mf_rem_hash(mfp, hp);               ;; remove from old hash list
;           hp.bh_bnum(new_bnum);
;           mf_ins_hash(mfp, hp);               ;; insert in new hash list

            ;; Insert "np" into "mf_trans" hashtable with key "np.nt_old_bnum".
;           mf_hash_add_item(mfp.mf_trans, np.nt_hashitem);
;       }
    ))

;; Lookup a translation from the trans lists and delete the entry.
;;
;; Return the positive new number when found, the old number when not found.

(defn- #_long mf_trans_del [#_memfile_C mfp, #_long old_nr]
    (§
;       mf_hashitem_C mhi = mf_hash_find(mfp.mf_trans, old_nr);
;       nr_trans_C np = (mhi != null) ? (nr_trans_C)mhi.mhi_data : null;

;       if (np == null)             ;; not found
;           return old_nr;

;       mfp.mf_neg_count--;
;       long new_bnum = np.nt_new_bnum;

        ;; remove entry from the trans list
;       mf_hash_rem_item(mfp.mf_trans, np.nt_hashitem);

;       return new_bnum;
    ))

;; Implementation of mf_hashtab_C follows.

;; The number of buckets in the hashtable is increased by a factor of MHT_GROWTH_FACTOR
;; when the average number of items per bucket exceeds (2 ^ MHT_LOG_LOAD_FACTOR).

(final int MHT_LOG_LOAD_FACTOR 6)
(final int MHT_GROWTH_FACTOR   2)   ;; must be a power of two

;; Initialize an empty hash table.

(defn- #_void mf_hash_init [#_mf_hashtab_C mht]
    (§
;       ZER0_mf_hashtab(mht);
;       mht.mht_buckets = ARRAY_mf_hashitem(MHT_INIT_SIZE);
;       mht.mht_mask = MHT_INIT_SIZE - 1;
    ))

;; Free the array of a hash table.  Does not free the items it contains!
;; The hash table must not be used again without another mf_hash_init() call.

(defn- #_void mf_hash_free [#_mf_hashtab_C mht]
    (§
;       mht.mht_buckets = null;
    ))

;; Find "key" in hashtable "mht".
;; Returns a pointer to a mf_hashitem_C or null if the item was not found.

(defn- #_mf_hashitem_C mf_hash_find [#_mf_hashtab_C mht, #_long key]
    (§
;       mf_hashitem_C mhi = mht.mht_buckets[(int)(key & mht.mht_mask)];

;       while (mhi != null && mhi.mhi_key != key)
;           mhi = mhi.mhi_next;

;       return mhi;
    ))

;; Add item "mhi" to hashtable "mht".
;; "mhi" must not be null.

(defn- #_void mf_hash_add_item [#_mf_hashtab_C mht, #_mf_hashitem_C mhi]
    (§
;       int i = (int)(mhi.mhi_key & mht.mht_mask);

;       mhi.mhi_next = mht.mht_buckets[i];
;       mhi.mhi_prev = null;
;       if (mhi.mhi_next != null)
;           mhi.mhi_next.mhi_prev = mhi;
;       mht.mht_buckets[i] = mhi;

;       mht.mht_count++;

        ;; Grow hashtable when we have more than (2 ^ MHT_LOG_LOAD_FACTOR) items per bucket on average.

;       if (mht.mht_mask < (mht.mht_count >>> MHT_LOG_LOAD_FACTOR))
;           mf_hash_grow(mht);
    ))

;; Remove item "mhi" from hashtable "mht".
;; "mhi" must not be null and must have been inserted into "mht".

(defn- #_void mf_hash_rem_item [#_mf_hashtab_C mht, #_mf_hashitem_C mhi]
    (§
;       if (mhi.mhi_prev == null)
;           mht.mht_buckets[(int)(mhi.mhi_key & mht.mht_mask)] = mhi.mhi_next;
;       else
;           mhi.mhi_prev.mhi_next = mhi.mhi_next;

;       if (mhi.mhi_next != null)
;           mhi.mhi_next.mhi_prev = mhi.mhi_prev;

;       mht.mht_count--;

        ;; We could shrink the table here, but it typically takes little memory, so why bother?
    ))

;; Increase number of buckets in the hashtable by MHT_GROWTH_FACTOR and rehash items.

(defn- #_void mf_hash_grow [#_mf_hashtab_C mht]
    (§
;       mf_hashitem_C[] buckets = new mf_hashitem_C[(mht.mht_mask + 1) * MHT_GROWTH_FACTOR];

;       int shift = 0;
;       while ((mht.mht_mask >>> shift) != 0)
;           shift++;

;       for (int i = 0; i <= mht.mht_mask; i++)
;       {
            ;; Traverse the items in the i-th original bucket and move them into MHT_GROWTH_FACTOR new buckets,
            ;; preserving their relative order within each new bucket.  Preserving the order is important
            ;; because mf_get() tries to keep most recently used items at the front of each bucket.
            ;;
            ;; Here we strongly rely on the fact the hashes are computed modulo a power of two.

;           mf_hashitem_C[] tails = new mf_hashitem_C[MHT_GROWTH_FACTOR];

;           for (mf_hashitem_C mhi = mht.mht_buckets[i]; mhi != null; mhi = mhi.mhi_next)
;           {
;               int j = (int)((mhi.mhi_key >>> shift) & (MHT_GROWTH_FACTOR - 1));
;               if (tails[j] == null)
;               {
;                   buckets[i + (j << shift)] = mhi;
;                   tails[j] = mhi;
;                   mhi.mhi_prev = null;
;               }
;               else
;               {
;                   tails[j].mhi_next = mhi;
;                   mhi.mhi_prev = tails[j];
;                   tails[j] = mhi;
;               }
;           }

;           for (int j = 0; j < MHT_GROWTH_FACTOR; j++)
;               if (tails[j] != null)
;                   tails[j].mhi_next = null;
;       }

;       mht.mht_buckets = buckets;
;       mht.mht_mask = (mht.mht_mask + 1) * MHT_GROWTH_FACTOR - 1;
    ))

;; memline.c: Contains the functions for appending, deleting and changing the
;; text lines.  The memfile functions are used to store the information in
;; blocks of memory, backed up by a file.  The structure of the information is
;; a tree.  The root of the tree is a pointer block.  The leaves of the tree
;; are data blocks.  In between may be several layers of pointer blocks,
;; forming branches.
;;
;; Three types of blocks are used:
;; - Block nr 0 contains information for recovery.
;; - Pointer blocks contain list of pointers to other blocks.
;; - Data blocks contain the actual text.
;;
;; Block nr 0 contains the block0 structure (see below).
;;
;; Block nr 1 is the first pointer block.  It is the root of the tree.
;; Other pointer blocks are branches.
;;
;; If a line is too big to fit in a single page, the block containing that
;; line is made big enough to hold the line.  It may span several pages.
;; Otherwise all blocks are one page.
;;
;; A data block that was filled when starting to edit a file and was not
;; changed since then, can have a negative block number.  This means that it
;; has not yet been assigned a place in the file.  When recovering, the lines
;; in this data block can be read from the original file.  When the block is
;; changed (lines appended/deleted/changed) or when it is flushed it gets a
;; positive number.  Use mf_trans_del() to get the new number, before calling
;; mf_get().

(final short
    B0_ID   (+ (<< (int \b) 8) (int \0)),             ;; block 0 id
    DATA_ID (+ (<< (int \d) 8) (int \a)),             ;; data block id
    PTR_ID  (+ (<< (int \p) 8) (int \t)))             ;; pointer block id

;; Block zero holds all info about the swap file.

(class! #_final zero_block_C
    [
        (field short    b0_id   B0_ID)      ;; ID for block 0: B0_ID
    ])

;; Pointer to a block, used in a pointer block.

(class! #_final ptr_entry_C
    [
        (field long     pe_bnum)            ;; block number
        (field long     pe_line_count)      ;; number of lines in this branch
        (field int      pe_page_count)      ;; number of pages in block pe_bnum
    ])

(defn- #_void COPY_ptr_entry [#_ptr_entry_C pe1, #_ptr_entry_C pe0]
    (§
;       pe1.pe_bnum = pe0.pe_bnum;
;       pe1.pe_line_count = pe0.pe_line_count;
;       pe1.pe_page_count = pe0.pe_page_count;
    ))

(defn- #_ptr_entry_C* ARRAY_ptr_entry [#_int n]
    (vec (repeatedly n §_ptr_entry_C)))

(defn- #_void COPY__ptr_entry [#_ptr_entry_C* a1, #_ptr_entry_C* a0, #_int n]
    (§
;       for (int i = 0; i < n; i++)
;           COPY_ptr_entry(a1[i], a0[i]);
    ))

;; A pointer block contains a list of branches in the tree.

(class! #_final ptr_block_C
    [
        (field short    pb_id           PTR_ID)                     ;; ID for pointer block: PTR_ID
        (field int      pb_count        0)                          ;; number of pointers in this block
        (field int      pb_count_max    (/ MEMFILE_PAGE_SIZE 8))    ;; maximum value for pb_count
        (field ptr_entry_C* pb_pointer  (ARRAY_ptr_entry #_pb_count_max (/ MEMFILE_PAGE_SIZE 8)))   ;; array of pointers to blocks
    ])

(defn- #_void COPY_ptr_block [#_ptr_block_C pb1, #_ptr_block_C pb0]
    (§
;       pb1.pb_id = pb0.pb_id;
;       pb1.pb_count = pb0.pb_count;
;       pb1.pb_count_max = pb0.pb_count_max;
;       COPY__ptr_entry(pb1.pb_pointer, pb0.pb_pointer, pb0.pb_count_max);
    ))

;; A data block is a leaf in the tree.
;;
;; The text of the lines is at the end of the block.  The text of the first line
;; in the block is put at the end, the text of the second line in front of it,
;; etc.  Thus the order of the lines is the opposite of the line number.

(class! #_final data_block_C
    [
        (field short    db_id)          ;; ID for data block: DATA_ID
        (field int      db_free)        ;; free space available
        (field int      db_txt_start)   ;; byte where text starts
        (field int      db_txt_end)     ;; byte just after data block
        (field int      db_line_count)  ;; number of lines in this block
        (field int*     db_index)       ;; index for start of line (*union* db_text)
                                        ;; followed by empty space upto db_txt_start
        (field Bytes    db_text)        ;; followed by the text in the lines until end of page
    ])

;; The low bits of db_index hold the actual index.
;; The topmost bit is used for the global command to be able to mark a line.
;; This method is not clean, but otherwise there would be at least one extra byte used for each line.
;; The mark has to be in this place to keep it with the correct line
;; when other lines are inserted or deleted.

(final int INDEX_SIZE      4)     ;; size of one db_index entry

(final int! DB_MARKED       (<< 1 (dec (* INDEX_SIZE 8))))
(final int! DB_INDEX_MASK   (bit-not DB_MARKED))

(final int STACK_INCR      5)       ;; nr of entries added to ml_stack at a time

(defn- #_data_block_C new_data_block [#_int page_count]
    (let [bs (* page_count MEMFILE_PAGE_SIZE) is (/ bs INDEX_SIZE)]
        (->data_block_C DATA_ID bs bs bs 0 #_"sic!" (int* is) #_"sic!" (Bytes. bs))))

;; The line number where the first mark may be is remembered.
;; If it is 0 there are no marks at all.
;; (always used for the current buffer only, no buffer change possible while executing a global command).

(atom! long lowest_marked)

;; arguments for ml_find_line()

(final int ML_DELETE       0x11)        ;; delete line
(final int ML_INSERT       0x12)        ;; insert line
(final int ML_FIND         0x13)        ;; just find the line
(final int ML_FLUSH        0x02)        ;; flush locked block

(defn- #_boolean ml_simple [#_int action]
    (§
;       return ((action & 0x10) != 0);         ;; DEL, INS or FIND
    ))

;; Open a new memline for "buf".
;;
;; Return false for failure, true otherwise.

(defn- #_boolean ml_open [#_buffer_C buf]
    (§
        ;; init fields in memline struct

;       buf.b_ml.ml_stack_size = 0;     ;; no stack yet
;       buf.b_ml.ml_stack = null;       ;; no stack yet
;       buf.b_ml.ml_stack_top = 0;      ;; nothing in the stack
;       buf.b_ml.ml_locked = null;      ;; no cached block
;       buf.b_ml.ml_line_lnum = 0;      ;; no cached line
;       buf.b_ml.ml_chunksize = null;

        ;; Open the memfile.  No swap file is created yet.

;       memfile_C mfp = mf_open();

;       buf.b_ml.ml_mfp = mfp;
;       buf.b_ml.ml_flags = ML_EMPTY;
;       buf.b_ml.ml_line_count = 1;
;       @curwin.w_nrwidth_line_count = 0;

;       block_hdr_C hp;

;       error:
;       {
            ;; fill block0 struct and write page 0

;           hp = ml_new_zero(mfp);
;           if (hp.bh_bnum() != 0)
;           {
;               emsg(u8("E298: Didn't get block nr 0?"));
;               break error;
;           }

;           set_mtime(buf);

            ;; Always sync block number 0 to disk.
            ;; Only works when there's a swapfile, otherwise it's done when the file is created.

;           mf_put(mfp, hp, true, false);

            ;; Fill in root pointer block and write page 1.

;           hp = ml_new_ptr(mfp);
;           if (hp.bh_bnum() != 1)
;           {
;               emsg(u8("E298: Didn't get block nr 1?"));
;               break error;
;           }

;           ptr_block_C pp = (ptr_block_C)hp.bh_data;
;           pp.pb_count = 1;
;           pp.pb_pointer[0].pe_bnum = 2;
;           pp.pb_pointer[0].pe_page_count = 1;
;           pp.pb_pointer[0].pe_line_count = 1; ;; line count after insertion
;           mf_put(mfp, hp, true, false);

            ;; Allocate first data block and create an empty line 1.

;           hp = ml_new_data(mfp, false, 1);
;           if (hp.bh_bnum() != 2)
;           {
;               emsg(u8("E298: Didn't get block nr 2?"));
;               break error;
;           }

;           data_block_C dp = (data_block_C)hp.bh_data;

;           dp.db_index[0] = --dp.db_txt_start;     ;; at end of block
;           dp.db_free -= 1 + INDEX_SIZE;
;           dp.db_line_count = 1;
;           dp.db_text.be(dp.db_txt_start, NUL);      ;; empty line

;           return true;
;       }

;       if (hp != null)
;           mf_put(mfp, hp, false, false);
;       mf_close(mfp);

;       buf.b_ml.ml_mfp = null;

;       return false;
    ))

;; Close memline for buffer 'buf'.

(defn- #_void ml_close [#_buffer_C buf]
    (§
;       if (buf.b_ml.ml_mfp != null)
;       {
;           mf_close(buf.b_ml.ml_mfp);
;           if (buf.b_ml.ml_line_lnum != 0 && (buf.b_ml.ml_flags & ML_LINE_DIRTY) != 0)
;               buf.b_ml.ml_line_ptr = null;
;           buf.b_ml.ml_stack = null;
;           buf.b_ml.ml_chunksize = null;
;           buf.b_ml.ml_mfp = null;

            ;; Reset the "recovered" flag,
            ;; give the ATTENTION prompt the next time this buffer is loaded.
;           buf.b_flags &= ~BF_RECOVERED;
;       }
    ))

;; Close all existing memlines and memfiles.
;; Only used when exiting.
;; But don't delete files that were ":preserve"d when we are POSIX compatible.

(defn- #_void ml_close_all []
    (§
;       for (buffer_C buf = @firstbuf; buf != null; buf = buf.b_next)
;           ml_close(buf);
    ))

;; Update the timestamp in the .swp file.
;; Used when the file has been written.

(defn- #_void ml_timestamp [#_buffer_C buf]
    (§
;       memfile_C mfp = buf.b_ml.ml_mfp;
;       if (mfp == null)
;           return;

;       block_hdr_C hp = mf_get(mfp, 0, 1);
;       if (hp == null)
;           return;

;       zero_block_C b0p = (zero_block_C)hp.bh_data;
;       if (b0p.b0_id != B0_ID)
;       {
;           emsg(u8("E304: Didn't get block 0??"));
;           return;
;       }

;       set_mtime(buf);

;       mf_put(mfp, hp, true, false);
    ))

;; Write timestamp into block 0.
;; Also set buf.b_mtime.

(defn- #_void set_mtime [#_buffer_C buf]
    (§
        
    ))

;; NOTE: The pointer returned by the ml_get_*() functions only remains valid until the next call!
;;  line1 = ml_get(1);
;;  line2 = ml_get(2);  // line1 is now invalid!
;; Make a copy of the line if necessary.

;; Return a pointer to a (read-only copy of a) line.
;;
;; On failure an error message is given and ioBuff is returned
;; (to avoid having to check for error everywhere).

(defn- #_Bytes ml_get [#_long lnum]
    (§
;       return ml_get_buf(@curbuf, lnum, false);
    ))

;; Return pointer to position "pos".

(defn- #_Bytes ml_get_pos [#_pos_C pos]
    (§
;       return ml_get_buf(@curbuf, pos.lnum, false).plus(pos.col);
    ))

;; Return pointer to cursor line.

(defn- #_Bytes ml_get_curline []
    (§
;       return ml_get_buf(@curbuf, @curwin.w_cursor.lnum, false);
    ))

;; Return pointer to cursor position.

(defn- #_Bytes ml_get_cursor []
    (§
;       return ml_get_buf(@curbuf, @curwin.w_cursor.lnum, false).plus(@curwin.w_cursor.col);
    ))

(atom! int _4_recurse)

;; Return a pointer to a line in a specific buffer
;;
;; "will_change": if true mark the buffer dirty (chars in the line will be changed)

(defn- #_Bytes ml_get_buf [#_buffer_C buf, #_long lnum, #_boolean will_change]
    ;; will_change: line will be changed
    (§
;       if (buf.b_ml.ml_line_count < lnum)  ;; invalid line number
;       {
;           if (@_4_recurse == 0)
;           {
                ;; Avoid giving this message for a recursive call,
                ;; may happen when the GUI redraws part of the text.
;               @_4_recurse++;
;               emsgn(u8("E315: ml_get: invalid lnum: %ld"), lnum);
;               --@_4_recurse;
;           }

;           STRCPY(@ioBuff, u8("???"));
;           return @ioBuff;
;       }
;       if (lnum <= 0)                      ;; pretend line 0 is line 1
;           lnum = 1;

;       if (buf.b_ml.ml_mfp == null)        ;; there are no lines
;           return u8("");

        ;; See if it is the same line as requested last time.
        ;; Otherwise may need to flush last used line.
        ;; Don't use the last used line when 'swapfile' is reset, need to load all blocks.

;       if (buf.b_ml.ml_line_lnum != lnum)
;       {
;           ml_flush_line(buf);

            ;; Find the data block containing the line.
            ;; This also fills the stack with the blocks from the root to the data
            ;; block and releases any locked block.

;           block_hdr_C hp = ml_find_line(buf, lnum, ML_FIND);
;           if (hp == null)
;           {
;               if (@_4_recurse == 0)
;               {
                    ;; Avoid giving this message for a recursive call,
                    ;; may happen when the GUI redraws part of the text.
;                   @_4_recurse++;
;                   emsgn(u8("E316: ml_get: cannot find line %ld"), lnum);
;                   --@_4_recurse;
;               }

;               STRCPY(@ioBuff, u8("???"));
;               return @ioBuff;
;           }

;           data_block_C dp = (data_block_C)hp.bh_data;

;           buf.b_ml.ml_line_ptr = dp.db_text.plus(dp.db_index[(int)(lnum - buf.b_ml.ml_locked_low)] & DB_INDEX_MASK);
;           buf.b_ml.ml_line_lnum = lnum;
;           buf.b_ml.ml_flags &= ~ML_LINE_DIRTY;
;       }
;       if (will_change)
;           buf.b_ml.ml_flags |= (ML_LOCKED_DIRTY | ML_LOCKED_POS);

;       return buf.b_ml.ml_line_ptr;
    ))

;; Check if a line that was just obtained by a call to ml_get() is in allocated memory.

(defn- #_boolean ml_line_alloced []
    (§
;       return ((@curbuf.b_ml.ml_flags & ML_LINE_DIRTY) != 0);
    ))

;; Append a line after lnum (may be 0 to insert a line in front of the file).
;; "line" does not need to be allocated, but can't be another line in a buffer,
;; unlocking may make it invalid.
;;
;;   newfile: true when starting to edit a new file
;;
;; Check: The caller of this function should probably also call appended_lines().
;;
;; return false for failure, true otherwise

(defn- #_boolean ml_append [#_long lnum, #_Bytes line, #_int len, #_boolean newfile]
    ;; lnum: append after this line (can be 0)
    ;; line: text of the new line
    ;; len: length of new line, including NUL, or 0
    ;; newfile: flag, see above
    (§
        ;; When starting up, we might still need to create the memfile.
;       if (@curbuf.b_ml.ml_mfp == null && open_buffer(false, null, 0) == false)
;           return false;

;       if (@curbuf.b_ml.ml_line_lnum != 0)
;           ml_flush_line(@curbuf);

;       return ml_append_int(@curbuf, lnum, line, len, newfile, false);
    ))

(defn- #_boolean ml_append_int [#_buffer_C buf, #_long lnum, #_Bytes line, #_int len, #_boolean newfile, #_boolean mark]
    ;; lnum: append after this line (can be 0)
    ;; line: text of the new line
    ;; len: length of line, including NUL, or 0
    ;; newfile: flag, see above
    ;; mark: mark the new line
    (§
;       if (buf.b_ml.ml_line_count < lnum || buf.b_ml.ml_mfp == null) ;; lnum out of range
;           return false;

;       if (@lowest_marked != 0 && lnum < @lowest_marked)
;           @lowest_marked = lnum + 1;

;       if (len == 0)
;           len = STRLEN(line) + 1;                ;; space needed for the text
;       int space_needed = len + INDEX_SIZE;            ;; space needed for new line (text + index)

;       memfile_C mfp = buf.b_ml.ml_mfp;

        ;; Find the data block containing the previous line.
        ;; This also fills the stack with the blocks from the root to the data block.
        ;; This also releases any locked block.

;       block_hdr_C hp = ml_find_line(buf, (lnum == 0) ? 1 : lnum, ML_INSERT);
;       if (hp == null)
;           return false;

;       buf.b_ml.ml_flags &= ~ML_EMPTY;

;       int db_idx;                                         ;; index for lnum in data block
;       if (lnum == 0)                                      ;; got line one instead, correct db_idx
;           db_idx = -1;                                    ;; careful, it is negative!
;       else
;           db_idx = (int)(lnum - buf.b_ml.ml_locked_low);

;       int line_count;                                     ;; number of indexes in current block
        ;; get line count before the insertion
;       line_count = (int)(buf.b_ml.ml_locked_high - buf.b_ml.ml_locked_low);

;       data_block_C dp = (data_block_C)hp.bh_data;

        ;; If
        ;; - there is not enough room in the current block
        ;; - appending to the last line in the block
        ;; - not appending to the last line in the file
        ;; insert in front of the next block.

;       if (dp.db_free < space_needed && db_idx == line_count - 1 && lnum < buf.b_ml.ml_line_count)
;       {
            ;; Now that the line is not going to be inserted in the block that we expected,
            ;; the line count has to be adjusted in the pointer blocks by using ml_locked_lineadd.

;           --buf.b_ml.ml_locked_lineadd;
;           --buf.b_ml.ml_locked_high;

;           hp = ml_find_line(buf, lnum + 1, ML_INSERT);
;           if (hp == null)
;               return false;

;           db_idx = -1;                                    ;; careful, it is negative!
            ;; get line count before the insertion
;           line_count = (int)(buf.b_ml.ml_locked_high - buf.b_ml.ml_locked_low);

;           dp = (data_block_C)hp.bh_data;
;       }

;       buf.b_ml.ml_line_count++;

;       if (space_needed <= dp.db_free)                     ;; enough room in data block
;       {
            ;; Insert new line in existing data block, or in data block allocated above.

;           dp.db_txt_start -= len;
;           dp.db_free -= space_needed;
;           dp.db_line_count++;

            ;; move the text of the lines that follow to the front
            ;; adjust the indexes of the lines that follow

;           if (db_idx + 1 < line_count)                    ;; if there are following lines
;           {
                ;; 'over' is the start of the previous line.
                ;; This will become the character just after the new line.

;               int from = dp.db_txt_start + len;
;               int over = (db_idx < 0) ? dp.db_txt_end : (dp.db_index[db_idx] & DB_INDEX_MASK);
;               BCOPY(dp.db_text, dp.db_txt_start, dp.db_text, from, over - from);
;               for (int i = line_count; db_idx < --i; )
;                   dp.db_index[i + 1] = dp.db_index[i] - len;
;               dp.db_index[db_idx + 1] = over - len;
;           }
;           else                                            ;; add line at the end
;               dp.db_index[db_idx + 1] = dp.db_txt_start;

            ;; copy the text into the block

;           BCOPY(dp.db_text, dp.db_index[db_idx + 1], line, 0, len);
;           if (mark)
;               dp.db_index[db_idx + 1] |= DB_MARKED;

            ;; Mark the block dirty.

;           buf.b_ml.ml_flags |= ML_LOCKED_DIRTY;
;           if (!newfile)
;               buf.b_ml.ml_flags |= ML_LOCKED_POS;
;       }
;       else                                                ;; not enough space in data block
;       {
            ;; If there is not enough room we have to create a new data block
            ;; and copy some lines into it.  Then we have to insert an entry
            ;; in the pointer block.  If this pointer block also is full,
            ;; we go up another block, and so on, up to the root if necessary.
            ;; The line counts in the pointer blocks have already been adjusted
            ;; by ml_find_line().

;           int lines_moved;
;           int data_moved = 0;
;           int total_moved = 0;
;           boolean in_left;

            ;; We are going to allocate a new data block.  Depending on the
            ;; situation it will be put to the left or right of the existing
            ;; block.  If possible we put the new line in the left block and move
            ;; the lines after it to the right block.  Otherwise the new line is
            ;; also put in the right block.  This method is more efficient when
            ;; inserting a lot of lines at one place.

;           if (db_idx < 0)                         ;; left block is new, right block is existing
;           {
;               lines_moved = 0;
;               in_left = true;                     ;; space_needed does not change
;           }
;           else                                    ;; left block is existing, right block is new
;           {
;               lines_moved = line_count - db_idx - 1;
;               if (lines_moved == 0)               ;; put new line in right block
;                   in_left = false;                ;; space_needed does not change
;               else
;               {
;                   data_moved = (dp.db_index[db_idx] & DB_INDEX_MASK) - dp.db_txt_start;
;                   total_moved = data_moved + lines_moved * INDEX_SIZE;
;                   if (space_needed <= dp.db_free + total_moved)
;                   {
;                       in_left = true;             ;; put new line in left block
;                       space_needed = total_moved;
;                   }
;                   else
;                   {
;                       in_left = false;            ;; put new line in right block
;                       space_needed += total_moved;
;                   }
;               }
;           }

;           int page_count = (space_needed + MEMFILE_PAGE_SIZE - 1) / MEMFILE_PAGE_SIZE;
;           block_hdr_C hp_new = ml_new_data(mfp, newfile, page_count);

;           block_hdr_C hp_left, hp_right;
;           int line_count_left, line_count_right;
;           if (db_idx < 0)         ;; left block is new
;           {
;               hp_left = hp_new;
;               hp_right = hp;
;               line_count_left = 0;
;               line_count_right = line_count;
;           }
;           else                    ;; right block is new
;           {
;               hp_left = hp;
;               hp_right = hp_new;
;               line_count_left = line_count;
;               line_count_right = 0;
;           }
;           data_block_C dp_left = (data_block_C)hp_left.bh_data;
;           data_block_C dp_right = (data_block_C)hp_right.bh_data;
;           long bnum_left = hp_left.bh_bnum();
;           long bnum_right = hp_right.bh_bnum();
;           int page_count_left = hp_left.bh_page_count;
;           int page_count_right = hp_right.bh_page_count;

            ;; May move the new line into the right/new block.

;           if (!in_left)
;           {
;               dp_right.db_txt_start -= len;
;               dp_right.db_free -= len + INDEX_SIZE;
;               dp_right.db_index[0] = dp_right.db_txt_start;
;               if (mark)
;                   dp_right.db_index[0] |= DB_MARKED;

;               BCOPY(dp_right.db_text, dp_right.db_txt_start, line, 0, len);
;               line_count_right++;
;           }

            ;; may move lines from the left/old block to the right/new one.

;           if (lines_moved != 0)
;           {
;               dp_right.db_txt_start -= data_moved;
;               dp_right.db_free -= total_moved;
;               BCOPY(dp_right.db_text, dp_right.db_txt_start, dp_left.db_text, dp_left.db_txt_start, data_moved);
;               int offset = dp_right.db_txt_start - dp_left.db_txt_start;
;               dp_left.db_txt_start += data_moved;
;               dp_left.db_free += total_moved;

                ;; update indexes in the new block

;               for (int from = db_idx + 1, to = line_count_right; from < line_count_left; from++, to++)
;                   dp_right.db_index[to] = dp.db_index[from] + offset;
;               line_count_right += lines_moved;
;               line_count_left -= lines_moved;
;           }

            ;; May move the new line into the left (old or new) block.

;           if (in_left)
;           {
;               dp_left.db_txt_start -= len;
;               dp_left.db_free -= len + INDEX_SIZE;
;               dp_left.db_index[line_count_left] = dp_left.db_txt_start;
;               if (mark)
;                   dp_left.db_index[line_count_left] |= DB_MARKED;
;               BCOPY(dp_left.db_text, dp_left.db_txt_start, line, 0, len);
;               line_count_left++;
;           }

;           long lnum_left, lnum_right;
;           if (db_idx < 0)         ;; left block is new
;           {
;               lnum_left = lnum + 1;
;               lnum_right = 0;
;           }
;           else                    ;; right block is new
;           {
;               lnum_left = 0;
;               if (in_left)
;                   lnum_right = lnum + 2;
;               else
;                   lnum_right = lnum + 1;
;           }
;           dp_left.db_line_count = line_count_left;
;           dp_right.db_line_count = line_count_right;

            ;; release the two data blocks
            ;; The new one (hp_new) already has a correct blocknumber.
            ;; The old one (hp, in ml_locked) gets a positive blocknumber if
            ;; we changed it and we are not editing a new file.

;           if (lines_moved != 0 || in_left)
;               buf.b_ml.ml_flags |= ML_LOCKED_DIRTY;
;           if (!newfile && 0 <= db_idx && in_left)
;               buf.b_ml.ml_flags |= ML_LOCKED_POS;
;           mf_put(mfp, hp_new, true, false);

            ;; flush the old data block
            ;; set ml_locked_lineadd to 0, because the updating of the
            ;; pointer blocks is done below

;           int lineadd = buf.b_ml.ml_locked_lineadd;
;           buf.b_ml.ml_locked_lineadd = 0;
;           ml_find_line(buf, 0, ML_FLUSH);             ;; flush data block

            ;; update pointer blocks for the new data block

;           int stack_idx;
;           for (stack_idx = buf.b_ml.ml_stack_top - 1; 0 <= stack_idx; --stack_idx)
;           {
;               infoptr_C ip = buf.b_ml.ml_stack[stack_idx];
;               int pb_idx = ip.ip_index;
;               if ((hp = mf_get(mfp, ip.ip_bnum, 1)) == null)
;                   return false;

;               ptr_block_C pp = (ptr_block_C)hp.bh_data; ;; must be pointer block
;               if (pp.pb_id != PTR_ID)
;               {
;                   emsg(u8("E317: pointer block id wrong 3"));
;                   mf_put(mfp, hp, false, false);
;                   return false;
;               }

                ;; TODO: If the pointer block is full and we are adding at the end,
                ;; try to insert in front of the next block.

                ;; block not full, add one entry
;               if (pp.pb_count < pp.pb_count_max)
;               {
;                   for (int i = pp.pb_count; pb_idx + 1 <= --i; )
;                       COPY_ptr_entry(pp.pb_pointer[i + 1], pp.pb_pointer[i]);
;                   pp.pb_count++;
;                   pp.pb_pointer[pb_idx].pe_line_count = line_count_left;
;                   pp.pb_pointer[pb_idx].pe_bnum = bnum_left;
;                   pp.pb_pointer[pb_idx].pe_page_count = page_count_left;
;                   pp.pb_pointer[pb_idx + 1].pe_line_count = line_count_right;
;                   pp.pb_pointer[pb_idx + 1].pe_bnum = bnum_right;
;                   pp.pb_pointer[pb_idx + 1].pe_page_count = page_count_right;

;                   mf_put(mfp, hp, true, false);
;                   buf.b_ml.ml_stack_top = stack_idx + 1;  ;; truncate stack

;                   if (lineadd != 0)
;                   {
;                       --buf.b_ml.ml_stack_top;
                        ;; fix line count for rest of blocks in the stack
;                       ml_lineadd(buf, lineadd);
                                                            ;; fix stack itself
;                       buf.b_ml.ml_stack[buf.b_ml.ml_stack_top].ip_high += lineadd;
;                       buf.b_ml.ml_stack_top++;
;                   }

                    ;; We are finished, break the loop here.

;                   break;
;               }
;               else                        ;; pointer block full
;               {
;                   ptr_block_C pp_new;

                    ;; split the pointer block
                    ;; allocate a new pointer block
                    ;; move some of the pointer into the new block
                    ;; prepare for updating the parent block

;                   for ( ; ; )             ;; do this twice when splitting block 1
;                   {
;                       hp_new = ml_new_ptr(mfp);
;                       pp_new = (ptr_block_C)hp_new.bh_data;

;                       if (hp.bh_bnum() != 1)
;                           break;

                        ;; if block 1 becomes full the tree is given an extra level
                        ;; The pointers from block 1 are moved into the new block.
                        ;; block 1 is updated to point to the new block
                        ;; then continue to split the new block

;                       COPY_ptr_block(pp_new, pp);
;                       pp.pb_count = 1;
;                       pp.pb_pointer[0].pe_bnum = hp_new.bh_bnum();
;                       pp.pb_pointer[0].pe_line_count = buf.b_ml.ml_line_count;
;                       pp.pb_pointer[0].pe_page_count = 1;
;                       mf_put(mfp, hp, true, false);           ;; release block 1
;                       hp = hp_new;                            ;; new block is to be split
;                       pp = pp_new;
;                       ip.ip_index = 0;
;                       stack_idx++;                            ;; do block 1 again later
;                   }

                    ;; Move the pointers after the current one to the new block.
                    ;; If there are none, the new entry will be in the new block.

;                   total_moved = pp.pb_count - pb_idx - 1;
;                   if (total_moved != 0)
;                   {
;                       for (int i = 0; i < total_moved; i++)
;                           COPY_ptr_entry(pp_new.pb_pointer[i], pp.pb_pointer[pb_idx + 1 + i]);
;                       pp_new.pb_count = total_moved;
;                       pp.pb_count -= total_moved - 1;
;                       pp.pb_pointer[pb_idx + 1].pe_bnum = bnum_right;
;                       pp.pb_pointer[pb_idx + 1].pe_line_count = line_count_right;
;                       pp.pb_pointer[pb_idx + 1].pe_page_count = page_count_right;
;                   }
;                   else
;                   {
;                       pp_new.pb_count = 1;
;                       pp_new.pb_pointer[0].pe_bnum = bnum_right;
;                       pp_new.pb_pointer[0].pe_line_count = line_count_right;
;                       pp_new.pb_pointer[0].pe_page_count = page_count_right;
;                   }
;                   pp.pb_pointer[pb_idx].pe_bnum = bnum_left;
;                   pp.pb_pointer[pb_idx].pe_line_count = line_count_left;
;                   pp.pb_pointer[pb_idx].pe_page_count = page_count_left;
;                   lnum_left = 0;
;                   lnum_right = 0;

                    ;; recompute line counts

;                   line_count_right = 0;
;                   for (int i = 0; i < pp_new.pb_count; i++)
;                       line_count_right += pp_new.pb_pointer[i].pe_line_count;
;                   line_count_left = 0;
;                   for (int i = 0; i < pp.pb_count; i++)
;                       line_count_left += pp.pb_pointer[i].pe_line_count;

;                   bnum_left = hp.bh_bnum();
;                   bnum_right = hp_new.bh_bnum();
;                   page_count_left = 1;
;                   page_count_right = 1;
;                   mf_put(mfp, hp, true, false);
;                   mf_put(mfp, hp_new, true, false);
;               }
;           }

            ;; Safety check: fallen out of for loop?

;           if (stack_idx < 0)
;           {
;               emsg(u8("E318: Updated too many blocks?"));
;               buf.b_ml.ml_stack_top = 0;      ;; invalidate stack
;           }
;       }

        ;; The line was inserted below 'lnum'.
;       ml_updatechunk(buf, lnum + 1, (long)len, ML_CHNK_ADDLINE);
;       return true;
    ))

;; Replace line lnum, with buffering, in current buffer.
;;
;; If "copy" is true, make a copy of the line,
;; otherwise the line has been copied to allocated memory already.
;;
;; Check: The caller of this function should probably also call
;; changed_lines(), unless update_screen(NOT_VALID) is used.
;;
;; return false for failure, true otherwise

(defn- #_boolean ml_replace [#_long lnum, #_Bytes line, #_boolean copy]
    (§
;       if (line == null)           ;; just checking...
;           return false;

        ;; When starting up, we might still need to create the memfile.
;       if (@curbuf.b_ml.ml_mfp == null && open_buffer(false, null, 0) == false)
;           return false;

;       if (copy)
;           line = STRDUP(line);

;       if (@curbuf.b_ml.ml_line_lnum != lnum)       ;; other line buffered
;           ml_flush_line(@curbuf);                  ;; flush it

;       @curbuf.b_ml.ml_line_ptr = line;
;       @curbuf.b_ml.ml_line_lnum = lnum;
;       @curbuf.b_ml.ml_flags = (@curbuf.b_ml.ml_flags | ML_LINE_DIRTY) & ~ML_EMPTY;

;       return true;
    ))

;; Delete line 'lnum' in the current buffer.
;;
;; Check: The caller of this function should probably also call
;; deleted_lines() after this.
;;
;; return false for failure, true otherwise

(defn- #_boolean ml_delete [#_long lnum, #_boolean message]
    (§
;       ml_flush_line(@curbuf);
;       return ml_delete_int(@curbuf, lnum, message);
    ))

(defn- #_boolean ml_delete_int [#_buffer_C buf, #_long lnum, #_boolean message]
    (§
;       if (lnum < 1 || buf.b_ml.ml_line_count < lnum)
;           return false;

;       if (@lowest_marked != 0 && lnum < @lowest_marked)
;           @lowest_marked--;

        ;; If the file becomes empty the last line is replaced by an empty line.

;       if (buf.b_ml.ml_line_count == 1)    ;; file becomes empty
;       {
;           if (message)
;               set_keep_msg(no_lines_msg, 0);

            ;; FEAT_BYTEOFF already handled in there, don't worry 'bout it below.
;           boolean b = ml_replace(1, u8(""), true);
;           buf.b_ml.ml_flags |= ML_EMPTY;

;           return b;
;       }

        ;; Find the data block containing the line.
        ;; This also fills the stack with the blocks from the root to the data block.
        ;; This also releases any locked block.

;       memfile_C mfp = buf.b_ml.ml_mfp;
;       if (mfp == null)
;           return false;

;       block_hdr_C hp = ml_find_line(buf, lnum, ML_DELETE);
;       if (hp == null)
;           return false;

;       data_block_C dp = (data_block_C)hp.bh_data;

        ;; compute line count before the delete; number of entries in block
;       int count = (int)(buf.b_ml.ml_locked_high - buf.b_ml.ml_locked_low + 2);
;       int idx = (int)(lnum - buf.b_ml.ml_locked_low);

;       --buf.b_ml.ml_line_count;

;       int line_start = (dp.db_index[idx] & DB_INDEX_MASK);
;       int line_size;
;       if (idx == 0)                           ;; first line in block, text at the end
;           line_size = dp.db_txt_end - line_start;
;       else
;           line_size = (dp.db_index[idx - 1] & DB_INDEX_MASK) - line_start;

        ;; special case: If there is only one line in the data block it becomes empty.
        ;; Then we have to remove the entry, pointing to this data block, from the pointer block.
        ;; If this pointer block also becomes empty, we go up another block, and so on,
        ;; up to the root if necessary.
        ;; The line counts in the pointer blocks have already been adjusted by ml_find_line().

;       if (count == 1)
;       {
;           mf_free(mfp, hp);                           ;; free the data block
;           buf.b_ml.ml_locked = null;

;           for (int stack_idx = buf.b_ml.ml_stack_top - 1; 0 <= stack_idx; --stack_idx)
;           {
;               buf.b_ml.ml_stack_top = 0;              ;; stack is invalid when failing
;               infoptr_C ip = buf.b_ml.ml_stack[stack_idx];
;               idx = ip.ip_index;
;               if ((hp = mf_get(mfp, ip.ip_bnum, 1)) == null)
;                   return false;

;               ptr_block_C pp = (ptr_block_C)hp.bh_data; ;; must be pointer block
;               if (pp.pb_id != PTR_ID)
;               {
;                   emsg(u8("E317: pointer block id wrong 4"));
;                   mf_put(mfp, hp, false, false);
;                   return false;
;               }
;               count = --pp.pb_count;
;               if (count == 0)                         ;; the pointer block becomes empty!
;                   mf_free(mfp, hp);
;               else
;               {
;                   if (count != idx)                   ;; move entries after the deleted one
;                       for (int i = idx; i < count; i++)
;                           COPY_ptr_entry(pp.pb_pointer[i], pp.pb_pointer[i + 1]);
;                   mf_put(mfp, hp, true, false);

;                   buf.b_ml.ml_stack_top = stack_idx; ;; truncate stack
                    ;; fix line count for rest of blocks in the stack
;                   if (buf.b_ml.ml_locked_lineadd != 0)
;                   {
;                       ml_lineadd(buf, buf.b_ml.ml_locked_lineadd);
;                       buf.b_ml.ml_stack[buf.b_ml.ml_stack_top].ip_high += buf.b_ml.ml_locked_lineadd;
;                   }
;                   buf.b_ml.ml_stack_top++;

;                   break;
;               }
;           }
;       }
;       else
;       {
            ;; delete the text by moving the next lines forwards

;           int text_start = dp.db_txt_start;
;           BCOPY(dp.db_text, text_start + line_size, dp.db_text, text_start, line_start - text_start);

            ;; delete the index by moving the next indexes backwards
            ;; Adjust the indexes for the text movement.

;           for (int i = idx; i < count - 1; i++)
;               dp.db_index[i] = dp.db_index[i + 1] + line_size;

;           dp.db_free += line_size + INDEX_SIZE;
;           dp.db_txt_start += line_size;
;           --dp.db_line_count;

            ;; mark the block dirty and make sure it is in the file (for recovery)

;           buf.b_ml.ml_flags |= (ML_LOCKED_DIRTY | ML_LOCKED_POS);
;       }

;       ml_updatechunk(buf, lnum, line_size, ML_CHNK_DELLINE);
;       return true;
    ))

;; set the B_MARKED flag for line 'lnum'

(defn- #_void ml_setmarked [#_long lnum]
    (§
        ;; invalid line number
;       if (lnum < 1 || @curbuf.b_ml.ml_line_count < lnum || @curbuf.b_ml.ml_mfp == null)
;           return;                     ;; give error message?

;       if (@lowest_marked == 0 || lnum < @lowest_marked)
;           @lowest_marked = lnum;

        ;; find the data block containing the line
        ;; This also fills the stack with the blocks from the root to the data block.
        ;; This also releases any locked block.

;       block_hdr_C hp = ml_find_line(@curbuf, lnum, ML_FIND);
;       if (hp == null)
;           return;                     ;; give error message?

;       data_block_C dp = (data_block_C)hp.bh_data;
;       dp.db_index[(int)(lnum - @curbuf.b_ml.ml_locked_low)] |= DB_MARKED;
;       @curbuf.b_ml.ml_flags |= ML_LOCKED_DIRTY;
    ))

;; find the first line with its B_MARKED flag set

(defn- #_long ml_firstmarked []
    (§
;       if (@curbuf.b_ml.ml_mfp == null)
;           return 0;

        ;; The search starts with lowest_marked line.
        ;; This is the last line where a mark was found, adjusted by inserting/deleting lines.

;       for (long lnum = @lowest_marked; lnum <= @curbuf.b_ml.ml_line_count; )
;       {
            ;; Find the data block containing the line.
            ;; This also fills the stack with the blocks from the root
            ;; to the data block and releases any locked block.

;           block_hdr_C hp = ml_find_line(@curbuf, lnum, ML_FIND);
;           if (hp == null)
;               return 0;               ;; give error message?

;           data_block_C dp = (data_block_C)hp.bh_data;

;           for (int i = (int)(lnum - @curbuf.b_ml.ml_locked_low); lnum <= @curbuf.b_ml.ml_locked_high; i++, lnum++)
;               if ((dp.db_index[i] & DB_MARKED) != 0)
;               {
;                   dp.db_index[i] &= DB_INDEX_MASK;
;                   @curbuf.b_ml.ml_flags |= ML_LOCKED_DIRTY;
;                   @lowest_marked = lnum + 1;
;                   return lnum;
;               }
;       }

;       return 0;
    ))

;; clear all DB_MARKED flags

(defn- #_void ml_clearmarked []
    (§
;       if (@curbuf.b_ml.ml_mfp == null)     ;; nothing to do
;           return;

        ;; The search starts with line lowest_marked.

;       for (long lnum = @lowest_marked; lnum <= @curbuf.b_ml.ml_line_count; )
;       {
            ;; Find the data block containing the line.
            ;; This also fills the stack with the blocks from the root
            ;; to the data block and releases any locked block.

;           block_hdr_C hp = ml_find_line(@curbuf, lnum, ML_FIND);
;           if (hp == null)
;               return;                         ;; give error message?

;           data_block_C dp = (data_block_C)hp.bh_data;

;           for (int i = (int)(lnum - @curbuf.b_ml.ml_locked_low); lnum <= @curbuf.b_ml.ml_locked_high; i++, lnum++)
;               if ((dp.db_index[i] & DB_MARKED) != 0)
;               {
;                   dp.db_index[i] &= DB_INDEX_MASK;
;                   @curbuf.b_ml.ml_flags |= ML_LOCKED_DIRTY;
;               }
;       }

;       @lowest_marked = 0;
    ))

(atom! boolean _1_entered)

;; flush ml_line if necessary

(defn- #_void ml_flush_line [#_buffer_C buf]
    (§
;       if (buf.b_ml.ml_line_lnum == 0 || buf.b_ml.ml_mfp == null)
;           return;                                         ;; nothing to do

;       if ((buf.b_ml.ml_flags & ML_LINE_DIRTY) != 0)
;       {
            ;; This code doesn't work recursively,
            ;; but Netbeans may call back here when obtaining the cursor position.
;           if (@_1_entered)
;               return;
;           @_1_entered = true;

;           long lnum = buf.b_ml.ml_line_lnum;
;           Bytes new_line = buf.b_ml.ml_line_ptr;

;           block_hdr_C hp = ml_find_line(buf, lnum, ML_FIND);
;           if (hp == null)
;               emsgn(u8("E320: Cannot find line %ld"), lnum);
;           else
;           {
;               data_block_C dp = (data_block_C)hp.bh_data;

;               int idx = (int)(lnum - buf.b_ml.ml_locked_low);
;               int start = (dp.db_index[idx] & DB_INDEX_MASK);
;               int old_len;
;               if (idx == 0)                               ;; line is last in block
;                   old_len = dp.db_txt_end - start;
;               else                                        ;; text of previous line follows
;                   old_len = (dp.db_index[idx - 1] & DB_INDEX_MASK) - start;
;               int new_len = STRLEN(new_line) + 1;
;               int extra = new_len - old_len;              ;; negative if lines gets smaller

                ;; if new line fits in data block, replace directly

;               if (extra <= dp.db_free)
;               {
                    ;; if the length changes and there are following lines
;                   int count = (int)(buf.b_ml.ml_locked_high - buf.b_ml.ml_locked_low + 1);
;                   if (extra != 0 && idx < count - 1)
;                   {
                        ;; move text of following lines
;                       BCOPY(dp.db_text, dp.db_txt_start - extra, dp.db_text, dp.db_txt_start, start - dp.db_txt_start);

                        ;; adjust pointers of this and following lines
;                       for (int i = idx + 1; i < count; i++)
;                           dp.db_index[i] -= extra;
;                   }
;                   dp.db_index[idx] -= extra;

                    ;; adjust free space
;                   dp.db_free -= extra;
;                   dp.db_txt_start -= extra;

                    ;; copy new line into the data block
;                   BCOPY(dp.db_text, start - extra, new_line, 0, new_len);
;                   buf.b_ml.ml_flags |= (ML_LOCKED_DIRTY | ML_LOCKED_POS);
                    ;; The else case is already covered by the insert and delete.
;                   ml_updatechunk(buf, lnum, (long)extra, ML_CHNK_UPDLINE);
;               }
;               else
;               {
                    ;; Cannot do it in one data block: Delete and append.
                    ;; Append first, because ml_delete_int() cannot delete the last line
                    ;; in a buffer, which causes trouble for a buffer that has only one line.
                    ;; Don't forget to copy the mark!

                    ;; How about handling errors???
;                   ml_append_int(buf, lnum, new_line, new_len, false, (dp.db_index[idx] & DB_MARKED) != 0);
;                   ml_delete_int(buf, lnum, false);
;               }
;           }

;           @_1_entered = false;
;       }

;       buf.b_ml.ml_line_lnum = 0;
    ))

;; create a new, empty, zero block

(defn- #_block_hdr_C ml_new_zero [#_memfile_C mfp]
    (§
;       return mf_new(mfp, false, §_zero_block_C(), 1);
    ))

;; create a new, empty, pointer block

(defn- #_block_hdr_C ml_new_ptr [#_memfile_C mfp]
    (§
;       return mf_new(mfp, false, §_ptr_block_C(), 1);
    ))

;; create a new, empty, data block

(defn- #_block_hdr_C ml_new_data [#_memfile_C mfp, #_boolean negative, #_int page_count]
    (§
;       return mf_new(mfp, negative, new_data_block(page_count), page_count);
    ))

;; lookup line 'lnum' in a memline
;;
;;   action: if ML_DELETE or ML_INSERT the line count is updated while searching
;;           if ML_FLUSH only flush a locked block
;;           if ML_FIND just find the line
;;
;; If the block was found it is locked and put in ml_locked.
;; The stack is updated to lead to the locked block.  The ip_high field in
;; the stack is updated to reflect the last line in the block AFTER the
;; insert or delete, also if the pointer block has not been updated yet.
;; But if ml_locked != null ml_locked_lineadd must be added to ip_high.
;;
;; return: null for failure, pointer to block header otherwise

(defn- #_block_hdr_C ml_find_line [#_buffer_C buf, #_long lnum, #_int action]
    (§
;       memfile_C mfp = buf.b_ml.ml_mfp;

        ;; If there is a locked block check if the wanted line is in it.
        ;; If not, flush and release the locked block.
        ;; Don't do this for ML_INSERT_SAME, because the stack need to be updated.
        ;; Don't do this for ML_FLUSH, because we want to flush the locked block.
        ;; Don't do this when 'swapfile' is reset, we want to load all the blocks.

;       if (buf.b_ml.ml_locked != null)
;       {
;           if (ml_simple(action) && buf.b_ml.ml_locked_low <= lnum && lnum <= buf.b_ml.ml_locked_high)
;           {
                ;; remember to update pointer blocks and stack later
;               if (action == ML_INSERT)
;               {
;                   buf.b_ml.ml_locked_lineadd++;
;                   buf.b_ml.ml_locked_high++;
;               }
;               else if (action == ML_DELETE)
;               {
;                   --buf.b_ml.ml_locked_lineadd;
;                   --buf.b_ml.ml_locked_high;
;               }
;               return buf.b_ml.ml_locked;
;           }

;           mf_put(mfp, buf.b_ml.ml_locked, (buf.b_ml.ml_flags & ML_LOCKED_DIRTY) != 0,
;                                             (buf.b_ml.ml_flags & ML_LOCKED_POS) != 0);
;           buf.b_ml.ml_locked = null;

            ;; If lines have been added or deleted in the locked block,
            ;; need to update the line count in pointer blocks.

;           if (buf.b_ml.ml_locked_lineadd != 0)
;               ml_lineadd(buf, buf.b_ml.ml_locked_lineadd);
;       }

;       if (action == ML_FLUSH)                         ;; nothing else to do
;           return null;

;       long bnum = 1;                                  ;; start at the root of the tree
;       int page_count = 1;
;       long low = 1;
;       long high = buf.b_ml.ml_line_count;

;       if (action == ML_FIND)                          ;; first try stack entries
;       {
;           int top;
;           for (top = buf.b_ml.ml_stack_top - 1; 0 <= top; --top)
;           {
;               infoptr_C ip = buf.b_ml.ml_stack[top];
;               if (ip.ip_low <= lnum && lnum <= ip.ip_high)
;               {
;                   bnum = ip.ip_bnum;
;                   low = ip.ip_low;
;                   high = ip.ip_high;
;                   buf.b_ml.ml_stack_top = top;        ;; truncate stack at prev entry
;                   break;
;               }
;           }
;           if (top < 0)
;               buf.b_ml.ml_stack_top = 0;              ;; not found, start at the root
;       }
;       else        ;; ML_DELETE or ML_INSERT
;           buf.b_ml.ml_stack_top = 0;                  ;; start at the root

;       error_noblock:
;       {
;           block_hdr_C hp;

            ;; search downwards in the tree until a data block is found

;           error_block:
;           for ( ; ; )
;           {
;               hp = mf_get(mfp, bnum, page_count);
;               if (hp == null)
;                   break error_noblock;

                ;; update high for insert/delete

;               if (action == ML_INSERT)
;                   high++;
;               else if (action == ML_DELETE)
;                   --high;

;               if (hp.bh_data instanceof data_block_C)
;               {
;                   data_block_C dp = (data_block_C)hp.bh_data;
;                   if (dp.db_id == DATA_ID)                    ;; data block
;                   {
;                       buf.b_ml.ml_locked = hp;
;                       buf.b_ml.ml_locked_low = low;
;                       buf.b_ml.ml_locked_high = high;
;                       buf.b_ml.ml_locked_lineadd = 0;
;                       buf.b_ml.ml_flags &= ~(ML_LOCKED_DIRTY | ML_LOCKED_POS);
;                       return hp;
;                   }
;               }

;               ptr_block_C pp = (ptr_block_C)hp.bh_data;           ;; must be pointer block
;               if (pp.pb_id != PTR_ID)
;               {
;                   emsg(u8("E317: pointer block id wrong"));
;                   break error_block;
;               }

;               int top = ml_add_stack(buf);
;               if (top < 0)                                ;; add new entry to stack
;                   break error_block;

;               infoptr_C ip = buf.b_ml.ml_stack[top];
;               ip.ip_bnum = bnum;
;               ip.ip_low = low;
;               ip.ip_high = high;
;               ip.ip_index = -1;                           ;; index not known yet

;               boolean dirty = false;
;               int idx;
;               for (idx = 0; idx < pp.pb_count; idx++)
;               {
;                   long t = pp.pb_pointer[idx].pe_line_count;

;                   if (lnum < (low += t))
;                   {
;                       ip.ip_index = idx;
;                       bnum = pp.pb_pointer[idx].pe_bnum;
;                       page_count = pp.pb_pointer[idx].pe_page_count;
;                       high = low - 1;
;                       low -= t;

                        ;; a negative block number may have been changed

;                       if (bnum < 0)
;                       {
;                           long bnum2 = mf_trans_del(mfp, bnum);
;                           if (bnum != bnum2)
;                           {
;                               bnum = bnum2;
;                               pp.pb_pointer[idx].pe_bnum = bnum;
;                               dirty = true;
;                           }
;                       }

;                       break;
;                   }
;               }
;               if (pp.pb_count <= idx)         ;; past the end: something wrong!
;               {
;                   if (buf.b_ml.ml_line_count < lnum)
;                       emsgn(u8("E322: line number out of range: %ld past the end"), lnum - buf.b_ml.ml_line_count);

;                   else
;                       emsgn(u8("E323: line count wrong in block %ld"), bnum);
;                   break error_block;
;               }
;               if (action == ML_DELETE)
;               {
;                   pp.pb_pointer[idx].pe_line_count--;
;                   dirty = true;
;               }
;               else if (action == ML_INSERT)
;               {
;                   pp.pb_pointer[idx].pe_line_count++;
;                   dirty = true;
;               }
;               mf_put(mfp, hp, dirty, false);
;           }

;           mf_put(mfp, hp, false, false);
;       }

        ;; If action is ML_DELETE or ML_INSERT we have to correct the tree for
        ;; the incremented/decremented line counts, because there won't be a line
        ;; inserted/deleted after all.

;       if (action == ML_DELETE)
;           ml_lineadd(buf, 1);
;       else if (action == ML_INSERT)
;           ml_lineadd(buf, -1);
;       buf.b_ml.ml_stack_top = 0;
;       return null;
    ))

;; add an entry to the info pointer stack
;;
;; return -1 for failure, number of the new entry otherwise

(defn- #_int ml_add_stack [#_buffer_C buf]
    (§
;       int top = buf.b_ml.ml_stack_top;

        ;; may have to increase the stack size
;       if (top == buf.b_ml.ml_stack_size)
;       {
;           infoptr_C[] newstack = ARRAY_infoptr(buf.b_ml.ml_stack_size + STACK_INCR);

;           for (int i = 0; i < top; i++)
;               COPY_infoptr(newstack[i], buf.b_ml.ml_stack[i]);
;           buf.b_ml.ml_stack = newstack;
;           buf.b_ml.ml_stack_size += STACK_INCR;
;       }

;       buf.b_ml.ml_stack_top++;
;       return top;
    ))

;; Update the pointer blocks on the stack for inserted/deleted lines.
;; The stack itself is also updated.
;;
;; When a insert/delete line action fails, the line is not inserted/deleted,
;; but the pointer blocks have already been updated.  That is fixed here by
;; walking through the stack.
;;
;; Count is the number of lines added, negative if lines have been deleted.

(defn- #_void ml_lineadd [#_buffer_C buf, #_int count]
    (§
;       memfile_C mfp = buf.b_ml.ml_mfp;

;       for (int idx = buf.b_ml.ml_stack_top - 1; 0 <= idx; --idx)
;       {
;           infoptr_C ip = buf.b_ml.ml_stack[idx];
;           block_hdr_C hp = mf_get(mfp, ip.ip_bnum, 1);
;           if (hp == null)
;               break;

;           ptr_block_C pp = (ptr_block_C)hp.bh_data; ;; must be pointer block
;           if (pp.pb_id != PTR_ID)
;           {
;               mf_put(mfp, hp, false, false);
;               emsg(u8("E317: pointer block id wrong 2"));
;               break;
;           }

;           pp.pb_pointer[ip.ip_index].pe_line_count += count;
;           ip.ip_high += count;
;           mf_put(mfp, hp, true, false);
;       }
    ))

;; Set the flags in the first block of the swap file:
;; - file is modified or not: buf.b_changed

(defn- #_void ml_setflags [#_buffer_C buf]
    (§
;       if (buf.b_ml.ml_mfp == null)
;           return;

;       for (block_hdr_C hp = buf.b_ml.ml_mfp.mf_used_last; hp != null; hp = hp.bh_prev)
;       {
;           if (hp.bh_bnum() == 0)
;           {
;               hp.bh_flags |= BH_DIRTY;
;               break;
;           }
;       }
    ))

(final int MLCS_MAXL 800)   ;; max no of lines in chunk
(final int MLCS_MINL 400)   ;; should be half of MLCS_MAXL

(atom! buffer_C     ml_upd_lastbuf)
(atom! long         ml_upd_lastline)
(atom! long         ml_upd_lastcurline)
(atom! int          ml_upd_lastcurix)

;; Keep information for finding byte offset of a line, updtype may be one of:
;; ML_CHNK_ADDLINE: Add len to parent chunk, possibly splitting it.
;;         Careful: ML_CHNK_ADDLINE may cause ml_find_line() to be called.
;; ML_CHNK_DELLINE: Subtract len from parent chunk, possibly deleting it.
;; ML_CHNK_UPDLINE: Add len to parent chunk, as a signed entity.

(defn- #_void ml_updatechunk [#_buffer_C buf, #_long line, #_long len, #_int updtype]
    (§
;       long curline = @ml_upd_lastcurline;
;       int curix = @ml_upd_lastcurix;

;       if (buf.b_ml.ml_usedchunks == -1 || len == 0)
;           return;

;       if (buf.b_ml.ml_chunksize == null)
;       {
;           buf.b_ml.ml_chunksize = ARRAY_chunksize(100);
;           buf.b_ml.ml_numchunks = 100;
;           buf.b_ml.ml_usedchunks = 1;
;           buf.b_ml.ml_chunksize[0].mlcs_numlines = 1;
;           buf.b_ml.ml_chunksize[0].mlcs_totalsize = 1;
;       }

;       if (updtype == ML_CHNK_UPDLINE && buf.b_ml.ml_line_count == 1)
;       {
            ;; First line in empty buffer from ml_flush_line() -- reset.

;           buf.b_ml.ml_usedchunks = 1;
;           buf.b_ml.ml_chunksize[0].mlcs_numlines = 1;
;           buf.b_ml.ml_chunksize[0].mlcs_totalsize = STRLEN(buf.b_ml.ml_line_ptr) + 1;
;           return;
;       }

        ;; Find chunk that our line belongs to, curline will be at start of the chunk.

;       if (buf != @ml_upd_lastbuf || line != @ml_upd_lastline + 1 || updtype != ML_CHNK_ADDLINE)
;       {
;           for (curline = 1, curix = 0;
;                curix < buf.b_ml.ml_usedchunks - 1
;                   && curline + buf.b_ml.ml_chunksize[curix].mlcs_numlines <= line;
;                curix++)
;           {
;               curline += buf.b_ml.ml_chunksize[curix].mlcs_numlines;
;           }
;       }
;       else if (curline + buf.b_ml.ml_chunksize[curix].mlcs_numlines <= line
;                   && curix < buf.b_ml.ml_usedchunks - 1)
;       {
            ;; Adjust cached curix & curline.
;           curline += buf.b_ml.ml_chunksize[curix].mlcs_numlines;
;           curix++;
;       }

;       if (updtype == ML_CHNK_DELLINE)
;           len = -len;
;       buf.b_ml.ml_chunksize[curix].mlcs_totalsize += len;

;       if (updtype == ML_CHNK_ADDLINE)
;       {
;           chunksize_C[] chunks = buf.b_ml.ml_chunksize;

;           chunks[curix].mlcs_numlines++;

            ;; May resize here so we don't have to do it in both cases below.
;           if (buf.b_ml.ml_numchunks <= buf.b_ml.ml_usedchunks + 1)
;           {
;               int n = buf.b_ml.ml_numchunks;
;               buf.b_ml.ml_numchunks = n * 3 / 2;
;               chunks = ARRAY_chunksize(buf.b_ml.ml_numchunks);
;               for (int i = 0; i < buf.b_ml.ml_usedchunks; i++)
;                   COPY_chunksize(chunks[i], buf.b_ml.ml_chunksize[i]);
;               buf.b_ml.ml_chunksize = chunks;
;           }

;           if (MLCS_MAXL <= chunks[curix].mlcs_numlines)
;           {
;               for (int i = buf.b_ml.ml_usedchunks; curix <= --i; )
;                   COPY_chunksize(chunks[i + 1], chunks[i]);

                ;; Compute length of first half of lines in the split chunk.
;               long size = 0;
;               int linecnt = 0;
;               while (curline < buf.b_ml.ml_line_count && linecnt < MLCS_MINL)
;               {
;                   block_hdr_C hp = ml_find_line(buf, curline, ML_FIND);
;                   if (hp == null)
;                   {
;                       buf.b_ml.ml_usedchunks = -1;
;                       return;
;                   }

;                   data_block_C dp = (data_block_C)hp.bh_data;

                    ;; number of entries in block
;                   int count = (int)(buf.b_ml.ml_locked_high - buf.b_ml.ml_locked_low + 1);
;                   int idx = (int)(curline - buf.b_ml.ml_locked_low);
;                   curline = buf.b_ml.ml_locked_high + 1;
;                   int text_end;
;                   if (idx == 0)       ;; first line in block, text at the end
;                       text_end = dp.db_txt_end;
;                   else
;                       text_end = (dp.db_index[idx - 1] & DB_INDEX_MASK);
                    ;; Compute index of last line to use in this MEMLINE.
;                   int rest = count - idx;
;                   if (MLCS_MINL < linecnt + rest)
;                   {
;                       idx += MLCS_MINL - linecnt - 1;
;                       linecnt = MLCS_MINL;
;                   }
;                   else
;                   {
;                       idx = count - 1;
;                       linecnt += rest;
;                   }
;                   size += text_end - (dp.db_index[idx] & DB_INDEX_MASK);
;               }

;               chunks[curix].mlcs_numlines = linecnt;
;               chunks[curix + 1].mlcs_numlines -= linecnt;
;               chunks[curix].mlcs_totalsize = size;
;               chunks[curix + 1].mlcs_totalsize -= size;
;               buf.b_ml.ml_usedchunks++;

;               @ml_upd_lastbuf = null;      ;; Force recalc of curix & curline.
;               return;
;           }

;           if (MLCS_MINL <= chunks[curix].mlcs_numlines
;                   && curix == buf.b_ml.ml_usedchunks - 1 && buf.b_ml.ml_line_count - line <= 1)
;           {
                ;; We are in the last chunk and it is cheap to crate a new one after this.
                ;; Do it now to avoid the loop above later on.

;               buf.b_ml.ml_usedchunks++;

;               if (line == buf.b_ml.ml_line_count)
;               {
;                   chunks[curix + 1].mlcs_numlines = 0;
;                   chunks[curix + 1].mlcs_totalsize = 0;
;               }
;               else
;               {
                    ;; Line is just prior to last, move count for last.
                    ;; This is the common case when loading a new file.

;                   block_hdr_C hp = ml_find_line(buf, buf.b_ml.ml_line_count, ML_FIND);
;                   if (hp == null)
;                   {
;                       buf.b_ml.ml_usedchunks = -1;
;                       return;
;                   }

;                   data_block_C dp = (data_block_C)hp.bh_data;

;                   int rest;
;                   if (dp.db_line_count == 1)
;                       rest = dp.db_txt_end - dp.db_txt_start;
;                   else
;                       rest = (dp.db_index[dp.db_line_count - 2] & DB_INDEX_MASK) - dp.db_txt_start;

;                   chunks[curix].mlcs_numlines -= 1;
;                   chunks[curix + 1].mlcs_numlines = 1;
;                   chunks[curix].mlcs_totalsize -= rest;
;                   chunks[curix + 1].mlcs_totalsize = rest;
;               }
;           }
;       }
;       else if (updtype == ML_CHNK_DELLINE)
;       {
;           chunksize_C[] chunks = buf.b_ml.ml_chunksize;

;           chunks[curix].mlcs_numlines--;
;           @ml_upd_lastbuf = null;          ;; Force recalc of curix & curline.

;           if (curix < buf.b_ml.ml_usedchunks - 1
;                   && chunks[curix].mlcs_numlines + chunks[curix + 1].mlcs_numlines <= MLCS_MINL)
;           {
;               curix++;
;           }
;           else if (curix == 0 && chunks[curix].mlcs_numlines <= 0)
;           {
;               buf.b_ml.ml_usedchunks--;
;               for (int i = 0; i < buf.b_ml.ml_usedchunks; i++)
;                   COPY_chunksize(chunks[i], chunks[i + 1]);
;               return;
;           }
;           else if (curix == 0 || (10 < chunks[curix].mlcs_numlines
;                   && MLCS_MINL < chunks[curix].mlcs_numlines + chunks[curix - 1].mlcs_numlines))
;           {
;               return;
;           }

            ;; Collapse chunks.
;           chunks[curix - 1].mlcs_numlines += chunks[curix].mlcs_numlines;
;           chunks[curix - 1].mlcs_totalsize += chunks[curix].mlcs_totalsize;
;           buf.b_ml.ml_usedchunks--;
;           for (int i = curix; i < buf.b_ml.ml_usedchunks; i++)
;               COPY_chunksize(chunks[i], chunks[i + 1]);
;           return;
;       }

;       @ml_upd_lastbuf = buf;
;       @ml_upd_lastline = line;
;       @ml_upd_lastcurline = curline;
;       @ml_upd_lastcurix = curix;
    ))

;; Find offset for line or line with offset.
;; Find line with offset if "lnum" is 0; return remaining offset in offp.
;; Find offset of line if "lnum" > 0.
;; return -1 if information is not available

(defn- #_long ml_find_line_or_offset [#_buffer_C buf, #_long lnum, #_long* offp]
    (§
;       int extra = 0;

        ;; take care of cached line first
;       ml_flush_line(@curbuf);

;       if (buf.b_ml.ml_usedchunks == -1 || buf.b_ml.ml_chunksize == null || lnum < 0)
;           return -1;

;       long offset = (offp != null) ? offp[0] : 0;
;       if (lnum == 0 && offset <= 0)
;           return 1;   ;; Not a "find offset" and offset 0 _must_ be in line 1.

        ;; Find the last chunk before the one containing our line.
        ;; Last chunk is special because it will never qualify.

;       long curline = 1;
;       int curix = 0;
;       long size = curix;
;       while (curix < buf.b_ml.ml_usedchunks - 1
;           && ((lnum != 0 && curline + buf.b_ml.ml_chunksize[curix].mlcs_numlines <= lnum)
;               || (offset != 0 && size + buf.b_ml.ml_chunksize[curix].mlcs_totalsize < offset)))
;       {
;           curline += buf.b_ml.ml_chunksize[curix].mlcs_numlines;
;           size += buf.b_ml.ml_chunksize[curix].mlcs_totalsize;
;           curix++;
;       }

;       while ((lnum != 0 && curline < lnum) || (offset != 0 && size < offset))
;       {
;           if (buf.b_ml.ml_line_count < curline)
;               return -1;

;           block_hdr_C hp = ml_find_line(buf, curline, ML_FIND);
;           if (hp == null)
;               return -1;

;           data_block_C dp = (data_block_C)hp.bh_data;

            ;; number of entries in block
;           int count = (int)(buf.b_ml.ml_locked_high - buf.b_ml.ml_locked_low + 1);
;           int idx = (int)(curline - buf.b_ml.ml_locked_low);
;           int start_idx = idx;
;           int text_end;
;           if (idx == 0)                           ;; first line in block, text at the end
;               text_end = dp.db_txt_end;
;           else
;               text_end = (dp.db_index[idx - 1] & DB_INDEX_MASK);
            ;; Compute index of last line to use in this MEMLINE.
;           if (lnum != 0)
;           {
;               if (lnum <= curline + (count - idx))
;                   idx += lnum - curline - 1;
;               else
;                   idx = count - 1;
;           }
;           else
;           {
;               extra = 0;
;               while (size + text_end - (dp.db_index[idx] & DB_INDEX_MASK) <= offset)
;               {
;                   if (idx == count - 1)
;                   {
;                       extra = 1;
;                       break;
;                   }
;                   idx++;
;               }
;           }
;           int len = text_end - (dp.db_index[idx] & DB_INDEX_MASK);
;           size += len;
;           if (offset != 0 && offset <= size)
;           {
;               if (size == offset)
;                   offp[0] = 0;
;               else if (idx == start_idx)
;                   offp[0] = offset - size + len;
;               else
;                   offp[0] = offset - size + len - (text_end - (dp.db_index[idx - 1] & DB_INDEX_MASK));
;               curline += idx - start_idx + extra;
;               if (buf.b_ml.ml_line_count < curline)
;                   return -1;      ;; exactly one byte beyond the end

;               return curline;
;           }
;           curline = buf.b_ml.ml_locked_high + 1;
;       }

;       return size;
    ))

;; Goto byte in buffer with offset 'cnt'.

(defn- #_void goto_byte [#_long cnt]
    (§
;       long[] boff = { cnt };

;       ml_flush_line(@curbuf);      ;; cached line may be dirty
;       setpcmark();
;       if (boff[0] != 0)
;           --boff[0];

;       long lnum = ml_find_line_or_offset(@curbuf, 0, boff);
;       if (lnum < 1)       ;; past the end
;       {
;           @curwin.w_cursor.lnum = @curbuf.b_ml.ml_line_count;
;           @curwin.w_curswant = MAXCOL;
;           coladvance(MAXCOL);
;       }
;       else
;       {
;           @curwin.w_cursor.lnum = lnum;
;           @curwin.w_cursor.col = (int)boff[0];
;           @curwin.w_cursor.coladd = 0;
;           @curwin.w_set_curswant = true;
;       }
;       check_cursor();

        ;; Make sure the cursor is on the first byte of a multi-byte char.
;       mb_adjust_pos(@curbuf, @curwin.w_cursor);
    ))

;; buffer.c: functions for dealing with the buffer structure --------------------------------------

;; The buffer list is a double linked list of all buffers.
;; Each buffer can be in one of these states:
;; never loaded: BF_NEVERLOADED is set, only the file name is valid
;;   not loaded: b_ml.ml_mfp == null, no memfile allocated
;;       hidden: b_nwindows == 0, loaded but not displayed in a window
;;       normal: loaded and displayed in a window
;;
;; Instead of storing file names all over the place, each file name is
;; stored in the buffer list.  It can be referenced by a number.
;;
;; The current implementation remembers all file names ever used.

(final Bytes e_auabort (u8 "E855: Autocommands caused command to abort"))

;; Open current buffer, that is: open the memfile and read the file into memory.
;; Return false for failure, true otherwise.

(defn- #_boolean open_buffer [#_boolean read_stdin, #_exarg_C eap, #_int flags]
    ;; read_stdin: read file from stdin
    ;; eap: for forced 'ff' and 'fenc' or null
    ;; flags: extra flags for readfile()
    (§
;       boolean[] retval = { true };
;       long old_tw = @curbuf.@b_p_tw;

;       if (ml_open(@curbuf) == false)
;       {
            ;; There MUST be a memfile, otherwise we can't do anything.
            ;; If we can't create one for the current buffer, take another buffer.

;           close_buffer(null, @curbuf, 0, false);
;           for (@curbuf = @firstbuf; @curbuf != null; @curbuf = @curbuf.b_next)
;               if (@curbuf.b_ml.ml_mfp != null)
;                   break;

            ;; If there is no memfile at all, exit.
            ;; This is OK, since there are no changes to lose.

;           if (@curbuf == null)
;           {
;               emsg(u8("E82: Cannot allocate any buffer, exiting..."));
;               getout(2);
;           }
;           emsg(u8("E83: Cannot allocate buffer, using other one..."));
;           enter_buffer(@curbuf);
;           if (old_tw != @curbuf.@b_p_tw)
;               check_colorcolumn(@curwin);
;           return false;
;       }

        ;; The autocommands in readfile() may change the buffer, but only AFTER reading the file.
;       buffer_C old_curbuf = @curbuf;
;       @modified_was_set = false;

        ;; mark cursor position as being invalid
;       @curwin.w_valid = 0;

        ;; if first time loading this buffer, init b_chartab[]
;       if ((@curbuf.b_flags & BF_NEVERLOADED) != 0)
;       {
;           buf_init_chartab(@curbuf, false);
;           parse_cino(@curbuf);
;       }

        ;; Set/reset the Changed flag first, autocmds may change the buffer.
        ;; Apply the automatic commands, before processing the modelines.
        ;; So the modelines have priority over auto commands.

        ;; When reading stdin, the buffer contents always needs writing, so set
        ;; the changed flag.  Unless in readonly mode: "ls | gview -".
        ;; When interrupted and 'cpoptions' contains 'i' set changed flag.
;       if ((@got_int && vim_strbyte(@p_cpo, CPO_INTMOD) != null)
;                   || @modified_was_set     ;; ":set modified" used in autocmd
;                   || (aborting() && vim_strbyte(@p_cpo, CPO_INTMOD) != null))
;           changed();
;       else if (retval[0] != false && !read_stdin)
;           unchanged(@curbuf, false);

        ;; require "!" to overwrite the file, because it wasn't read completely
;       if (aborting())
;           @curbuf.b_flags |= BF_READERR;

        ;; need to set w_topline, unless some autocommand already did that.
;       if ((@curwin.w_valid & VALID_TOPLINE) == 0)
;       {
;           @curwin.w_topline = 1;
;       }

;       if (retval[0] != false)
;       {
            ;; The autocommands may have changed the current buffer.  Apply the
            ;; modelines to the correct buffer, if it still exists and is loaded.

;           if (buf_valid(old_curbuf) && old_curbuf.b_ml.ml_mfp != null)
;           {
;               @curbuf.b_flags &= ~(BF_CHECK_RO | BF_NEVERLOADED);
;           }
;       }

;       return retval[0];
    ))

;; Return true if "buf" points to a valid buffer (in the buffer list).

(defn- #_boolean buf_valid [#_buffer_C buf]
    (§
;       for (buffer_C bp = @firstbuf; bp != null; bp = bp.b_next)
;           if (bp == buf)
;               return true;

;       return false;
    ))

;; Close the link to a buffer.
;; "action" is used when there is no longer a window for the buffer.
;; It can be:
;; 0                    buffer becomes hidden
;; DOBUF_UNLOAD         buffer is unloaded
;; DOBUF_DELETE         buffer is unloaded and removed from buffer list
;; DOBUF_WIPE           buffer is unloaded and really deleted
;; When doing all but the first one on the current buffer, the caller should
;; get a new buffer very soon!
;;
;; The 'bufhidden' option can force freeing and deleting.
;;
;; When "abort_if_last" is true then do not close the buffer if autocommands
;; cause there to be only one window with this buffer.  e.g. when ":quit" is
;; supposed to close the window but autocommands close all other windows.

(defn- #_void close_buffer [#_window_C win, #_buffer_C buf, #_int action, #_boolean abort_if_last]
    ;; win: if not null, set b_last_cursor
    (§
;       boolean unload_buf = (action != 0);
;       boolean del_buf = (action == DOBUF_DEL || action == DOBUF_WIPE);
;       boolean wipe_buf = (action == DOBUF_WIPE);

;       if (win != null && win_valid(win))      ;; in case autocommands closed the window
;       {
            ;; Set b_last_cursor when closing the last window for the buffer.
            ;; Remember the last cursor position and window options of the buffer.
            ;; This used to be only for the current window, but then options like
            ;; 'foldmethod' may be lost with a ":only" command.
;           if (buf.b_nwindows == 1)
;               set_last_cursor(win);
;           buflist_setfpos(buf, win, (win.w_cursor.lnum == 1) ? 0 : win.w_cursor.lnum, win.w_cursor.col, true);
;       }

        ;; When the buffer is no longer in a window, trigger BufWinLeave.
;       if (buf.b_nwindows == 1)
;       {
;           buf.b_closing = true;
;           if (!buf_valid(buf))
;           {
                ;; Autocommands deleted the buffer.
;               emsg(e_auabort);
;               return;
;           }
;           buf.b_closing = false;
;           if (abort_if_last && one_window())
;           {
                ;; Autocommands made this the only window.
;               emsg(e_auabort);
;               return;
;           }

            ;; When the buffer becomes hidden, but is not unloaded, trigger BufHidden.
;           if (!unload_buf)
;           {
;               buf.b_closing = true;
;               if (!buf_valid(buf))
;               {
                    ;; Autocommands deleted the buffer.
;                   emsg(e_auabort);
;                   return;
;               }
;               buf.b_closing = false;
;               if (abort_if_last && one_window())
;               {
                    ;; Autocommands made this the only window.
;                   emsg(e_auabort);
;                   return;
;               }
;           }
;           if (aborting())     ;; autocmds may abort script processing
;               return;
;       }

;       int nwindows = buf.b_nwindows;

        ;; decrease the link count from windows (unless not in any window)
;       if (0 < buf.b_nwindows)
;           --buf.b_nwindows;

        ;; Return when a window is displaying the buffer or when it's not unloaded.
;       if (0 < buf.b_nwindows || !unload_buf)
;           return;

        ;; Always remove the buffer when there is no file name.
;       del_buf = true;

        ;; Remember if we are closing the current buffer.  Restore the number of
        ;; windows, so that autocommands in buf_freeall() don't get confused.
;       boolean is_curbuf = (buf == @curbuf);
;       buf.b_nwindows = nwindows;

;       buf_freeall(buf, (del_buf ? BFA_DEL : 0) + (wipe_buf ? BFA_WIPE : 0));
;       if (win_valid(win) && win.w_buffer == buf)
;           win.w_buffer = null;    ;; make sure we don't use the buffer now

        ;; Autocommands may have deleted the buffer.
;       if (!buf_valid(buf))
;           return;
;       if (aborting())             ;; autocmds may abort script processing
;           return;

        ;; Autocommands may have opened or closed windows for this buffer.
        ;; Decrement the count for the close we do here.
;       if (0 < buf.b_nwindows)
;           --buf.b_nwindows;

        ;; It's possible that autocommands change curbuf to the one being deleted.
        ;; This might cause the previous curbuf to be deleted unexpectedly.
        ;; But in some cases it's OK to delete the curbuf, because a new one is
        ;; obtained anyway.  Therefore only return if curbuf changed to the deleted buffer.

;       if (buf == @curbuf && !is_curbuf)
;           return;

        ;; Remove the buffer from the list.

;       if (wipe_buf)
;       {
;           if (buf.b_prev == null)
;               @firstbuf = buf.b_next;
;           else
;               buf.b_prev.b_next = buf.b_next;
;           if (buf.b_next == null)
;               @lastbuf = buf.b_prev;
;           else
;               buf.b_next.b_prev = buf.b_prev;
;           free_buffer(buf);
;       }
;       else
;       {
;           if (del_buf)
;           {
                ;; Free all internal variables and reset option values
                ;; to make ":bdel" compatible with Vim 5.7.
;               free_buffer_stuff(buf, true);

                ;; Make it look like a new buffer.
;               buf.b_flags = BF_CHECK_RO | BF_NEVERLOADED;

                ;; Init the options when loaded again.
;               buf.b_p_initialized = false;
;           }
;           buf_clear_file(buf);
;       }
    ))

;; Make buffer not contain a file.

(defn- #_void buf_clear_file [#_buffer_C buf]
    (§
;       buf.b_ml.ml_line_count = 1;
;       unchanged(buf, true);
;       buf.b_ml.ml_mfp = null;
;       buf.b_ml.ml_flags = ML_EMPTY;   ;; empty buffer
    ))

;; buf_freeall() - free all things allocated for a buffer that are related to the file.
;; flags:
;;  BFA_DEL        buffer is going to be deleted
;;  BFA_WIPE       buffer is going to be wiped out
;;  BFA_KEEP_UNDO  do not free undo information

(defn- #_void buf_freeall [#_buffer_C buf, #_int flags]
    (§
;       boolean is_curbuf = (buf == @curbuf);

;       buf.b_closing = true;
;       if (!buf_valid(buf))            ;; autocommands may delete the buffer
;           return;
;       if ((flags & BFA_DEL) != 0)
;       {
;           if (!buf_valid(buf))        ;; autocommands may delete the buffer
;               return;
;       }
;       if ((flags & BFA_WIPE) != 0)
;       {
;           if (!buf_valid(buf))        ;; autocommands may delete the buffer
;               return;
;       }
;       buf.b_closing = false;
;       if (aborting())                 ;; autocommands may abort script processing
;           return;

        ;; It's possible that autocommands change curbuf to the one being deleted.
        ;; This might cause curbuf to be deleted unexpectedly.  But in some cases
        ;; it's OK to delete the curbuf, because a new one is obtained anyway.
        ;; Therefore only return if curbuf changed to the deleted buffer.

;       if (buf == @curbuf && !is_curbuf)
;           return;

;       ml_close(buf);                  ;; close the memline/memfile
;       buf.b_ml.ml_line_count = 0;     ;; no lines in buffer
;       if ((flags & BFA_KEEP_UNDO) == 0)
;       {
;           u_blockfree(buf);           ;; free the memory allocated for undo
;           u_clearall(buf);            ;; reset all undo information
;       }
;       buf.b_flags &= ~BF_READERR;     ;; a read error is no longer relevant
    ))

;; Free a buffer structure and the things it contains related to the buffer
;; itself (not the file, that must have been done already).

(defn- #_void free_buffer [#_buffer_C buf]
    (§
;       free_buffer_stuff(buf, true);
    ))

;; Free stuff in the buffer for ":bdel" and when wiping out the buffer.

(defn- #_void free_buffer_stuff [#_buffer_C buf, #_boolean free_options]
    ;; free_options: free options as well
    (§
;       if (free_options)
;       {
;           clear_wininfo(buf);                             ;; including window-local options
;           free_buf_options(buf, true);
;       }
;       map_clear_int(buf, MAP_ALL_MODES, true, false);     ;; clear local mappings
;       map_clear_int(buf, MAP_ALL_MODES, true, true);      ;; clear local abbrevs
    ))

;; Free the b_wininfo list for buffer "buf".

(defn- #_void clear_wininfo [#_buffer_C buf]
    (§
;       while (buf.b_wininfo != null)
;       {
;           wininfo_C wip = buf.b_wininfo;
;           buf.b_wininfo = wip.wi_next;
;           if (wip.wi_optset)
;               clear_winopt(wip.wi_opt);
;       }
    ))

;; Go to another buffer.  Handles the result of the ATTENTION dialog.

(defn- #_void goto_buffer [#_exarg_C eap, #_int start, #_int dir, #_int count]
    (§
;       do_buffer(eap.cmd.at(0) == (byte)'s' ? DOBUF_SPLIT : DOBUF_GOTO, start, dir, count, eap.forceit);
    ))

;; do_bufdel() - delete or unload buffer(s)
;;
;; addr_count == 0: ":bdel" - delete current buffer
;; addr_count == 1: ":N bdel" or ":bdel N [N ..]" - first delete buffer "end_bnr", then any other arguments.
;; addr_count == 2: ":N,N bdel" - delete buffers in range
;;
;; command can be DOBUF_UNLOAD (":bunload"), DOBUF_WIPE (":bwipeout") or DOBUF_DEL (":bdel")
;;
;; Returns error message or null

(defn- #_Bytes do_bufdel [#_int command, #_Bytes arg, #_int addr_count, #_int start_bnr, #_int end_bnr, #_boolean forceit]
    ;; arg: pointer to extra arguments
    ;; start_bnr: first buffer number in a range
    ;; end_bnr: buffer nr or last buffer nr in a range
    (§
;       int do_current = 0;         ;; delete current buffer?
;       int deleted = 0;            ;; number of buffers deleted
;       Bytes errormsg = null;     ;; return value

;       if (addr_count == 0)
;       {
;           do_buffer(command, DOBUF_CURRENT, FORWARD, 0, forceit);
;       }
;       else
;       {
;           int bnr;                    ;; buffer number
;           if (addr_count == 2)
;           {
;               if (arg.at(0) != NUL)           ;; both range and argument is not allowed
;                   return e_trailing;
;               bnr = start_bnr;
;           }
;           else    ;; addr_count == 1
;               bnr = end_bnr;

;           for ( ; !@got_int; ui_breakcheck())
;           {
                ;; delete the current buffer last, otherwise when the
                ;; current buffer is deleted, the next buffer becomes
                ;; the current one and will be loaded, which may then
                ;; also be deleted, etc.

;               if (bnr == @curbuf.b_fnum)
;                   do_current = bnr;
;               else if (do_buffer(command, DOBUF_FIRST, FORWARD, bnr, forceit) == true)
;                   deleted++;

                ;; find next buffer number to delete/unload

;               if (addr_count == 2)
;               {
;                   if (end_bnr < ++bnr)
;                       break;
;               }
;               else    ;; addr_count == 1
;               {
;                   arg = skipwhite(arg);
;                   if (arg.at(0) == NUL)
;                       break;
;                   if (!asc_isdigit(arg.at(0)))
;                   {
;                       Bytes p = skiptowhite_esc(arg);
;                       bnr = buflist_findpat(arg, p);
;                       if (bnr < 0)            ;; failed
;                           break;
;                       arg = p;
;                   }
;                   else
;                   {
;                       Bytes[] __ = { arg }; bnr = (int)getdigits(__); arg = __[0];
;                   }
;               }
;           }
;           if (!@got_int && do_current != 0 && do_buffer(command, DOBUF_FIRST, FORWARD, do_current, forceit) == true)
;               deleted++;

;           if (deleted == 0)
;           {
;               if (command == DOBUF_UNLOAD)
;                   STRCPY(@ioBuff, u8("E515: No buffers were unloaded"));
;               else if (command == DOBUF_DEL)
;                   STRCPY(@ioBuff, u8("E516: No buffers were deleted"));
;               else
;                   STRCPY(@ioBuff, u8("E517: No buffers were wiped out"));
;               errormsg = @ioBuff;
;           }
;           else if (@p_report <= deleted)
;           {
;               if (command == DOBUF_UNLOAD)
;               {
;                   if (deleted == 1)
;                       msg(u8("1 buffer unloaded"));
;                   else
;                       smsg(u8("%d buffers unloaded"), deleted);
;               }
;               else if (command == DOBUF_DEL)
;               {
;                   if (deleted == 1)
;                       msg(u8("1 buffer deleted"));
;                   else
;                       smsg(u8("%d buffers deleted"), deleted);
;               }
;               else
;               {
;                   if (deleted == 1)
;                       msg(u8("1 buffer wiped out"));
;                   else
;                       smsg(u8("%d buffers wiped out"), deleted);
;               }
;           }
;       }

;       return errormsg;
    ))

;; Make the current buffer empty.
;; Used when it is wiped out and it's the last buffer.

(defn- #_boolean empty_curbuf [#_boolean close_others, #_boolean forceit, #_int action]
    (§
;       if (action == DOBUF_UNLOAD)
;       {
;           emsg(u8("E90: Cannot unload last buffer"));
;           return false;
;       }

;       buffer_C buf = @curbuf;

;       if (close_others)
;       {
            ;; Close any other windows on this buffer, then make it empty.
;           close_windows(buf, true);
;       }

;       setpcmark();
;       boolean retval = do_ecmd(null, null, ECMD_ONE, forceit ? ECMD_FORCEIT : 0, @curwin);

        ;; do_ecmd() may create a new buffer, then we have to delete the old one.
        ;; But do_ecmd() may have done that already, check if the buffer still exists.

;       if (buf != @curbuf && buf_valid(buf) && buf.b_nwindows == 0)
;           close_buffer(null, buf, action, false);
;       if (!close_others)
;           @need_fileinfo = false;

;       return retval;
    ))

;; Implementation of the commands for the buffer list.
;;
;; action == DOBUF_GOTO     go to specified buffer
;; action == DOBUF_SPLIT    split window and go to specified buffer
;; action == DOBUF_UNLOAD   unload specified buffer(s)
;; action == DOBUF_DEL      delete specified buffer(s) from buffer list
;; action == DOBUF_WIPE     delete specified buffer(s) really
;;
;; start == DOBUF_CURRENT   go to "count" buffer from current buffer
;; start == DOBUF_FIRST     go to "count" buffer from first buffer
;; start == DOBUF_LAST      go to "count" buffer from last buffer
;; start == DOBUF_MOD       go to "count" modified buffer from current buffer
;;
;; Return false or true.

(defn- #_boolean do_buffer [#_int action, #_int start, #_int dir, #_int count, #_boolean forceit]
    ;; dir: FORWARD or BACKWARD
    ;; count: buffer number or number of buffers
    ;; forceit: true for :...!
    (§
;       boolean unload = (action == DOBUF_UNLOAD || action == DOBUF_DEL || action == DOBUF_WIPE);

;       buffer_C buf;
;       switch (start)
;       {
;           case DOBUF_FIRST:   buf = @firstbuf; break;
;           case DOBUF_LAST:    buf = @lastbuf;  break;
;           default:            buf = @curbuf;   break;
;       }
;       if (start == DOBUF_MOD)         ;; find next modified buffer
;       {
;           while (0 < count--)
;           {
;               do
;               {
;                   buf = buf.b_next;
;                   if (buf == null)
;                       buf = @firstbuf;
;               } while (buf != @curbuf && !bufIsChanged(buf));
;           }
;           if (!bufIsChanged(buf))
;           {
;               emsg(u8("E84: No modified buffer found"));
;               return false;
;           }
;       }
;       else if (start == DOBUF_FIRST && count != 0)    ;; find specified buffer number
;       {
;           while (buf != null && buf.b_fnum != count)
;               buf = buf.b_next;
;       }
;       else
;       {
;           for (buffer_C bp = null; 0 < count; )
;           {
                ;; Remember the buffer where we start,
                ;; we come back there when all buffers are unlisted.
;               if (bp == null)
;                   bp = buf;
;               if (dir == FORWARD)
;               {
;                   buf = buf.b_next;
;                   if (buf == null)
;                       buf = @firstbuf;
;               }
;               else
;               {
;                   buf = buf.b_prev;
;                   if (buf == null)
;                       buf = @lastbuf;
;               }

;               --count;
;               bp = null;      ;; use this buffer as new starting point

;               if (bp == buf)
;               {
                    ;; back where we started, didn't find anything.
;                   emsg(u8("E85: There is no listed buffer"));
;                   return false;
;               }
;           }
;       }

;       if (buf == null)        ;; could not find it
;       {
;           if (start == DOBUF_FIRST)
;           {
                ;; don't warn when deleting
;               if (!unload)
;                   emsgn(e_nobufnr, (long)count);
;           }
;           else if (dir == FORWARD)
;               emsg(u8("E87: Cannot go beyond last buffer"));
;           else
;               emsg(u8("E88: Cannot go before first buffer"));
;           return false;
;       }

        ;; delete buffer buf from memory and/or the list

;       if (unload)
;       {
;           if (!forceit && bufIsChanged(buf))
;           {
;               emsgn(u8("E89: No write since last change for buffer %ld (add ! to override)"), (long)buf.b_fnum);
;               return false;
;           }

            ;; If deleting the last (listed) buffer, make it empty.
            ;; The last (listed) buffer cannot be unloaded.

;           buffer_C bp;
;           for (bp = @firstbuf; bp != null; bp = bp.b_next)
;               if (bp != buf)
;                   break;
;           if (bp == null && buf == @curbuf)
;               return empty_curbuf(true, forceit, action);

            ;; If the deleted buffer is the current one, close the current window
            ;; (unless it's the only window).  Repeat this so long as we end up in
            ;; a window with this buffer.

;           while (buf == @curbuf
;                      && !(@curwin.w_closing || @curwin.w_buffer.b_closing)
;                      && (@firstwin != @lastwin || null != null))
;           {
;               if (win_close(@curwin, false) == false)
;                   break;
;           }

            ;; If the buffer to be deleted is not the current one, delete it here.

;           if (buf != @curbuf)
;           {
;               close_windows(buf, false);
;               if (buf != @curbuf && buf_valid(buf) && buf.b_nwindows <= 0)
;                   close_buffer(null, buf, action, false);
;               return true;
;           }

            ;; Deleting the current buffer: Need to find another buffer to go to.
            ;; There should be another, otherwise it would have been handled
            ;; above.  However, autocommands may have deleted all buffers.
            ;; First use au_new_curbuf, if it is valid.
            ;; Then prefer the buffer we most recently visited.
            ;; Else try to find one that is loaded, after the current buffer,
            ;; then before the current buffer.
            ;; Finally use any buffer.

;           buf = null;     ;; selected buffer
;           bp = null;      ;; used when no loaded buffer found
;           if (0 < @curwin.w_jumplistlen)
;           {
;               int jumpidx = @curwin.w_jumplistidx - 1;
;               if (jumpidx < 0)
;                   jumpidx = @curwin.w_jumplistlen - 1;

;               for (int stop = jumpidx; jumpidx != @curwin.w_jumplistidx; )
;               {
;                   buf = buflist_findnr(@curwin.w_jumplist[jumpidx].fmark.fnum);
;                   if (buf != null)
;                   {
;                       if (buf == @curbuf)
;                           buf = null;     ;; skip current buffer
;                       else if (buf.b_ml.ml_mfp == null)
;                       {
                            ;; skip unloaded buf, but may keep it for later
;                           if (bp == null)
;                               bp = buf;
;                           buf = null;
;                       }
;                   }
;                   if (buf != null)    ;; found a valid buffer: stop searching
;                       break;
                    ;; advance to older entry in jump list
;                   if (jumpidx == 0 && @curwin.w_jumplistidx == @curwin.w_jumplistlen)
;                       break;
;                   if (--jumpidx < 0)
;                       jumpidx = @curwin.w_jumplistlen - 1;
;                   if (jumpidx == stop)        ;; list exhausted for sure
;                       break;
;               }
;           }

;           if (buf == null)            ;; No previous buffer, Try 2'nd approach
;           {
;               boolean forward = true;
;               buf = @curbuf.b_next;
;               for ( ; ; )
;               {
;                   if (buf == null)
;                   {
;                       if (!forward)       ;; tried both directions
;                           break;
;                       buf = @curbuf.b_prev;
;                       forward = false;
;                       continue;
;                   }
                    ;; in non-help buffer, try to skip help buffers, and vv
;                   {
;                       if (buf.b_ml.ml_mfp != null)    ;; found loaded buffer
;                           break;
;                       if (bp == null)     ;; remember unloaded buf for later
;                           bp = buf;
;                   }
;                   if (forward)
;                       buf = buf.b_next;
;                   else
;                       buf = buf.b_prev;
;               }
;           }
;           if (buf == null)        ;; no loaded buffer, use unloaded one
;               buf = bp;
;           if (buf == null)        ;; no loaded buffer, find listed one
;           {
;               for (buf = @firstbuf; buf != null; buf = buf.b_next)
;                   if (buf != @curbuf)
;                       break;
;           }
;           if (buf == null)        ;; Still no buffer, just take one
;           {
;               if (@curbuf.b_next != null)
;                   buf = @curbuf.b_next;
;               else
;                   buf = @curbuf.b_prev;
;           }
;       }

;       if (buf == null)
;       {
            ;; Autocommands must have wiped out all other buffers.
            ;; Only option now is to make the current buffer empty.
;           return empty_curbuf(false, forceit, action);
;       }

        ;; make buf current buffer

;       if (action == DOBUF_SPLIT)      ;; split window first
;       {
;           if (win_split(0, 0) == false)
;               return false;
;       }

        ;; go to current buffer - nothing to do
;       if (buf == @curbuf)
;           return true;

        ;; Check if the current buffer may be abandoned.

;       if (action == DOBUF_GOTO && !can_abandon(@curbuf, forceit))
;       {
;           if (bufIsChanged(@curbuf))
;           {
;               emsg(e_nowrtmsg);
;               return false;
;           }
;       }

        ;; Go to the other buffer.
;       set_curbuf(buf, action);

;       if (action == DOBUF_SPLIT)
;       {
;           @curwin.w_onebuf_opt.@wo_scb = false;    ;; reset 'scrollbind' and 'cursorbind'
;           @curwin.w_onebuf_opt.@wo_crb = false;
;       }

;       if (aborting())         ;; autocmds may abort script processing
;           return false;

;       return true;
    ))

;; Set current buffer to "buf".  Executes autocommands and closes current
;; buffer.  "action" tells how to close the current buffer:
;; DOBUF_GOTO       free or hide it
;; DOBUF_SPLIT      nothing
;; DOBUF_UNLOAD     unload it
;; DOBUF_DEL        delete it
;; DOBUF_WIPE       wipe it out

(defn- #_void set_curbuf [#_buffer_C buf, #_int action]
    (§
;       buffer_C prevbuf;
;       boolean unload = (action == DOBUF_UNLOAD || action == DOBUF_DEL || action == DOBUF_WIPE);
;       long old_tw = @curbuf.@b_p_tw;

;       setpcmark();
;       if (!@cmdmod.keepalt)
;           @curwin.w_alt_fnum = @curbuf.b_fnum;      ;; remember alternate file
;       buflist_altfpos(@curwin);                    ;; remember curpos

        ;; Don't restart Select mode after switching to another buffer.
;       @VIsual_reselect = false;

        ;; close_windows() or apply_autocmds() may change curbuf
;       prevbuf = @curbuf;

;       if (buf_valid(prevbuf) && !aborting())
;       {
;           if (unload)
;               close_windows(prevbuf, false);
;           if (buf_valid(prevbuf) && !aborting())
;           {
;               window_C previouswin = @curwin;
;               if (prevbuf == @curbuf)
;                   u_sync(false);
;               close_buffer(prevbuf == @curwin.w_buffer ? @curwin : null, prevbuf,
;                       unload ? action : (action == DOBUF_GOTO
;                           && !@cmdmod.hide
;                           && !bufIsChanged(prevbuf)) ? DOBUF_UNLOAD : 0, false);
;               if (@curwin != previouswin && win_valid(previouswin))
                    ;; autocommands changed curwin, Grr!
;                   @curwin = previouswin;
;           }
;       }
        ;; An autocommand may have deleted "buf", already entered it
        ;; (e.g., when it did ":bunload") or aborted the script processing!
        ;; If curwin.w_buffer is null, enter_buffer() will make it valid again
;       if ((buf_valid(buf) && buf != @curbuf && !aborting()) || @curwin.w_buffer == null)
;       {
;           enter_buffer(buf);
;           if (old_tw != @curbuf.@b_p_tw)
;               check_colorcolumn(@curwin);
;       }
    ))

;; Enter a new current buffer.
;; Old curbuf must have been abandoned already!  This also means "curbuf" may
;; be pointing to freed memory.

(defn- #_void enter_buffer [#_buffer_C buf]
    (§
        ;; Copy buffer and window local option values.
;       buf_copy_options(buf, BCO_ENTER);
;       get_winopts(buf);

        ;; Get the buffer in the current window.
;       @curwin.w_buffer = buf;
;       @curbuf = buf;
;       @curbuf.b_nwindows++;

        ;; Cursor on first line by default.
;       @curwin.w_cursor.lnum = 1;
;       @curwin.w_cursor.col = 0;
;       @curwin.w_cursor.coladd = 0;
;       @curwin.w_set_curswant = true;
;       @curwin.w_topline_was_set = false;

        ;; mark cursor position as being invalid
;       @curwin.w_valid = 0;

        ;; Make sure the buffer is loaded.
;       if (@curbuf.b_ml.ml_mfp == null)     ;; need to load the file
;       {
;           open_buffer(false, null, 0);
;       }
;       else
;       {
;           if (@msg_silent == 0)
;               @need_fileinfo = true;       ;; display file info after redraw
;           buf_check_timestamp(@curbuf);    ;; check if file changed
;           @curwin.w_topline = 1;
;       }

        ;; If autocommands did not change the cursor position,
        ;; restore cursor lnum and possibly cursor col.
;       if (@curwin.w_cursor.lnum == 1 && inindent(0))
;           buflist_getfpos();

        ;; when autocmds didn't change it
;       if (@curwin.w_topline == 1 && !@curwin.w_topline_was_set)
;           scroll_cursor_halfway(false);   ;; redisplay at correct position

;       redraw_later(NOT_VALID);
    ))

;; functions for dealing with the buffer list

;; This is the ONLY way to create a new buffer.

(atom! int  top_file_num 1)       ;; highest file number

(defn- #_buffer_C newBuffer [#_long lnum]
    ;; lnum: preferred cursor line
    (§
;       buffer_C buf = §_buffer_C();

;       buf.b_ml = §_memline_C();
;       buf.b_namedm = ARRAY_pos(NMARKS);
;       buf.b_visual = §_visualinfo_C();
;       buf.b_last_cursor = §_pos_C();
;       buf.b_last_insert = §_pos_C();
;       buf.b_last_change = §_pos_C();
;       buf.b_changelist = ARRAY_pos(JUMPLISTSIZE);
;       buf.b_chartab = new int[8];
;       buf.b_maphash = new mapblock_C[256][1];
;       buf.b_op_start = §_pos_C();
;       buf.b_op_start_orig = §_pos_C();
;       buf.b_op_end = §_pos_C();

;       clear_wininfo(buf);
;       buf.b_wininfo = §_wininfo_C();

        ;; Put new buffer at the end of the buffer list.

;       buf.b_next = null;
;       if (@firstbuf == null)           ;; buffer list is empty
;       {
;           buf.b_prev = null;
;           @firstbuf = buf;
;       }
;       else                            ;; append new buffer at end of list
;       {
;           @lastbuf.b_next = buf;
;           buf.b_prev = @lastbuf;
;       }
;       @lastbuf = buf;

;       buf.b_fnum = @top_file_num++;
;       if (@top_file_num < 0)           ;; wrap around (may cause duplicates)
;       {
;           emsg(u8("W14: Warning: List of file names overflow"));
;           if (@emsg_silent == 0)
;           {
;               out_flush();
;               ui_delay(3000L, true);  ;; make sure it is noticed
;           }
;           @top_file_num = 1;
;       }

        ;; Always copy the options from the current buffer.

;       buf_copy_options(buf, BCO_ALWAYS);

;       buf.b_wininfo.wi_fpos.lnum = lnum;
;       buf.b_wininfo.wi_win = @curwin;

;       buf.b_u_synced = true;
;       buf.b_flags = BF_CHECK_RO | BF_NEVERLOADED;
;       buf_clear_file(buf);
;       clrallmarks(buf);                           ;; clear marks

;       return buf;
    ))

;; Free the memory for the options of a buffer.
;; If "free_p_ff" is true also free 'fileformat', 'buftype' and 'fileencoding'.

(defn- #_void free_buf_options [#_buffer_C buf, #_boolean free_p_ff]
    (§
;       clear_string_option(buf.b_p_kp);
;       clear_string_option(buf.b_p_mps);
;       clear_string_option(buf.b_p_fo);
;       clear_string_option(buf.b_p_flp);
;       clear_string_option(buf.b_p_isk);
;       clear_string_option(buf.b_p_com);
;       clear_string_option(buf.b_p_nf);
;       clear_string_option(buf.b_p_cink);
;       clear_string_option(buf.b_p_cino);
;       clear_string_option(buf.b_p_cinw);
;       clear_string_option(buf.b_p_qe);
;       buf.@b_p_ul = NO_LOCAL_UNDOLEVEL;
;       clear_string_option(buf.b_p_lw);
    ))

;; go to the last know line number for the current buffer

(defn- #_void buflist_getfpos []
    (§
;       pos_C fpos = buflist_findfpos(@curbuf);

;       @curwin.w_cursor.lnum = fpos.lnum;
;       check_cursor_lnum();

;       if (@p_sol)
;           @curwin.w_cursor.col = 0;
;       else
;       {
;           @curwin.w_cursor.col = fpos.col;
;           check_cursor_col();
;           @curwin.w_cursor.coladd = 0;
;           @curwin.w_set_curswant = true;
;       }
    ))

;; Find file in buffer list by a regexp pattern.
;; Return fnum of the found buffer.
;; Return < 0 for error.

(defn- #_int buflist_findpat [#_Bytes pattern, #_Bytes pattern_end]
    ;; pattern_end: pointer to first char after pattern
    (§
;       int match = -1;

;       if (BEQ(pattern_end, pattern.plus(1)) && (pattern.at(0) == (byte)'%' || pattern.at(0) == (byte)'#'))
;       {
;           if (pattern.at(0) == (byte)'%')
;               match = @curbuf.b_fnum;
;           else
;               match = @curwin.w_alt_fnum;
;       }

;       if (match == -2)
;           emsg2(u8("E93: More than one match for %s"), pattern);
;       else if (match < 0)
;           emsg2(u8("E94: No matching buffer for %s"), pattern);

;       return match;
    ))

;; find file in buffer list by number

(defn- #_buffer_C buflist_findnr [#_int nr]
    (§
;       if (nr == 0)
;           nr = @curwin.w_alt_fnum;

;       for (buffer_C buf = @firstbuf; buf != null; buf = buf.b_next)
;           if (buf.b_fnum == nr)
;               return buf;

;       return null;
    ))

;; Set the "lnum" and "col" for the buffer "buf" and the current window.
;; When "copy_options" is true save the local window option values.
;; When "lnum" is 0 only do the options.

(defn- #_void buflist_setfpos [#_buffer_C buf, #_window_C win, #_long lnum, #_int col, #_boolean copy_options]
    (§
;       wininfo_C wip;

;       for (wip = buf.b_wininfo; wip != null; wip = wip.wi_next)
;           if (wip.wi_win == win)
;               break;
;       if (wip == null)
;       {
            ;; allocate a new entry
;           wip = §_wininfo_C();
;           wip.wi_win = win;
;           if (lnum == 0)          ;; set lnum even when it's 0
;               lnum = 1;
;       }
;       else
;       {
            ;; remove the entry from the list
;           if (wip.wi_prev != null)
;               wip.wi_prev.wi_next = wip.wi_next;
;           else
;               buf.b_wininfo = wip.wi_next;
;           if (wip.wi_next != null)
;               wip.wi_next.wi_prev = wip.wi_prev;
;           if (copy_options && wip.wi_optset)
;               clear_winopt(wip.wi_opt);
;       }
;       if (lnum != 0)
;       {
;           wip.wi_fpos.lnum = lnum;
;           wip.wi_fpos.col = col;
;       }
;       if (copy_options)
;       {
            ;; Save the window-specific option values.
;           copy_winopt(win.w_onebuf_opt, wip.wi_opt);
;           wip.wi_optset = true;
;       }

        ;; insert the entry in front of the list
;       wip.wi_next = buf.b_wininfo;
;       buf.b_wininfo = wip;
;       wip.wi_prev = null;
;       if (wip.wi_next != null)
;           wip.wi_next.wi_prev = wip;
    ))

;; Find info for the current window in buffer "buf".
;; If not found, return the info for the most recently used window.
;; Returns null when there isn't any info.

(defn- #_wininfo_C find_wininfo [#_buffer_C buf]
    (§
;       wininfo_C wip;

;       for (wip = buf.b_wininfo; wip != null; wip = wip.wi_next)
;           if (wip.wi_win == @curwin)
;               break;

        ;; If no wininfo for curwin, use the first in the list
        ;; (that doesn't have 'diff' set and is in another tab page).
;       if (wip == null)
;           wip = buf.b_wininfo;

;       return wip;
    ))

;; Reset the local window options to the values last used in this window.
;; If the buffer wasn't used in this window before, use the values from
;; the most recently used window.  If the values were never set, use the
;; global values for the window.

(defn- #_void get_winopts [#_buffer_C buf]
    (§
;       clear_winopt(@curwin.w_onebuf_opt);

;       wininfo_C wip = find_wininfo(buf);
;       if (wip != null && wip.wi_optset)
;           copy_winopt(wip.wi_opt, @curwin.w_onebuf_opt);
;       else
;           copy_winopt(@curwin.w_allbuf_opt, @curwin.w_onebuf_opt);

;       check_colorcolumn(@curwin);
    ))

(atom! pos_C no_position (new_pos 1, 0, 0))

;; Find the position (lnum and col) for the buffer 'buf' for the current window.
;; Returns a pointer to no_position if no position is found.

(defn- #_pos_C buflist_findfpos [#_buffer_C buf]
    (§
;       wininfo_C wip = find_wininfo(buf);
;       if (wip != null)
;           return wip.wi_fpos;
;       else
;           return @no_position;
    ))

;; Find the lnum for the buffer 'buf' for the current window.

(defn- #_long buflist_findlnum [#_buffer_C buf]
    (§
;       return buflist_findfpos(buf).lnum;
    ))

;; List all know file names (for :files and :buffers command).

(defn- #_void ex_buflist [#_exarg_C eap]
    (§
;       for (buffer_C buf = @firstbuf; buf != null && !@got_int; buf = buf.b_next)
;       {
;           msg_putchar('\n');

;           int len = vim_snprintf(@ioBuff, IOSIZE - 20, u8("%3d%c%c%c%c%c \"%s\""),
;                   buf.b_fnum,
;                   ' ',
;                   (buf == @curbuf) ? '%' : (@curwin.w_alt_fnum == buf.b_fnum ? '#' : ' '),
;                   (buf.b_ml.ml_mfp == null) ? ' ' : (buf.b_nwindows == 0 ? 'h' : 'a'),
;                   !buf.@b_p_ma ? '-' : (buf.@b_p_ro ? '=' : ' '),
;                   (buf.b_flags & BF_READERR) != 0 ? 'x' : (bufIsChanged(buf) ? '+' : ' '),
;                   buf_spname(buf, false));

                ;; put "line 999" in column 40 or after the file name
;           int i = 40 - mb_string2cells(@ioBuff, -1);
;           do
;           {
;               @ioBuff.be(len++, (byte)' ');
;           } while (0 < --i && len < IOSIZE - 18);
;           vim_snprintf(@ioBuff.plus(len), IOSIZE - len, u8("line %ld"),
;               (buf == @curbuf) ? @curwin.w_cursor.lnum : buflist_findlnum(buf));

;           msg_outtrans(@ioBuff);
;           out_flush();        ;; output one line at a time
;           ui_breakcheck();
;       }
    ))

;; Take care of what needs to be done when the name of buffer "buf" has changed.

(defn- #_void buf_name_changed [#_buffer_C buf]
    (§
;       status_redraw_all();            ;; status lines need to be redrawn
;       ml_timestamp(buf);              ;; reset timestamp
    ))

;; Set alternate cursor position for the current buffer and window "win".
;; Also save the local window option values.

(defn- #_void buflist_altfpos [#_window_C win]
    (§
;       buflist_setfpos(@curbuf, win, win.w_cursor.lnum, win.w_cursor.col, true);
    ))

;; Print info about the current buffer.

(defn- #_void fileinfo [#_int fullname, #_boolean dont_truncate]
    ;; fullname: when non-zero print full path
    (§
;       Bytes buffer = new Bytes(IOSIZE);

;       Bytes p = buffer;
;       if (1 < fullname)       ;; 2 CTRL-G: include buffer number
;       {
;           vim_snprintf(buffer, IOSIZE, u8("buf %d: "), @curbuf.b_fnum);
;           p = buffer.plus(STRLEN(buffer));
;       }

;       (p = p.plus(1)).be(-1, (byte)'"');
;       vim_strncpy(p, buf_spname(@curbuf, fullname != 0), IOSIZE - BDIFF(p, buffer) - 1);

;       vim_snprintf_add(buffer, IOSIZE, u8("\"%s%s%s%s%s%s"),
;               curbufIsChanged() ? (shortmess(SHM_MOD) ? u8(" [+]") : u8(" [Modified]")) : u8(" "),
;               (@curbuf.b_flags & BF_NOTEDITED) != 0 ? u8("[Not edited]") : u8(""),
;               (@curbuf.b_flags & BF_NEW) != 0 ? u8("[New file]") : u8(""),
;               (@curbuf.b_flags & BF_READERR) != 0 ? u8("[Read errors]") : u8(""),
;               @curbuf.@b_p_ro ? (shortmess(SHM_RO) ? u8("[RO]") : u8("[readonly]")) : u8(""),
;               (curbufIsChanged() || (@curbuf.b_flags & BF_WRITE_MASK) != 0 || @curbuf.@b_p_ro) ? u8(" ") : u8(""));
        ;; With 32 bit longs and more than 21,474,836 lines multiplying by 100
        ;; causes an overflow, thus for large numbers divide instead.
;       int n;
;       if (1000000L < @curwin.w_cursor.lnum)
;           n = (int)(@curwin.w_cursor.lnum / (@curbuf.b_ml.ml_line_count / 100L));
;       else
;           n = (int)((@curwin.w_cursor.lnum * 100L) / @curbuf.b_ml.ml_line_count);
;       if ((@curbuf.b_ml.ml_flags & ML_EMPTY) != 0)
;       {
;           vim_snprintf_add(buffer, IOSIZE, u8("%s"), no_lines_msg);
;       }
;       else if (@p_ru)
;       {
            ;; Current line and column are already on the screen.
;           if (@curbuf.b_ml.ml_line_count == 1)
;               vim_snprintf_add(buffer, IOSIZE, u8("1 line --%d%%--"), n);
;           else
;               vim_snprintf_add(buffer, IOSIZE, u8("%ld lines --%d%%--"), @curbuf.b_ml.ml_line_count, n);
;       }
;       else
;       {
;           vim_snprintf_add(buffer, IOSIZE, u8("line %ld of %ld --%d%%-- col "),
;                                               @curwin.w_cursor.lnum, @curbuf.b_ml.ml_line_count, n);
;           validate_virtcol();
;           int len = STRLEN(buffer);
;           col_print(buffer.plus(len), IOSIZE - len, @curwin.w_cursor.col + 1, @curwin.w_virtcol + 1);
;       }

;       append_arg_number(@curwin, buffer, IOSIZE, !shortmess(SHM_FILE));

;       if (dont_truncate)
;       {
            ;; Temporarily set msg_scroll to avoid the message being truncated.
            ;; First call msg_start() to get the message in the right place.
;           msg_start();
;           boolean m = @msg_scroll;
;           @msg_scroll = true;
;           msg(buffer);
;           @msg_scroll = m;
;       }
;       else
;       {
;           p = msg_trunc_attr(buffer, false, 0);
;           if (@restart_edit != 0 || (@msg_scrolled != 0 && !@need_wait_return))
                ;; Need to repeat the message after redrawing when:
                ;; - When restart_edit is set (otherwise there will be a delay before redrawing).
                ;; - When the screen was scrolled but there is no wait-return prompt.
;               set_keep_msg(p, 0);
;       }
    ))

(defn- #_void col_print [#_Bytes buf, #_int buflen, #_int col, #_int vcol]
    (§
;       if (col == vcol)
;           vim_snprintf(buf, buflen, u8("%d"), col);
;       else
;           vim_snprintf(buf, buflen, u8("%d-%d"), col, vcol);
    ))

;; enum for "type" below
(final int
    Normal    0,
    Empty     1,
    Group     2,
    Middle    3,
    Highlight 4,
    TabPage   5,
    Trunc     6)

(class! #_final stl_item_C
    [
        (field Bytes    start)
        (field int      minwid)
        (field int      maxwid)
        (field int      type)
    ])

(defn- #_stl_item_C* ARRAY_stl_item [#_int n]
    (vec (repeatedly n §_stl_item_C)))

;; Build a string from the status line items in "fmt".
;; Return length of string in screen cells.
;;
;; Normally works for window "wp", except when working for 'tabline' then it is "curwin".
;;
;; Items are drawn interspersed with the text that surrounds it
;; Specials: %-<wid>(xxx%) => group, %= => middle marker, %< => truncation
;; Item: %-<minwid>.<maxwid><itemch> All but <itemch> are optional
;;
;; If maxwidth is not zero, the string will be filled at any middle marker
;; or truncated if too long, fillchar is used for all whitespace.

(defn- #_int build_stl_str_hl [#_window_C wp, #_Bytes out, #_int outlen, #_Bytes fmt, #_boolean use_sandbox, #_int fillchar, #_int maxwidth, #_stl_hlrec_C* hltab, #_stl_hlrec_C* tabtab]
    ;; out: buffer to write into != nameBuff
    ;; outlen: length of out[]
    ;; use_sandbox: "fmt" was set insecurely, use sandbox
    ;; hltab: return: HL attributes (can be null)
    ;; tabtab: return: tab page nrs (can be null)
    (§
;       int[] groupitem = new int[STL_MAX_ITEM];
;       stl_item_C[] item = ARRAY_stl_item(STL_MAX_ITEM);

;       final int TMPLEN = 70;

        ;; When the format starts with "%!" then evaluate it as an expression and
        ;; use the result as the actual format string.

;       Bytes usefmt = fmt;
;       if (fmt.at(0) == (byte)'%' && fmt.at(1) == (byte)'!')
;       {
;           usefmt = eval_to_string_safe(fmt.plus(2), null, use_sandbox);
;           if (usefmt == null)
;               usefmt = fmt;
;       }

;       if (fillchar == 0)
;           fillchar = ' ';
        ;; Can't handle a multi-byte fill character yet.
;       else if (1 < utf_char2len(fillchar))
;           fillchar = '-';

        ;; Get line and check if empty (cursorpos will show "0-1").
        ;; Note that 'p' will become invalid when getting another buffer line.
;       Bytes p = ml_get_buf(wp.w_buffer, wp.w_cursor.lnum, false);
;       boolean empty_line = (p.at(0) == NUL);

        ;; Get the byte value now in case we need it below.
        ;; This is more efficient than making a copy of the line.
;       int byteval;
;       if (STRLEN(p) < wp.w_cursor.col)
;           byteval = 0;
;       else
;           byteval = us_ptr2char(p.plus(wp.w_cursor.col));

;       int groupdepth = 0;
;       p = out;
;       int curitem = 0;
;       boolean prevchar_isflag = true;
;       boolean prevchar_isitem = false;

;       Bytes s;
;       for (s = usefmt; s.at(0) != NUL; )
;       {
;           if (curitem == STL_MAX_ITEM)
;           {
                ;; There are too many items.  Add the error code to the statusline
                ;; to give the user a hint about what went wrong.
;               if (BLT(p.plus(6), out.plus(outlen)))
;               {
;                   BCOPY(p, u8(" E541"), 5);
;                   p = p.plus(5);
;               }
;               break;
;           }

;           if (s.at(0) != NUL && s.at(0) != (byte)'%')
;               prevchar_isflag = prevchar_isitem = false;

            ;; Handle up to the next '%' or the end.

;           while (s.at(0) != NUL && s.at(0) != (byte)'%' && BLT(p.plus(1), out.plus(outlen)))
;               (p = p.plus(1)).be(-1, (s = s.plus(1)).at(-1));
;           if (s.at(0) == NUL || BLE(out.plus(outlen), p.plus(1)))
;               break;

            ;; Handle one '%' item.

;           s = s.plus(1);
;           if (s.at(0) == NUL)     ;; ignore trailing %
;               break;
;           if (s.at(0) == (byte)'%')
;           {
;               if (BLE(out.plus(outlen), p.plus(1)))
;                   break;
;               (p = p.plus(1)).be(-1, (s = s.plus(1)).at(-1));
;               prevchar_isflag = prevchar_isitem = false;
;               continue;
;           }
;           if (s.at(0) == STL_MIDDLEMARK)
;           {
;               s = s.plus(1);
;               if (0 < groupdepth)
;                   continue;
;               item[curitem].type = Middle;
;               item[curitem++].start = p;
;               continue;
;           }
;           if (s.at(0) == STL_TRUNCMARK)
;           {
;               s = s.plus(1);
;               item[curitem].type = Trunc;
;               item[curitem++].start = p;
;               continue;
;           }
;           if (s.at(0) == (byte)')')
;           {
;               s = s.plus(1);
;               if (groupdepth < 1)
;                   continue;
;               groupdepth--;

;               Bytes t = item[groupitem[groupdepth]].start;
;               p.be(0, NUL);
;               int l = mb_string2cells(t, -1);
;               if (groupitem[groupdepth] + 1 < curitem && item[groupitem[groupdepth]].minwid == 0)
;               {
                    ;; remove group if all items are empty
;                   int n;
;                   for (n = groupitem[groupdepth] + 1; n < curitem; n++)
;                       if (item[n].type == Normal)
;                           break;
;                   if (n == curitem)
;                   {
;                       p = t;
;                       l = 0;
;                   }
;               }
;               if (item[groupitem[groupdepth]].maxwid < l)
;               {
                    ;; truncate, remove n bytes of text at the start

                    ;; Find the first character that should be included.
;                   int n = 0;
;                   while (item[groupitem[groupdepth]].maxwid <= l)
;                   {
;                       l -= mb_ptr2cells(t.plus(n));
;                       n += us_ptr2len_cc(t.plus(n));
;                   }

;                   t.be(0, (byte)'<');
;                   BCOPY(t, 1, t, n, BDIFF(p, t) - n);
;                   p = p.minus(n - 1);
                    ;; Fill up space left over by half a double-wide char.
;                   while (++l < item[groupitem[groupdepth]].minwid)
;                       (p = p.plus(1)).be(-1, fillchar);

                    ;; correct the start of the items for the truncation
;                   for (l = groupitem[groupdepth] + 1; l < curitem; l++)
;                   {
;                       item[l].start = item[l].start.minus(n);
;                       if (BLT(item[l].start, t))
;                           item[l].start = t;
;                   }
;               }
;               else if (l < Math.abs(item[groupitem[groupdepth]].minwid))
;               {
                    ;; fill
;                   int n = item[groupitem[groupdepth]].minwid;
;                   if (n < 0)
;                   {
                        ;; fill by appending characters
;                       n = 0 - n;
;                       while (l++ < n && BLT(p.plus(1), out.plus(outlen)))
;                           (p = p.plus(1)).be(-1, fillchar);
;                   }
;                   else
;                   {
                        ;; fill by inserting characters
;                       BCOPY(t, n - l, t, 0, BDIFF(p, t));
;                       l = n - l;
;                       if (BLE(out.plus(outlen), p.plus(l)))
;                           l = BDIFF(out.plus(outlen), p.minus(1));
;                       p = p.plus(l);
;                       for (n = groupitem[groupdepth] + 1; n < curitem; n++)
;                           item[n].start = item[n].start.plus(l);
;                       for ( ; 0 < l; l--)
;                           (t = t.plus(1)).be(-1, fillchar);
;                   }
;               }
;               continue;
;           }
;           int minwid = 0, maxwid = 9999;
;           boolean zeropad = false;
;           int l = 1;
;           if (s.at(0) == (byte)'0')
;           {
;               s = s.plus(1);
;               zeropad = true;
;           }
;           if (s.at(0) == (byte)'-')
;           {
;               s = s.plus(1);
;               l = -1;
;           }
;           if (asc_isdigit(s.at(0)))
;           {
;               { Bytes[] __ = { s }; minwid = (int)getdigits(__); s = __[0]; }
;               if (minwid < 0)     ;; overflow
;                   minwid = 0;
;           }
;           if (s.at(0) == STL_USER_HL)
;           {
;               item[curitem].type = Highlight;
;               item[curitem].start = p;
;               item[curitem].minwid = (9 < minwid) ? 1 : minwid;
;               s = s.plus(1);
;               curitem++;
;               continue;
;           }
;           if (s.at(0) == STL_TABPAGENR || s.at(0) == STL_TABCLOSENR)
;           {
;               if (s.at(0) == STL_TABCLOSENR)
;               {
;                   if (minwid == 0)
;                   {
                        ;; %X ends the close label, go back to the previously define tab label nr.
;                       for (int n = curitem - 1; 0 <= n; --n)
;                           if (item[n].type == TabPage && 0 <= item[n].minwid)
;                           {
;                               minwid = item[n].minwid;
;                               break;
;                           }
;                   }
;                   else
                        ;; close nrs are stored as negative values
;                       minwid = - minwid;
;               }
;               item[curitem].type = TabPage;
;               item[curitem].start = p;
;               item[curitem].minwid = minwid;
;               s = s.plus(1);
;               curitem++;
;               continue;
;           }
;           if (s.at(0) == (byte)'.')
;           {
;               s = s.plus(1);
;               if (asc_isdigit(s.at(0)))
;               {
;                   { Bytes[] __ = { s }; maxwid = (int)getdigits(__); s = __[0]; }
;                   if (maxwid <= 0)        ;; overflow
;                       maxwid = 50;
;               }
;           }
;           minwid = (50 < minwid ? 50 : minwid) * l;
;           if (s.at(0) == (byte)'(')
;           {
;               groupitem[groupdepth++] = curitem;
;               item[curitem].type = Group;
;               item[curitem].start = p;
;               item[curitem].minwid = minwid;
;               item[curitem].maxwid = maxwid;
;               s = s.plus(1);
;               curitem++;
;               continue;
;           }
;           if (vim_strchr(STL_ALL, s.at(0)) == null)
;           {
;               s = s.plus(1);
;               continue;
;           }
;           byte opt = (s = s.plus(1)).at(-1);

            ;; OK - now for the real work.
;           byte base = 'D';
;           boolean itemisflag = false;
;           boolean fillable = true;
;           long num = -1;
;           Bytes str = null;
;           switch (opt)
;           {
;               case STL_FILEPATH:
;               case STL_FULLPATH:
;               case STL_FILENAME:
;               {
;                   fillable = false;   ;; don't change ' ' to fillchar
;                   vim_strncpy(@nameBuff, buf_spname(wp.w_buffer, opt == STL_FULLPATH), MAXPATHL - 1);
;                   trans_characters(@nameBuff, MAXPATHL);
;                   if (opt != STL_FILENAME)
;                       str = @nameBuff;
;                   else
;                       str = gettail(@nameBuff);
;                   break;
;               }

;               case STL_VIM_EXPR: ;; '{'
;               {
;                   itemisflag = true;
;                   Bytes[] t = { p };
;                   while (s.at(0) != (byte)'}' && s.at(0) != NUL && BLT(p.plus(1), out.plus(outlen)))
;                       (p = p.plus(1)).be(-1, (s = s.plus(1)).at(-1));
;                   if (s.at(0) != (byte)'}')      ;; missing '}' or out of space
;                       break;
;                   s = s.plus(1);
;                   p.be(0, NUL);
;                   p = t[0];

;                   buffer_C o_curbuf = @curbuf;
;                   window_C o_curwin = @curwin;
;                   @curwin = wp;
;                   @curbuf = wp.w_buffer;

;                   str = eval_to_string_safe(p, t, use_sandbox);

;                   @curwin = o_curwin;
;                   @curbuf = o_curbuf;

;                   if (str != null && str.at(0) != 0)
;                   {
;                       if (skipdigits(str).at(0) == NUL)
;                       {
;                           num = libC.atoi(str);
;                           str = null;
;                           itemisflag = false;
;                       }
;                   }
;                   break;
;               }

;               case STL_LINE:
;               {
;                   num = ((wp.w_buffer.b_ml.ml_flags & ML_EMPTY) != 0) ? 0 : wp.w_cursor.lnum;
;                   break;
;               }

;               case STL_NUMLINES:
;               {
;                   num = wp.w_buffer.b_ml.ml_line_count;
;                   break;
;               }

;               case STL_COLUMN:
;               {
;                   num = ((@State & INSERT) == 0 && empty_line) ? 0 : wp.w_cursor.col + 1;
;                   break;
;               }

;               case STL_VIRTCOL:
;               case STL_VIRTCOL_ALT:
;               {
                    ;; In list mode virtcol needs to be recomputed.
;                   int[] virtcol = { wp.w_virtcol };
;                   if (wp.w_onebuf_opt.@wo_list && lcs_tab1[0] == NUL)
;                   {
;                       wp.w_onebuf_opt.@wo_list = false;
;                       getvcol(wp, wp.w_cursor, null, virtcol, null);
;                       wp.w_onebuf_opt.@wo_list = true;
;                   }
;                   virtcol[0]++;
                    ;; Don't display %V if it's the same as %c.
;                   if (opt == STL_VIRTCOL_ALT && (virtcol[0] == (((@State & INSERT) == 0 && empty_line) ? 0 : wp.w_cursor.col + 1)))
;                       break;
;                   num = (long)virtcol[0];
;                   break;
;               }

;               case STL_PERCENTAGE:
;               {
;                   num = (int)(wp.w_cursor.lnum * 100L / wp.w_buffer.b_ml.ml_line_count);
;                   break;
;               }

;               case STL_ALTPERCENT:
;               {
;                   str = tmp;
;                   get_rel_pos(wp, str, TMPLEN);
;                   break;
;               }

;               case STL_ARGLISTSTAT:
;               {
;                   fillable = false;
;                   tmp.be(0, NUL);
;                   if (append_arg_number(wp, tmp, tmp.size(), false))
;                       str = tmp;
;                   break;
;               }

;               case STL_KEYMAP:
;               {
;                   fillable = false;
;                   break;
;               }

;               case STL_PAGENUM:
;               {
;                   num = 0;
;                   break;
;               }

;               case STL_BUFNO:
;               {
;                   num = wp.w_buffer.b_fnum;
;                   break;
;               }

;               case STL_OFFSET_X:
;                   base = 'X';
;               case STL_OFFSET:
;               {
;                   long off = ml_find_line_or_offset(wp.w_buffer, wp.w_cursor.lnum, null);
;                   num = ((wp.w_buffer.b_ml.ml_flags & ML_EMPTY) != 0 || off < 0)
;                       ? 0
;                       : off + 1 + (((@State & INSERT) == 0 && empty_line) ? 0 : wp.w_cursor.col);
;                   break;
;               }

;               case STL_BYTEVAL_X:
;                   base = 'X';
;               case STL_BYTEVAL:
;                   num = byteval;
;                   if (num == NL)
;                       num = 0;
;                   break;

;               case STL_ROFLAG:
;               case STL_ROFLAG_ALT:
;               {
;                   itemisflag = true;
;                   if (wp.w_buffer.@b_p_ro)
;                       str = (opt == STL_ROFLAG_ALT) ? u8(",RO") : u8("[RO]");
;                   break;
;               }

;               case STL_HELPFLAG:
;               case STL_HELPFLAG_ALT:
;               {
;                   itemisflag = true;
;                   break;
;               }

;               case STL_FILETYPE:
;                   break;

;               case STL_FILETYPE_ALT:
;               {
;                   itemisflag = true;
;                   break;
;               }

;               case STL_MODIFIED:
;               case STL_MODIFIED_ALT:
;               {
;                   itemisflag = true;
;                   switch ((opt == STL_MODIFIED_ALT ? 1 : 0) + (bufIsChanged(wp.w_buffer) ? 2 : 0) + (!wp.w_buffer.@b_p_ma ? 4 : 0))
;                   {
;                       case 2: str = u8("[+]"); break;
;                       case 3: str = u8(",+"); break;
;                       case 4: str = u8("[-]"); break;
;                       case 5: str = u8(",-"); break;
;                       case 6: str = u8("[+-]"); break;
;                       case 7: str = u8(",+-"); break;
;                   }
;                   break;
;               }

;               case STL_HIGHLIGHT:
;               {
;                   Bytes t = s;
;                   while (s.at(0) != (byte)'#' && s.at(0) != NUL)
;                       s = s.plus(1);
;                   if (s.at(0) == (byte)'#')
;                   {
;                       item[curitem].type = Highlight;
;                       item[curitem].start = p;
;                       item[curitem].minwid = -syn_namen2id(t, BDIFF(s, t));
;                       curitem++;
;                   }
;                   if (s.at(0) != NUL)
;                       s = s.plus(1);
;                   continue;
;               }
;           }

;           item[curitem].start = p;
;           item[curitem].type = Normal;
;           if (str != null && str.at(0) != NUL)
;           {
;               Bytes t = str;
;               if (itemisflag)
;               {
;                   if ((t.at(0) != NUL && t.at(1) != NUL)
;                           && ((!prevchar_isitem && t.at(0) == (byte)',') || (prevchar_isflag && t.at(0) == (byte)' ')))
;                       t = t.plus(1);
;                   prevchar_isflag = true;
;               }
;               l = mb_string2cells(t, -1);
;               if (0 < l)
;                   prevchar_isitem = true;
;               if (maxwid < l)
;               {
;                   while (maxwid <= l)
;                   {
;                       l -= mb_ptr2cells(t);
;                       t = t.plus(us_ptr2len_cc(t));
;                   }
;                   if (BLE(out.plus(outlen), p.plus(1)))
;                       break;
;                   (p = p.plus(1)).be(-1, (byte)'<');
;               }
;               if (0 < minwid)
;               {
;                   for ( ; l < minwid && BLT(p.plus(1), out.plus(outlen)); l++)
;                   {
                        ;; Don't put a "-" in front of a digit.
;                       if (l + 1 == minwid && fillchar == '-' && asc_isdigit(t.at(0)))
;                           (p = p.plus(1)).be(-1, (byte)' ');
;                       else
;                           (p = p.plus(1)).be(-1, fillchar);
;                   }
;                   minwid = 0;
;               }
;               else
;                   minwid *= -1;
;               while (t.at(0) != NUL && BLT(p.plus(1), out.plus(outlen)))
;               {
;                   (p = p.plus(1)).be(-1, (t = t.plus(1)).at(-1));
                    ;; Change a space by fillchar, unless fillchar is '-' and a digit follows.
;                   if (fillable && p.at(-1) == (byte)' ' && (!asc_isdigit(t.at(0)) || fillchar != '-'))
;                       p.be(-1, fillchar);
;               }
;               for ( ; l < minwid && BLT(p.plus(1), out.plus(outlen)); l++)
;                   (p = p.plus(1)).be(-1, fillchar);
;           }
;           else if (0 <= num)
;           {
;               int nbase = (base == 'D' ? 10 : (base == 'O' ? 8 : 16));
;               Bytes nstr = new Bytes(20);

;               if (BLE(out.plus(outlen), p.plus(20)))
;                   break;          ;; not sufficient space
;               prevchar_isitem = true;
;               Bytes t = nstr;
;               if (opt == STL_VIRTCOL_ALT)
;               {
;                   (t = t.plus(1)).be(-1, (byte)'-');
;                   minwid--;
;               }
;               (t = t.plus(1)).be(-1, (byte)'%');
;               if (zeropad)
;                   (t = t.plus(1)).be(-1, (byte)'0');
;               (t = t.plus(1)).be(-1, (byte)'*');
;               (t = t.plus(1)).be(-1, (nbase == 16) ? base : (nbase == 8) ? (byte)'o' : (byte)'d');
;               t.be(0, NUL);

;               l = 1;
;               for (long n = num; nbase <= n; n /= nbase)
;                   l++;
;               if (opt == STL_VIRTCOL_ALT)
;                   l++;
;               if (maxwid < l)
;               {
;                   l += 2;
;                   long n = l - maxwid;
;                   while (maxwid < l--)
;                       num /= nbase;
;                   (t = t.plus(1)).be(-1, (byte)'>');
;                   (t = t.plus(1)).be(-1, (byte)'%');
;                   t.be(0, t.at(-3));
;                   (t = t.plus(1)).be(0, NUL);
;                   vim_snprintf(p, outlen - BDIFF(p, out), nstr, 0, num, n);
;               }
;               else
;                   vim_snprintf(p, outlen - BDIFF(p, out), nstr, minwid, num);
;               p = p.plus(STRLEN(p));
;           }
;           else
;               item[curitem].type = Empty;

;           if (0 <= num || (!itemisflag && str != null && str.at(0) != NUL))
;               prevchar_isflag = false;        ;; Item not null, but not a flag.
;           curitem++;
;       }
;       p.be(0, NUL);
;       int itemcnt = curitem;

;       int width = mb_string2cells(out, -1);
;       if (0 < maxwidth && maxwidth < width)
;       {
            ;; Result is too long, must truncate somewhere.
;           int l = 0;
;           if (itemcnt == 0)
;               s = out;
;           else
;           {
;               for ( ; l < itemcnt; l++)
;                   if (item[l].type == Trunc)
;                   {
                        ;; Truncate at %< item.
;                       s = item[l].start;
;                       break;
;                   }
;               if (l == itemcnt)
;               {
                    ;; No %< item, truncate first item.
;                   l = 0;
;                   s = item[l].start;
;               }
;           }

;           if (maxwidth <= width - mb_string2cells(s, -1))
;           {
                ;; Truncation mark is beyond max length.
;               s = out;
;               width = 0;
;               for ( ; ; )
;               {
;                   width += mb_ptr2cells(s);
;                   if (maxwidth <= width)
;                       break;
;                   s = s.plus(us_ptr2len_cc(s));
;               }
                ;; Fill up for half a double-wide character.
;               while (++width < maxwidth)
;                   (s = s.plus(1)).be(-1, fillchar);
;               for (l = 0; l < itemcnt; l++)
;                   if (BLT(s, item[l].start))
;                       break;
;               itemcnt = l;
;               (s = s.plus(1)).be(-1, (byte)'>');
;               s.be(0, NUL);
;           }
;           else
;           {
;               int n = 0;
;               while (maxwidth <= width)
;               {
;                   width -= mb_ptr2cells(s.plus(n));
;                   n += us_ptr2len_cc(s.plus(n));
;               }

;               p = s.plus(n);
;               BCOPY(s, 1, p, 0, STRLEN(p) + 1);
;               s.be(0, (byte)'<');

                ;; Fill up for half a double-wide character.
;               while (++width < maxwidth)
;               {
;                   s = s.plus(STRLEN(s));
;                   (s = s.plus(1)).be(-1, fillchar);
;                   s.be(0, NUL);
;               }

;               --n;        ;; count the '<'
;               for ( ; l < itemcnt; l++)
;               {
;                   if (BLE(s, item[l].start.minus(n)))
;                       item[l].start = item[l].start.minus(n);
;                   else
;                       item[l].start = s;
;               }
;           }
;           width = maxwidth;
;       }
;       else if (width < maxwidth && STRLEN(out) + maxwidth - width + 1 < outlen)
;       {
            ;; Apply STL_MIDDLE if any.
;           int l;
;           for (l = 0; l < itemcnt; l++)
;               if (item[l].type == Middle)
;                   break;
;           if (l < itemcnt)
;           {
;               p = item[l].start.plus(maxwidth - width);
;               BCOPY(p, item[l].start, STRLEN(item[l].start) + 1);
;               for (s = item[l].start; BLT(s, p); s = s.plus(1))
;                   s.be(0, fillchar);
;               for (l++; l < itemcnt; l++)
;                   item[l].start = item[l].start.plus(maxwidth - width);
;               width = maxwidth;
;           }
;       }

        ;; Store the info about highlighting.
;       if (hltab != null)
;       {
;           int i = 0;
;           for (int j = 0; j < itemcnt; j++)
;           {
;               if (item[j].type == Highlight)
;               {
;                   hltab[i].start = item[j].start;
;                   hltab[i].userhl = item[j].minwid;
;                   i++;
;               }
;           }
;           hltab[i].start = null;
;           hltab[i].userhl = 0;
;       }

        ;; Store the info about tab pages labels.
;       if (tabtab != null)
;       {
;           int i = 0;
;           for (int j = 0; j < itemcnt; j++)
;           {
;               if (item[j].type == TabPage)
;               {
;                   tabtab[i].start = item[j].start;
;                   tabtab[i].userhl = item[j].minwid;
;                   i++;
;               }
;           }
;           tabtab[i].start = null;
;           tabtab[i].userhl = 0;
;       }

;       return width;
    ))

;; Get relative cursor position in window into "buf[buflen]", in the form 99%,
;; using "Top", "Bot" or "All" when appropriate.

(defn- #_void get_rel_pos [#_window_C wp, #_Bytes buf, #_int buflen]
    (§
;       if (buflen < 3) ;; need at least 3 chars for writing
;           return;

        ;; number of lines above/below window
;       long above = wp.w_topline - 1;
;       long below = wp.w_buffer.b_ml.ml_line_count - wp.w_botline + 1;

;       if (below <= 0)
;           vim_strncpy(buf, (above == 0) ? u8("All") : u8("Bot"), buflen - 1);
;       else if (above <= 0)
;           vim_strncpy(buf, u8("Top"), buflen - 1);
;       else
;       {
;           int cent = (1000000L < above)
;               ? (int)(above / ((above + below) / 100L))
;               : (int)(above * 100L / (above + below));
;           vim_snprintf(buf, buflen, u8("%2d%%"), cent);
;       }
    ))

;; Append (file 2 of 8) to "buf[buflen]", if editing more than one file.
;; Return true if it was appended.

(defn- #_boolean append_arg_number [#_window_C wp, #_Bytes buf, #_int buflen, #_boolean add_file]
    ;; add_file: Add "file" before the arg number
    (§
;       return false;
    ))

;; Open a window for a number of buffers.

(defn- #_void ex_buffer_all [#_exarg_C eap]
    (§
;       boolean split_ret = true;
;       int open_wins = 0;

            ;; Maximum number of windows to open.
;       int count;
;       if (eap.addr_count == 0)        ;; make as many windows as possible
;           count = 9999;
;       else
;           count = (int)eap.line2;     ;; make as many windows as specified

            ;; When true also load inactive buffers.
;       boolean all;
;       if (eap.cmdidx == CMD_unhide || eap.cmdidx == CMD_sunhide)
;           all = false;
;       else
;           all = true;

;       setpcmark();

            ;; Close superfluous windows (two windows for the same buffer).
            ;; Also close windows that are not full-width.

;       tabpage_C tpnext = null;

;       for (window_C wp = @firstwin, wpnext; wp != null; wp = wpnext)
;       {
;           wpnext = wp.w_next;
;           if ((1 < wp.w_buffer.b_nwindows
;                   || ((@cmdmod.split & WSP_VERT) != 0
;                       ? wp.w_height + wp.w_status_height < @Rows - @p_ch - tabline_height()
;                       : wp.w_width != (int)@Columns))
;               && @firstwin != @lastwin
;               && !(wp.w_closing || wp.w_buffer.b_closing))
;           {
;               win_close(wp, false);
;               wpnext = @firstwin;          ;; just in case an autocommand does something strange with windows
;               tpnext = @first_tabpage;     ;; start all over...
;               open_wins = 0;
;           }
;           else
;               open_wins++;
;       }

            ;; Go through the buffer list.  When a buffer doesn't have a window yet,
            ;; open one.  Otherwise move the window to the right position.
            ;; Watch out for autocommands that delete buffers or windows!

            ;; Don't execute Win/Buf Enter/Leave autocommands here.
;       win_enter(@lastwin, false);

;       for (buffer_C buf = @firstbuf; buf != null && open_wins < count; buf = buf.b_next)
;       {
                ;; Check if this buffer needs a window.
;           if (!all && buf.b_ml.ml_mfp == null)
;               continue;

;           window_C wp;

                ;; Check if this buffer already has a window.
;           for (wp = @firstwin; wp != null; wp = wp.w_next)
;               if (wp.w_buffer == buf)
;                   break;
                ;; If the buffer already has a window, move it.
;           if (wp != null)
;               win_move_after(wp, @curwin);

;           if (wp == null && split_ret == true)
;           {
                    ;; Split the window and put the buffer in it.
;               boolean p_ea_save = @p_ea;
;               @p_ea = true;                        ;; use space from all windows
;               split_ret = win_split(0, WSP_ROOM | WSP_BELOW);
;               open_wins++;
;               @p_ea = p_ea_save;
;               if (split_ret == false)
;                   continue;

                    ;; Open the buffer in this window.
;               set_curbuf(buf, DOBUF_GOTO);
;               if (!buf_valid(buf))                ;; autocommands deleted the buffer!!!
;                   break;
;           }

;           ui_breakcheck();
;           if (@got_int)
;           {
;               vgetc();        ;; only break the file loading, not the rest
;               break;
;           }
                ;; Autocommands deleted the buffer or aborted script processing!!!
;           if (aborting())
;               break;
;       }

;       win_enter(@firstwin, false);         ;; back to first window

            ;; Close superfluous windows.

;       for (window_C wp = @lastwin; count < open_wins; )
;       {
;           boolean r = (@cmdmod.hide || !bufIsChanged(wp.w_buffer));
;           if (!win_valid(wp))
;           {
                    ;; BufWrite Autocommands made the window invalid, start over.
;               wp = @lastwin;
;           }
;           else if (r)
;           {
;               win_close(wp, !@cmdmod.hide);
;               --open_wins;
;               wp = @lastwin;
;           }
;           else
;           {
;               wp = wp.w_prev;
;               if (wp == null)
;                   break;
;           }
;       }
    ))

;; Return special buffer name.
;; Returns null when the buffer has a normal file name.

(defn- #_Bytes buf_spname [#_buffer_C buf, #_boolean full]
    (§
;       return u8("[No Name]");
    ))

;;; ============================================================================================== VimQ

;; charset.c --------------------------------------------------------------------------------------

(atom! boolean chartab_initialized)

;; b_chartab[] is an array of 8 ints, each bit representing one of the characters 0-255.
(defn- #_void set_chartab [#_buffer_C buf, #_int c]
    (§
;       buf.b_chartab[c >>> 5] |= (1 << (c & 0x1f));
    ))

(defn- #_void reset_chartab [#_buffer_C buf, #_int c]
    (§
;       buf.b_chartab[c >>> 5] &= ~(1 << (c & 0x1f));
    ))

(defn- #_int get_chartab [#_buffer_C buf, #_int c]
    (§
;       return (buf.b_chartab[c >>> 5] & (1 << (c & 0x1f)));
    ))

;; Fill chartab[].  Also fills curbuf.b_chartab[] with flags for keyword
;; characters for current buffer.
;;
;; Depends on the option settings 'iskeyword', 'isident', 'isfname',
;; 'isprint' and 'encoding'.
;;
;; The index in chartab[] depends on 'encoding':
;; - For non-multi-byte index with the byte (same as the character).
;; - For UTF-8 index with the character (when first byte is up to 0x80 it is
;;   the same as the character, if the first byte is 0x80 and above it depends
;;   on further bytes).
;;
;; The contents of chartab[]:
;; - The lower two bits, masked by CT_CELL_MASK, give the number of display
;;   cells the character occupies (1 or 2).  Not valid for UTF-8 above 0x80.
;; - CT_PRINT_CHAR bit is set when the character is printable (no need to
;;   translate the character before displaying it).
;; - CT_FNAME_CHAR bit is set when the character can be in a file name.
;; - CT_ID_CHAR bit is set when the character can be in an identifier.
;;
;; Return false if 'iskeyword', 'isident', 'isfname' or 'isprint' option has
;; an error, true otherwise.

(defn- #_boolean init_chartab []
    (§
;       return buf_init_chartab(@curbuf, true);
    ))

(defn- #_boolean buf_init_chartab [#_buffer_C buf, #_boolean global]
    ;; global: false: only set buf.b_chartab[]
    (§
;       if (global)
;       {
            ;; Set the default size for printable characters:
            ;; From <Space> to '~' is 1 (printable), others are 2 (not printable).
            ;; This also inits all 'isident' and 'isfname' flags to false.

;           int c = 0;
;           while (c < ' ')
;               chartab[c++] = (@dy_flags & DY_UHEX) != 0 ? (byte)4 : (byte)2;
;           while (c <= '~')
;               chartab[c++] = 1 + CT_PRINT_CHAR;
;           while (c < 256)
;           {
                ;; UTF-8: bytes 0xa0 - 0xff are printable (latin1).
;               if (0xa0 <= c)
;                   chartab[c++] = CT_PRINT_CHAR + 1;
;               else
                    ;; the rest is unprintable by default
;                   chartab[c++] = (@dy_flags & DY_UHEX) != 0 ? (byte)4 : (byte)2;
;           }

            ;; Assume that every multi-byte char is a filename character.
;           for (c = 1; c < 256; c++)
;               if (0xa0 <= c)
;                   chartab[c] |= CT_FNAME_CHAR;
;       }

        ;; Init word char flags all to false.

;       AFILL(buf.b_chartab, 0);

        ;; In lisp mode the '-' character is included in keywords.

;       if (buf.@b_p_lisp)
;           set_chartab(buf, '-');

        ;; Walk through the 'isident', 'iskeyword', 'isfname' and 'isprint' options.
        ;; Each option is a list of characters, character numbers or ranges,
        ;; separated by commas, e.g.: "200-210,x,#-178,-"

;       for (int i = global ? 0 : 3; i <= 3; i++)
;       {
;           Bytes p;
;           if (i == 0)
;               p = @p_isi;          ;; first round: 'isident'
;           else if (i == 1)
;               p = @p_isp;          ;; second round: 'isprint'
;           else if (i == 2)
;               p = @p_isf;          ;; third round: 'isfname'
;           else    ;; i == 3
;               p = buf.@b_p_isk;    ;; fourth round: 'iskeyword'

;           while (p.at(0) != NUL)
;           {
;               boolean tilde = false;
;               boolean do_isalpha = false;
;               if (p.at(0) == (byte)'^' && p.at(1) != NUL)
;               {
;                   tilde = true;
;                   p = p.plus(1);
;               }
;               int c;
;               if (asc_isdigit(p.at(0)))
;               {
;                   Bytes[] __ = { p }; c = (int)getdigits(__); p = __[0];
;               }
;               else
;               {
;                   Bytes[] __ = { p }; c = us_ptr2char_adv(__, true); p = __[0];
;               }
;               int c2 = -1;
;               if (p.at(0) == (byte)'-' && p.at(1) != NUL)
;               {
;                   p = p.plus(1);
;                   if (asc_isdigit(p.at(0)))
;                   {
;                       Bytes[] __ = { p }; c2 = (int)getdigits(__); p = __[0];
;                   }
;                   else
;                   {
;                       Bytes[] __ = { p }; c2 = us_ptr2char_adv(__, true); p = __[0];
;                   }
;               }
;               if (c <= 0 || 256 <= c || (c2 < c && c2 != -1) || 256 <= c2 || !(p.at(0) == NUL || p.at(0) == (byte)','))
;                   return false;

;               if (c2 == -1)       ;; not a range
;               {
                    ;; A single '@' (not "@-@"):
                    ;; Decide on letters being ID/printable/keyword chars with
                    ;; standard function isalpha().  This takes care of locale
                    ;; for single-byte characters).

;                   if (c == '@')
;                   {
;                       do_isalpha = true;
;                       c = 1;
;                       c2 = 255;
;                   }
;                   else
;                       c2 = c;
;               }
;               while (c <= c2)
;               {
                    ;; Use the MB_ functions here, because isalpha() doesn't work properly
                    ;; when 'encoding' is "latin1" and the locale is "C".
;                   if (!do_isalpha || utf_islower(c) || utf_isupper(c))
;                   {
;                       if (i == 0)                 ;; (re)set ID flag
;                       {
;                           if (tilde)
;                               chartab[c] &= ~CT_ID_CHAR;
;                           else
;                               chartab[c] |= CT_ID_CHAR;
;                       }
;                       else if (i == 1)            ;; (re)set printable
;                       {
;                           if (c < ' ' || '~' < c)
;                           {
;                               if (tilde)
;                               {
;                                   chartab[c] = (byte)((chartab[c] & ~CT_CELL_MASK) + ((@dy_flags & DY_UHEX) != 0 ? 4 : 2));
;                                   chartab[c] &= ~CT_PRINT_CHAR;
;                               }
;                               else
;                               {
;                                   chartab[c] = (byte)((chartab[c] & ~CT_CELL_MASK) + 1);
;                                   chartab[c] |= CT_PRINT_CHAR;
;                               }
;                           }
;                       }
;                       else if (i == 2)            ;; (re)set fname flag
;                       {
;                           if (tilde)
;                               chartab[c] &= ~CT_FNAME_CHAR;
;                           else
;                               chartab[c] |= CT_FNAME_CHAR;
;                       }
;                       else /* i == 3 */           ;; (re)set keyword flag
;                       {
;                           if (tilde)
;                               reset_chartab(buf, c);
;                           else
;                               set_chartab(buf, c);
;                       }
;                   }
;                   c++;
;               }

;               c = p.at(0);
;               p = skip_to_option_part(p);
;               if (c == ',' && p.at(0) == NUL)
                    ;; Trailing comma is not allowed.
;                   return false;
;           }
;       }

;       @chartab_initialized = true;
;       return true;
    ))

;; Translate any special characters in buf[bufsize] in-place.
;; The result is a string with only printable characters, but if there is not
;; enough room, not all characters will be translated.

(defn- #_void trans_characters [#_Bytes buf, #_int bufsize]
    (§
;       int len = STRLEN(buf);
;       int room = bufsize - len;                           ;; room in buffer after string

;       while (buf.at(0) != 0)
;       {
;           int trs_len = us_ptr2len_cc(buf);

            ;; Assume a multi-byte character doesn't need translation.
;           if (1 < trs_len)
;               len -= trs_len;
;           else
;           {
;               Bytes trs = transchar_byte(buf.at(0));          ;; translated character
;               trs_len = STRLEN(trs);
;               if (1 < trs_len)
;               {
;                   room -= trs_len - 1;
;                   if (room <= 0)
;                       return;
;                   BCOPY(buf, trs_len, buf, 1, len);
;               }
;               BCOPY(buf, trs, trs_len);
;               --len;
;           }

;           buf = buf.plus(trs_len);
;       }
    ))

;; Translate a string into allocated memory, replacing special chars with printable chars.

(defn- #_Bytes transstr [#_Bytes s]
    (§
;       Bytes hexbuf = new Bytes(11);

        ;; Compute the length of the result, taking account of unprintable multi-byte characters.
;       int len = 0;

;       for (Bytes p = s; p.at(0) != NUL; )
;       {
;           int l = us_ptr2len_cc(p);
;           if (1 < l)
;           {
;               int c = us_ptr2char(p);
;               p = p.plus(l);
;               if (vim_isprintc(c))
;                   len += l;
;               else
;               {
;                   transchar_hex(hexbuf, c);
;                   len += STRLEN(hexbuf);
;               }
;           }
;           else
;           {
;               l = mb_byte2cells((p = p.plus(1)).at(-1));
;               if (0 < l)
;                   len += l;
;               else
;                   len += 4;   ;; illegal byte sequence
;           }
;       }

;       Bytes res = new Bytes(len + 1);
;       res.be(0, NUL);

;       for (Bytes p = s; p.at(0) != NUL; )
;       {
;           int l = us_ptr2len_cc(p);
;           if (1 < l)
;           {
;               int c = us_ptr2char(p);
;               if (vim_isprintc(c))
;                   STRNCAT(res, p, l);     ;; append printable multi-byte char
;               else
;                   transchar_hex(res.plus(STRLEN(res)), c);
;               p = p.plus(l);
;           }
;           else
;               STRCAT(res, transchar_byte((p = p.plus(1)).at(-1)));
;       }

;       return res;
    ))

;; Convert the string "str[orglen]" to do ignore-case comparing.
;; Puts the result in "buf[buflen]".

(defn- #_Bytes str_foldcase [#_Bytes str, #_int orglen, #_Bytes buf, #_int buflen]
    (§
;       int len = orglen;

;       if (buflen <= len)          ;; Ugly!
;           len = buflen - 1;
;       BCOPY(buf, str, len);
;       buf.be(len, NUL);

        ;; Make each character lower case.
;       int i = 0;
;       while (buf.at(i) != NUL)
;       {
;           int c = us_ptr2char(buf.plus(i));
;           int olen = us_ptr2len(buf.plus(i));
;           int lc = utf_tolower(c);

            ;; Only replace the character when it is not an invalid
            ;; sequence (ASCII character or more than one byte) and
            ;; utf_tolower() doesn't return the original character.
;           if ((c < 0x80 || 1 < olen) && c != lc)
;           {
;               int nlen = utf_char2len(lc);

                ;; If the byte length changes, need to shift
                ;; the following characters forward or backward.
;               if (olen != nlen)
;               {
;                   if (olen < nlen && buflen <= len + nlen - olen)
;                   {
                        ;; out of memory, keep old char
;                       lc = c;
;                       nlen = olen;
;                   }
;                   if (olen != nlen)
;                   {
;                       BCOPY(buf, i + nlen, buf, i + olen, STRLEN(buf, i + olen) + 1);
;                       len += nlen - olen;
;                   }
;               }
;               utf_char2bytes(lc, buf.plus(i));
;           }

            ;; skip to next multi-byte char
;           i += us_ptr2len_cc(buf.plus(i));
;       }

;       return buf;
    ))

;; Catch 22: chartab[] can't be initialized before the options are initialized,
;; and initializing options may cause transchar() to be called!
;; When !chartab_initialized, don't use chartab[].
;; Does NOT work for multi-byte characters, c must be <= 255.
;; Also doesn't work for the first byte of a multi-byte, "c" must be a character!

(final Bytes transchar_buf (Bytes. 7))

(defn- #_Bytes transchar [#_int c]
    (§
;       int i = 0;

;       if (is_special(c))      ;; special key code, display as ~@ char
;       {
;           transchar_buf.be(0, (byte)'~');
;           transchar_buf.be(1, (byte)'@');
;           i = 2;
;           c = char_u(KB_SECOND(c));
;       }

;       if ((!@chartab_initialized && (' ' <= c && c <= '~')) || (c < 256 && vim_isprintc(c)))
;       {
            ;; printable character
;           transchar_buf.be(i, c);
;           transchar_buf.be(i + 1, NUL);
;       }
;       else
;           transchar_nonprint(transchar_buf.plus(i), c);

;       return transchar_buf;
    ))

;; Like transchar(), but called with a byte instead of a character.
;; Checks for an illegal UTF-8 byte.

(defn- #_Bytes transchar_byte [#_byte b]
    (§
;       if (0x80 <= char_u(b))
;       {
;           transchar_nonprint(transchar_buf, char_u(b));
;           return transchar_buf;
;       }
;       return transchar(char_u(b));
    ))

;; Convert non-printable character to two or more printable characters in "buf[]".
;; "buf" needs to be able to hold five bytes.
;; Does NOT work for multi-byte characters, c must be <= 255.

(defn- #_void transchar_nonprint [#_Bytes buf, #_int c]
    (§
;       if (c == NL)
;           c = NUL;                                    ;; we use newline in place of a NUL

;       if ((@dy_flags & DY_UHEX) != 0)                  ;; 'display' has "uhex"
;           transchar_hex(buf, c);

;       else if (c <= 0x7f)                             ;; 0x00 - 0x1f and 0x7f
;       {
;           buf.be(0, (byte)'^');
;           buf.be(1, (byte)(c ^ 0x40));                          ;; DEL displayed as ^?

;           buf.be(2, NUL);
;       }
;       else if (0x80 <= c)
;       {
;           transchar_hex(buf, c);
;       }
;       else if (' ' + 0x80 <= c && c <= '~' + 0x80)    ;; 0xa0 - 0xfe
;       {
;           buf.be(0, (byte)'|');
;           buf.be(1, (byte)(c - 0x80));
;           buf.be(2, NUL);
;       }
;       else                                            ;; 0x80 - 0x9f and 0xff
;       {
;           buf.be(0, (byte)'~');
;           buf.be(1, (byte)((c - 0x80) ^ 0x40));                 ;; 0xff displayed as ~?
;           buf.be(2, NUL);
;       }
    ))

(defn- #_void transchar_hex [#_Bytes buf, #_int c]
    (§
;       int i = 0;

;       buf.be(i, (byte)'<');
;       if (0xff < c)
;       {
;           buf.be(++i, nr2hex(c >>> 12));
;           buf.be(++i, nr2hex(c >>> 8));
;       }
;       buf.be(++i, nr2hex(c >>> 4));
;       buf.be(++i, nr2hex(c));
;       buf.be(++i, (byte)'>');
;       buf.be(++i, NUL);
    ))

;; Convert the lower 4 bits of byte "c" to its hex character.
;; Lower case letters are used to avoid the confusion of <F1> being 0xf1 or function key 1.

(defn- #_int nr2hex [#_int c]
    (§
;       if ((c & 0xf) <= 9)
;           return (c & 0xf) + '0';

;       return (c & 0xf) - 10 + 'a';
    ))

;; Return number of display cells occupied by byte "b".
;; For multi-byte mode "b" must be the first byte of a character.
;; A TAB is counted as two cells: "^I".
;; For UTF-8 mode this will return 0 for bytes >= 0x80, because the number of cells depends on further bytes.

(defn- #_int mb_byte2cells [#_byte b]
    (§
;       if (0x80 <= char_u(b))
;           return 0;

;       return (chartab[char_u(b)] & CT_CELL_MASK);
    ))

;; Return number of display cells occupied by character "c".
;; "c" can be a special key (negative number) in which case 3 or 4 is returned.
;; A TAB is counted as two cells: "^I" or four: "<09>".

(defn- #_int mb_char2cells [#_int c]
    (§
;       if (is_special(c))
;           return mb_char2cells(char_u(KB_SECOND(c))) + 2;

        ;; UTF-8: above 0x80 need to check the value.
;       if (0x80 <= c)
;           return utf_char2cells(c);

;       return (chartab[c & 0xff] & CT_CELL_MASK);
    ))

;; Return number of display cells occupied by character at "*p".
;; A TAB is counted as two cells: "^I" or four: "<09>".

(defn- #_int mb_ptr2cells [#_Bytes p]
    (§
        ;; For UTF-8 we need to look at more bytes if the first byte is >= 0x80.
;       if (0x80 <= char_u(p.at(0)))
;           return us_ptr2cells(p);

;       return (chartab[char_u(p.at(0))] & CT_CELL_MASK);
    ))

;; Return the number of character cells string "s[len]" will take on the screen,
;; counting TABs as two characters: "^I".

(defn- #_int mb_string2cells [#_Bytes p, #_int len]
    (§
;       int cells = 0;

;       for (int i = 0; (len < 0 || i < len) && p.at(i) != NUL; i += us_ptr2len_cc(p.plus(i)))
;           cells += mb_ptr2cells(p.plus(i));

;       return cells;
    ))

;; Return the number of characters 'c' will take on the screen,
;; taking into account the size of a tab.
;; Use a define to make it fast, this is used very often!!!
;; Also see getvcol() below.

(defn- #_int win_buf_chartabsize [#_window_C wp, #_buffer_C buf, #_Bytes p, #_int col]
    (§
;       if (p.at(0) == TAB && (!wp.w_onebuf_opt.@wo_list || lcs_tab1[0] != NUL))
;       {
;           int ts = (int)buf.@b_p_ts;
;           return ts - (col % ts);
;       }

;       return mb_ptr2cells(p);
    ))

(defn- #_int chartabsize [#_Bytes p, #_int col]
    (§
;       return win_buf_chartabsize(@curwin, @curbuf, p, col);
    ))

;; Return the number of characters the string 's' will take on the screen,
;; taking into account the size of a tab.

(defn- #_int linetabsize [#_Bytes s]
    (§
;       return linetabsize_col(s, 0);
    ))

;; Like linetabsize(), but starting at column "startcol".

(defn- #_int linetabsize_col [#_Bytes _s, #_int startcol]
    (§
;       Bytes[] s = { _s };

;       int col = startcol;

;       Bytes line = s[0];        ;; pointer to start of line, for breakindent
;       while (s[0].at(0) != NUL)
;           col += lbr_chartabsize_adv(line, s, col);

;       return col;
    ))

;; Like linetabsize(), but for a given window instead of the current one.

(defn- #_int win_linetabsize [#_window_C wp, #_Bytes line, #_int len]
    (§
;       int col = 0;

;       for (Bytes s = line; s.at(0) != NUL && (len == MAXCOL || BLT(s, line.plus(len))); s = s.plus(us_ptr2len_cc(s)))
;           col += win_lbr_chartabsize(wp, line, s, col, null);

;       return col;
    ))

;; Return true if 'c' is a normal identifier character:
;; Letters and characters from the 'isident' option.

(defn- #_boolean vim_isIDc [#_int c]
    (§
;       return (0 < c && c < 0x100 && (chartab[c] & CT_ID_CHAR) != 0);
    ))

;; Return true if 'c' is a keyword character:
;; Letters and characters from 'iskeyword' option for current buffer.
;; For multi-byte characters us_get_class() is used (builtin rules).

(defn- #_boolean vim_iswordc [#_int c, #_buffer_C buf]
    (§
;       if (0x100 <= c)
;           return (2 <= utf_class(c));

;       return (0 < c && c < 0x100 && get_chartab(buf, c) != 0);
    ))

(defn- #_boolean us_iswordb [#_byte b, #_buffer_C buf]
    (§
;       return (b != 0 && get_chartab(buf, char_u(b)) != 0);
    ))

(defn- #_boolean us_iswordp [#_Bytes p, #_buffer_C buf]
    (§
;       if (1 < us_byte2len(p.at(0), false))
;           return (2 <= us_get_class(p, buf));

;       return us_iswordb(p.at(0), buf);
    ))

;; Return true if 'c' is a valid file-name character.
;; Assume characters above 0x100 are valid (multi-byte).

(defn- #_boolean vim_isfilec [#_int c]
    (§
;       return (0x100 <= c || (0 < c && (chartab[c] & CT_FNAME_CHAR) != 0));
    ))

;; return true if 'c' is a printable character
;; Assume characters above 0x100 are printable (multi-byte), except for Unicode.

(defn- #_boolean vim_isprintc [#_int c]
    (§
;       if (0x100 <= c)
;           return utf_printable(c);

;       return (0x100 <= c || (0 < c && (chartab[c] & CT_PRINT_CHAR) != 0));
    ))

;; like chartabsize(), but also check for line breaks on the screen

(defn- #_int lbr_chartabsize [#_Bytes line, #_Bytes s, #_int col]
    ;; line: start of the line
    (§
;       if (!@curwin.w_onebuf_opt.@wo_lbr && @p_sbr.at(0) == NUL && !@curwin.w_onebuf_opt.@wo_bri)
;       {
;           if (@curwin.w_onebuf_opt.@wo_wrap)
;               return win_nolbr_chartabsize(@curwin, s, col, null);

;           return win_buf_chartabsize(@curwin, @curbuf, s, col);
;       }
;       return win_lbr_chartabsize(@curwin, (line == null) ? s : line, s, col, null);
    ))

;; Call lbr_chartabsize() and advance the pointer.

(defn- #_int lbr_chartabsize_adv [#_Bytes line, #_Bytes* s, #_int col]
    ;; line: start of the line
    (§
;       int retval = lbr_chartabsize(line, s[0], col);
;       s[0] = s[0].plus(us_ptr2len_cc(s[0]));
;       return retval;
    ))

;; This function is used very often, keep it fast!!!!
;;
;; If "headp" not null, set "*headp" to the size of what we for 'showbreak' string at start of line.
;; Warning: "*headp" is only set if it's a non-zero value, init to 0 before calling.

(defn- #_int win_lbr_chartabsize [#_window_C wp, #_Bytes line, #_Bytes s, #_int col, #_int* headp]
    ;; line: start of the line
    (§
;       int col_adj = 0;                ;; col + screen size of tab
;       int mb_added = 0;
;       boolean tab_corr = (s.at(0) == TAB);

        ;; No 'linebreak', 'showbreak' and 'breakindent': return quickly.

;       if (!wp.w_onebuf_opt.@wo_lbr && !wp.w_onebuf_opt.@wo_bri && @p_sbr.at(0) == NUL)
;       {
;           if (wp.w_onebuf_opt.@wo_wrap)
;               return win_nolbr_chartabsize(wp, s, col, headp);

;           return win_buf_chartabsize(wp, wp.w_buffer, s, col);
;       }

        ;; First get normal size, without 'linebreak'.

;       int size = win_buf_chartabsize(wp, wp.w_buffer, s, col);
;       byte c = s.at(0);
;       if (tab_corr)
;           col_adj = size - 1;

        ;; If 'linebreak' set check at a blank before a non-blank if the line needs a break here.

;       if (wp.w_onebuf_opt.@wo_lbr && @breakat_flags[char_u(c)] && !@breakat_flags[char_u(s.at(1))]
;                       && wp.w_onebuf_opt.@wo_wrap && wp.w_width != 0)
;       {
            ;; Count all characters from first non-blank after a blank up to next non-blank after a blank.

;           int numberextra = win_col_off(wp);
;           int col2 = col;
;           int colmax = wp.w_width - numberextra - col_adj;
;           if (colmax <= col)
;           {
;               colmax += col_adj;
;               int n = colmax +  win_col_off2(wp);
;               if (0 < n)
;                   colmax += (((col - colmax) / n) + 1) * n - col_adj;
;           }

;           for ( ; ; )
;           {
;               Bytes ps = s;
;               s = s.plus(us_ptr2len_cc(s));
;               c = s.at(0);
;               if (!(c != NUL
;                       && (@breakat_flags[char_u(c)]
;                           || (!@breakat_flags[char_u(c)]
;                               && (col2 == col || !@breakat_flags[char_u(ps.at(0))])))))
;                   break;

;               col2 += win_buf_chartabsize(wp, wp.w_buffer, s, col2);
;               if (colmax <= col2)         ;; doesn't fit
;               {
;                   size = colmax - col + col_adj;
;                   tab_corr = false;
;                   break;
;               }
;           }
;       }
;       else if (size == 2 && 1 < us_byte2len(s.at(0), false) && wp.w_onebuf_opt.@wo_wrap && in_win_border(wp, col))
;       {
;           size++;         ;; Count the ">" in the last column.
;           mb_added = 1;
;       }

        ;; May have to add something for 'breakindent' and/or 'showbreak' string at start of line.
        ;; Set "*headp" to the size of what we add.

;       int added = 0;
;       if ((@p_sbr.at(0) != NUL || wp.w_onebuf_opt.@wo_bri) && wp.w_onebuf_opt.@wo_wrap && col != 0)
;       {
;           int sbrlen = 0;
;           int numberwidth = win_col_off(wp);

;           int numberextra = numberwidth;
;           col += numberextra + mb_added;
;           if (wp.w_width <= col)
;           {
;               col -= wp.w_width;
;               numberextra = wp.w_width - (numberextra - win_col_off2(wp));
;               if (col >= numberextra && 0 < numberextra)
;                   col %= numberextra;
;               if (@p_sbr.at(0) != NUL)
;               {
;                   sbrlen = us_charlen(@p_sbr);
;                   if (sbrlen <= col)
;                       col -= sbrlen;
;               }
;               if (col >= numberextra && 0 < numberextra)
;                   col %= numberextra;
;               else if (0 < col && 0 < numberextra)
;                   col += numberwidth - win_col_off2(wp);

;               numberwidth -= win_col_off2(wp);
;           }
;           if (col == 0 || wp.w_width < col + size + sbrlen)
;           {
;               added = 0;
;               if (@p_sbr.at(0) != NUL)
;               {
;                   if (wp.w_width < size + sbrlen + numberwidth)
;                   {
                        ;; calculate effective window width
;                       int width = wp.w_width - sbrlen - numberwidth;
;                       int prev_width = (col != 0) ? wp.w_width - (sbrlen + col) : 0;
;                       if (width == 0)
;                           width = wp.w_width;
;                       added += ((size - prev_width) / width) * mb_string2cells(@p_sbr, -1);
;                       if ((size - prev_width) % width != 0)
                            ;; wrapped, add another length of 'sbr'
;                           added += mb_string2cells(@p_sbr, -1);
;                   }
;                   else
;                       added += mb_string2cells(@p_sbr, -1);
;               }
;               if (wp.w_onebuf_opt.@wo_bri)
;                   added += get_breakindent_win(wp, line);

;               size += added;
;               if (col != 0)
;                   added = 0;
;           }
;       }
;       if (headp != null)
;           headp[0] = added + mb_added;

;       return size;
    ))

;; Like win_lbr_chartabsize(), except that we know 'linebreak' is off and 'wrap' is on.
;; This means we need to check for a double-byte character that doesn't fit
;; at the end of the screen line.

(defn- #_int win_nolbr_chartabsize [#_window_C wp, #_Bytes p, #_int col, #_int* headp]
    (§
;       if (p.at(0) == TAB && (!wp.w_onebuf_opt.@wo_list || lcs_tab1[0] != NUL))
;       {
;           int ts = (int)wp.w_buffer.@b_p_ts;
;           return ts - (col % ts);
;       }

;       int n = mb_ptr2cells(p);
        ;; Add one cell for a double-width character in the last column of the window,
        ;; displayed with a ">".
;       if (n == 2 && 1 < us_byte2len(p.at(0), false) && in_win_border(wp, col))
;       {
;           if (headp != null)
;               headp[0] = 1;
;           return 3;
;       }
;       return n;
    ))

;; Return true if virtual column "vcol" is in the rightmost column of window "wp".

(defn- #_boolean in_win_border [#_window_C wp, #_int vcol]
    (§
;       if (wp.w_width == 0)                            ;; there is no border
;           return false;
;       int width1 = wp.w_width - win_col_off(wp);      ;; width of first line (after line number)
;       if (vcol < width1 - 1)
;           return false;
;       if (vcol == width1 - 1)
;           return true;
;       int width2 = width1 + win_col_off2(wp);         ;; width of further lines
;       if (width2 <= 0)
;           return false;

;       return ((vcol - width1) % width2 == width2 - 1);
    ))

;; Get virtual column number of pos.
;;  start: on the first position of this character (TAB, ctrl)
;; cursor: where the cursor is on this character (first char, except for TAB)
;;    end: on the last position of this character (TAB, ctrl)
;;
;; This is used very often, keep it fast!

(defn- #_void getvcol [#_window_C wp, #_pos_C pos, #_int* start, #_int* cursor, #_int* end]
    (§
;       Bytes p = ml_get_buf(wp.w_buffer, pos.lnum, false);    ;; points to current char
;       Bytes line = p;                                        ;; start of the line
;       Bytes posptr;                                          ;; points to char at pos.col
;       if (pos.col == MAXCOL)
;           posptr = null;                                      ;; continue until the NUL
;       else
;           posptr = p.plus(pos.col);

;       int vcol = 0;
;       int ts = (int)wp.w_buffer.@b_p_ts;

;       int[] head = new int[1];
;       int incr;

        ;; This function is used very often, do some speed optimizations.
        ;; When 'list', 'linebreak', 'showbreak' and 'breakindent' are not set use a simple loop.
        ;; Also use this when 'list' is set but tabs take their normal size.

;       if ((!wp.w_onebuf_opt.@wo_list || lcs_tab1[0] != NUL) && !wp.w_onebuf_opt.@wo_lbr && @p_sbr.at(0) == NUL && !wp.w_onebuf_opt.@wo_bri)
;       {
;           for ( ; ; p = p.plus(us_ptr2len_cc(p)))
;           {
;               head[0] = 0;
                ;; make sure we don't go past the end of the line
;               if (p.at(0) == NUL)
;               {
;                   incr = 1;       ;; NUL at end of line only takes one column
;                   break;
;               }
                ;; A tab gets expanded, depending on the current column.
;               if (p.at(0) == TAB)
;                   incr = ts - (vcol % ts);
;               else
;               {
;                   incr = mb_ptr2cells(p);

                    ;; If a double-cell char doesn't fit at the end of a line,
                    ;; it wraps to the next line, it's like this char is three cells wide.
;                   if (incr == 2 && wp.w_onebuf_opt.@wo_wrap && 1 < us_byte2len(p.at(0), false) && in_win_border(wp, vcol))
;                   {
;                       incr++;
;                       head[0] = 1;
;                   }
;               }

;               if (posptr != null && BLE(posptr, p))  ;; character at pos.col
;                   break;

;               vcol += incr;
;           }
;       }
;       else
;       {
;           for ( ; ; p = p.plus(us_ptr2len_cc(p)))
;           {
                ;; A tab gets expanded, depending on the current column.
;               head[0] = 0;
;               incr = win_lbr_chartabsize(wp, line, p, vcol, head);
                ;; make sure we don't go past the end of the line
;               if (p.at(0) == NUL)
;               {
;                   incr = 1;       ;; NUL at end of line only takes one column
;                   break;
;               }

;               if (posptr != null && BLE(posptr, p))  ;; character at pos.col
;                   break;

;               vcol += incr;
;           }
;       }
;       if (start != null)
;           start[0] = vcol + head[0];
;       if (end != null)
;           end[0] = vcol + incr - 1;
;       if (cursor != null)
;       {
;           if (p.at(0) == TAB
;                   && (@State & NORMAL) != 0
;                   && !wp.w_onebuf_opt.@wo_list
;                   && !virtual_active()
;                   && !(@VIsual_active && (@p_sel.at(0) == (byte)'e' || ltoreq(pos, @VIsual))))
;               cursor[0] = vcol + incr - 1;        ;; cursor at end
;           else
;               cursor[0] = vcol + head[0];         ;; cursor at start
;       }
    ))

;; Get virtual cursor column in the current window, pretending 'list' is off.

(defn- #_int getvcol_nolist [#_pos_C posp]
    (§
;       boolean list_save = @curwin.w_onebuf_opt.@wo_list;
;       @curwin.w_onebuf_opt.@wo_list = false;

;       int[] vcol = new int[1];
;       getvcol(@curwin, posp, null, vcol, null);

;       @curwin.w_onebuf_opt.@wo_list = list_save;

;       return vcol[0];
    ))

;; Get virtual column in virtual mode.

(defn- #_void getvvcol [#_window_C wp, #_pos_C pos, #_int* start, #_int* cursor, #_int* end]
    (§
;       if (virtual_active())
;       {
            ;; For virtual mode, only want one value.
;           int[] col = new int[1];
;           getvcol(wp, pos, col, null, null);
;           int coladd = pos.coladd;
;           int endadd = 0;

            ;; Cannot put the cursor on part of a wide character.
;           Bytes ptr = ml_get_buf(wp.w_buffer, pos.lnum, false);
;           if (pos.col < STRLEN(ptr))
;           {
;               int c = us_ptr2char(ptr.plus(pos.col));

;               if (c != TAB && vim_isprintc(c))
;               {
;                   endadd = mb_char2cells(c) - 1;
;                   if (endadd < coladd)    ;; past end of line
;                       endadd = 0;
;                   else
;                       coladd = 0;
;               }
;           }
;           col[0] += coladd;
;           if (start != null)
;               start[0] = col[0];
;           if (cursor != null)
;               cursor[0] = col[0];
;           if (end != null)
;               end[0] = col[0] + endadd;
;       }
;       else
;           getvcol(wp, pos, start, cursor, end);
    ))

;; Get the leftmost and rightmost virtual column of pos1 and pos2.
;; Used for Visual block mode.

(defn- #_void getvcols [#_window_C wp, #_pos_C pos1, #_pos_C pos2, #_int* left, #_int* right]
    (§
;       int[] from1 = new int[1];
;       int[] from2 = new int[1];
;       int[] to1 = new int[1];
;       int[] to2 = new int[1];

;       if (ltpos(pos1, pos2))
;       {
;           getvvcol(wp, pos1, from1, null, to1);
;           getvvcol(wp, pos2, from2, null, to2);
;       }
;       else
;       {
;           getvvcol(wp, pos2, from1, null, to1);
;           getvvcol(wp, pos1, from2, null, to2);
;       }
;       if (from2[0] < from1[0])
;           left[0] = from2[0];
;       else
;           left[0] = from1[0];
;       if (to1[0] < to2[0])
;       {
;           if (@p_sel.at(0) == (byte)'e' && to1[0] <= from2[0] - 1)
;               right[0] = from2[0] - 1;
;           else
;               right[0] = to2[0];
;       }
;       else
;           right[0] = to1[0];
    ))

;; Skip over ' ' and '\t'.

(defn- #_Bytes skipwhite [#_Bytes q]
    (§
;       Bytes p = q;

;       while (vim_iswhite(p.at(0)))    ;; skip to next non-white
;           p = p.plus(1);
;       return p;
    ))

;; skip over digits

(defn- #_Bytes skipdigits [#_Bytes q]
    (§
;       Bytes p = q;

;       while (asc_isdigit(p.at(0)))    ;; skip to next non-digit
;           p = p.plus(1);
;       return p;
    ))

;; skip over digits and hex characters

(defn- #_Bytes skiphex [#_Bytes q]
    (§
;       Bytes p = q;

;       while (asc_isxdigit(p.at(0)))   ;; skip to next non-digit
;           p = p.plus(1);
;       return p;
    ))

;; skip to digit (or NUL after the string)

(defn- #_Bytes skiptodigit [#_Bytes q]
    (§
;       Bytes p = q;

;       while (p.at(0) != NUL && !asc_isdigit(p.at(0)))       ;; skip to next digit
;           p = p.plus(1);
;       return p;
    ))

;; skip to hex character (or NUL after the string)

(defn- #_Bytes skiptohex [#_Bytes q]
    (§
;       Bytes p = q;

;       while (p.at(0) != NUL && !asc_isxdigit(p.at(0)))      ;; skip to next digit
;           p = p.plus(1);
;       return p;
    ))

;; Variant of isdigit() that can handle characters > 0x100.
;; We don't use isdigit() here, because on some systems it also considers
;; superscript 1 to be a digit.

(defn- #_boolean asc_isdigit [#_int c]
    (§
;       return ('0' <= c && c <= '9');
    ))

(defn- #_boolean asc_isodigit [#_int c]
    (§
;       return ('0' <= c && c <= '7');
    ))

;; Variant of isxdigit() that can handle characters > 0x100.
;; We don't use isxdigit() here, because on some systems it also considers
;; superscript 1 to be a digit.

(defn- #_boolean asc_isxdigit [#_int c]
    (§
;       return ('0' <= c && c <= '9')
;           || ('a' <= c && c <= 'f')
;           || ('A' <= c && c <= 'F');
    ))

;; Skip over text until ' ' or '\t' or NUL.

(defn- #_Bytes skiptowhite [#_Bytes p]
    (§
;       while (p.at(0) != (byte)' ' && p.at(0) != (byte)'\t' && p.at(0) != NUL)
;           p = p.plus(1);
;       return p;
    ))

;; Like skiptowhite(), but also skip escaped chars.

(defn- #_Bytes skiptowhite_esc [#_Bytes p]
    (§
;       while (p.at(0) != (byte)' ' && p.at(0) != (byte)'\t' && p.at(0) != NUL)
;       {
;           if ((p.at(0) == (byte)'\\' || p.at(0) == Ctrl_V) && p.at(1) != NUL)
;               p = p.plus(1);
;           p = p.plus(1);
;       }
;       return p;
    ))

;; Getdigits: Get a number from a string and skip over it.
;; Note: the argument is a pointer to a byte pointer!

(defn- #_long getdigits [#_Bytes* pp]
    (§
;       Bytes p = pp[0];
;       long retval = libC.atol(p);
;       if (p.at(0) == (byte)'-')                  ;; skip negative sign
;           p = p.plus(1);
;       p = skipdigits(p);              ;; skip to next non-digit
;       pp[0] = p;

;       return retval;
    ))

;; Return true if "lbuf" is empty or only contains blanks.

(defn- #_boolean vim_isblankline [#_Bytes lbuf]
    (§
;       Bytes p = skipwhite(lbuf);
;       return (p.at(0) == NUL || p.at(0) == (byte)'\r' || p.at(0) == (byte)'\n');
    ))

;; Convert a string into a long and/or unsigned long, taking care of
;; hexadecimal and octal numbers.  Accepts a '-' sign.
;; If "hexp" is not null, returns a flag to indicate the type of the number:
;;  0       decimal
;;  '0'     octal
;;  'X'     hex
;;  'x'     hex
;; If "len" is not null, the length of the number in characters is returned.
;; If "nptr" is not null, the signed result is returned in it.
;; If "unptr" is not null, the unsigned result is returned in it.
;; If "dooct" is non-zero recognize octal numbers, when > 1 always assume octal number.
;; If "dohex" is non-zero recognize hex numbers, when > 1 always assume hex number.

(defn- #_void vim_str2nr [#_Bytes start, #_int* hexp, #_int* len, #_int dooct, #_int dohex, #_long* nptr]
    ;; hexp: return: type of number 0 = decimal, 'x' or 'X' is hex, '0' = octal
    ;; len: return: detected length of number
    ;; dooct: recognize octal number
    ;; dohex: recognize hex number
    ;; nptr: return: signed result
    (§
;       Bytes ptr = start;

;       boolean negative = false;
;       if (ptr.at(0) == (byte)'-')
;       {
;           negative = true;
;           ptr = ptr.plus(1);
;       }

;       int hex = 0;                        ;; default is decimal

        ;; Recognize hex and octal.
;       if (ptr.at(0) == (byte)'0' && ptr.at(1) != (byte)'8' && ptr.at(1) != (byte)'9')
;       {
;           hex = ptr.at(1);
;           if (dohex != 0 && (hex == 'X' || hex == 'x') && asc_isxdigit(ptr.at(2)))
;               ptr = ptr.plus(2);          ;; hexadecimal
;           else
;           {
;               hex = 0;                    ;; default is decimal
;               if (dooct != 0)
;               {
                    ;; Don't interpret "0", "08" or "0129" as octal.
;                   for (int n = 1; asc_isdigit(ptr.at(n)); n++)
;                   {
;                       if ('7' < ptr.at(n))
;                       {
;                           hex = 0;        ;; can't be octal
;                           break;
;                       }
;                       if ('0' <= ptr.at(n))
;                           hex = '0';      ;; assume octal
;                   }
;               }
;           }
;       }

;       long nr = 0;

        ;; Do the string-to-numeric conversion "manually" to avoid sscanf quirks.

;       if (hex == '0' || 1 < dooct)
;       {
;           for ( ; asc_isodigit(ptr.at(0)); ptr = ptr.plus(1))         ;; octal
;           {
;               long l = 8 * nr + (long)(ptr.at(0) - '0');
;               if (l < nr)
;                   break;
;               nr = l;
;           }
;       }
;       else if (hex != 0 || 1 < dohex)
;       {
;           for ( ; asc_isxdigit(ptr.at(0)); ptr = ptr.plus(1))         ;; hex
;           {
;               long l = 16 * nr + (long)hex2nr(ptr.at(0));
;               if (l < nr)
;                   break;
;               nr = l;
;           }
;       }
;       else
;       {
;           for ( ; asc_isdigit(ptr.at(0)); ptr = ptr.plus(1))          ;; decimal
;           {
;               long l = 10 * nr + (long)(ptr.at(0) - '0');
;               if (l < nr)
;                   break;
;               nr = l;
;           }
;       }

;       if (hexp != null)
;           hexp[0] = hex;
;       if (len != null)
;           len[0] = BDIFF(ptr, start);
;       if (nptr != null)
;       {
;           if (negative)               ;; account for leading '-' for decimal numbers
;               nptr[0] = -nr;
;           else
;               nptr[0] = nr;
;       }
    ))

;; Return the value of a single hex character.
;; Only valid when the argument is '0' - '9', 'A' - 'F' or 'a' - 'f'.

(defn- #_int hex2nr [#_int c]
    (§
;       if ('a' <= c && c <= 'f')
;           return c - 'a' + 10;
;       if ('A' <= c && c <= 'F')
;           return c - 'A' + 10;

;       return c - '0';
    ))

;; Convert two hex characters to a byte.
;; Return -1 if one of the characters is not hex.

(defn- #_int hexhex2nr [#_Bytes p]
    (§
;       if (!asc_isxdigit(p.at(0)) || !asc_isxdigit(p.at(1)))
;           return -1;

;       return (hex2nr(p.at(0)) << 4) + hex2nr(p.at(1));
    ))

;; Return true if "str" starts with a backslash that should be removed.

(defn- #_boolean rem_backslash [#_Bytes str]
    (§
;       return (str.at(0) == (byte)'\\' && str.at(1) != NUL);
    ))

;; Halve the number of backslashes in a file name argument.
;; For MS-DOS we only do this if the character after the backslash
;; is not a normal file character.

(defn- #_void backslash_halve [#_Bytes p]
    (§
;       for ( ; p.at(0) != NUL; p = p.plus(1))
;           if (rem_backslash(p))
;               BCOPY(p, 0, p, 1, STRLEN(p, 1) + 1);
    ))

;; backslash_halve() plus save the result in allocated memory.

(defn- #_Bytes backslash_halve_save [#_Bytes p]
    (§
;       Bytes res = STRDUP(p);
;       backslash_halve(res);
;       return res;
    ))

;;; ============================================================================================== VimR

;; digraph.c: code for digraphs -------------------------------------------------------------------

(class! #_final digr_C
    [
        (field byte     char1)
        (field byte     char2)
        (field int      result)
    ])

;; digraphs added by the user
(atom! digr_C* user_digraphs    0)

(defn- #_final #_digr_C digr [#_"/*byte*/char" char1, #_"/*byte*/char" char2, #_int result]
    (§
;       return new digr_C((byte)char1, (byte)char2, result);
    ))

;; digraphs for Unicode from RFC1345 (also work for ISO-8859-1 aka latin1)
(final digr_C* digraphdefault
    [
        (digr \N, \U, 0x0a),       ;; LF for NUL
        (digr \S, \H, 0x01),
        (digr \S, \X, 0x02),
        (digr \E, \X, 0x03),
        (digr \E, \T, 0x04),
        (digr \E, \Q, 0x05),
        (digr \A, \K, 0x06),
        (digr \B, \L, 0x07),
        (digr \B, \S, 0x08),
        (digr \H, \T, 0x09),
        (digr \L, \F, 0x0a),
        (digr \V, \T, 0x0b),
        (digr \F, \F, 0x0c),
        (digr \C, \R, 0x0d),
        (digr \S, \O, 0x0e),
        (digr \S, \I, 0x0f),
        (digr \D, \L, 0x10),
        (digr \D, \1, 0x11),
        (digr \D, \2, 0x12),
        (digr \D, \3, 0x13),
        (digr \D, \4, 0x14),
        (digr \N, \K, 0x15),
        (digr \S, \Y, 0x16),
        (digr \E, \B, 0x17),
        (digr \C, \N, 0x18),
        (digr \E, \M, 0x19),
        (digr \S, \B, 0x1a),
        (digr \E, \C, 0x1b),
        (digr \F, \S, 0x1c),
        (digr \G, \S, 0x1d),
        (digr \R, \S, 0x1e),
        (digr \U, \S, 0x1f),
        (digr \S, \P, 0x20),
        (digr \N, \b, 0x23),
        (digr \D, \O, 0x24),
        (digr \A, \t, 0x40),
        (digr \<, \(, 0x5b),
        (digr \/, \/, 0x5c),
        (digr \), \>, 0x5d),
        (digr \', \>, 0x5e),
        (digr \', \!, 0x60),
        (digr \(, \!, 0x7b),
        (digr \!, \!, 0x7c),
        (digr \!, \), 0x7d),
        (digr \', \?, 0x7e),
        (digr \D, \T, 0x7f),
        (digr \P, \A, 0x80),
        (digr \H, \O, 0x81),
        (digr \B, \H, 0x82),
        (digr \N, \H, 0x83),
        (digr \I, \N, 0x84),
        (digr \N, \L, 0x85),
        (digr \S, \A, 0x86),
        (digr \E, \S, 0x87),
        (digr \H, \S, 0x88),
        (digr \H, \J, 0x89),
        (digr \V, \S, 0x8a),
        (digr \P, \D, 0x8b),
        (digr \P, \U, 0x8c),
        (digr \R, \I, 0x8d),
        (digr \S, \2, 0x8e),
        (digr \S, \3, 0x8f),
        (digr \D, \C, 0x90),
        (digr \P, \1, 0x91),
        (digr \P, \2, 0x92),
        (digr \T, \S, 0x93),
        (digr \C, \C, 0x94),
        (digr \M, \W, 0x95),
        (digr \S, \G, 0x96),
        (digr \E, \G, 0x97),
        (digr \S, \S, 0x98),
        (digr \G, \C, 0x99),
        (digr \S, \C, 0x9a),
        (digr \C, \I, 0x9b),
        (digr \S, \T, 0x9c),
        (digr \O, \C, 0x9d),
        (digr \P, \M, 0x9e),
        (digr \A, \C, 0x9f),
        (digr \N, \S, 0xa0),
        (digr \!, \I, 0xa1),
        (digr \C, \t, 0xa2),
        (digr \P, \d, 0xa3),
        (digr \C, \u, 0xa4),
        (digr \Y, \e, 0xa5),
        (digr \B, \B, 0xa6),
        (digr \S, \E, 0xa7),
        (digr \', \:, 0xa8),
        (digr \C, \o, 0xa9),
        (digr \-, \a, 0xaa),
        (digr \<, \<, 0xab),
        (digr \N, \O, 0xac),
        (digr \-, \-, 0xad),
        (digr \R, \g, 0xae),
        (digr \', \m, 0xaf),
        (digr \D, \G, 0xb0),
        (digr \+, \-, 0xb1),
        (digr \2, \S, 0xb2),
        (digr \3, \S, 0xb3),
        (digr \', \', 0xb4),
        (digr \M, \y, 0xb5),
        (digr \P, \I, 0xb6),
        (digr \., \M, 0xb7),
        (digr \', \,, 0xb8),
        (digr \1, \S, 0xb9),
        (digr \-, \o, 0xba),
        (digr \>, \>, 0xbb),
        (digr \1, \4, 0xbc),
        (digr \1, \2, 0xbd),
        (digr \3, \4, 0xbe),
        (digr \?, \I, 0xbf),
        (digr \A, \!, 0xc0),
        (digr \A, \', 0xc1),
        (digr \A, \>, 0xc2),
        (digr \A, \?, 0xc3),
        (digr \A, \:, 0xc4),
        (digr \A, \A, 0xc5),
        (digr \A, \E, 0xc6),
        (digr \C, \,, 0xc7),
        (digr \E, \!, 0xc8),
        (digr \E, \', 0xc9),
        (digr \E, \>, 0xca),
        (digr \E, \:, 0xcb),
        (digr \I, \!, 0xcc),
        (digr \I, \', 0xcd),
        (digr \I, \>, 0xce),
        (digr \I, \:, 0xcf),
        (digr \D, \-, 0xd0),
        (digr \N, \?, 0xd1),
        (digr \O, \!, 0xd2),
        (digr \O, \', 0xd3),
        (digr \O, \>, 0xd4),
        (digr \O, \?, 0xd5),
        (digr \O, \:, 0xd6),
        (digr \*, \X, 0xd7),
        (digr \O, \/, 0xd8),
        (digr \U, \!, 0xd9),
        (digr \U, \', 0xda),
        (digr \U, \>, 0xdb),
        (digr \U, \:, 0xdc),
        (digr \Y, \', 0xdd),
        (digr \T, \H, 0xde),
        (digr \s, \s, 0xdf),
        (digr \a, \!, 0xe0),
        (digr \a, \', 0xe1),
        (digr \a, \>, 0xe2),
        (digr \a, \?, 0xe3),
        (digr \a, \:, 0xe4),
        (digr \a, \a, 0xe5),
        (digr \a, \e, 0xe6),
        (digr \c, \,, 0xe7),
        (digr \e, \!, 0xe8),
        (digr \e, \', 0xe9),
        (digr \e, \>, 0xea),
        (digr \e, \:, 0xeb),
        (digr \i, \!, 0xec),
        (digr \i, \', 0xed),
        (digr \i, \>, 0xee),
        (digr \i, \:, 0xef),
        (digr \d, \-, 0xf0),
        (digr \n, \?, 0xf1),
        (digr \o, \!, 0xf2),
        (digr \o, \', 0xf3),
        (digr \o, \>, 0xf4),
        (digr \o, \?, 0xf5),
        (digr \o, \:, 0xf6),
        (digr \-, \:, 0xf7),
        (digr \o, \/, 0xf8),
        (digr \u, \!, 0xf9),
        (digr \u, \', 0xfa),
        (digr \u, \>, 0xfb),
        (digr \u, \:, 0xfc),
        (digr \y, \', 0xfd),
        (digr \t, \h, 0xfe),
        (digr \y, \:, 0xff),

        (digr \A, \-, 0x0100),
        (digr \a, \-, 0x0101),
        (digr \A, \(, 0x0102),
        (digr \a, \(, 0x0103),
        (digr \A, \;, 0x0104),
        (digr \a, \;, 0x0105),
        (digr \C, \', 0x0106),
        (digr \c, \', 0x0107),
        (digr \C, \>, 0x0108),
        (digr \c, \>, 0x0109),
        (digr \C, \., 0x010a),
        (digr \c, \., 0x010b),
        (digr \C, \<, 0x010c),
        (digr \c, \<, 0x010d),
        (digr \D, \<, 0x010e),
        (digr \d, \<, 0x010f),
        (digr \D, \/, 0x0110),
        (digr \d, \/, 0x0111),
        (digr \E, \-, 0x0112),
        (digr \e, \-, 0x0113),
        (digr \E, \(, 0x0114),
        (digr \e, \(, 0x0115),
        (digr \E, \., 0x0116),
        (digr \e, \., 0x0117),
        (digr \E, \;, 0x0118),
        (digr \e, \;, 0x0119),
        (digr \E, \<, 0x011a),
        (digr \e, \<, 0x011b),
        (digr \G, \>, 0x011c),
        (digr \g, \>, 0x011d),
        (digr \G, \(, 0x011e),
        (digr \g, \(, 0x011f),
        (digr \G, \., 0x0120),
        (digr \g, \., 0x0121),
        (digr \G, \,, 0x0122),
        (digr \g, \,, 0x0123),
        (digr \H, \>, 0x0124),
        (digr \h, \>, 0x0125),
        (digr \H, \/, 0x0126),
        (digr \h, \/, 0x0127),
        (digr \I, \?, 0x0128),
        (digr \i, \?, 0x0129),
        (digr \I, \-, 0x012a),
        (digr \i, \-, 0x012b),
        (digr \I, \(, 0x012c),
        (digr \i, \(, 0x012d),
        (digr \I, \;, 0x012e),
        (digr \i, \;, 0x012f),
        (digr \I, \., 0x0130),
        (digr \i, \., 0x0131),
        (digr \I, \J, 0x0132),
        (digr \i, \j, 0x0133),
        (digr \J, \>, 0x0134),
        (digr \j, \>, 0x0135),
        (digr \K, \,, 0x0136),
        (digr \k, \,, 0x0137),
        (digr \k, \k, 0x0138),
        (digr \L, \', 0x0139),
        (digr \l, \', 0x013a),
        (digr \L, \,, 0x013b),
        (digr \l, \,, 0x013c),
        (digr \L, \<, 0x013d),
        (digr \l, \<, 0x013e),
        (digr \L, \., 0x013f),
        (digr \l, \., 0x0140),
        (digr \L, \/, 0x0141),
        (digr \l, \/, 0x0142),
        (digr \N, \', 0x0143),
        (digr \n, \', 0x0144),
        (digr \N, \,, 0x0145),
        (digr \n, \,, 0x0146),
        (digr \N, \<, 0x0147),
        (digr \n, \<, 0x0148),
        (digr \', \n, 0x0149),
        (digr \N, \G, 0x014a),
        (digr \n, \g, 0x014b),
        (digr \O, \-, 0x014c),
        (digr \o, \-, 0x014d),
        (digr \O, \(, 0x014e),
        (digr \o, \(, 0x014f),
        (digr \O, \", 0x0150),
        (digr \o, \", 0x0151),
        (digr \O, \E, 0x0152),
        (digr \o, \e, 0x0153),
        (digr \R, \', 0x0154),
        (digr \r, \', 0x0155),
        (digr \R, \,, 0x0156),
        (digr \r, \,, 0x0157),
        (digr \R, \<, 0x0158),
        (digr \r, \<, 0x0159),
        (digr \S, \', 0x015a),
        (digr \s, \', 0x015b),
        (digr \S, \>, 0x015c),
        (digr \s, \>, 0x015d),
        (digr \S, \,, 0x015e),
        (digr \s, \,, 0x015f),
        (digr \S, \<, 0x0160),
        (digr \s, \<, 0x0161),
        (digr \T, \,, 0x0162),
        (digr \t, \,, 0x0163),
        (digr \T, \<, 0x0164),
        (digr \t, \<, 0x0165),
        (digr \T, \/, 0x0166),
        (digr \t, \/, 0x0167),
        (digr \U, \?, 0x0168),
        (digr \u, \?, 0x0169),
        (digr \U, \-, 0x016a),
        (digr \u, \-, 0x016b),
        (digr \U, \(, 0x016c),
        (digr \u, \(, 0x016d),
        (digr \U, \0, 0x016e),
        (digr \u, \0, 0x016f),
        (digr \U, \", 0x0170),
        (digr \u, \", 0x0171),
        (digr \U, \;, 0x0172),
        (digr \u, \;, 0x0173),
        (digr \W, \>, 0x0174),
        (digr \w, \>, 0x0175),
        (digr \Y, \>, 0x0176),
        (digr \y, \>, 0x0177),
        (digr \Y, \:, 0x0178),
        (digr \Z, \', 0x0179),
        (digr \z, \', 0x017a),
        (digr \Z, \., 0x017b),
        (digr \z, \., 0x017c),
        (digr \Z, \<, 0x017d),
        (digr \z, \<, 0x017e),
        (digr \O, \9, 0x01a0),
        (digr \o, \9, 0x01a1),
        (digr \O, \I, 0x01a2),
        (digr \o, \i, 0x01a3),
        (digr \y, \r, 0x01a6),
        (digr \U, \9, 0x01af),
        (digr \u, \9, 0x01b0),
        (digr \Z, \/, 0x01b5),
        (digr \z, \/, 0x01b6),
        (digr \E, \D, 0x01b7),
        (digr \A, \<, 0x01cd),
        (digr \a, \<, 0x01ce),
        (digr \I, \<, 0x01cf),
        (digr \i, \<, 0x01d0),
        (digr \O, \<, 0x01d1),
        (digr \o, \<, 0x01d2),
        (digr \U, \<, 0x01d3),
        (digr \u, \<, 0x01d4),
        (digr \A, \1, 0x01de),
        (digr \a, \1, 0x01df),
        (digr \A, \7, 0x01e0),
        (digr \a, \7, 0x01e1),
        (digr \A, \3, 0x01e2),
        (digr \a, \3, 0x01e3),
        (digr \G, \/, 0x01e4),
        (digr \g, \/, 0x01e5),
        (digr \G, \<, 0x01e6),
        (digr \g, \<, 0x01e7),
        (digr \K, \<, 0x01e8),
        (digr \k, \<, 0x01e9),
        (digr \O, \;, 0x01ea),
        (digr \o, \;, 0x01eb),
        (digr \O, \1, 0x01ec),
        (digr \o, \1, 0x01ed),
        (digr \E, \Z, 0x01ee),
        (digr \e, \z, 0x01ef),
        (digr \j, \<, 0x01f0),
        (digr \G, \', 0x01f4),
        (digr \g, \', 0x01f5),
        (digr \;, \S, 0x02bf),
        (digr \', \<, 0x02c7),
        (digr \', \(, 0x02d8),
        (digr \', \., 0x02d9),
        (digr \', \0, 0x02da),
        (digr \', \;, 0x02db),
        (digr \', \", 0x02dd),
        (digr \A, \%, 0x0386),
        (digr \E, \%, 0x0388),
        (digr \Y, \%, 0x0389),
        (digr \I, \%, 0x038a),
        (digr \O, \%, 0x038c),
        (digr \U, \%, 0x038e),
        (digr \W, \%, 0x038f),
        (digr \i, \3, 0x0390),
        (digr \A, \*, 0x0391),
        (digr \B, \*, 0x0392),
        (digr \G, \*, 0x0393),
        (digr \D, \*, 0x0394),
        (digr \E, \*, 0x0395),
        (digr \Z, \*, 0x0396),
        (digr \Y, \*, 0x0397),
        (digr \H, \*, 0x0398),
        (digr \I, \*, 0x0399),
        (digr \K, \*, 0x039a),
        (digr \L, \*, 0x039b),
        (digr \M, \*, 0x039c),
        (digr \N, \*, 0x039d),
        (digr \C, \*, 0x039e),
        (digr \O, \*, 0x039f),
        (digr \P, \*, 0x03a0),
        (digr \R, \*, 0x03a1),
        (digr \S, \*, 0x03a3),
        (digr \T, \*, 0x03a4),
        (digr \U, \*, 0x03a5),
        (digr \F, \*, 0x03a6),
        (digr \X, \*, 0x03a7),
        (digr \Q, \*, 0x03a8),
        (digr \W, \*, 0x03a9),
        (digr \J, \*, 0x03aa),
        (digr \V, \*, 0x03ab),
        (digr \a, \%, 0x03ac),
        (digr \e, \%, 0x03ad),
        (digr \y, \%, 0x03ae),
        (digr \i, \%, 0x03af),
        (digr \u, \3, 0x03b0),
        (digr \a, \*, 0x03b1),
        (digr \b, \*, 0x03b2),
        (digr \g, \*, 0x03b3),
        (digr \d, \*, 0x03b4),
        (digr \e, \*, 0x03b5),
        (digr \z, \*, 0x03b6),
        (digr \y, \*, 0x03b7),
        (digr \h, \*, 0x03b8),
        (digr \i, \*, 0x03b9),
        (digr \k, \*, 0x03ba),
        (digr \l, \*, 0x03bb),
        (digr \m, \*, 0x03bc),
        (digr \n, \*, 0x03bd),
        (digr \c, \*, 0x03be),
        (digr \o, \*, 0x03bf),
        (digr \p, \*, 0x03c0),
        (digr \r, \*, 0x03c1),
        (digr \*, \s, 0x03c2),
        (digr \s, \*, 0x03c3),
        (digr \t, \*, 0x03c4),
        (digr \u, \*, 0x03c5),
        (digr \f, \*, 0x03c6),
        (digr \x, \*, 0x03c7),
        (digr \q, \*, 0x03c8),
        (digr \w, \*, 0x03c9),
        (digr \j, \*, 0x03ca),
        (digr \v, \*, 0x03cb),
        (digr \o, \%, 0x03cc),
        (digr \u, \%, 0x03cd),
        (digr \w, \%, 0x03ce),
        (digr \', \G, 0x03d8),
        (digr \,, \G, 0x03d9),
        (digr \T, \3, 0x03da),
        (digr \t, \3, 0x03db),
        (digr \M, \3, 0x03dc),
        (digr \m, \3, 0x03dd),
        (digr \K, \3, 0x03de),
        (digr \k, \3, 0x03df),
        (digr \P, \3, 0x03e0),
        (digr \p, \3, 0x03e1),
        (digr \', \%, 0x03f4),
        (digr \j, \3, 0x03f5),
        (digr \I, \O, 0x0401),
        (digr \D, \%, 0x0402),
        (digr \G, \%, 0x0403),
        (digr \I, \E, 0x0404),
        (digr \D, \S, 0x0405),
        (digr \I, \I, 0x0406),
        (digr \Y, \I, 0x0407),
        (digr \J, \%, 0x0408),
        (digr \L, \J, 0x0409),
        (digr \N, \J, 0x040a),
        (digr \T, \s, 0x040b),
        (digr \K, \J, 0x040c),
        (digr \V, \%, 0x040e),
        (digr \D, \Z, 0x040f),
        (digr \A, \=, 0x0410),
        (digr \B, \=, 0x0411),
        (digr \V, \=, 0x0412),
        (digr \G, \=, 0x0413),
        (digr \D, \=, 0x0414),
        (digr \E, \=, 0x0415),
        (digr \Z, \%, 0x0416),
        (digr \Z, \=, 0x0417),
        (digr \I, \=, 0x0418),
        (digr \J, \=, 0x0419),
        (digr \K, \=, 0x041a),
        (digr \L, \=, 0x041b),
        (digr \M, \=, 0x041c),
        (digr \N, \=, 0x041d),
        (digr \O, \=, 0x041e),
        (digr \P, \=, 0x041f),
        (digr \R, \=, 0x0420),
        (digr \S, \=, 0x0421),
        (digr \T, \=, 0x0422),
        (digr \U, \=, 0x0423),
        (digr \F, \=, 0x0424),
        (digr \H, \=, 0x0425),
        (digr \C, \=, 0x0426),
        (digr \C, \%, 0x0427),
        (digr \S, \%, 0x0428),
        (digr \S, \c, 0x0429),
        (digr \=, \", 0x042a),
        (digr \Y, \=, 0x042b),
        (digr \%, \", 0x042c),
        (digr \J, \E, 0x042d),
        (digr \J, \U, 0x042e),
        (digr \J, \A, 0x042f),
        (digr \a, \=, 0x0430),
        (digr \b, \=, 0x0431),
        (digr \v, \=, 0x0432),
        (digr \g, \=, 0x0433),
        (digr \d, \=, 0x0434),
        (digr \e, \=, 0x0435),
        (digr \z, \%, 0x0436),
        (digr \z, \=, 0x0437),
        (digr \i, \=, 0x0438),
        (digr \j, \=, 0x0439),
        (digr \k, \=, 0x043a),
        (digr \l, \=, 0x043b),
        (digr \m, \=, 0x043c),
        (digr \n, \=, 0x043d),
        (digr \o, \=, 0x043e),
        (digr \p, \=, 0x043f),
        (digr \r, \=, 0x0440),
        (digr \s, \=, 0x0441),
        (digr \t, \=, 0x0442),
        (digr \u, \=, 0x0443),
        (digr \f, \=, 0x0444),
        (digr \h, \=, 0x0445),
        (digr \c, \=, 0x0446),
        (digr \c, \%, 0x0447),
        (digr \s, \%, 0x0448),
        (digr \s, \c, 0x0449),
        (digr \=, \', 0x044a),
        (digr \y, \=, 0x044b),
        (digr \%, \', 0x044c),
        (digr \j, \e, 0x044d),
        (digr \j, \u, 0x044e),
        (digr \j, \a, 0x044f),
        (digr \i, \o, 0x0451),
        (digr \d, \%, 0x0452),
        (digr \g, \%, 0x0453),
        (digr \i, \e, 0x0454),
        (digr \d, \s, 0x0455),
        (digr \i, \i, 0x0456),
        (digr \y, \i, 0x0457),
        (digr \j, \%, 0x0458),
        (digr \l, \j, 0x0459),
        (digr \n, \j, 0x045a),
        (digr \t, \s, 0x045b),
        (digr \k, \j, 0x045c),
        (digr \v, \%, 0x045e),
        (digr \d, \z, 0x045f),
        (digr \Y, \3, 0x0462),
        (digr \y, \3, 0x0463),
        (digr \O, \3, 0x046a),
        (digr \o, \3, 0x046b),
        (digr \F, \3, 0x0472),
        (digr \f, \3, 0x0473),
        (digr \V, \3, 0x0474),
        (digr \v, \3, 0x0475),
        (digr \C, \3, 0x0480),
        (digr \c, \3, 0x0481),
        (digr \G, \3, 0x0490),
        (digr \g, \3, 0x0491),
        (digr \A, \+, 0x05d0),
        (digr \B, \+, 0x05d1),
        (digr \G, \+, 0x05d2),
        (digr \D, \+, 0x05d3),
        (digr \H, \+, 0x05d4),
        (digr \W, \+, 0x05d5),
        (digr \Z, \+, 0x05d6),
        (digr \X, \+, 0x05d7),
        (digr \T, \j, 0x05d8),
        (digr \J, \+, 0x05d9),
        (digr \K, \%, 0x05da),
        (digr \K, \+, 0x05db),
        (digr \L, \+, 0x05dc),
        (digr \M, \%, 0x05dd),
        (digr \M, \+, 0x05de),
        (digr \N, \%, 0x05df),
        (digr \N, \+, 0x05e0),
        (digr \S, \+, 0x05e1),
        (digr \E, \+, 0x05e2),
        (digr \P, \%, 0x05e3),
        (digr \P, \+, 0x05e4),
        (digr \Z, \j, 0x05e5),
        (digr \Z, \J, 0x05e6),
        (digr \Q, \+, 0x05e7),
        (digr \R, \+, 0x05e8),
        (digr \S, \h, 0x05e9),
        (digr \T, \+, 0x05ea),
        (digr \,, \+, 0x060c),
        (digr \;, \+, 0x061b),
        (digr \?, \+, 0x061f),
        (digr \H, \', 0x0621),
        (digr \a, \M, 0x0622),
        (digr \a, \H, 0x0623),
        (digr \w, \H, 0x0624),
        (digr \a, \h, 0x0625),
        (digr \y, \H, 0x0626),
        (digr \a, \+, 0x0627),
        (digr \b, \+, 0x0628),
        (digr \t, \m, 0x0629),
        (digr \t, \+, 0x062a),
        (digr \t, \k, 0x062b),
        (digr \g, \+, 0x062c),
        (digr \h, \k, 0x062d),
        (digr \x, \+, 0x062e),
        (digr \d, \+, 0x062f),
        (digr \d, \k, 0x0630),
        (digr \r, \+, 0x0631),
        (digr \z, \+, 0x0632),
        (digr \s, \+, 0x0633),
        (digr \s, \n, 0x0634),
        (digr \c, \+, 0x0635),
        (digr \d, \d, 0x0636),
        (digr \t, \j, 0x0637),
        (digr \z, \H, 0x0638),
        (digr \e, \+, 0x0639),
        (digr \i, \+, 0x063a),
        (digr \+, \+, 0x0640),
        (digr \f, \+, 0x0641),
        (digr \q, \+, 0x0642),
        (digr \k, \+, 0x0643),
        (digr \l, \+, 0x0644),
        (digr \m, \+, 0x0645),
        (digr \n, \+, 0x0646),
        (digr \h, \+, 0x0647),
        (digr \w, \+, 0x0648),
        (digr \j, \+, 0x0649),
        (digr \y, \+, 0x064a),
        (digr \:, \+, 0x064b),
        (digr \", \+, 0x064c),
        (digr \=, \+, 0x064d),
        (digr \/, \+, 0x064e),
        (digr \', \+, 0x064f),
        (digr \1, \+, 0x0650),
        (digr \3, \+, 0x0651),
        (digr \0, \+, 0x0652),
        (digr \a, \S, 0x0670),
        (digr \p, \+, 0x067e),
        (digr \v, \+, 0x06a4),
        (digr \g, \f, 0x06af),
        (digr \0, \a, 0x06f0),
        (digr \1, \a, 0x06f1),
        (digr \2, \a, 0x06f2),
        (digr \3, \a, 0x06f3),
        (digr \4, \a, 0x06f4),
        (digr \5, \a, 0x06f5),
        (digr \6, \a, 0x06f6),
        (digr \7, \a, 0x06f7),
        (digr \8, \a, 0x06f8),
        (digr \9, \a, 0x06f9),
        (digr \B, \., 0x1e02),
        (digr \b, \., 0x1e03),
        (digr \B, \_, 0x1e06),
        (digr \b, \_, 0x1e07),
        (digr \D, \., 0x1e0a),
        (digr \d, \., 0x1e0b),
        (digr \D, \_, 0x1e0e),
        (digr \d, \_, 0x1e0f),
        (digr \D, \,, 0x1e10),
        (digr \d, \,, 0x1e11),
        (digr \F, \., 0x1e1e),
        (digr \f, \., 0x1e1f),
        (digr \G, \-, 0x1e20),
        (digr \g, \-, 0x1e21),
        (digr \H, \., 0x1e22),
        (digr \h, \., 0x1e23),
        (digr \H, \:, 0x1e26),
        (digr \h, \:, 0x1e27),
        (digr \H, \,, 0x1e28),
        (digr \h, \,, 0x1e29),
        (digr \K, \', 0x1e30),
        (digr \k, \', 0x1e31),
        (digr \K, \_, 0x1e34),
        (digr \k, \_, 0x1e35),
        (digr \L, \_, 0x1e3a),
        (digr \l, \_, 0x1e3b),
        (digr \M, \', 0x1e3e),
        (digr \m, \', 0x1e3f),
        (digr \M, \., 0x1e40),
        (digr \m, \., 0x1e41),
        (digr \N, \., 0x1e44),
        (digr \n, \., 0x1e45),
        (digr \N, \_, 0x1e48),
        (digr \n, \_, 0x1e49),
        (digr \P, \', 0x1e54),
        (digr \p, \', 0x1e55),
        (digr \P, \., 0x1e56),
        (digr \p, \., 0x1e57),
        (digr \R, \., 0x1e58),
        (digr \r, \., 0x1e59),
        (digr \R, \_, 0x1e5e),
        (digr \r, \_, 0x1e5f),
        (digr \S, \., 0x1e60),
        (digr \s, \., 0x1e61),
        (digr \T, \., 0x1e6a),
        (digr \t, \., 0x1e6b),
        (digr \T, \_, 0x1e6e),
        (digr \t, \_, 0x1e6f),
        (digr \V, \?, 0x1e7c),
        (digr \v, \?, 0x1e7d),
        (digr \W, \!, 0x1e80),
        (digr \w, \!, 0x1e81),
        (digr \W, \', 0x1e82),
        (digr \w, \', 0x1e83),
        (digr \W, \:, 0x1e84),
        (digr \w, \:, 0x1e85),
        (digr \W, \., 0x1e86),
        (digr \w, \., 0x1e87),
        (digr \X, \., 0x1e8a),
        (digr \x, \., 0x1e8b),
        (digr \X, \:, 0x1e8c),
        (digr \x, \:, 0x1e8d),
        (digr \Y, \., 0x1e8e),
        (digr \y, \., 0x1e8f),
        (digr \Z, \>, 0x1e90),
        (digr \z, \>, 0x1e91),
        (digr \Z, \_, 0x1e94),
        (digr \z, \_, 0x1e95),
        (digr \h, \_, 0x1e96),
        (digr \t, \:, 0x1e97),
        (digr \w, \0, 0x1e98),
        (digr \y, \0, 0x1e99),
        (digr \A, \2, 0x1ea2),
        (digr \a, \2, 0x1ea3),
        (digr \E, \2, 0x1eba),
        (digr \e, \2, 0x1ebb),
        (digr \E, \?, 0x1ebc),
        (digr \e, \?, 0x1ebd),
        (digr \I, \2, 0x1ec8),
        (digr \i, \2, 0x1ec9),
        (digr \O, \2, 0x1ece),
        (digr \o, \2, 0x1ecf),
        (digr \U, \2, 0x1ee6),
        (digr \u, \2, 0x1ee7),
        (digr \Y, \!, 0x1ef2),
        (digr \y, \!, 0x1ef3),
        (digr \Y, \2, 0x1ef6),
        (digr \y, \2, 0x1ef7),
        (digr \Y, \?, 0x1ef8),
        (digr \y, \?, 0x1ef9),
        (digr \;, \', 0x1f00),
        (digr \,, \', 0x1f01),
        (digr \;, \!, 0x1f02),
        (digr \,, \!, 0x1f03),
        (digr \?, \;, 0x1f04),
        (digr \?, \,, 0x1f05),
        (digr \!, \:, 0x1f06),
        (digr \?, \:, 0x1f07),
        (digr \1, \N, 0x2002),
        (digr \1, \M, 0x2003),
        (digr \3, \M, 0x2004),
        (digr \4, \M, 0x2005),
        (digr \6, \M, 0x2006),
        (digr \1, \T, 0x2009),
        (digr \1, \H, 0x200a),
        (digr \-, \1, 0x2010),
        (digr \-, \N, 0x2013),
        (digr \-, \M, 0x2014),
        (digr \-, \3, 0x2015),
        (digr \!, \2, 0x2016),
        (digr \=, \2, 0x2017),
        (digr \', \6, 0x2018),
        (digr \', \9, 0x2019),
        (digr \., \9, 0x201a),
        (digr \9, \', 0x201b),
        (digr \", \6, 0x201c),
        (digr \", \9, 0x201d),
        (digr \:, \9, 0x201e),
        (digr \9, \", 0x201f),
        (digr \/, \-, 0x2020),
        (digr \/, \=, 0x2021),
        (digr \., \., 0x2025),
        (digr \%, \0, 0x2030),
        (digr \1, \', 0x2032),
        (digr \2, \', 0x2033),
        (digr \3, \', 0x2034),
        (digr \1, \", 0x2035),
        (digr \2, \", 0x2036),
        (digr \3, \", 0x2037),
        (digr \C, \a, 0x2038),
        (digr \<, \1, 0x2039),
        (digr \>, \1, 0x203a),
        (digr \:, \X, 0x203b),
        (digr \', \-, 0x203e),
        (digr \/, \f, 0x2044),
        (digr \0, \S, 0x2070),
        (digr \4, \S, 0x2074),
        (digr \5, \S, 0x2075),
        (digr \6, \S, 0x2076),
        (digr \7, \S, 0x2077),
        (digr \8, \S, 0x2078),
        (digr \9, \S, 0x2079),
        (digr \+, \S, 0x207a),
        (digr \-, \S, 0x207b),
        (digr \=, \S, 0x207c),
        (digr \(, \S, 0x207d),
        (digr \), \S, 0x207e),
        (digr \n, \S, 0x207f),
        (digr \0, \s, 0x2080),
        (digr \1, \s, 0x2081),
        (digr \2, \s, 0x2082),
        (digr \3, \s, 0x2083),
        (digr \4, \s, 0x2084),
        (digr \5, \s, 0x2085),
        (digr \6, \s, 0x2086),
        (digr \7, \s, 0x2087),
        (digr \8, \s, 0x2088),
        (digr \9, \s, 0x2089),
        (digr \+, \s, 0x208a),
        (digr \-, \s, 0x208b),
        (digr \=, \s, 0x208c),
        (digr \(, \s, 0x208d),
        (digr \), \s, 0x208e),
        (digr \L, \i, 0x20a4),
        (digr \P, \t, 0x20a7),
        (digr \W, \=, 0x20a9),
        (digr \=, \e, 0x20ac), ;; euro
        (digr \E, \u, 0x20ac), ;; euro
        (digr \=, \R, 0x20bd), ;; rouble
        (digr \=, \P, 0x20bd), ;; rouble
        (digr \o, \C, 0x2103),
        (digr \c, \o, 0x2105),
        (digr \o, \F, 0x2109),
        (digr \N, \0, 0x2116),
        (digr \P, \O, 0x2117),
        (digr \R, \x, 0x211e),
        (digr \S, \M, 0x2120),
        (digr \T, \M, 0x2122),
        (digr \O, \m, 0x2126),
        (digr \A, \O, 0x212b),
        (digr \1, \3, 0x2153),
        (digr \2, \3, 0x2154),
        (digr \1, \5, 0x2155),
        (digr \2, \5, 0x2156),
        (digr \3, \5, 0x2157),
        (digr \4, \5, 0x2158),
        (digr \1, \6, 0x2159),
        (digr \5, \6, 0x215a),
        (digr \1, \8, 0x215b),
        (digr \3, \8, 0x215c),
        (digr \5, \8, 0x215d),
        (digr \7, \8, 0x215e),
        (digr \1, \R, 0x2160),
        (digr \2, \R, 0x2161),
        (digr \3, \R, 0x2162),
        (digr \4, \R, 0x2163),
        (digr \5, \R, 0x2164),
        (digr \6, \R, 0x2165),
        (digr \7, \R, 0x2166),
        (digr \8, \R, 0x2167),
        (digr \9, \R, 0x2168),
        (digr \a, \R, 0x2169),
        (digr \b, \R, 0x216a),
        (digr \c, \R, 0x216b),
        (digr \1, \r, 0x2170),
        (digr \2, \r, 0x2171),
        (digr \3, \r, 0x2172),
        (digr \4, \r, 0x2173),
        (digr \5, \r, 0x2174),
        (digr \6, \r, 0x2175),
        (digr \7, \r, 0x2176),
        (digr \8, \r, 0x2177),
        (digr \9, \r, 0x2178),
        (digr \a, \r, 0x2179),
        (digr \b, \r, 0x217a),
        (digr \c, \r, 0x217b),
        (digr \<, \-, 0x2190),
        (digr \-, \!, 0x2191),
        (digr \-, \>, 0x2192),
        (digr \-, \v, 0x2193),
        (digr \<, \>, 0x2194),
        (digr \U, \D, 0x2195),
        (digr \<, \=, 0x21d0),
        (digr \=, \>, 0x21d2),
        (digr \=, \=, 0x21d4),
        (digr \F, \A, 0x2200),
        (digr \d, \P, 0x2202),
        (digr \T, \E, 0x2203),
        (digr \/, \0, 0x2205),
        (digr \D, \E, 0x2206),
        (digr \N, \B, 0x2207),
        (digr \(, \-, 0x2208),
        (digr \-, \), 0x220b),
        (digr \*, \P, 0x220f),
        (digr \+, \Z, 0x2211),
        (digr \-, \2, 0x2212),
        (digr \-, \+, 0x2213),
        (digr \*, \-, 0x2217),
        (digr \O, \b, 0x2218),
        (digr \S, \b, 0x2219),
        (digr \R, \T, 0x221a),
        (digr \0, \(, 0x221d),
        (digr \0, \0, 0x221e),
        (digr \-, \L, 0x221f),
        (digr \-, \V, 0x2220),
        (digr \P, \P, 0x2225),
        (digr \A, \N, 0x2227),
        (digr \O, \R, 0x2228),
        (digr \(, \U, 0x2229),
        (digr \), \U, 0x222a),
        (digr \I, \n, 0x222b),
        (digr \D, \I, 0x222c),
        (digr \I, \o, 0x222e),
        (digr \., \:, 0x2234),
        (digr \:, \., 0x2235),
        (digr \:, \R, 0x2236),
        (digr \:, \:, 0x2237),
        (digr \?, \1, 0x223c),
        (digr \C, \G, 0x223e),
        (digr \?, \-, 0x2243),
        (digr \?, \=, 0x2245),
        (digr \?, \2, 0x2248),
        (digr \=, \?, 0x224c),
        (digr \H, \I, 0x2253),
        (digr \!, \=, 0x2260),
        (digr \=, \3, 0x2261),
        (digr \=, \<, 0x2264),
        (digr \>, \=, 0x2265),
        (digr \<, \*, 0x226a),
        (digr \*, \>, 0x226b),
        (digr \!, \<, 0x226e),
        (digr \!, \>, 0x226f),
        (digr \(, \C, 0x2282),
        (digr \), \C, 0x2283),
        (digr \(, \_, 0x2286),
        (digr \), \_, 0x2287),
        (digr \0, \., 0x2299),
        (digr \0, \2, 0x229a),
        (digr \-, \T, 0x22a5),
        (digr \., \P, 0x22c5),
        (digr \:, \3, 0x22ee),
        (digr \., \3, 0x22ef),
        (digr \E, \h, 0x2302),
        (digr \<, \7, 0x2308),
        (digr \>, \7, 0x2309),
        (digr \7, \<, 0x230a),
        (digr \7, \>, 0x230b),
        (digr \N, \I, 0x2310),
        (digr \(, \A, 0x2312),
        (digr \T, \R, 0x2315),
        (digr \I, \u, 0x2320),
        (digr \I, \l, 0x2321),
        (digr \<, \/, 0x2329),
        (digr \/, \>, 0x232a),
        (digr \V, \s, 0x2423),
        (digr \1, \h, 0x2440),
        (digr \3, \h, 0x2441),
        (digr \2, \h, 0x2442),
        (digr \4, \h, 0x2443),
        (digr \1, \j, 0x2446),
        (digr \2, \j, 0x2447),
        (digr \3, \j, 0x2448),
        (digr \4, \j, 0x2449),
        (digr \1, \., 0x2488),
        (digr \2, \., 0x2489),
        (digr \3, \., 0x248a),
        (digr \4, \., 0x248b),
        (digr \5, \., 0x248c),
        (digr \6, \., 0x248d),
        (digr \7, \., 0x248e),
        (digr \8, \., 0x248f),
        (digr \9, \., 0x2490),
        (digr \h, \h, 0x2500),
        (digr \H, \H, 0x2501),
        (digr \v, \v, 0x2502),
        (digr \V, \V, 0x2503),
        (digr \3, \-, 0x2504),
        (digr \3, \_, 0x2505),
        (digr \3, \!, 0x2506),
        (digr \3, \/, 0x2507),
        (digr \4, \-, 0x2508),
        (digr \4, \_, 0x2509),
        (digr \4, \!, 0x250a),
        (digr \4, \/, 0x250b),
        (digr \d, \r, 0x250c),
        (digr \d, \R, 0x250d),
        (digr \D, \r, 0x250e),
        (digr \D, \R, 0x250f),
        (digr \d, \l, 0x2510),
        (digr \d, \L, 0x2511),
        (digr \D, \l, 0x2512),
        (digr \L, \D, 0x2513),
        (digr \u, \r, 0x2514),
        (digr \u, \R, 0x2515),
        (digr \U, \r, 0x2516),
        (digr \U, \R, 0x2517),
        (digr \u, \l, 0x2518),
        (digr \u, \L, 0x2519),
        (digr \U, \l, 0x251a),
        (digr \U, \L, 0x251b),
        (digr \v, \r, 0x251c),
        (digr \v, \R, 0x251d),
        (digr \V, \r, 0x2520),
        (digr \V, \R, 0x2523),
        (digr \v, \l, 0x2524),
        (digr \v, \L, 0x2525),
        (digr \V, \l, 0x2528),
        (digr \V, \L, 0x252b),
        (digr \d, \h, 0x252c),
        (digr \d, \H, 0x252f),
        (digr \D, \h, 0x2530),
        (digr \D, \H, 0x2533),
        (digr \u, \h, 0x2534),
        (digr \u, \H, 0x2537),
        (digr \U, \h, 0x2538),
        (digr \U, \H, 0x253b),
        (digr \v, \h, 0x253c),
        (digr \v, \H, 0x253f),
        (digr \V, \h, 0x2542),
        (digr \V, \H, 0x254b),
        (digr \F, \D, 0x2571),
        (digr \B, \D, 0x2572),
        (digr \T, \B, 0x2580),
        (digr \L, \B, 0x2584),
        (digr \F, \B, 0x2588),
        (digr \l, \B, 0x258c),
        (digr \R, \B, 0x2590),
        (digr \., \S, 0x2591),
        (digr \:, \S, 0x2592),
        (digr \?, \S, 0x2593),
        (digr \f, \S, 0x25a0),
        (digr \O, \S, 0x25a1),
        (digr \R, \O, 0x25a2),
        (digr \R, \r, 0x25a3),
        (digr \R, \F, 0x25a4),
        (digr \R, \Y, 0x25a5),
        (digr \R, \H, 0x25a6),
        (digr \R, \Z, 0x25a7),
        (digr \R, \K, 0x25a8),
        (digr \R, \X, 0x25a9),
        (digr \s, \B, 0x25aa),
        (digr \S, \R, 0x25ac),
        (digr \O, \r, 0x25ad),
        (digr \U, \T, 0x25b2),
        (digr \u, \T, 0x25b3),
        (digr \P, \R, 0x25b6),
        (digr \T, \r, 0x25b7),
        (digr \D, \t, 0x25bc),
        (digr \d, \T, 0x25bd),
        (digr \P, \L, 0x25c0),
        (digr \T, \l, 0x25c1),
        (digr \D, \b, 0x25c6),
        (digr \D, \w, 0x25c7),
        (digr \L, \Z, 0x25ca),
        (digr \0, \m, 0x25cb),
        (digr \0, \o, 0x25ce),
        (digr \0, \M, 0x25cf),
        (digr \0, \L, 0x25d0),
        (digr \0, \R, 0x25d1),
        (digr \S, \n, 0x25d8),
        (digr \I, \c, 0x25d9),
        (digr \F, \d, 0x25e2),
        (digr \B, \d, 0x25e3),
        (digr \*, \2, 0x2605),
        (digr \*, \1, 0x2606),
        (digr \<, \H, 0x261c),
        (digr \>, \H, 0x261e),
        (digr \0, \u, 0x263a),
        (digr \0, \U, 0x263b),
        (digr \S, \U, 0x263c),
        (digr \F, \m, 0x2640),
        (digr \M, \l, 0x2642),
        (digr \c, \S, 0x2660),
        (digr \c, \H, 0x2661),
        (digr \c, \D, 0x2662),
        (digr \c, \C, 0x2663),
        (digr \M, \d, 0x2669),
        (digr \M, \8, 0x266a),
        (digr \M, \2, 0x266b),
        (digr \M, \b, 0x266d),
        (digr \M, \x, 0x266e),
        (digr \M, \X, 0x266f),
        (digr \O, \K, 0x2713),
        (digr \X, \X, 0x2717),
        (digr \-, \X, 0x2720),
        (digr \I, \S, 0x3000),
        (digr \,, \_, 0x3001),
        (digr \., \_, 0x3002),
        (digr \+, \", 0x3003),
        (digr \+, \_, 0x3004),
        (digr \*, \_, 0x3005),
        (digr \;, \_, 0x3006),
        (digr \0, \_, 0x3007),
        (digr \<, \+, 0x300a),
        (digr \>, \+, 0x300b),
        (digr \<, \', 0x300c),
        (digr \>, \', 0x300d),
        (digr \<, \", 0x300e),
        (digr \>, \", 0x300f),
        (digr \(, \", 0x3010),
        (digr \), \", 0x3011),
        (digr \=, \T, 0x3012),
        (digr \=, \_, 0x3013),
        (digr \(, \', 0x3014),
        (digr \), \', 0x3015),
        (digr \(, \I, 0x3016),
        (digr \), \I, 0x3017),
        (digr \-, \?, 0x301c),
        (digr \A, \5, 0x3041),
        (digr \a, \5, 0x3042),
        (digr \I, \5, 0x3043),
        (digr \i, \5, 0x3044),
        (digr \U, \5, 0x3045),
        (digr \u, \5, 0x3046),
        (digr \E, \5, 0x3047),
        (digr \e, \5, 0x3048),
        (digr \O, \5, 0x3049),
        (digr \o, \5, 0x304a),
        (digr \k, \a, 0x304b),
        (digr \g, \a, 0x304c),
        (digr \k, \i, 0x304d),
        (digr \g, \i, 0x304e),
        (digr \k, \u, 0x304f),
        (digr \g, \u, 0x3050),
        (digr \k, \e, 0x3051),
        (digr \g, \e, 0x3052),
        (digr \k, \o, 0x3053),
        (digr \g, \o, 0x3054),
        (digr \s, \a, 0x3055),
        (digr \z, \a, 0x3056),
        (digr \s, \i, 0x3057),
        (digr \z, \i, 0x3058),
        (digr \s, \u, 0x3059),
        (digr \z, \u, 0x305a),
        (digr \s, \e, 0x305b),
        (digr \z, \e, 0x305c),
        (digr \s, \o, 0x305d),
        (digr \z, \o, 0x305e),
        (digr \t, \a, 0x305f),
        (digr \d, \a, 0x3060),
        (digr \t, \i, 0x3061),
        (digr \d, \i, 0x3062),
        (digr \t, \U, 0x3063),
        (digr \t, \u, 0x3064),
        (digr \d, \u, 0x3065),
        (digr \t, \e, 0x3066),
        (digr \d, \e, 0x3067),
        (digr \t, \o, 0x3068),
        (digr \d, \o, 0x3069),
        (digr \n, \a, 0x306a),
        (digr \n, \i, 0x306b),
        (digr \n, \u, 0x306c),
        (digr \n, \e, 0x306d),
        (digr \n, \o, 0x306e),
        (digr \h, \a, 0x306f),
        (digr \b, \a, 0x3070),
        (digr \p, \a, 0x3071),
        (digr \h, \i, 0x3072),
        (digr \b, \i, 0x3073),
        (digr \p, \i, 0x3074),
        (digr \h, \u, 0x3075),
        (digr \b, \u, 0x3076),
        (digr \p, \u, 0x3077),
        (digr \h, \e, 0x3078),
        (digr \b, \e, 0x3079),
        (digr \p, \e, 0x307a),
        (digr \h, \o, 0x307b),
        (digr \b, \o, 0x307c),
        (digr \p, \o, 0x307d),
        (digr \m, \a, 0x307e),
        (digr \m, \i, 0x307f),
        (digr \m, \u, 0x3080),
        (digr \m, \e, 0x3081),
        (digr \m, \o, 0x3082),
        (digr \y, \A, 0x3083),
        (digr \y, \a, 0x3084),
        (digr \y, \U, 0x3085),
        (digr \y, \u, 0x3086),
        (digr \y, \O, 0x3087),
        (digr \y, \o, 0x3088),
        (digr \r, \a, 0x3089),
        (digr \r, \i, 0x308a),
        (digr \r, \u, 0x308b),
        (digr \r, \e, 0x308c),
        (digr \r, \o, 0x308d),
        (digr \w, \A, 0x308e),
        (digr \w, \a, 0x308f),
        (digr \w, \i, 0x3090),
        (digr \w, \e, 0x3091),
        (digr \w, \o, 0x3092),
        (digr \n, \5, 0x3093),
        (digr \v, \u, 0x3094),
        (digr \", \5, 0x309b),
        (digr \0, \5, 0x309c),
        (digr \*, \5, 0x309d),
        (digr \+, \5, 0x309e),
        (digr \a, \6, 0x30a1),
        (digr \A, \6, 0x30a2),
        (digr \i, \6, 0x30a3),
        (digr \I, \6, 0x30a4),
        (digr \u, \6, 0x30a5),
        (digr \U, \6, 0x30a6),
        (digr \e, \6, 0x30a7),
        (digr \E, \6, 0x30a8),
        (digr \o, \6, 0x30a9),
        (digr \O, \6, 0x30aa),
        (digr \K, \a, 0x30ab),
        (digr \G, \a, 0x30ac),
        (digr \K, \i, 0x30ad),
        (digr \G, \i, 0x30ae),
        (digr \K, \u, 0x30af),
        (digr \G, \u, 0x30b0),
        (digr \K, \e, 0x30b1),
        (digr \G, \e, 0x30b2),
        (digr \K, \o, 0x30b3),
        (digr \G, \o, 0x30b4),
        (digr \S, \a, 0x30b5),
        (digr \Z, \a, 0x30b6),
        (digr \S, \i, 0x30b7),
        (digr \Z, \i, 0x30b8),
        (digr \S, \u, 0x30b9),
        (digr \Z, \u, 0x30ba),
        (digr \S, \e, 0x30bb),
        (digr \Z, \e, 0x30bc),
        (digr \S, \o, 0x30bd),
        (digr \Z, \o, 0x30be),
        (digr \T, \a, 0x30bf),
        (digr \D, \a, 0x30c0),
        (digr \T, \i, 0x30c1),
        (digr \D, \i, 0x30c2),
        (digr \T, \U, 0x30c3),
        (digr \T, \u, 0x30c4),
        (digr \D, \u, 0x30c5),
        (digr \T, \e, 0x30c6),
        (digr \D, \e, 0x30c7),
        (digr \T, \o, 0x30c8),
        (digr \D, \o, 0x30c9),
        (digr \N, \a, 0x30ca),
        (digr \N, \i, 0x30cb),
        (digr \N, \u, 0x30cc),
        (digr \N, \e, 0x30cd),
        (digr \N, \o, 0x30ce),
        (digr \H, \a, 0x30cf),
        (digr \B, \a, 0x30d0),
        (digr \P, \a, 0x30d1),
        (digr \H, \i, 0x30d2),
        (digr \B, \i, 0x30d3),
        (digr \P, \i, 0x30d4),
        (digr \H, \u, 0x30d5),
        (digr \B, \u, 0x30d6),
        (digr \P, \u, 0x30d7),
        (digr \H, \e, 0x30d8),
        (digr \B, \e, 0x30d9),
        (digr \P, \e, 0x30da),
        (digr \H, \o, 0x30db),
        (digr \B, \o, 0x30dc),
        (digr \P, \o, 0x30dd),
        (digr \M, \a, 0x30de),
        (digr \M, \i, 0x30df),
        (digr \M, \u, 0x30e0),
        (digr \M, \e, 0x30e1),
        (digr \M, \o, 0x30e2),
        (digr \Y, \A, 0x30e3),
        (digr \Y, \a, 0x30e4),
        (digr \Y, \U, 0x30e5),
        (digr \Y, \u, 0x30e6),
        (digr \Y, \O, 0x30e7),
        (digr \Y, \o, 0x30e8),
        (digr \R, \a, 0x30e9),
        (digr \R, \i, 0x30ea),
        (digr \R, \u, 0x30eb),
        (digr \R, \e, 0x30ec),
        (digr \R, \o, 0x30ed),
        (digr \W, \A, 0x30ee),
        (digr \W, \a, 0x30ef),
        (digr \W, \i, 0x30f0),
        (digr \W, \e, 0x30f1),
        (digr \W, \o, 0x30f2),
        (digr \N, \6, 0x30f3),
        (digr \V, \u, 0x30f4),
        (digr \K, \A, 0x30f5),
        (digr \K, \E, 0x30f6),
        (digr \V, \a, 0x30f7),
        (digr \V, \i, 0x30f8),
        (digr \V, \e, 0x30f9),
        (digr \V, \o, 0x30fa),
        (digr \., \6, 0x30fb),
        (digr \-, \6, 0x30fc),
        (digr \*, \6, 0x30fd),
        (digr \+, \6, 0x30fe),
        (digr \b, \4, 0x3105),
        (digr \p, \4, 0x3106),
        (digr \m, \4, 0x3107),
        (digr \f, \4, 0x3108),
        (digr \d, \4, 0x3109),
        (digr \t, \4, 0x310a),
        (digr \n, \4, 0x310b),
        (digr \l, \4, 0x310c),
        (digr \g, \4, 0x310d),
        (digr \k, \4, 0x310e),
        (digr \h, \4, 0x310f),
        (digr \j, \4, 0x3110),
        (digr \q, \4, 0x3111),
        (digr \x, \4, 0x3112),
        (digr \z, \h, 0x3113),
        (digr \c, \h, 0x3114),
        (digr \s, \h, 0x3115),
        (digr \r, \4, 0x3116),
        (digr \z, \4, 0x3117),
        (digr \c, \4, 0x3118),
        (digr \s, \4, 0x3119),
        (digr \a, \4, 0x311a),
        (digr \o, \4, 0x311b),
        (digr \e, \4, 0x311c),
        (digr \a, \i, 0x311e),
        (digr \e, \i, 0x311f),
        (digr \a, \u, 0x3120),
        (digr \o, \u, 0x3121),
        (digr \a, \n, 0x3122),
        (digr \e, \n, 0x3123),
        (digr \a, \N, 0x3124),
        (digr \e, \N, 0x3125),
        (digr \e, \r, 0x3126),
        (digr \i, \4, 0x3127),
        (digr \u, \4, 0x3128),
        (digr \i, \u, 0x3129),
        (digr \v, \4, 0x312a),
        (digr \n, \G, 0x312b),
        (digr \g, \n, 0x312c),
        (digr \1, \c, 0x3220),
        (digr \2, \c, 0x3221),
        (digr \3, \c, 0x3222),
        (digr \4, \c, 0x3223),
        (digr \5, \c, 0x3224),
        (digr \6, \c, 0x3225),
        (digr \7, \c, 0x3226),
        (digr \8, \c, 0x3227),
        (digr \9, \c, 0x3228),
        ;; Code points 0xe000 - 0xefff excluded;
        ;; they have no assigned characters, only used in proposals.
        (digr \f, \f, 0xfb00),
        (digr \f, \i, 0xfb01),
        (digr \f, \l, 0xfb02),
        (digr \f, \t, 0xfb05),
        (digr \s, \t, 0xfb06),

        ;; Vim 5.x compatible digraphs that don't conflict with the above.
        (digr \~, \!, 161),
        (digr \c, \|, 162),
        (digr \$, \$, 163),
        (digr \o, \x, 164),
        (digr \Y, \-, 165),
        (digr \|, \|, 166),
        (digr \c, \O, 169),
        (digr \-, \,, 172),
        (digr \-, \=, 175),
        (digr \~, \o, 176),
        (digr \2, \2, 178),
        (digr \3, \3, 179),
        (digr \p, \p, 182),
        (digr \~, \., 183),
        (digr \1, \1, 185),
        (digr \~, \?, 191),
        (digr \A, \`, 192),
        (digr \A, \^, 194),
        (digr \A, \~, 195),
        (digr \A, \", 196),
        (digr \A, \@, 197),
        (digr \E, \`, 200),
        (digr \E, \^, 202),
        (digr \E, \", 203),
        (digr \I, \`, 204),
        (digr \I, \^, 206),
        (digr \I, \", 207),
        (digr \N, \~, 209),
        (digr \O, \`, 210),
        (digr \O, \^, 212),
        (digr \O, \~, 213),
        (digr \/, \\, 215),
        (digr \U, \`, 217),
        (digr \U, \^, 219),
        (digr \I, \p, 222),
        (digr \a, \`, 224),
        (digr \a, \^, 226),
        (digr \a, \~, 227),
        (digr \a, \", 228),
        (digr \a, \@, 229),
        (digr \e, \`, 232),
        (digr \e, \^, 234),
        (digr \e, \", 235),
        (digr \i, \`, 236),
        (digr \i, \^, 238),
        (digr \n, \~, 241),
        (digr \o, \`, 242),
        (digr \o, \^, 244),
        (digr \o, \~, 245),
        (digr \u, \`, 249),
        (digr \u, \^, 251),
        (digr \y, \", 255)
    ])

(atom! int backspaced)  ;; character before K_BS
(atom! int lastchar)    ;; last typed character

;; handle digraphs after typing a character

(defn- #_int do_digraph [#_int c]
    (§
;       if (c == -1)                ;; init values
;       {
;           @backspaced = -1;
;       }
;       else if (@p_dg)
;       {
;           if (0 <= @backspaced)
;               c = getdigraph(@backspaced, c, false);
;           @backspaced = -1;
;           if ((c == K_BS || c == Ctrl_H) && 0 <= @lastchar)
;               @backspaced = @lastchar;
;       }
;       @lastchar = c;
;       return c;
    ))

;; Get a digraph.  Used after typing CTRL-K on the command line or in normal mode.
;; Returns composed character, or NUL when ESC was used.

(defn- #_int get_digraph [#_boolean cmdline]
    ;; cmdline: true when called from the cmdline
    (§
;       int c, cc;

;       @no_mapping++;
;       @allow_keys++;
;       c = plain_vgetc();
;       --@no_mapping;
;       --@allow_keys;
;       if (c != ESC)               ;; ESC cancels CTRL-K
;       {
;           if (is_special(c))      ;; insert special key code
;               return c;
;           if (cmdline)
;           {
;               if (mb_char2cells(c) == 1 && @cmdline_star == 0)
;                   putcmdline(c, true);
;           }
;           else
;               add_to_showcmd(c);
;           @no_mapping++;
;           @allow_keys++;
;           cc = plain_vgetc();
;           --@no_mapping;
;           --@allow_keys;
;           if (cc != ESC)      ;; ESC cancels CTRL-K
;               return getdigraph(c, cc, true);
;       }
;       return NUL;
    ))

;; Lookup the pair "char1", "char2" in the digraph tables.
;; If no match, return "char2".
;; If "meta_char" is true and "char1" is a space, return "char2" | 0x80.

(defn- #_int getexactdigraph [#_int char1, #_int char2, #_boolean meta_char]
    (§
;       int retval = 0;

;       if (is_special(char1) || is_special(char2))
;           return char2;

        ;; Search user digraphs first.

;       for (int i = 0; i < @user_digraphs.ga_len; i++)
;       {
;           digr_C dp = @user_digraphs.ga_data[i];
;           if ((int)dp.char1 == char1 && (int)dp.char2 == char2)
;           {
;               retval = dp.result;
;               break;
;           }
;       }

        ;; Search default digraphs.

;       if (retval == 0)
;       {
;           digr_C[] dgs = digraphdefault;
;           for (int i = 0; i < dgs.length; i++)
;               if ((int)dgs[i].char1 == char1 && (int)dgs[i].char2 == char2)
;               {
;                   retval = dgs[i].result;
;                   break;
;               }
;       }

;       if (retval == 0)            ;; digraph deleted or not found
;       {
;           if (char1 == ' ' && meta_char)  ;; <space> <char> --> meta-char
;               return (char2 | 0x80);

;           return char2;
;       }

;       return retval;
    ))

;; Get digraph.
;; Allow for both char1-char2 and char2-char1

(defn- #_int getdigraph [#_int char1, #_int char2, #_boolean meta_char]
    (§
;       int retval;

;       if (((retval = getexactdigraph(char1, char2, meta_char)) == char2)
;               && (char1 != char2)
;               && ((retval = getexactdigraph(char2, char1, meta_char)) == char1))
;           return char2;

;       return retval;
    ))

;; Add the digraphs in the argument to the digraph table.
;; Format: {c1}{c2} char {c1}{c2} char ...

(defn- #_void putdigraph [#_Bytes s]
    (§
;       while (s.at(0) != NUL)
;       {
;           s = skipwhite(s);
;           if (s.at(0) == NUL)
;               return;
;           byte char1 = (s = s.plus(1)).at(-1);
;           byte char2 = (s = s.plus(1)).at(-1);
;           if (char2 == NUL)
;           {
;               emsg(e_invarg);
;               return;
;           }
;           if (char1 == ESC || char2 == ESC)
;           {
;               emsg(u8("E104: Escape not allowed in digraph"));
;               return;
;           }
;           s = skipwhite(s);
;           if (!asc_isdigit(s.at(0)))
;           {
;               emsg(e_number_exp);
;               return;
;           }

;           int n;
;           { Bytes[] __ = { s }; n = (int)getdigits(__); s = __[0]; }
;           int i;

            ;; If the digraph already exists, replace the result.
;           for (i = 0; i < @user_digraphs.ga_len; i++)
;           {
;               digr_C dp = @user_digraphs.ga_data[i];
;               if (dp.char1 == char1 && dp.char2 == char2)
;               {
;                   dp.result = n;
;                   break;
;               }
;           }

            ;; Add a new digraph to the table.
;           if (i == @user_digraphs.ga_len)
;           {
;               @user_digraphs.ga_grow(1);

;               digr_C dp = @user_digraphs.ga_data[@user_digraphs.ga_len++] = §_digr_C();
;               dp.char1 = char1;
;               dp.char2 = char2;
;               dp.result = n;
;           }
;       }
    ))

(defn- #_void listdigraphs []
    (§
;       msg_putchar('\n');

;       digr_C[] dgs = digraphdefault;
;       for (int i = 0; i < dgs.length && !@got_int; i++)
;       {
;           digr_C tmp = §_digr_C();

            ;; May need to convert the result to 'encoding'.
;           tmp.char1 = dgs[i].char1;
;           tmp.char2 = dgs[i].char2;
;           tmp.result = getexactdigraph(tmp.char1, tmp.char2, false);
;           if (tmp.result != 0 && tmp.result != tmp.char2)
;               printdigraph(tmp);
;           ui_breakcheck();
;       }

;       for (int i = 0; i < @user_digraphs.ga_len && !@got_int; i++)
;       {
;           digr_C dp = @user_digraphs.ga_data[i];
;           printdigraph(dp);
;           ui_breakcheck();
;       }

;       @must_redraw = CLEAR;    ;; clear screen, because some digraphs may be wrong,
                                ;; in which case we messed up "screenLines"
    ))

(defn- #_void printdigraph [#_digr_C dp]
    (§
;       int list_width = 13;

;       if (dp.result != 0)
;       {
;           if ((int)@Columns - list_width < @msg_col)
;               msg_putchar('\n');
;           if (@msg_col != 0)
;               while (@msg_col % list_width != 0)
;                   msg_putchar(' ');

;           Bytes buf = new Bytes(30);

;           Bytes p = buf;
;           (p = p.plus(1)).be(-1, dp.char1);
;           (p = p.plus(1)).be(-1, dp.char2);
;           (p = p.plus(1)).be(-1, (byte)' ');

            ;; add a space to draw a composing char on
;           if (utf_iscomposing(dp.result))
;               (p = p.plus(1)).be(-1, (byte)' ');
;           p = p.plus(utf_char2bytes(dp.result, p));

;           if (mb_char2cells(dp.result) == 1)
;               (p = p.plus(1)).be(-1, (byte)' ');
;           vim_snprintf(p, buf.size() - BDIFF(p, buf), u8(" %3d"), dp.result);
;           msg_outtrans(buf);
;       }
    ))

;; mbyte.c: Code specifically for handling multi-byte characters.
;;
;; "enc_utf8"   Use Unicode characters in UTF-8 encoding.
;;              The cell width on the display needs to be determined from the character value.
;;              Recognizing bytes is easy: 0xxx.xxxx is a single-byte char, 10xx.xxxx is a
;;              trailing byte, 11xx.xxxx is a leading byte of a multi-byte character.
;;              To make things complicated, up to six composing characters are allowed.
;;              These are drawn on top of the first char.
;;              For most editing the sequence of bytes with composing
;;              characters included is considered to be one character.
;;
;; 'encoding' specifies the encoding used in the core.  This is in registers,
;; text manipulation, buffers, etc.  Conversion has to be done when characters
;; in another encoding are received or send:
;;
;;                     clipboard
;;                         ^
;;                         | (2)
;;                         V
;;                 +---------------+
;;            (1)  |               | (3)
;;  keyboard ----->|     core      |-----> display
;;                 |               |
;;                 +---------------+
;;                         ^
;;                         | (4)
;;                         V
;;                       file
;;
;; (1) Typed characters arrive in the current locale.  Conversion is to be
;;     done when 'encoding' is different from 'termencoding'.
;; (2) Text will be made available with the encoding specified with
;;     'encoding'.  If this is not sufficient, system-specific conversion
;;     might be required.
;; (3) For the GUI the correct font must be selected, no conversion done.
;;     Otherwise, conversion is to be done when 'encoding' differs from
;;     'termencoding'.
;; (4) The encoding of the file is specified with 'fileencoding'.  Conversion
;;     is to be done when it's different from 'encoding'.

;; Lookup table to quickly get the length in bytes of a UTF-8 sequence from the first byte.
;; Bytes which are illegal when used as the first byte have a 0.
;; The NUL byte has length 1.

(final byte* #_"[/*256*/]" utf8len_tab_zero
    [
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
        3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,6,6,0,0
    ])

;; Returns the length of a UTF-8 sequence, obtained from the first byte.
;; For an invalid first byte returns zero ? 0 : 1.

(defn- #_int us_byte2len [#_byte b, #_boolean zero]
    (§
;       int len = utf8len_tab_zero[char_u(b)];
;       return (zero || 0 < len) ? len : 1;
    ))

;; Return byte length of character that starts with byte "b".
;; Returns 1 for a single-byte character.
;; mb_byte2len() can be used to count a special key as one byte.

(defn- #_int mb_byte2len [#_int b]
    (§
;       return (b < 0 || 0xff < b) ? 1 : us_byte2len((byte)b, false);
    ))

;; Get class of pointer:
;;  0 for blank or NUL
;;  1 for punctuation
;;  2 for an (ASCII) word character
;; >2 for other word characters

(defn- #_int us_get_class [#_Bytes p, #_buffer_C buf]
    (§
;       if (us_byte2len(p.at(0), false) == 1)
;       {
;           if (p.at(0) == NUL || vim_iswhite(p.at(0)))
;               return 0;
;           if (us_iswordb(p.at(0), buf))
;               return 2;

;           return 1;
;       }
;       return utf_class(us_ptr2char(p));
    ))

(defn- #_boolean intable [#_int* table, #_int c]
    (§
        ;; first quick check for Latin1 etc. characters
;       if (c < table[0])
;           return false;

        ;; binary search in table
;       for (int bot = 0, top = table.length / 2 - 1; bot <= top; )
;       {
;           int mid = (bot + top) / 2;
;           if (table[2 * mid + 1] < c)
;               bot = mid + 1;
;           else if (c < table[2 * mid])
;               top = mid - 1;
;           else
;               return true;
;       }

;       return false;
    ))

;; Sorted list of non-overlapping intervals of East Asian double width characters,
;; generated with tools/unicode.vim.

(final int* doublewidth
    [
        0x1100, 0x115f,
        0x2329, 0x232a,
        0x2e80, 0x2e99,
        0x2e9b, 0x2ef3,
        0x2f00, 0x2fd5,
        0x2ff0, 0x2ffb,
        0x3000, 0x303e,
        0x3041, 0x3096,
        0x3099, 0x30ff,
        0x3105, 0x312d,
        0x3131, 0x318e,
        0x3190, 0x31ba,
        0x31c0, 0x31e3,
        0x31f0, 0x321e,
        0x3220, 0x3247,
        0x3250, 0x32fe,
        0x3300, 0x4dbf,
        0x4e00, 0xa48c,
        0xa490, 0xa4c6,
        0xa960, 0xa97c,
        0xac00, 0xd7a3,
        0xf900, 0xfaff,
        0xfe10, 0xfe19,
        0xfe30, 0xfe52,
        0xfe54, 0xfe66,
        0xfe68, 0xfe6b,
        0xff01, 0xff60,
        0xffe0, 0xffe6,
        0x1b000, 0x1b001,
        0x1f200, 0x1f202,
        0x1f210, 0x1f23a,
        0x1f240, 0x1f248,
        0x1f250, 0x1f251,
        0x20000, 0x2fffd,
        0x30000, 0x3fffd
    ])

;; Sorted list of non-overlapping intervals of East Asian Ambiguous characters,
;; generated with tools/unicode.vim.

(final int* ambiguous
    [
        0x00a1, 0x00a1,
        0x00a4, 0x00a4,
        0x00a7, 0x00a8,
        0x00aa, 0x00aa,
        0x00ad, 0x00ae,
        0x00b0, 0x00b4,
        0x00b6, 0x00ba,
        0x00bc, 0x00bf,
        0x00c6, 0x00c6,
        0x00d0, 0x00d0,
        0x00d7, 0x00d8,
        0x00de, 0x00e1,
        0x00e6, 0x00e6,
        0x00e8, 0x00ea,
        0x00ec, 0x00ed,
        0x00f0, 0x00f0,
        0x00f2, 0x00f3,
        0x00f7, 0x00fa,
        0x00fc, 0x00fc,
        0x00fe, 0x00fe,
        0x0101, 0x0101,
        0x0111, 0x0111,
        0x0113, 0x0113,
        0x011b, 0x011b,
        0x0126, 0x0127,
        0x012b, 0x012b,
        0x0131, 0x0133,
        0x0138, 0x0138,
        0x013f, 0x0142,
        0x0144, 0x0144,
        0x0148, 0x014b,
        0x014d, 0x014d,
        0x0152, 0x0153,
        0x0166, 0x0167,
        0x016b, 0x016b,
        0x01ce, 0x01ce,
        0x01d0, 0x01d0,
        0x01d2, 0x01d2,
        0x01d4, 0x01d4,
        0x01d6, 0x01d6,
        0x01d8, 0x01d8,
        0x01da, 0x01da,
        0x01dc, 0x01dc,
        0x0251, 0x0251,
        0x0261, 0x0261,
        0x02c4, 0x02c4,
        0x02c7, 0x02c7,
        0x02c9, 0x02cb,
        0x02cd, 0x02cd,
        0x02d0, 0x02d0,
        0x02d8, 0x02db,
        0x02dd, 0x02dd,
        0x02df, 0x02df,
        0x0300, 0x036f,
        0x0391, 0x03a1,
        0x03a3, 0x03a9,
        0x03b1, 0x03c1,
        0x03c3, 0x03c9,
        0x0401, 0x0401,
        0x0410, 0x044f,
        0x0451, 0x0451,
        0x2010, 0x2010,
        0x2013, 0x2016,
        0x2018, 0x2019,
        0x201c, 0x201d,
        0x2020, 0x2022,
        0x2024, 0x2027,
        0x2030, 0x2030,
        0x2032, 0x2033,
        0x2035, 0x2035,
        0x203b, 0x203b,
        0x203e, 0x203e,
        0x2074, 0x2074,
        0x207f, 0x207f,
        0x2081, 0x2084,
        0x20ac, 0x20ac,
        0x2103, 0x2103,
        0x2105, 0x2105,
        0x2109, 0x2109,
        0x2113, 0x2113,
        0x2116, 0x2116,
        0x2121, 0x2122,
        0x2126, 0x2126,
        0x212b, 0x212b,
        0x2153, 0x2154,
        0x215b, 0x215e,
        0x2160, 0x216b,
        0x2170, 0x2179,
        0x2189, 0x2189,
        0x2190, 0x2199,
        0x21b8, 0x21b9,
        0x21d2, 0x21d2,
        0x21d4, 0x21d4,
        0x21e7, 0x21e7,
        0x2200, 0x2200,
        0x2202, 0x2203,
        0x2207, 0x2208,
        0x220b, 0x220b,
        0x220f, 0x220f,
        0x2211, 0x2211,
        0x2215, 0x2215,
        0x221a, 0x221a,
        0x221d, 0x2220,
        0x2223, 0x2223,
        0x2225, 0x2225,
        0x2227, 0x222c,
        0x222e, 0x222e,
        0x2234, 0x2237,
        0x223c, 0x223d,
        0x2248, 0x2248,
        0x224c, 0x224c,
        0x2252, 0x2252,
        0x2260, 0x2261,
        0x2264, 0x2267,
        0x226a, 0x226b,
        0x226e, 0x226f,
        0x2282, 0x2283,
        0x2286, 0x2287,
        0x2295, 0x2295,
        0x2299, 0x2299,
        0x22a5, 0x22a5,
        0x22bf, 0x22bf,
        0x2312, 0x2312,
        0x2460, 0x24e9,
        0x24eb, 0x254b,
        0x2550, 0x2573,
        0x2580, 0x258f,
        0x2592, 0x2595,
        0x25a0, 0x25a1,
        0x25a3, 0x25a9,
        0x25b2, 0x25b3,
        0x25b6, 0x25b7,
        0x25bc, 0x25bd,
        0x25c0, 0x25c1,
        0x25c6, 0x25c8,
        0x25cb, 0x25cb,
        0x25ce, 0x25d1,
        0x25e2, 0x25e5,
        0x25ef, 0x25ef,
        0x2605, 0x2606,
        0x2609, 0x2609,
        0x260e, 0x260f,
        0x2614, 0x2615,
        0x261c, 0x261c,
        0x261e, 0x261e,
        0x2640, 0x2640,
        0x2642, 0x2642,
        0x2660, 0x2661,
        0x2663, 0x2665,
        0x2667, 0x266a,
        0x266c, 0x266d,
        0x266f, 0x266f,
        0x269e, 0x269f,
        0x26be, 0x26bf,
        0x26c4, 0x26cd,
        0x26cf, 0x26e1,
        0x26e3, 0x26e3,
        0x26e8, 0x26ff,
        0x273d, 0x273d,
        0x2757, 0x2757,
        0x2776, 0x277f,
        0x2b55, 0x2b59,
        0x3248, 0x324f,
        0xe000, 0xf8ff,
        0xfe00, 0xfe0f,
        0xfffd, 0xfffd,
        0x1f100, 0x1f10a,
        0x1f110, 0x1f12d,
        0x1f130, 0x1f169,
        0x1f170, 0x1f19a,
        0xe0100, 0xe01ef,
        0xf0000, 0xffffd,
        0x100000, 0x10fffd
    ])

;; For UTF-8 character "c" return 2 for a double-width character, 1 for others.
;; Returns 4 or 6 for an unprintable character.
;; Is only correct for characters >= 0x80.
;; When "p_ambw" is 'double', return 2 for a character with East Asian Width class 'A'(mbiguous).

(defn- #_int utf_char2cells [#_int c]
    (§
;       if (0x80 <= c)
;       {
            ;; Characters below 0x100 are influenced by 'isprint' option.
;           if (c < 0x100)
;           {
;               if (!vim_isprintc(c))
;                   return 4;                           ;; unprintable, displays <xx>
;           }
;           else
;           {
;               if (!utf_printable(c))
;                   return 6;                           ;; unprintable, displays <xxxx>
;               if (intable(doublewidth, c))
;                   return 2;
;           }

;           if (@p_ambw.at(0) == (byte)'d' && intable(ambiguous, c))
;               return 2;
;       }

;       return 1;
    ))

(defn- #_int us_ptr2cells [#_Bytes p]
    (§
        ;; Need to convert to a wide character.
;       if (0x80 <= char_u(p.at(0)))
;       {
;           int c = us_ptr2char(p);
            ;; An illegal byte is displayed as <xx>.
;           if (us_ptr2len(p) == 1 || c == NUL)
;               return 4;
            ;; If the char is ASCII it must be an overlong sequence.
;           if (c < 0x80)
;               return mb_char2cells(c);

;           return utf_char2cells(c);
;       }
;       return 1;
    ))

;; Return the number of cells occupied by string "p".
;; Stop at a NUL character.  When "len" >= 0 stop at character "p[len]".

(defn- #_int us_string2cells [#_Bytes p, #_int len]
    (§
;       int cells = 0;

;       for (int i = 0; (len < 0 || i < len) && p.at(i) != NUL; i += us_ptr2len_cc(p.plus(i)))
;           cells += us_ptr2cells(p.plus(i));

;       return cells;
    ))

(defn- #_int utf_off2cells [#_int off, #_int max_off]
    (§
;       return (off + 1 < max_off && @screenLines.at(off + 1) == 0) ? 2 : 1;
    ))

;; Convert a UTF-8 byte sequence to a wide character.
;; If the sequence is illegal or truncated by a NUL the first byte is returned.
;; Does not include composing characters, of course.

(defn- #_int us_ptr2char [#_Bytes p]
    (§
;       if (char_u(p.at(0)) < 0x80)    ;; be quick for ASCII
;           return p.at(0);

;       int len = us_byte2len(p.at(0), true);
;       if (1 < len && (char_u(p.at(1)) & 0xc0) == 0x80)
;       {
;           if (len == 2)
;               return ((p.at(0) & 0x1f) << 6) + (p.at(1) & 0x3f);

;           if ((char_u(p.at(2)) & 0xc0) == 0x80)
;           {
;               if (len == 3)
;                   return ((p.at(0) & 0x0f) << 12) + ((p.at(1) & 0x3f) << 6) + (p.at(2) & 0x3f);

;               if ((char_u(p.at(3)) & 0xc0) == 0x80)
;               {
;                   if (len == 4)
;                       return ((p.at(0) & 0x07) << 18) + ((p.at(1) & 0x3f) << 12)
;                            + ((p.at(2) & 0x3f) << 6) + (p.at(3) & 0x3f);

;                   if ((char_u(p.at(4)) & 0xc0) == 0x80)
;                   {
;                       if (len == 5)
;                           return ((p.at(0) & 0x03) << 24) + ((p.at(1) & 0x3f) << 18)
;                                + ((p.at(2) & 0x3f) << 12) + ((p.at(3) & 0x3f) << 6) + (p.at(4) & 0x3f);

;                       if ((char_u(p.at(5)) & 0xc0) == 0x80 && len == 6)
;                           return ((p.at(0) & 0x01) << 30) + ((p.at(1) & 0x3f) << 24)
;                                + ((p.at(2) & 0x3f) << 18) + ((p.at(3) & 0x3f) << 12)
;                                + ((p.at(4) & 0x3f) << 6) + (p.at(5) & 0x3f);
;                   }
;               }
;           }
;       }

        ;; Illegal value, just return the first byte.
;       return char_u(p.at(0));
    ))

;; Convert a UTF-8 byte sequence to a wide character.
;; String is assumed to be terminated by NUL or after "n" bytes, whichever comes first.
;; The function is safe in the sense that it never accesses memory beyond the first "n" bytes of "s".
;;
;; On success, returns decoded codepoint,
;; advances "s" to the beginning of next character and decreases "n" accordingly.
;;
;; If end of string was reached, returns 0 and, if "n" > 0, advances "s" past NUL byte.
;;
;; If byte sequence is illegal or incomplete, returns -1 and does not advance "s".

(defn- #_int us_safe_read_char_adv [#_Bytes* s, #_int* n]
    (§
;       if (n[0] == 0)    ;; end of buffer
;           return 0;

;       int k = us_byte2len(s[0].at(0), true);

;       if (k == 1)     ;; ASCII character or NUL
;       {
;           n[0]--;
;           return (s[0] = s[0].plus(1)).at(-1);
;       }

;       if (k <= n[0])
;       {
            ;; We have a multibyte sequence and it isn't truncated by buffer
            ;; limits so us_ptr2char() is safe to use.  Or the first byte is
            ;; illegal (k=0), and it's also safe to use us_ptr2char().
;           int c = us_ptr2char(s[0]);

            ;; On failure, us_ptr2char() returns the first byte, so here we
            ;; check equality with the first byte.  The only non-ASCII character
            ;; which equals the first byte of its own UTF-8 representation is
            ;; U+00C3 (UTF-8: 0xC3 0x83), so need to check that special case too.
            ;; It's safe even if n=1, else we would have k=2 > n.
;           if (c != char_u(s[0].at(0)) || (c == 0xc3 && char_u(s[0].at(1)) == 0x83))
;           {
                ;; byte sequence was successfully decoded
;               s[0] = s[0].plus(k);
;               n[0] -= k;
;               return c;
;           }
;       }

        ;; byte sequence is incomplete or illegal
;       return -1;
    ))

;; Get character at **pp and advance *pp to the next character.
;; skip: composing characters are skipped!
;; !skip: composing characters are returned as separate characters.

(defn- #_int us_ptr2char_adv [#_Bytes* pp, #_boolean skip]
    (§
;       int c = us_ptr2char(pp[0]);
;       pp[0] = pp[0].plus((skip) ? us_ptr2len_cc(pp[0]) : us_ptr2len(pp[0]));
;       return c;
    ))

;; Convert a UTF-8 byte string to a wide character.
;; Also get up to MAX_MCO composing characters.

(defn- #_int us_ptr2char_cc [#_Bytes p, #_int* pcc]
    ;; pcc: return: composing chars, last one is 0
    (§
;       int j = 0;

        ;; Only accept a composing char when the first char isn't illegal.
;       int i = us_ptr2len(p);
;       if (1 < i || char_u(p.at(0)) < 0x80)
;           for (int cc; 0x80 <= char_u(p.at(i)) && utf_iscomposing(cc = us_ptr2char(p.plus(i))); i += us_ptr2len(p.plus(i)))
;           {
;               pcc[j++] = cc;
;               if (j == MAX_MCO)
;                   break;
;           }

;       if (j < MAX_MCO)    ;; last composing char must be 0
;           pcc[j] = 0;

;       return us_ptr2char(p);
    ))

;; Convert a UTF-8 byte string to a wide character.
;; Also get up to MAX_MCO composing characters.
;; Use no more than p[maxlen].

(defn- #_int us_ptr2char_cc_len [#_Bytes p, #_int* pcc, #_int maxlen]
    ;; pcc: return: composing chars, last one is 0
    (§
;       int j = 0;

        ;; Only accept a composing char when the first char isn't illegal.
;       int i = us_ptr2len_len(p, maxlen);
;       if (1 < i || char_u(p.at(0)) < 0x80)
;           for (int cc; i < maxlen && 0x80 <= char_u(p.at(i)) && utf_iscomposing(cc = us_ptr2char(p.plus(i))); i += us_ptr2len_len(p.plus(i), maxlen - i))
;           {
;               pcc[j++] = cc;
;               if (j == MAX_MCO)
;                   break;
;           }

;       if (j < MAX_MCO)    ;; last composing char must be 0
;           pcc[j] = 0;

;       return us_ptr2char(p);
    ))

;; Convert the character at screen position "off" to a sequence of bytes.
;; Includes the composing characters.
;; "buf" must at least have the length MB_MAXBYTES + 1.
;; Only to be used when screenLinesUC[off] != 0.
;; Returns the produced number of bytes.

(defn- #_int utfc_char2bytes [#_int off, #_Bytes buf]
    (§
;       int len = utf_char2bytes(@screenLinesUC[off], buf);
;       for (int i = 0; i < @screen_mco; i++)
;       {
;           if (@screenLinesC[i][off] == 0)
;               break;
;           len += utf_char2bytes(@screenLinesC[i][off], buf.plus(len));
;       }
;       return len;
    ))

;; Get the length of a UTF-8 byte sequence, not including any following composing characters.
;; Returns 0 for "".
;; Returns 1 for an illegal byte sequence.

(defn- #_int us_ptr2len [#_Bytes p]
    (§
;       if (p.at(0) == NUL)
;           return 0;

;       int len = us_byte2len(p.at(0), false);
;       for (int i = 1; i < len; i++)
;           if ((char_u(p.at(i)) & 0xc0) != 0x80)
;               return 1;

;       return len;
    ))

;; Get the length of UTF-8 byte sequence "p[size]".
;; Does not include any following composing characters.
;; Returns 1 for "".
;; Returns 1 for an illegal byte sequence (also in incomplete byte seq.).
;; Returns number > "size" for an incomplete byte sequence.
;; Never returns zero.

(defn- #_int us_ptr2len_len [#_Bytes p, #_int size]
    (§
;       int len = us_byte2len(p.at(0), false);
;       if (len == 1)
;           return 1;       ;; NUL, ASCII or illegal lead byte

;       int m = (size < len) ? size : len;  ;; incomplete byte sequence?
;       for (int i = 1; i < m; i++)
;           if ((char_u(p.at(i)) & 0xc0) != 0x80)
;               return 1;

;       return len;
    ))

;; Return the number of bytes the UTF-8 encoding of the character at "p" takes.
;; This includes following composing characters.

(defn- #_int us_ptr2len_cc [#_Bytes p]
    (§
;       if (p.at(0) == NUL)
;           return 0;
;       if (char_u(p.at(0)) < 0x80 && char_u(p.at(1)) < 0x80)     ;; be quick for ASCII
;           return 1;

        ;; Skip over first UTF-8 char, stopping at a NUL byte.
;       int len = us_ptr2len(p);

        ;; Check for illegal byte.
;       if (len == 1 && 0x80 <= char_u(p.at(0)))
;           return 1;

        ;; Check for composing characters.  We can handle only the first six,
        ;; but skip all of them (otherwise the cursor would get stuck).

;       while (0x80 <= char_u(p.at(len)) && utf_iscomposing(us_ptr2char(p.plus(len))))
;       {
            ;; Skip over composing char.
;           len += us_ptr2len(p.plus(len));
;       }

;       return len;
    ))

;; Return the number of bytes the UTF-8 encoding of the character at "p[size]" takes.
;; This includes following composing characters.
;; Returns 0 for an empty string.
;; Returns 1 for an illegal char or an incomplete byte sequence.

(defn- #_int us_ptr2len_cc_len [#_Bytes p, #_int size]
    (§
;       if (size < 1 || p.at(0) == NUL)
;           return 0;
;       if (char_u(p.at(0)) < 0x80 && (size == 1 || char_u(p.at(1)) < 0x80))    ;; be quick for ASCII
;           return 1;

        ;; Skip over first UTF-8 char, stopping at a NUL byte.
;       int len = us_ptr2len_len(p, size);

        ;; Check for illegal byte and incomplete byte sequence.
;       if ((len == 1 && 0x80 <= char_u(p.at(0))) || size < len)
;           return 1;

        ;; Check for composing characters.  We can handle only the first six,
        ;; but skip all of them (otherwise the cursor would get stuck).

;       while (len < size && 0x80 <= char_u(p.at(len)))
;       {
            ;; Next character length should not go beyond size to ensure
            ;; that UTF_COMPOSINGLIKE(...) does not read beyond size.

;           int len_next_char = us_ptr2len_len(p.plus(len), size - len);
;           if (size - len < len_next_char)
;               break;

;           if (!utf_iscomposing(us_ptr2char(p.plus(len))))
;               break;

            ;; Skip over composing char.
;           len += len_next_char;
;       }

;       return len;
    ))

;; Return the number of bytes the UTF-8 encoding of character "c" takes.
;; This does not include composing characters.

(defn- #_int utf_char2len [#_int c]
    (§
;       if (c < 0x80)
;           return 1;
;       if (c < 0x800)
;           return 2;
;       if (c < 0x10000)
;           return 3;
;       if (c < 0x200000)
;           return 4;
;       if (c < 0x4000000)
;           return 5;

;       return 6;
    ))

;; Convert Unicode character "c" to UTF-8 string in "buf[]".
;; Returns the number of bytes.
;; This does not include composing characters.

(defn- #_int utf_char2bytes [#_int c, #_Bytes buf]
    (§
;       if (c < 0x80)               ;; 7 bits
;       {
;           buf.be(0, c);
;           return 1;
;       }

;       if (c < 0x800)              ;; 11 bits
;       {
;           buf.be(0, 0xc0 + (c >>> 6));
;           buf.be(1, 0x80 + (c & 0x3f));
;           return 2;
;       }

;       if (c < 0x10000)            ;; 16 bits
;       {
;           buf.be(0, 0xe0 + (c >>> 12));
;           buf.be(1, 0x80 + ((c >>> 6) & 0x3f));
;           buf.be(2, 0x80 + (c & 0x3f));
;           return 3;
;       }

;       if (c < 0x200000)           ;; 21 bits
;       {
;           buf.be(0, 0xf0 + (c >>> 18));
;           buf.be(1, 0x80 + ((c >>> 12) & 0x3f));
;           buf.be(2, 0x80 + ((c >>> 6) & 0x3f));
;           buf.be(3, 0x80 + (c & 0x3f));
;           return 4;
;       }

;       if (c < 0x4000000)          ;; 26 bits
;       {
;           buf.be(0, 0xf8 + (c >>> 24));
;           buf.be(1, 0x80 + ((c >>> 18) & 0x3f));
;           buf.be(2, 0x80 + ((c >>> 12) & 0x3f));
;           buf.be(3, 0x80 + ((c >>> 6) & 0x3f));
;           buf.be(4, 0x80 + (c & 0x3f));
;           return 5;
;       }

                                    ;; 31 bits
;       {
;           buf.be(0, 0xfc + (c >>> 30));
;           buf.be(1, 0x80 + ((c >>> 24) & 0x3f));
;           buf.be(2, 0x80 + ((c >>> 18) & 0x3f));
;           buf.be(3, 0x80 + ((c >>> 12) & 0x3f));
;           buf.be(4, 0x80 + ((c >>> 6) & 0x3f));
;           buf.be(5, 0x80 + (c & 0x3f));
;           return 6;
;       }
    ))

;; Sorted list of non-overlapping intervals.
;; Generated by tools/unicode.vim.

(final int* combining
    [
        0x0300, 0x036f,
        0x0483, 0x0489,
        0x0591, 0x05bd,
        0x05bf, 0x05bf,
        0x05c1, 0x05c2,
        0x05c4, 0x05c5,
        0x05c7, 0x05c7,
        0x0610, 0x061a,
        0x064b, 0x065f,
        0x0670, 0x0670,
        0x06d6, 0x06dc,
        0x06df, 0x06e4,
        0x06e7, 0x06e8,
        0x06ea, 0x06ed,
        0x0711, 0x0711,
        0x0730, 0x074a,
        0x07a6, 0x07b0,
        0x07eb, 0x07f3,
        0x0816, 0x0819,
        0x081b, 0x0823,
        0x0825, 0x0827,
        0x0829, 0x082d,
        0x0859, 0x085b,
        0x08e4, 0x0903,
        0x093a, 0x093c,
        0x093e, 0x094f,
        0x0951, 0x0957,
        0x0962, 0x0963,
        0x0981, 0x0983,
        0x09bc, 0x09bc,
        0x09be, 0x09c4,
        0x09c7, 0x09c8,
        0x09cb, 0x09cd,
        0x09d7, 0x09d7,
        0x09e2, 0x09e3,
        0x0a01, 0x0a03,
        0x0a3c, 0x0a3c,
        0x0a3e, 0x0a42,
        0x0a47, 0x0a48,
        0x0a4b, 0x0a4d,
        0x0a51, 0x0a51,
        0x0a70, 0x0a71,
        0x0a75, 0x0a75,
        0x0a81, 0x0a83,
        0x0abc, 0x0abc,
        0x0abe, 0x0ac5,
        0x0ac7, 0x0ac9,
        0x0acb, 0x0acd,
        0x0ae2, 0x0ae3,
        0x0b01, 0x0b03,
        0x0b3c, 0x0b3c,
        0x0b3e, 0x0b44,
        0x0b47, 0x0b48,
        0x0b4b, 0x0b4d,
        0x0b56, 0x0b57,
        0x0b62, 0x0b63,
        0x0b82, 0x0b82,
        0x0bbe, 0x0bc2,
        0x0bc6, 0x0bc8,
        0x0bca, 0x0bcd,
        0x0bd7, 0x0bd7,
        0x0c00, 0x0c03,
        0x0c3e, 0x0c44,
        0x0c46, 0x0c48,
        0x0c4a, 0x0c4d,
        0x0c55, 0x0c56,
        0x0c62, 0x0c63,
        0x0c81, 0x0c83,
        0x0cbc, 0x0cbc,
        0x0cbe, 0x0cc4,
        0x0cc6, 0x0cc8,
        0x0cca, 0x0ccd,
        0x0cd5, 0x0cd6,
        0x0ce2, 0x0ce3,
        0x0d01, 0x0d03,
        0x0d3e, 0x0d44,
        0x0d46, 0x0d48,
        0x0d4a, 0x0d4d,
        0x0d57, 0x0d57,
        0x0d62, 0x0d63,
        0x0d82, 0x0d83,
        0x0dca, 0x0dca,
        0x0dcf, 0x0dd4,
        0x0dd6, 0x0dd6,
        0x0dd8, 0x0ddf,
        0x0df2, 0x0df3,
        0x0e31, 0x0e31,
        0x0e34, 0x0e3a,
        0x0e47, 0x0e4e,
        0x0eb1, 0x0eb1,
        0x0eb4, 0x0eb9,
        0x0ebb, 0x0ebc,
        0x0ec8, 0x0ecd,
        0x0f18, 0x0f19,
        0x0f35, 0x0f35,
        0x0f37, 0x0f37,
        0x0f39, 0x0f39,
        0x0f3e, 0x0f3f,
        0x0f71, 0x0f84,
        0x0f86, 0x0f87,
        0x0f8d, 0x0f97,
        0x0f99, 0x0fbc,
        0x0fc6, 0x0fc6,
        0x102b, 0x103e,
        0x1056, 0x1059,
        0x105e, 0x1060,
        0x1062, 0x1064,
        0x1067, 0x106d,
        0x1071, 0x1074,
        0x1082, 0x108d,
        0x108f, 0x108f,
        0x109a, 0x109d,
        0x135d, 0x135f,
        0x1712, 0x1714,
        0x1732, 0x1734,
        0x1752, 0x1753,
        0x1772, 0x1773,
        0x17b4, 0x17d3,
        0x17dd, 0x17dd,
        0x180b, 0x180d,
        0x18a9, 0x18a9,
        0x1920, 0x192b,
        0x1930, 0x193b,
        0x19b0, 0x19c0,
        0x19c8, 0x19c9,
        0x1a17, 0x1a1b,
        0x1a55, 0x1a5e,
        0x1a60, 0x1a7c,
        0x1a7f, 0x1a7f,
        0x1ab0, 0x1abe,
        0x1b00, 0x1b04,
        0x1b34, 0x1b44,
        0x1b6b, 0x1b73,
        0x1b80, 0x1b82,
        0x1ba1, 0x1bad,
        0x1be6, 0x1bf3,
        0x1c24, 0x1c37,
        0x1cd0, 0x1cd2,
        0x1cd4, 0x1ce8,
        0x1ced, 0x1ced,
        0x1cf2, 0x1cf4,
        0x1cf8, 0x1cf9,
        0x1dc0, 0x1df5,
        0x1dfc, 0x1dff,
        0x20d0, 0x20f0,
        0x2cef, 0x2cf1,
        0x2d7f, 0x2d7f,
        0x2de0, 0x2dff,
        0x302a, 0x302f,
        0x3099, 0x309a,
        0xa66f, 0xa672,
        0xa674, 0xa67d,
        0xa69f, 0xa69f,
        0xa6f0, 0xa6f1,
        0xa802, 0xa802,
        0xa806, 0xa806,
        0xa80b, 0xa80b,
        0xa823, 0xa827,
        0xa880, 0xa881,
        0xa8b4, 0xa8c4,
        0xa8e0, 0xa8f1,
        0xa926, 0xa92d,
        0xa947, 0xa953,
        0xa980, 0xa983,
        0xa9b3, 0xa9c0,
        0xa9e5, 0xa9e5,
        0xaa29, 0xaa36,
        0xaa43, 0xaa43,
        0xaa4c, 0xaa4d,
        0xaa7b, 0xaa7d,
        0xaab0, 0xaab0,
        0xaab2, 0xaab4,
        0xaab7, 0xaab8,
        0xaabe, 0xaabf,
        0xaac1, 0xaac1,
        0xaaeb, 0xaaef,
        0xaaf5, 0xaaf6,
        0xabe3, 0xabea,
        0xabec, 0xabed,
        0xfb1e, 0xfb1e,
        0xfe00, 0xfe0f,
        0xfe20, 0xfe2d,
        0x101fd, 0x101fd,
        0x102e0, 0x102e0,
        0x10376, 0x1037a,
        0x10a01, 0x10a03,
        0x10a05, 0x10a06,
        0x10a0c, 0x10a0f,
        0x10a38, 0x10a3a,
        0x10a3f, 0x10a3f,
        0x10ae5, 0x10ae6,
        0x11000, 0x11002,
        0x11038, 0x11046,
        0x1107f, 0x11082,
        0x110b0, 0x110ba,
        0x11100, 0x11102,
        0x11127, 0x11134,
        0x11173, 0x11173,
        0x11180, 0x11182,
        0x111b3, 0x111c0,
        0x1122c, 0x11237,
        0x112df, 0x112ea,
        0x11301, 0x11303,
        0x1133c, 0x1133c,
        0x1133e, 0x11344,
        0x11347, 0x11348,
        0x1134b, 0x1134d,
        0x11357, 0x11357,
        0x11362, 0x11363,
        0x11366, 0x1136c,
        0x11370, 0x11374,
        0x114b0, 0x114c3,
        0x115af, 0x115b5,
        0x115b8, 0x115c0,
        0x11630, 0x11640,
        0x116ab, 0x116b7,
        0x16af0, 0x16af4,
        0x16b30, 0x16b36,
        0x16f51, 0x16f7e,
        0x16f8f, 0x16f92,
        0x1bc9d, 0x1bc9e,
        0x1d165, 0x1d169,
        0x1d16d, 0x1d172,
        0x1d17b, 0x1d182,
        0x1d185, 0x1d18b,
        0x1d1aa, 0x1d1ad,
        0x1d242, 0x1d244,
        0x1e8d0, 0x1e8d6,
        0xe0100, 0xe01ef
    ])

;; Return true if "c" is a composing UTF-8 character.
;; This means it will be drawn on top of the preceding character.

(defn- #_boolean utf_iscomposing [#_int c]
    (§
;       return intable(combining, c);
    ))

;; Sorted list of non-overlapping intervals.
;; 0xd800-0xdfff is reserved for UTF-16, actually illegal.

(final int* nonprint
    [
        0x070f, 0x070f,
        0x180b, 0x180e,
        0x200b, 0x200f,
        0x202a, 0x202e,
        0x206a, 0x206f,
        0xd800, 0xdfff,
        0xfeff, 0xfeff,
        0xfff9, 0xfffb,
        0xfffe, 0xffff
    ])

;; Return true for characters that can be displayed in a normal way.
;; Only for characters of 0x100 and above!

(defn- #_boolean utf_printable [#_int c]
    (§
;       return !intable(nonprint, c);
    ))

;; sorted list of non-overlapping intervals
(final int* classes
    [
        0x037e, 0x037e, 1,          ;; Greek question mark
        0x0387, 0x0387, 1,          ;; Greek ano teleia
        0x055a, 0x055f, 1,          ;; Armenian punctuation
        0x0589, 0x0589, 1,          ;; Armenian full stop
        0x05be, 0x05be, 1,
        0x05c0, 0x05c0, 1,
        0x05c3, 0x05c3, 1,
        0x05f3, 0x05f4, 1,
        0x060c, 0x060c, 1,
        0x061b, 0x061b, 1,
        0x061f, 0x061f, 1,
        0x066a, 0x066d, 1,
        0x06d4, 0x06d4, 1,
        0x0700, 0x070d, 1,          ;; Syriac punctuation
        0x0964, 0x0965, 1,
        0x0970, 0x0970, 1,
        0x0df4, 0x0df4, 1,
        0x0e4f, 0x0e4f, 1,
        0x0e5a, 0x0e5b, 1,
        0x0f04, 0x0f12, 1,
        0x0f3a, 0x0f3d, 1,
        0x0f85, 0x0f85, 1,
        0x104a, 0x104f, 1,          ;; Myanmar punctuation
        0x10fb, 0x10fb, 1,          ;; Georgian punctuation
        0x1361, 0x1368, 1,          ;; Ethiopic punctuation
        0x166d, 0x166e, 1,          ;; Canadian Syl. punctuation
        0x1680, 0x1680, 0,
        0x169b, 0x169c, 1,
        0x16eb, 0x16ed, 1,
        0x1735, 0x1736, 1,
        0x17d4, 0x17dc, 1,          ;; Khmer punctuation
        0x1800, 0x180a, 1,          ;; Mongolian punctuation
        0x2000, 0x200b, 0,          ;; spaces
        0x200c, 0x2027, 1,          ;; punctuation and symbols
        0x2028, 0x2029, 0,
        0x202a, 0x202e, 1,          ;; punctuation and symbols
        0x202f, 0x202f, 0,
        0x2030, 0x205e, 1,          ;; punctuation and symbols
        0x205f, 0x205f, 0,
        0x2060, 0x27ff, 1,          ;; punctuation and symbols
        0x2070, 0x207f, 0x2070,     ;; superscript
        0x2080, 0x2094, 0x2080,     ;; subscript
        0x20a0, 0x27ff, 1,          ;; all kinds of symbols
        0x2800, 0x28ff, 0x2800,     ;; braille
        0x2900, 0x2998, 1,          ;; arrows, brackets, etc.
        0x29d8, 0x29db, 1,
        0x29fc, 0x29fd, 1,
        0x2e00, 0x2e7f, 1,          ;; supplemental punctuation
        0x3000, 0x3000, 0,          ;; ideographic space
        0x3001, 0x3020, 1,          ;; ideographic punctuation
        0x3030, 0x3030, 1,
        0x303d, 0x303d, 1,
        0x3040, 0x309f, 0x3040,     ;; Hiragana
        0x30a0, 0x30ff, 0x30a0,     ;; Katakana
        0x3300, 0x9fff, 0x4e00,     ;; CJK Ideographs
        0xac00, 0xd7a3, 0xac00,     ;; Hangul Syllables
        0xf900, 0xfaff, 0x4e00,     ;; CJK Ideographs
        0xfd3e, 0xfd3f, 1,
        0xfe30, 0xfe6b, 1,          ;; punctuation forms
        0xff00, 0xff0f, 1,          ;; half/fullwidth ASCII
        0xff1a, 0xff20, 1,          ;; half/fullwidth ASCII
        0xff3b, 0xff40, 1,          ;; half/fullwidth ASCII
        0xff5b, 0xff65, 1,          ;; half/fullwidth ASCII
        0x20000, 0x2a6df, 0x4e00,   ;; CJK Ideographs
        0x2a700, 0x2b73f, 0x4e00,   ;; CJK Ideographs
        0x2b740, 0x2b81f, 0x4e00,   ;; CJK Ideographs
        0x2f800, 0x2fa1f, 0x4e00    ;; CJK Ideographs
    ])

;; Get class of a Unicode character.
;;  0: white space
;;  1: punctuation
;;  2 or bigger: some class of word character.

(defn- #_int utf_class [#_int c]
    (§
        ;; First quick check for Latin1 characters, use 'iskeyword'.
;       if (c < 0x100)
;       {
;           if (c == ' ' || c == '\t' || c == NUL || c == 0xa0)
;               return 0;       ;; blank
;           if (vim_iswordc(c, @curbuf))
;               return 2;       ;; word character

;           return 1;           ;; punctuation
;       }

        ;; binary search in table
;       for (int bot = 0, top = classes.length / 3 - 1; bot <= top; )
;       {
;           int mid = (bot + top) / 2;
;           if (classes[3 * mid + 1] < c)
;               bot = mid + 1;
;           else if (c < classes[3 * mid])
;               top = mid - 1;
;           else
;               return classes[3 * mid + 2];
;       }

        ;; most other characters are "word" characters
;       return 2;
    ))

;; Code for Unicode case-dependent operations.  Based on notes in
;; http://www.unicode.org/Public/UNIDATA/CaseFolding.txt
;; This code uses simple case folding, not full case folding.
;; Last updated for Unicode 5.2.

;; Generic conversion function for case operations.
;; Return the converted equivalent of "c", which is a UCS-4 character.
;; Use the given conversion "table".
;; Uses binary search on "table".

(defn- #_int utf_convert [#_int c, #_int* table]
    (§
;       int start = 0, entries = table.length / 4;

;       for (int end = entries; start < end; )
;       {
            ;; need to search further
;           int mid = (start + end) / 2;
;           if (table[4 * mid + 1] < c)
;               start = mid + 1;
;           else
;               end = mid;
;       }

;       if (start < entries)
;       {
;           int i = 4 * start;
;           if (table[i] <= c && c <= table[i + 1] && (c - table[i]) % table[i + 2] == 0)
;               return c + table[i + 3];
;       }

;       return c;
    ))

;; The following tables are built by tools/unicode.vim.
;; They must be in numeric order, because we use binary search.
;; An entry such as {0x41,0x5a,1,32} means that Unicode characters in the
;; range from 0x41 to 0x5a inclusive, stepping by 1, are changed to
;; folded/upper/lower by adding 32.

(final int* foldCase
    [
        0x41, 0x5a, 1, 32,
        0xb5, 0xb5,-1, 775,
        0xc0, 0xd6, 1, 32,
        0xd8, 0xde, 1, 32,
        0x100, 0x12e, 2, 1,
        0x132, 0x136, 2, 1,
        0x139, 0x147, 2, 1,
        0x14a, 0x176, 2, 1,
        0x178, 0x178,-1,-121,
        0x179, 0x17d, 2, 1,
        0x17f, 0x17f,-1,-268,
        0x181, 0x181,-1, 210,
        0x182, 0x184, 2, 1,
        0x186, 0x186,-1, 206,
        0x187, 0x187,-1, 1,
        0x189, 0x18a, 1, 205,
        0x18b, 0x18b,-1, 1,
        0x18e, 0x18e,-1, 79,
        0x18f, 0x18f,-1, 202,
        0x190, 0x190,-1, 203,
        0x191, 0x191,-1, 1,
        0x193, 0x193,-1, 205,
        0x194, 0x194,-1, 207,
        0x196, 0x196,-1, 211,
        0x197, 0x197,-1, 209,
        0x198, 0x198,-1, 1,
        0x19c, 0x19c,-1, 211,
        0x19d, 0x19d,-1, 213,
        0x19f, 0x19f,-1, 214,
        0x1a0, 0x1a4, 2, 1,
        0x1a6, 0x1a6,-1, 218,
        0x1a7, 0x1a7,-1, 1,
        0x1a9, 0x1a9,-1, 218,
        0x1ac, 0x1ac,-1, 1,
        0x1ae, 0x1ae,-1, 218,
        0x1af, 0x1af,-1, 1,
        0x1b1, 0x1b2, 1, 217,
        0x1b3, 0x1b5, 2, 1,
        0x1b7, 0x1b7,-1, 219,
        0x1b8, 0x1bc, 4, 1,
        0x1c4, 0x1c4,-1, 2,
        0x1c5, 0x1c5,-1, 1,
        0x1c7, 0x1c7,-1, 2,
        0x1c8, 0x1c8,-1, 1,
        0x1ca, 0x1ca,-1, 2,
        0x1cb, 0x1db, 2, 1,
        0x1de, 0x1ee, 2, 1,
        0x1f1, 0x1f1,-1, 2,
        0x1f2, 0x1f4, 2, 1,
        0x1f6, 0x1f6,-1,-97,
        0x1f7, 0x1f7,-1,-56,
        0x1f8, 0x21e, 2, 1,
        0x220, 0x220,-1,-130,
        0x222, 0x232, 2, 1,
        0x23a, 0x23a,-1, 10795,
        0x23b, 0x23b,-1, 1,
        0x23d, 0x23d,-1,-163,
        0x23e, 0x23e,-1, 10792,
        0x241, 0x241,-1, 1,
        0x243, 0x243,-1,-195,
        0x244, 0x244,-1, 69,
        0x245, 0x245,-1, 71,
        0x246, 0x24e, 2, 1,
        0x345, 0x345,-1, 116,
        0x370, 0x372, 2, 1,
        0x376, 0x376,-1, 1,
        0x37f, 0x37f,-1, 116,
        0x386, 0x386,-1, 38,
        0x388, 0x38a, 1, 37,
        0x38c, 0x38c,-1, 64,
        0x38e, 0x38f, 1, 63,
        0x391, 0x3a1, 1, 32,
        0x3a3, 0x3ab, 1, 32,
        0x3c2, 0x3c2,-1, 1,
        0x3cf, 0x3cf,-1, 8,
        0x3d0, 0x3d0,-1,-30,
        0x3d1, 0x3d1,-1,-25,
        0x3d5, 0x3d5,-1,-15,
        0x3d6, 0x3d6,-1,-22,
        0x3d8, 0x3ee, 2, 1,
        0x3f0, 0x3f0,-1,-54,
        0x3f1, 0x3f1,-1,-48,
        0x3f4, 0x3f4,-1,-60,
        0x3f5, 0x3f5,-1,-64,
        0x3f7, 0x3f7,-1, 1,
        0x3f9, 0x3f9,-1,-7,
        0x3fa, 0x3fa,-1, 1,
        0x3fd, 0x3ff, 1,-130,
        0x400, 0x40f, 1, 80,
        0x410, 0x42f, 1, 32,
        0x460, 0x480, 2, 1,
        0x48a, 0x4be, 2, 1,
        0x4c0, 0x4c0,-1, 15,
        0x4c1, 0x4cd, 2, 1,
        0x4d0, 0x52e, 2, 1,
        0x531, 0x556, 1, 48,
        0x10a0, 0x10c5, 1, 7264,
        0x10c7, 0x10cd, 6, 7264,
        0x1e00, 0x1e94, 2, 1,
        0x1e9b, 0x1e9b,-1,-58,
        0x1e9e, 0x1e9e,-1,-7615,
        0x1ea0, 0x1efe, 2, 1,
        0x1f08, 0x1f0f, 1,-8,
        0x1f18, 0x1f1d, 1,-8,
        0x1f28, 0x1f2f, 1,-8,
        0x1f38, 0x1f3f, 1,-8,
        0x1f48, 0x1f4d, 1,-8,
        0x1f59, 0x1f5f, 2,-8,
        0x1f68, 0x1f6f, 1,-8,
        0x1f88, 0x1f8f, 1,-8,
        0x1f98, 0x1f9f, 1,-8,
        0x1fa8, 0x1faf, 1,-8,
        0x1fb8, 0x1fb9, 1,-8,
        0x1fba, 0x1fbb, 1,-74,
        0x1fbc, 0x1fbc,-1,-9,
        0x1fbe, 0x1fbe,-1,-7173,
        0x1fc8, 0x1fcb, 1,-86,
        0x1fcc, 0x1fcc,-1,-9,
        0x1fd8, 0x1fd9, 1,-8,
        0x1fda, 0x1fdb, 1,-100,
        0x1fe8, 0x1fe9, 1,-8,
        0x1fea, 0x1feb, 1,-112,
        0x1fec, 0x1fec,-1,-7,
        0x1ff8, 0x1ff9, 1,-128,
        0x1ffa, 0x1ffb, 1,-126,
        0x1ffc, 0x1ffc,-1,-9,
        0x2126, 0x2126,-1,-7517,
        0x212a, 0x212a,-1,-8383,
        0x212b, 0x212b,-1,-8262,
        0x2132, 0x2132,-1, 28,
        0x2160, 0x216f, 1, 16,
        0x2183, 0x2183,-1, 1,
        0x24b6, 0x24cf, 1, 26,
        0x2c00, 0x2c2e, 1, 48,
        0x2c60, 0x2c60,-1, 1,
        0x2c62, 0x2c62,-1,-10743,
        0x2c63, 0x2c63,-1,-3814,
        0x2c64, 0x2c64,-1,-10727,
        0x2c67, 0x2c6b, 2, 1,
        0x2c6d, 0x2c6d,-1,-10780,
        0x2c6e, 0x2c6e,-1,-10749,
        0x2c6f, 0x2c6f,-1,-10783,
        0x2c70, 0x2c70,-1,-10782,
        0x2c72, 0x2c75, 3, 1,
        0x2c7e, 0x2c7f, 1,-10815,
        0x2c80, 0x2ce2, 2, 1,
        0x2ceb, 0x2ced, 2, 1,
        0x2cf2, 0xa640, 31054, 1,
        0xa642, 0xa66c, 2, 1,
        0xa680, 0xa69a, 2, 1,
        0xa722, 0xa72e, 2, 1,
        0xa732, 0xa76e, 2, 1,
        0xa779, 0xa77b, 2, 1,
        0xa77d, 0xa77d,-1,-35332,
        0xa77e, 0xa786, 2, 1,
        0xa78b, 0xa78b,-1, 1,
        0xa78d, 0xa78d,-1,-42280,
        0xa790, 0xa792, 2, 1,
        0xa796, 0xa7a8, 2, 1,
        0xa7aa, 0xa7aa,-1,-42308,
        0xa7ab, 0xa7ab,-1,-42319,
        0xa7ac, 0xa7ac,-1,-42315,
        0xa7ad, 0xa7ad,-1,-42305,
        0xa7b0, 0xa7b0,-1,-42258,
        0xa7b1, 0xa7b1,-1,-42282,
        0xff21, 0xff3a, 1, 32,
        0x10400, 0x10427, 1, 40,
        0x118a0, 0x118bf, 1, 32
    ])

;; Return the folded-case equivalent of "c", which is a UCS-4 character.  Uses simple case folding.

(defn- #_int utf_fold [#_int c]
    (§
;       return utf_convert(c, foldCase);
    ))

(final int* toLower
    [
        0x41, 0x5a, 1, 32,
        0xc0, 0xd6, 1, 32,
        0xd8, 0xde, 1, 32,
        0x100, 0x12e, 2, 1,
        0x130, 0x130,-1,-199,
        0x132, 0x136, 2, 1,
        0x139, 0x147, 2, 1,
        0x14a, 0x176, 2, 1,
        0x178, 0x178,-1,-121,
        0x179, 0x17d, 2, 1,
        0x181, 0x181,-1, 210,
        0x182, 0x184, 2, 1,
        0x186, 0x186,-1, 206,
        0x187, 0x187,-1, 1,
        0x189, 0x18a, 1, 205,
        0x18b, 0x18b,-1, 1,
        0x18e, 0x18e,-1, 79,
        0x18f, 0x18f,-1, 202,
        0x190, 0x190,-1, 203,
        0x191, 0x191,-1, 1,
        0x193, 0x193,-1, 205,
        0x194, 0x194,-1, 207,
        0x196, 0x196,-1, 211,
        0x197, 0x197,-1, 209,
        0x198, 0x198,-1, 1,
        0x19c, 0x19c,-1, 211,
        0x19d, 0x19d,-1, 213,
        0x19f, 0x19f,-1, 214,
        0x1a0, 0x1a4, 2, 1,
        0x1a6, 0x1a6,-1, 218,
        0x1a7, 0x1a7,-1, 1,
        0x1a9, 0x1a9,-1, 218,
        0x1ac, 0x1ac,-1, 1,
        0x1ae, 0x1ae,-1, 218,
        0x1af, 0x1af,-1, 1,
        0x1b1, 0x1b2, 1, 217,
        0x1b3, 0x1b5, 2, 1,
        0x1b7, 0x1b7,-1, 219,
        0x1b8, 0x1bc, 4, 1,
        0x1c4, 0x1c4,-1, 2,
        0x1c5, 0x1c5,-1, 1,
        0x1c7, 0x1c7,-1, 2,
        0x1c8, 0x1c8,-1, 1,
        0x1ca, 0x1ca,-1, 2,
        0x1cb, 0x1db, 2, 1,
        0x1de, 0x1ee, 2, 1,
        0x1f1, 0x1f1,-1, 2,
        0x1f2, 0x1f4, 2, 1,
        0x1f6, 0x1f6,-1,-97,
        0x1f7, 0x1f7,-1,-56,
        0x1f8, 0x21e, 2, 1,
        0x220, 0x220,-1,-130,
        0x222, 0x232, 2, 1,
        0x23a, 0x23a,-1, 10795,
        0x23b, 0x23b,-1, 1,
        0x23d, 0x23d,-1,-163,
        0x23e, 0x23e,-1, 10792,
        0x241, 0x241,-1, 1,
        0x243, 0x243,-1,-195,
        0x244, 0x244,-1, 69,
        0x245, 0x245,-1, 71,
        0x246, 0x24e, 2, 1,
        0x370, 0x372, 2, 1,
        0x376, 0x376,-1, 1,
        0x37f, 0x37f,-1, 116,
        0x386, 0x386,-1, 38,
        0x388, 0x38a, 1, 37,
        0x38c, 0x38c,-1, 64,
        0x38e, 0x38f, 1, 63,
        0x391, 0x3a1, 1, 32,
        0x3a3, 0x3ab, 1, 32,
        0x3cf, 0x3cf,-1, 8,
        0x3d8, 0x3ee, 2, 1,
        0x3f4, 0x3f4,-1,-60,
        0x3f7, 0x3f7,-1, 1,
        0x3f9, 0x3f9,-1,-7,
        0x3fa, 0x3fa,-1, 1,
        0x3fd, 0x3ff, 1,-130,
        0x400, 0x40f, 1, 80,
        0x410, 0x42f, 1, 32,
        0x460, 0x480, 2, 1,
        0x48a, 0x4be, 2, 1,
        0x4c0, 0x4c0,-1, 15,
        0x4c1, 0x4cd, 2, 1,
        0x4d0, 0x52e, 2, 1,
        0x531, 0x556, 1, 48,
        0x10a0, 0x10c5, 1, 7264,
        0x10c7, 0x10cd, 6, 7264,
        0x1e00, 0x1e94, 2, 1,
        0x1e9e, 0x1e9e,-1,-7615,
        0x1ea0, 0x1efe, 2, 1,
        0x1f08, 0x1f0f, 1,-8,
        0x1f18, 0x1f1d, 1,-8,
        0x1f28, 0x1f2f, 1,-8,
        0x1f38, 0x1f3f, 1,-8,
        0x1f48, 0x1f4d, 1,-8,
        0x1f59, 0x1f5f, 2,-8,
        0x1f68, 0x1f6f, 1,-8,
        0x1f88, 0x1f8f, 1,-8,
        0x1f98, 0x1f9f, 1,-8,
        0x1fa8, 0x1faf, 1,-8,
        0x1fb8, 0x1fb9, 1,-8,
        0x1fba, 0x1fbb, 1,-74,
        0x1fbc, 0x1fbc,-1,-9,
        0x1fc8, 0x1fcb, 1,-86,
        0x1fcc, 0x1fcc,-1,-9,
        0x1fd8, 0x1fd9, 1,-8,
        0x1fda, 0x1fdb, 1,-100,
        0x1fe8, 0x1fe9, 1,-8,
        0x1fea, 0x1feb, 1,-112,
        0x1fec, 0x1fec,-1,-7,
        0x1ff8, 0x1ff9, 1,-128,
        0x1ffa, 0x1ffb, 1,-126,
        0x1ffc, 0x1ffc,-1,-9,
        0x2126, 0x2126,-1,-7517,
        0x212a, 0x212a,-1,-8383,
        0x212b, 0x212b,-1,-8262,
        0x2132, 0x2132,-1, 28,
        0x2160, 0x216f, 1, 16,
        0x2183, 0x2183,-1, 1,
        0x24b6, 0x24cf, 1, 26,
        0x2c00, 0x2c2e, 1, 48,
        0x2c60, 0x2c60,-1, 1,
        0x2c62, 0x2c62,-1,-10743,
        0x2c63, 0x2c63,-1,-3814,
        0x2c64, 0x2c64,-1,-10727,
        0x2c67, 0x2c6b, 2, 1,
        0x2c6d, 0x2c6d,-1,-10780,
        0x2c6e, 0x2c6e,-1,-10749,
        0x2c6f, 0x2c6f,-1,-10783,
        0x2c70, 0x2c70,-1,-10782,
        0x2c72, 0x2c75, 3, 1,
        0x2c7e, 0x2c7f, 1,-10815,
        0x2c80, 0x2ce2, 2, 1,
        0x2ceb, 0x2ced, 2, 1,
        0x2cf2, 0xa640, 31054, 1,
        0xa642, 0xa66c, 2, 1,
        0xa680, 0xa69a, 2, 1,
        0xa722, 0xa72e, 2, 1,
        0xa732, 0xa76e, 2, 1,
        0xa779, 0xa77b, 2, 1,
        0xa77d, 0xa77d,-1,-35332,
        0xa77e, 0xa786, 2, 1,
        0xa78b, 0xa78b,-1, 1,
        0xa78d, 0xa78d,-1,-42280,
        0xa790, 0xa792, 2, 1,
        0xa796, 0xa7a8, 2, 1,
        0xa7aa, 0xa7aa,-1,-42308,
        0xa7ab, 0xa7ab,-1,-42319,
        0xa7ac, 0xa7ac,-1,-42315,
        0xa7ad, 0xa7ad,-1,-42305,
        0xa7b0, 0xa7b0,-1,-42258,
        0xa7b1, 0xa7b1,-1,-42282,
        0xff21, 0xff3a, 1, 32,
        0x10400, 0x10427, 1, 40,
        0x118a0, 0x118bf, 1, 32
    ])

(final int* toUpper
    [
        0x61, 0x7a, 1,-32,
        0xb5, 0xb5,-1, 743,
        0xe0, 0xf6, 1,-32,
        0xf8, 0xfe, 1,-32,
        0xff, 0xff,-1, 121,
        0x101, 0x12f, 2,-1,
        0x131, 0x131,-1,-232,
        0x133, 0x137, 2,-1,
        0x13a, 0x148, 2,-1,
        0x14b, 0x177, 2,-1,
        0x17a, 0x17e, 2,-1,
        0x17f, 0x17f,-1,-300,
        0x180, 0x180,-1, 195,
        0x183, 0x185, 2,-1,
        0x188, 0x18c, 4,-1,
        0x192, 0x192,-1,-1,
        0x195, 0x195,-1, 97,
        0x199, 0x199,-1,-1,
        0x19a, 0x19a,-1, 163,
        0x19e, 0x19e,-1, 130,
        0x1a1, 0x1a5, 2,-1,
        0x1a8, 0x1ad, 5,-1,
        0x1b0, 0x1b4, 4,-1,
        0x1b6, 0x1b9, 3,-1,
        0x1bd, 0x1bd,-1,-1,
        0x1bf, 0x1bf,-1, 56,
        0x1c5, 0x1c5,-1,-1,
        0x1c6, 0x1c6,-1,-2,
        0x1c8, 0x1c8,-1,-1,
        0x1c9, 0x1c9,-1,-2,
        0x1cb, 0x1cb,-1,-1,
        0x1cc, 0x1cc,-1,-2,
        0x1ce, 0x1dc, 2,-1,
        0x1dd, 0x1dd,-1,-79,
        0x1df, 0x1ef, 2,-1,
        0x1f2, 0x1f2,-1,-1,
        0x1f3, 0x1f3,-1,-2,
        0x1f5, 0x1f9, 4,-1,
        0x1fb, 0x21f, 2,-1,
        0x223, 0x233, 2,-1,
        0x23c, 0x23c,-1,-1,
        0x23f, 0x240, 1, 10815,
        0x242, 0x247, 5,-1,
        0x249, 0x24f, 2,-1,
        0x250, 0x250,-1, 10783,
        0x251, 0x251,-1, 10780,
        0x252, 0x252,-1, 10782,
        0x253, 0x253,-1,-210,
        0x254, 0x254,-1,-206,
        0x256, 0x257, 1,-205,
        0x259, 0x259,-1,-202,
        0x25b, 0x25b,-1,-203,
        0x25c, 0x25c,-1, 42319,
        0x260, 0x260,-1,-205,
        0x261, 0x261,-1, 42315,
        0x263, 0x263,-1,-207,
        0x265, 0x265,-1, 42280,
        0x266, 0x266,-1, 42308,
        0x268, 0x268,-1,-209,
        0x269, 0x269,-1,-211,
        0x26b, 0x26b,-1, 10743,
        0x26c, 0x26c,-1, 42305,
        0x26f, 0x26f,-1,-211,
        0x271, 0x271,-1, 10749,
        0x272, 0x272,-1,-213,
        0x275, 0x275,-1,-214,
        0x27d, 0x27d,-1, 10727,
        0x280, 0x283, 3,-218,
        0x287, 0x287,-1, 42282,
        0x288, 0x288,-1,-218,
        0x289, 0x289,-1,-69,
        0x28a, 0x28b, 1,-217,
        0x28c, 0x28c,-1,-71,
        0x292, 0x292,-1,-219,
        0x29e, 0x29e,-1, 42258,
        0x345, 0x345,-1, 84,
        0x371, 0x373, 2,-1,
        0x377, 0x377,-1,-1,
        0x37b, 0x37d, 1, 130,
        0x3ac, 0x3ac,-1,-38,
        0x3ad, 0x3af, 1,-37,
        0x3b1, 0x3c1, 1,-32,
        0x3c2, 0x3c2,-1,-31,
        0x3c3, 0x3cb, 1,-32,
        0x3cc, 0x3cc,-1,-64,
        0x3cd, 0x3ce, 1,-63,
        0x3d0, 0x3d0,-1,-62,
        0x3d1, 0x3d1,-1,-57,
        0x3d5, 0x3d5,-1,-47,
        0x3d6, 0x3d6,-1,-54,
        0x3d7, 0x3d7,-1,-8,
        0x3d9, 0x3ef, 2,-1,
        0x3f0, 0x3f0,-1,-86,
        0x3f1, 0x3f1,-1,-80,
        0x3f2, 0x3f2,-1, 7,
        0x3f3, 0x3f3,-1,-116,
        0x3f5, 0x3f5,-1,-96,
        0x3f8, 0x3fb, 3,-1,
        0x430, 0x44f, 1,-32,
        0x450, 0x45f, 1,-80,
        0x461, 0x481, 2,-1,
        0x48b, 0x4bf, 2,-1,
        0x4c2, 0x4ce, 2,-1,
        0x4cf, 0x4cf,-1,-15,
        0x4d1, 0x52f, 2,-1,
        0x561, 0x586, 1,-48,
        0x1d79, 0x1d79,-1, 35332,
        0x1d7d, 0x1d7d,-1, 3814,
        0x1e01, 0x1e95, 2,-1,
        0x1e9b, 0x1e9b,-1,-59,
        0x1ea1, 0x1eff, 2,-1,
        0x1f00, 0x1f07, 1, 8,
        0x1f10, 0x1f15, 1, 8,
        0x1f20, 0x1f27, 1, 8,
        0x1f30, 0x1f37, 1, 8,
        0x1f40, 0x1f45, 1, 8,
        0x1f51, 0x1f57, 2, 8,
        0x1f60, 0x1f67, 1, 8,
        0x1f70, 0x1f71, 1, 74,
        0x1f72, 0x1f75, 1, 86,
        0x1f76, 0x1f77, 1, 100,
        0x1f78, 0x1f79, 1, 128,
        0x1f7a, 0x1f7b, 1, 112,
        0x1f7c, 0x1f7d, 1, 126,
        0x1f80, 0x1f87, 1, 8,
        0x1f90, 0x1f97, 1, 8,
        0x1fa0, 0x1fa7, 1, 8,
        0x1fb0, 0x1fb1, 1, 8,
        0x1fb3, 0x1fb3,-1, 9,
        0x1fbe, 0x1fbe,-1,-7205,
        0x1fc3, 0x1fc3,-1, 9,
        0x1fd0, 0x1fd1, 1, 8,
        0x1fe0, 0x1fe1, 1, 8,
        0x1fe5, 0x1fe5,-1, 7,
        0x1ff3, 0x1ff3,-1, 9,
        0x214e, 0x214e,-1,-28,
        0x2170, 0x217f, 1,-16,
        0x2184, 0x2184,-1,-1,
        0x24d0, 0x24e9, 1,-26,
        0x2c30, 0x2c5e, 1,-48,
        0x2c61, 0x2c61,-1,-1,
        0x2c65, 0x2c65,-1,-10795,
        0x2c66, 0x2c66,-1,-10792,
        0x2c68, 0x2c6c, 2,-1,
        0x2c73, 0x2c76, 3,-1,
        0x2c81, 0x2ce3, 2,-1,
        0x2cec, 0x2cee, 2,-1,
        0x2cf3, 0x2cf3,-1,-1,
        0x2d00, 0x2d25, 1,-7264,
        0x2d27, 0x2d2d, 6,-7264,
        0xa641, 0xa66d, 2,-1,
        0xa681, 0xa69b, 2,-1,
        0xa723, 0xa72f, 2,-1,
        0xa733, 0xa76f, 2,-1,
        0xa77a, 0xa77c, 2,-1,
        0xa77f, 0xa787, 2,-1,
        0xa78c, 0xa791, 5,-1,
        0xa793, 0xa797, 4,-1,
        0xa799, 0xa7a9, 2,-1,
        0xff41, 0xff5a, 1,-32,
        0x10428, 0x1044f, 1,-40,
        0x118c0, 0x118df, 1,-32
    ])

;; Return the lower-case equivalent of "c", which is a UCS-4 character.  Use simple case folding.

(defn- #_int utf_tolower [#_int c]
    (§
;       if (c < 0x80)
;           return asc_tolower(c);

;       return utf_convert(c, toLower);
    ))

;; Return the upper-case equivalent of "c", which is a UCS-4 character.  Use simple case folding.

(defn- #_int utf_toupper [#_int c]
    (§
;       if (c < 0x80)
;           return asc_toupper(c);

;       return utf_convert(c, toUpper);
    ))

(defn- #_boolean utf_islower [#_int c]
    (§
;       if (c < 0x80)
;           return asc_islower(c);

        ;; German sharp s is lower case but has no upper case equivalent.
;       return (utf_toupper(c) != c || c == 0xdf);
    ))

(defn- #_boolean utf_isupper [#_int c]
    (§
;       if (c < 0x80)
;           return asc_isupper(c);

;       return (utf_tolower(c) != c);
    ))

(defn- #_int us__strnicmp [#_Bytes _s1, #_Bytes _s2, #_int _n1, #_int _n2]
    (§
;       int c1, c2;
;       Bytes[] s1 = { _s1 }, s2 = { _s2 };
;       int[] n1 = { _n1 }, n2 = { _n2 };

;       for ( ; ; )
;       {
;           c1 = us_safe_read_char_adv(s1, n1);
;           c2 = us_safe_read_char_adv(s2, n2);

;           if (c1 <= 0 || c2 <= 0)
;               break;

;           if (c1 == c2)
;               continue;

;           int cmp = utf_fold(c1) - utf_fold(c2);
;           if (cmp != 0)
;               return cmp;
;       }

        ;; some string ended or has an incomplete/illegal character sequence

;       if (c1 == 0 || c2 == 0)
;       {
            ;; some string ended. shorter string is smaller
;           if (c1 == 0 && c2 == 0)
;               return 0;

;           return (c1 == 0) ? -1 : 1;
;       }

        ;; Continue with bytewise comparison to produce some result that
        ;; would make comparison operations involving this function transitive.
        ;;
        ;; If only one string had an error, comparison should be made with
        ;; folded version of the other string.  In this case it is enough
        ;; to fold just one character to determine the result of comparison.

;       Bytes buffer = new Bytes(6);

;       if (c1 != -1 && c2 == -1)
;       {
;           n1[0] = utf_char2bytes(utf_fold(c1), buffer);
;           s1[0] = buffer;
;       }
;       else if (c2 != -1 && c1 == -1)
;       {
;           n2[0] = utf_char2bytes(utf_fold(c2), buffer);
;           s2[0] = buffer;
;       }

;       while (0 < n1[0] && 0 < n2[0] && s1[0].at(0) != NUL && s2[0].at(0) != NUL)
;       {
;           int cmp = (int)s1[0].at(0) - (int)s2[0].at(0);
;           if (cmp != 0)
;               return cmp;

;           s1[0] = s1[0].plus(1);
;           s2[0] = s2[0].plus(1);
;           n1[0]--;
;           n2[0]--;
;       }

;       if (0 < n1[0] && s1[0].at(0) == NUL)
;           n1[0] = 0;
;       if (0 < n2[0] && s2[0].at(0) == NUL)
;           n2[0] = 0;

;       if (n1[0] == 0 && n2[0] == 0)
;           return 0;

;       return (n1[0] == 0) ? -1 : 1;
    ))

;; Version of strnicmp() that handles multi-byte characters.
;; Needed for Big5, Shift-JIS and UTF-8 encoding.
;; Returns zero if s1 and s2 are equal (ignoring case),
;; the difference between two characters otherwise.

(defn- #_int us_strnicmp [#_Bytes s1, #_Bytes s2, #_int nn]
    (§
;       return us__strnicmp(s1, s2, nn, nn);
    ))

;; "g8": show bytes of the UTF-8 char under the cursor.
;; Doesn't matter what 'encoding' has been set to.

(defn- #_void show_utf8 []
    (§
;       Bytes p = ml_get_cursor();

        ;; Get the byte length of the char under the cursor, including composing characters.
;       int len = us_ptr2len_cc(p);
;       if (len == 0)
;       {
;           msg(u8("NUL"));
;           return;
;       }

;       int clen = 0, rlen = 0;

;       for (int i = 0; i < len; i++)
;       {
;           if (clen == 0)
;           {
                ;; start of (composing) character, get its length
;               if (0 < i)
;               {
;                   STRCPY(@ioBuff.plus(rlen), u8("+ "));
;                   rlen += 2;
;               }
;               clen = us_ptr2len(p.plus(i));
;           }
            ;; NUL is stored as NL
;           libC.sprintf(@ioBuff.plus(rlen), u8("%02x "), (p.at(i) == NL) ? NUL : p.at(i));
;           --clen;
;           rlen += STRLEN(@ioBuff, rlen);
;           if (IOSIZE - 20 < rlen)
;               break;
;       }

;       msg(@ioBuff);
    ))

(defn- #_int us_head_off [#_Bytes base, #_Bytes p]
    (§
;       if (char_u(p.at(0)) < 0x80)        ;; be quick for ASCII
;           return 0;

;       Bytes q;

        ;; Skip backwards over trailing bytes: 10xx.xxxx
        ;; Skip backwards again if on a composing char.
;       for (q = p; ; q = q.minus(1))
;       {
;           Bytes s;
            ;; Move 's' to the last byte of this char.
;           for (s = q; (char_u(s.at(1)) & 0xc0) == 0x80; s = s.plus(1))
            ;
            ;; Move 'q' to the first byte of this char.
;           while (BLT(base, q) && (char_u(q.at(0)) & 0xc0) == 0x80)
;               q = q.minus(1);
            ;; Check for illegal sequence.  Do allow an illegal byte after where we started.
;           int len = us_byte2len(q.at(0), false);
;           if (len != BDIFF(s, q) + 1 && len != BDIFF(p, q) + 1)
;               return 0;

;           if (BLE(q, base) || !utf_iscomposing(us_ptr2char(q)))
;               break;
;       }

;       return BDIFF(p, q);
    ))

;; Return the offset from "p" to the first byte of a character.  When "p" is
;; at the start of a character 0 is returned, otherwise the offset to the next
;; character.  Can start anywhere in a stream of bytes.

(defn- #_int us_off_next [#_Bytes base, #_Bytes p]
    (§
;       if (char_u(p.at(0)) < 0x80)        ;; be quick for ASCII
;           return 0;

        ;; Find the next character that isn't 10xx.xxxx.
;       int i;
;       for (i = 0; (char_u(p.at(i)) & 0xc0) == 0x80; i++)
        ;
;       if (0 < i)
;       {
            ;; Check for illegal sequence.
;           int j;
;           for (j = 0; BLT(base, p.minus(j)); j++)
;               if ((char_u(p.at(-j)) & 0xc0) != 0x80)
;                   break;
;           if (us_byte2len(p.at(-j), false) != i + j)
;               return 0;
;       }
;       return i;
    ))

;; Return the offset from "p" to the last byte of the character it points into.
;; Can start anywhere in a stream of bytes.

(defn- #_int us_tail_off [#_Bytes base, #_Bytes p]
    (§
;       if (p.at(0) == NUL)
;           return 0;

;       int i, j;

        ;; Find the last character that is 10xx.xxxx.
;       for (i = 0; (char_u(p.at(i + 1)) & 0xc0) == 0x80; i++)
        ;

        ;; Check for illegal sequence.
;       for (j = 0; BLT(base, p.minus(j)); j++)
;           if ((char_u(p.at(-j)) & 0xc0) != 0x80)
;               break;

;       if (us_byte2len(p.at(-j), false) != i + j + 1)
;           return 0;

;       return i;
    ))

;; Find the next illegal byte sequence.

(defn- #_void utf_find_illegal []
    (§
;       pos_C cursor = @curwin.w_cursor;
;       pos_C save_pos = §_pos_C();
;       COPY_pos(save_pos, cursor);

;       for (cursor.coladd = 0; ; cursor.lnum++, cursor.col = 0)
;       {
;           for (Bytes p = ml_get_cursor(); p.at(0) != NUL; )
;           {
                ;; Illegal means that there are not enough trail bytes (checked
                ;; by us_ptr2len()) or too many of them (overlong sequence).
;               int len = us_ptr2len(p);
;               if (0x80 <= char_u(p.at(0)) && (len == 1 || utf_char2len(us_ptr2char(p)) != len))
;               {
;                   cursor.col += BDIFF(p, ml_get_cursor());
;                   return;
;               }
;               p = p.plus(len);
;           }

;           if (cursor.lnum == @curbuf.b_ml.ml_line_count)
;               break;
;       }

        ;; didn't find it: don't move and beep
;       COPY_pos(cursor, save_pos);
;       beep_flush();
    ))

;; Adjust position "*posp" to point to the first byte of a multi-byte character.
;; If it points to a tail byte it's moved backwards to the head byte.

(defn- #_void mb_adjust_pos [#_buffer_C buf, #_pos_C posp]
    (§
;       if (0 < posp.col || 1 < posp.coladd)
;       {
;           Bytes p = ml_get_buf(buf, posp.lnum, false);
;           posp.col -= us_head_off(p, p.plus(posp.col));
            ;; Reset "coladd" when the cursor would be on the right half of a double-wide character.
;           if (posp.coladd == 1
;                   && p.at(posp.col) != TAB
;                   && vim_isprintc(us_ptr2char(p.plus(posp.col)))
;                   && 1 < mb_ptr2cells(p.plus(posp.col)))
;               posp.coladd = 0;
;       }
    ))

;; Backup multi-byte pointer.  Only use with "base" < "p" !
(defn- #_int us_ptr_back [#_Bytes base, #_Bytes p]
    (§
;       return us_head_off(base, p.minus(1)) + 1;
    ))

;; Return a pointer to the character before "*p", if there is one.

(defn- #_Bytes us_prevptr [#_Bytes base, #_Bytes p]
    ;; base: start of the string
    (§
;       if (BLT(base, p))
;           p = p.minus(us_ptr_back(base, p));
;       return p;
    ))

;; Return the character length of "p".
;; Each multi-byte character (with following composing characters) counts as one.

(defn- #_int us_charlen [#_Bytes p]
    (§
;       int count = 0;

;       if (p != null)
;           for ( ; p.at(0) != NUL; p = p.plus(us_ptr2len_cc(p)))
;               count++;

;       return count;
    ))

(final Bytes mb_unescape_buf (Bytes. 6))

;; Try to un-escape a multi-byte character.
;; Used for the "to" and "from" part of a mapping.
;; Return the un-escaped string if it is a multi-byte character,
;; and advance "pp" to just after the bytes that formed it.
;; Return null if no multi-byte char was found.

(defn- #_Bytes mb_unescape [#_Bytes* pp]
    (§
;       Bytes p = pp[0];

        ;; Must translate KB_SPECIAL KS_SPECIAL KE_FILLER to KB_SPECIAL and CSI KS_EXTRA KE_CSI to CSI.
        ;; Maximum length of a utf-8 character is 4 bytes.
;       for (int n = 0, m = 0; p.at(n) != NUL && m < 4; n++)
;       {
;           if (p.at(n) == KB_SPECIAL && p.at(n + 1) == KS_SPECIAL && p.at(n + 2) == KE_FILLER)
;           {
;               mb_unescape_buf.be(m++, KB_SPECIAL);
;               n += 2;
;           }
;           else if (p.at(n) == KB_SPECIAL && p.at(n + 1) == KS_EXTRA && p.at(n + 2) == KE_CSI)
;           {
;               mb_unescape_buf.be(m++, CSI);
;               n += 2;
;           }
;           else if (p.at(n) == KB_SPECIAL)
;               break;                          ;; a special key can't be a multibyte char
;           else
;               mb_unescape_buf.be(m++, p.at(n));
;           mb_unescape_buf.be(m, NUL);

            ;; Return a multi-byte character if it's found.
            ;; An illegal sequence will result in a 1 here.
;           if (1 < us_ptr2len_cc(mb_unescape_buf))
;           {
;               pp[0] = p.plus(n + 1);
;               return mb_unescape_buf;
;           }

            ;; Bail out quickly for ASCII.
;           if (char_u(mb_unescape_buf.at(0)) < 0x80)
;               break;
;       }

;       return null;
    ))

;; Return true if the character at "row"/"col" on the screen
;; is the left side of a double-width character.
;; Caller must make sure "row" and "col" are not invalid!

(defn- #_boolean mb_lefthalve [#_int row, #_int col]
    (§
;       return (1 < utf_off2cells(@lineOffset[row] + col, @lineOffset[row] + @screenColumns));
    ))

;; Correct a position on the screen,
;; if it's the right half of a double-wide char move it to the left half.
;; Returns the corrected column.

(defn- #_int mb_fix_col [#_int col, #_int row]
    (§
;       col = check_col(col);
;       row = check_row(row);

;       if (@screenLines != null && 0 < col && @screenLines.at(@lineOffset[row] + col) == 0)
;           return col - 1;

;       return col;
    ))

;; Find the canonical name for encoding "enc".
;; When the name isn't recognized, returns "enc" itself,
;; but with all lower case characters and '_' replaced with '-'.
;; Returns an allocated string.

(defn- #_Bytes enc_canonize [#_Bytes enc]
    (§
;       if (STRCMP(enc, u8("default")) == 0)
;           return STRDUP(u8("utf-8"));

        ;; copy "enc" to allocated memory, with room for two '-'
;       Bytes r = new Bytes(STRLEN(enc) + 3);

        ;; Make it all lower case and replace '_' with '-'.
;       Bytes p = r;
;       for (Bytes s = enc; s.at(0) != NUL; s = s.plus(1))
;       {
;           if (s.at(0) == (byte)'_')
;               (p = p.plus(1)).be(-1, (byte)'-');
;           else
;               (p = p.plus(1)).be(-1, asc_tolower(s.at(0)));
;       }
;       p.be(0, NUL);

;       return r;
    ))

;; misc.c: functions that didn't seem to fit elsewhere --------------------------------------------

;; Count the size (in window cells) of the indent in the current line.

(defn- #_int get_indent []
    (§
;       return get_indent_str(ml_get_curline(), (int)@curbuf.@b_p_ts, false);
    ))

;; Count the size (in window cells) of the indent in line "lnum".

(defn- #_int get_indent_lnum [#_long lnum]
    (§
;       return get_indent_str(ml_get(lnum), (int)@curbuf.@b_p_ts, false);
    ))

;; count the size (in window cells) of the indent in line "ptr", with 'tabstop' at "ts"

(defn- #_int get_indent_str [#_Bytes ptr, #_int ts, #_boolean list]
    ;; list: if true, count only screen size for tabs
    (§
;       int count = 0;

;       for ( ; ptr.at(0) != NUL; ptr = ptr.plus(1))
;       {
;           if (ptr.at(0) == TAB)
;           {
;               if (!list || lcs_tab1[0] != NUL)       ;; count a tab for what it is worth
;                   count += ts - (count % ts);
;               else
                    ;; In list mode, when tab is not set,
                    ;; count screen char width for Tab, displays: ^I
;                   count += mb_ptr2cells(ptr);
;           }
;           else if (ptr.at(0) == (byte)' ')
;               count++;                            ;; count a space for one
;           else
;               break;
;       }

;       return count;
    ))

;; Set the indent of the current line.
;; Leaves the cursor on the first non-blank in the line.
;; Caller must take care of undo.
;; "flags":
;;      SIN_CHANGED:    call changed_bytes() if the line was changed.
;;      SIN_INSERT:     insert the indent in front of the line.
;;      SIN_UNDO:       save line for undo before changing it.
;; Returns true if the line was changed.

(defn- #_boolean set_indent [#_int size, #_int flags]
    ;; size: measured in spaces
    (§
;       boolean doit = false;
;       int ind_done = 0;                       ;; measured in spaces
;       boolean retval = false;
;       int orig_char_len = -1;                 ;; number of initial whitespace chars
                                                ;; when 'et' and 'pi' are both set

        ;; First check if there is anything to do and compute
        ;; the number of characters needed for the indent.

;       int todo = size;
;       int ind_len = 0;                        ;; measured in characters
;       Bytes oldline = ml_get_curline();
;       Bytes p = oldline;

        ;; Calculate the buffer size for the new indent and check if it isn't already set.

        ;; If 'expandtab' isn't set: use TABs; if both 'expandtab' and
        ;; 'preserveindent' are set: count the number of characters at
        ;; the beginning of the line to be copied.
;       if (!@curbuf.@b_p_et || ((flags & SIN_INSERT) == 0 && @curbuf.@b_p_pi))
;       {
            ;; If 'preserveindent' is set, then reuse as much as possible
            ;; of the existing indent structure for the new indent.
;           if ((flags & SIN_INSERT) == 0 && @curbuf.@b_p_pi)
;           {
;               ind_done = 0;

                ;; count as many characters as we can use
;               while (0 < todo && vim_iswhite(p.at(0)))
;               {
;                   if (p.at(0) == TAB)
;                   {
;                       int tab_pad = (int)@curbuf.@b_p_ts - (ind_done % (int)@curbuf.@b_p_ts);
                        ;; stop if this tab will overshoot the target
;                       if (todo < tab_pad)
;                           break;
;                       todo -= tab_pad;
;                       ind_len++;
;                       ind_done += tab_pad;
;                   }
;                   else
;                   {
;                       --todo;
;                       ind_len++;
;                       ind_done++;
;                   }
;                   p = p.plus(1);
;               }

                ;; Set initial number of whitespace chars to copy
                ;; if we are preserving indent but expandtab is set.
;               if (@curbuf.@b_p_et)
;                   orig_char_len = ind_len;

                ;; Fill to next tabstop with a tab, if possible.
;               int tab_pad = (int)@curbuf.@b_p_ts - (ind_done % (int)@curbuf.@b_p_ts);
;               if (tab_pad <= todo && orig_char_len == -1)
;               {
;                   doit = true;
;                   todo -= tab_pad;
;                   ind_len++;
                    ;; ind_done += tab_pad;
;               }
;           }

            ;; count tabs required for indent
;           while ((int)@curbuf.@b_p_ts <= todo)
;           {
;               if (p.at(0) != TAB)
;                   doit = true;
;               else
;                   p = p.plus(1);
;               todo -= (int)@curbuf.@b_p_ts;
;               ind_len++;
                ;; ind_done += (int)curbuf.b_p_ts[0];
;           }
;       }
        ;; count spaces required for indent
;       while (0 < todo)
;       {
;           if (p.at(0) != (byte)' ')
;               doit = true;
;           else
;               p = p.plus(1);
;           --todo;
;           ind_len++;
            ;; ++ind_done;
;       }

        ;; Return if the indent is OK already.
;       if (!doit && !vim_iswhite(p.at(0)) && (flags & SIN_INSERT) == 0)
;           return false;

        ;; Allocate memory for the new line.
;       if ((flags & SIN_INSERT) != 0)
;           p = oldline;
;       else
;           p = skipwhite(p);
;       int line_len = STRLEN(p) + 1;

        ;; If 'preserveindent' and 'expandtab' are both set keep the original
        ;; characters and allocate accordingly.  We will fill the rest with spaces
        ;; after the if (!curbuf.b_p_et) below.
;       Bytes newline;
;       Bytes s;
;       if (orig_char_len != -1)
;       {
;           newline = new Bytes(orig_char_len + size - ind_done + line_len);

;           todo = size - ind_done;
;           ind_len = orig_char_len + todo;     ;; Set total length of indent in characters,
                                                ;; which may have been undercounted until now
;           p = oldline;
;           s = newline;
;           while (0 < orig_char_len)
;           {
;               (s = s.plus(1)).be(-1, (p = p.plus(1)).at(-1));
;               orig_char_len--;
;           }

            ;; Skip over any additional white space (useful when newindent is less than old).
;           while (vim_iswhite(p.at(0)))
;               p = p.plus(1);
;       }
;       else
;       {
;           todo = size;
;           newline = new Bytes(ind_len + line_len);
;           s = newline;
;       }

        ;; Put the characters in the new line.
        ;; If 'expandtab' isn't set: use TABs.
;       if (!@curbuf.@b_p_et)
;       {
            ;; If 'preserveindent' is set, then reuse as much as possible
            ;; of the existing indent structure for the new indent.
;           if ((flags & SIN_INSERT) == 0 && @curbuf.@b_p_pi)
;           {
;               p = oldline;
;               ind_done = 0;

;               while (0 < todo && vim_iswhite(p.at(0)))
;               {
;                   if (p.at(0) == TAB)
;                   {
;                       int tab_pad = (int)@curbuf.@b_p_ts - (ind_done % (int)@curbuf.@b_p_ts);
                        ;; stop if this tab will overshoot the target
;                       if (todo < tab_pad)
;                           break;
;                       todo -= tab_pad;
;                       ind_done += tab_pad;
;                   }
;                   else
;                   {
;                       --todo;
;                       ind_done++;
;                   }
;                   (s = s.plus(1)).be(-1, (p = p.plus(1)).at(-1));
;               }

                ;; Fill to next tabstop with a tab, if possible.
;               int tab_pad = (int)@curbuf.@b_p_ts - (ind_done % (int)@curbuf.@b_p_ts);
;               if (tab_pad <= todo)
;               {
;                   (s = s.plus(1)).be(-1, TAB);
;                   todo -= tab_pad;
;               }

;               p = skipwhite(p);
;           }

;           while ((int)@curbuf.@b_p_ts <= todo)
;           {
;               (s = s.plus(1)).be(-1, TAB);
;               todo -= (int)@curbuf.@b_p_ts;
;           }
;       }
;       while (0 < todo)
;       {
;           (s = s.plus(1)).be(-1, (byte)' ');
;           --todo;
;       }
;       BCOPY(s, p, line_len);

        ;; Replace the line (unless undo fails).
;       if ((flags & SIN_UNDO) == 0 || u_savesub(@curwin.w_cursor.lnum) == true)
;       {
;           ml_replace(@curwin.w_cursor.lnum, newline, false);
;           if ((flags & SIN_CHANGED) != 0)
;               changed_bytes(@curwin.w_cursor.lnum, 0);
            ;; Correct saved cursor position if it is in this line.
;           if (@saved_cursor.lnum == @curwin.w_cursor.lnum)
;           {
;               if (BDIFF(p, oldline) <= @saved_cursor.col)
                    ;; cursor was after the indent, adjust for the number of bytes added/removed
;                   @saved_cursor.col += ind_len - BDIFF(p, oldline);
;               else if (BDIFF(s, newline) <= @saved_cursor.col)
                    ;; cursor was in the indent and is now after it; put it back
                    ;; at the start of the indent (replacing spaces with TAB)
;                   @saved_cursor.col = BDIFF(s, newline);
;           }
;           retval = true;
;       }

;       @curwin.w_cursor.col = ind_len;
;       return retval;
    ))

;; Copy the indent from ptr to the current line (and fill to size)
;; Leaves the cursor on the first non-blank in the line.
;; Returns true if the line was changed.

(defn- #_boolean copy_indent [#_int size, #_Bytes src]
    (§
;       Bytes p = null;
;       Bytes line = null;
;       int ind_len = 0;	// %% red.
;       int line_len = 0;

        ;; Round 1: compute the number of characters needed for the indent.
        ;; Round 2: copy the characters.
;       for (int round = 1; round <= 2; round++)
;       {
;           int todo = size;
;           ind_len = 0;
;           int ind_done = 0;
;           Bytes s = src;

            ;; Count/copy the usable portion of the source line.
;           while (0 < todo && vim_iswhite(s.at(0)))
;           {
;               if (s.at(0) == TAB)
;               {
;                   int tab_pad = (int)@curbuf.@b_p_ts - (ind_done % (int)@curbuf.@b_p_ts);
                    ;; Stop if this tab will overshoot the target.
;                   if (todo < tab_pad)
;                       break;
;                   todo -= tab_pad;
;                   ind_done += tab_pad;
;               }
;               else
;               {
;                   --todo;
;                   ind_done++;
;               }
;               ind_len++;
;               if (p != null)
;                   (p = p.plus(1)).be(-1, s.at(0));
;               s = s.plus(1);
;           }

            ;; Fill to next tabstop with a tab, if possible.
;           int tab_pad = (int)@curbuf.@b_p_ts - (ind_done % (int)@curbuf.@b_p_ts);
;           if (tab_pad <= todo && !@curbuf.@b_p_et)
;           {
;               todo -= tab_pad;
;               ind_len++;
;               if (p != null)
;                   (p = p.plus(1)).be(-1, TAB);
;           }

            ;; Add tabs required for indent.
;           while ((int)@curbuf.@b_p_ts <= todo && !@curbuf.@b_p_et)
;           {
;               todo -= (int)@curbuf.@b_p_ts;
;               ind_len++;
;               if (p != null)
;                   (p = p.plus(1)).be(-1, TAB);
;           }

            ;; Count/add spaces required for indent.
;           while (0 < todo)
;           {
;               --todo;
;               ind_len++;
;               if (p != null)
;                   (p = p.plus(1)).be(-1, (byte)' ');
;           }

;           if (p == null)
;           {
                ;; Allocate memory for the result:
                ;; the copied indent, new indent and the rest of the line.
;               line_len = STRLEN(ml_get_curline()) + 1;
;               line = new Bytes(ind_len + line_len);
;               p = line;
;           }
;       }

        ;; Append the original line.
;       BCOPY(p, ml_get_curline(), line_len);

        ;; Replace the line.
;       ml_replace(@curwin.w_cursor.lnum, line, false);

        ;; Put the cursor after the indent.
;       @curwin.w_cursor.col = ind_len;
;       return true;
    ))

;; Return the indent of the current line after a number.  Return -1 if no
;; number was found.  Used for 'n' in 'formatoptions': numbered list.
;; Since a pattern is used it can actually handle more than numbers.

(defn- #_int get_number_indent [#_long lnum]
    (§
;       if (@curbuf.b_ml.ml_line_count < lnum)
;           return -1;

;       pos_C pos = §_pos_C();
;       pos.lnum = 0;

        ;; In format_lines() (i.e. not insert mode), fo+=q is needed too...
;       int lead_len = 0;       ;; length of comment leader
;       if ((@State & INSERT) != 0 || has_format_option(FO_Q_COMS))
;           lead_len = get_leader_len(ml_get(lnum), null, false, true);

;       regmatch_C regmatch = §_regmatch_C();
;       regmatch.regprog = vim_regcomp(@curbuf.@b_p_flp, RE_MAGIC);
;       if (regmatch.regprog != null)
;       {
;           regmatch.rm_ic = false;

            ;; vim_regexec() expects a pointer to a line.
            ;; This lets us start matching for the "flp" beyond any comment leader...
;           if (vim_regexec(regmatch, ml_get(lnum).plus(lead_len), 0))
;           {
;               pos.lnum = lnum;
;               pos.col = BDIFF(regmatch.endp[0], ml_get(lnum));
;               pos.coladd = 0;
;           }
;       }

;       if (pos.lnum == 0 || ml_get_pos(pos).at(0) == NUL)
;           return -1;

;       int[] col = new int[1];
;       getvcol(@curwin, pos, col, null, null);
;       return col[0];
    ))

(atom! int      bri_prev_indent)    ;; cached indent value
(atom! long     bri_prev_ts)        ;; cached tabstop value
(atom! Bytes    bri_prev_line)      ;; cached pointer to line
(atom! int      bri_prev_tick)      ;; changedtick of cached value

;; Return appropriate space number for breakindent, taking influencing
;; parameters into account.  Window must be specified, since it is not
;; necessarily always the current one.

(defn- #_int get_breakindent_win [#_window_C wp, #_Bytes line]
    ;; line: start of the line
    (§
;       int bri = 0;
        ;; window width minus window margin space, i.e. what rests for text
;       int eff_wwidth = wp.w_width - (((wp.w_onebuf_opt.@wo_nu || wp.w_onebuf_opt.@wo_rnu) && vim_strbyte(@p_cpo, CPO_NUMCOL) == null) ? number_width(wp) + 1 : 0);

        ;; used cached indent, unless pointer or 'tabstop' changed
;       if (BNE(@bri_prev_line, line) || @bri_prev_ts != wp.w_buffer.@b_p_ts || @bri_prev_tick != wp.w_buffer.b_changedtick)
;       {
;           @bri_prev_line = line;
;           @bri_prev_ts = wp.w_buffer.@b_p_ts;
;           @bri_prev_tick = wp.w_buffer.b_changedtick;
;           @bri_prev_indent = get_indent_str(line, (int)wp.w_buffer.@b_p_ts, wp.w_onebuf_opt.@wo_list);
;       }
;       bri = @bri_prev_indent + wp.w_p_brishift;

        ;; indent minus the length of the showbreak string
;       if (wp.w_p_brisbr)
;           bri -= mb_string2cells(@p_sbr, -1);

        ;; add offset for number column, if 'n' is in 'cpoptions'
;       bri += win_col_off2(wp);

        ;; never indent past left window margin
;       if (bri < 0)
;           bri = 0;
        ;; always leave at least bri_min characters on the left, if text width is sufficient
;       else if (eff_wwidth - wp.w_p_brimin < bri)
;           bri = (eff_wwidth - wp.w_p_brimin < 0) ? 0 : eff_wwidth - wp.w_p_brimin;

;       return bri;
    ))

;; Return true if the string "line" starts with a word from 'cinwords'.

(defn- #_boolean cin_is_cinword [#_Bytes line]
    (§
;       boolean retval = false;

;       int cinw_len = STRLEN(@curbuf.@b_p_cinw) + 1;
;       Bytes cinw_buf = new Bytes(cinw_len);

;       line = skipwhite(line);

;       for (Bytes[] cinw = { @curbuf.@b_p_cinw }; cinw[0].at(0) != NUL; )
;       {
;           int len = copy_option_part(cinw, cinw_buf, cinw_len, u8(","));
;           if (STRNCMP(line, cinw_buf, len) == 0
;                   && (!us_iswordb(line.at(len), @curbuf) || !us_iswordb(line.at(len - 1), @curbuf)))
;           {
;               retval = true;
;               break;
;           }
;       }

;       return retval;
    ))

;; open_line: Add a new line below or above the current line.
;;
;; For VREPLACE mode, we only add a new line when we get to the end of the
;; file, otherwise we just start replacing the next line.
;;
;; Caller must take care of undo.  Since VREPLACE may affect any number of
;; lines however, it may call u_save_cursor() again when starting to change a new line.
;; "flags": OPENLINE_DELSPACES  delete spaces after cursor
;;          OPENLINE_DO_COM     format comments
;;          OPENLINE_KEEPTRAIL  keep trailing spaces
;;          OPENLINE_MARKFIX    adjust mark positions after the line break
;;          OPENLINE_COM_LIST   format comments with list or 2nd line indent
;;
;; "second_line_indent": indent for after ^^D in Insert mode or if flag
;;                        OPENLINE_COM_LIST
;;
;; Return true for success, false for failure

(defn- #_boolean open_line [#_int dir, #_int flags, #_int second_line_indent]
    ;; dir: FORWARD or BACKWARD
    (§
;       boolean retval = false;             ;; return value, default is FAIL

;       boolean do_si = (!@p_paste && @curbuf.@b_p_si && !@curbuf.@b_p_cin);
;       boolean no_si = false;              ;; reset did_si afterwards
;       boolean saved_pi = @curbuf.@b_p_pi;       ;; copy of preserveindent setting

        ;; make a copy of the current line so we can mess with it

;       Bytes saved_line = STRDUP(ml_get_curline());
;       Bytes next_line = null;            ;; copy of the next line

;       if ((@State & VREPLACE_FLAG) != 0)
;       {
            ;; With VREPLACE we make a copy of the next line, which we will be starting to replace.
            ;; First make the new line empty and let vim play with the indenting and comment leader
            ;; to its heart's content.  Then we grab what it ended up putting on the new line, put
            ;; back the original line, and call ins_char() to put each new character onto the line,
            ;; replacing what was there before and pushing the right stuff onto the replace stack.

;           if (@curwin.w_cursor.lnum < @orig_line_count)
;               next_line = STRDUP(ml_get(@curwin.w_cursor.lnum + 1));
;           else
;               next_line = STRDUP(u8(""));

            ;; In VREPLACE mode, a NL replaces the rest of the line, and starts replacing the next line,
            ;; so push all of the characters left on the line onto the replace stack.  We'll push any other
            ;; characters that might be replaced at the start of the next line (due to autoindent, etc.)
            ;; a bit later.

;           replace_push(NUL);      ;; call twice because BS over NL expects it
;           replace_push(NUL);
;           for (Bytes s = saved_line.plus(@curwin.w_cursor.col); s.at(0) != NUL; )
;               s = s.plus(replace_push_mb(s));
;           saved_line.be(@curwin.w_cursor.col, NUL);
;       }

;       Bytes p_extra = null;              ;; what goes to next line
;       int first_char = NUL;
;       int extra_len = 0;                  ;; length of "p_extra" string
;       int saved_char = NUL;

;       if ((@State & INSERT) != 0 && (@State & VREPLACE_FLAG) == 0)
;       {
;           p_extra = saved_line.plus(@curwin.w_cursor.col);
;           if (do_si)              ;; need first char after new line break
;           {
;               Bytes p = skipwhite(p_extra);
;               first_char = p.at(0);
;           }
;           extra_len = STRLEN(p_extra);
;           saved_char = p_extra.at(0);
;           p_extra.be(0, NUL);
;       }

;       u_clearline();              ;; cannot do "U" command when adding lines
;       @did_si = false;
;       @ai_col = 0;

        ;; If we just did an auto-indent, then we didn't type anything on the
        ;; prior line, and it should be truncated.  Do this even if 'ai' is not set
        ;; because automatically inserting a comment leader also sets did_ai.

;       boolean trunc_line = false;         ;; truncate current line afterwards
;       if (dir == FORWARD && @did_ai)
;           trunc_line = true;

;       pos_C old_cursor = §_pos_C();     ;; old cursor position

;       int newindent = 0;                  ;; auto-indent of the new line

        ;; If 'autoindent' and/or 'smartindent' is set, try to figure out what
        ;; indent to use for the new line.

;       if (@curbuf.@b_p_ai || do_si)
;       {
            ;; count white space on current line

;           newindent = get_indent_str(saved_line, (int)@curbuf.@b_p_ts, false);
;           if (newindent == 0 && (flags & OPENLINE_COM_LIST) == 0)
;               newindent = second_line_indent; ;; for ^^D command in insert mode

            ;; Do smart indenting.
            ;; In insert/replace mode (only when dir == FORWARD)
            ;; we may move some text to the next line.  If it starts with '{'
            ;; don't add an indent.  Fixes inserting a NL before '{' in line
            ;;      "if (condition) {"

;           if (!trunc_line && do_si && saved_line.at(0) != NUL && (p_extra == null || first_char != '{'))
;           {
;               COPY_pos(old_cursor, @curwin.w_cursor);

;               int lead_len;                   ;; length of comment leader
;               Bytes s = saved_line;
;               if ((flags & OPENLINE_DO_COM) != 0)
;                   lead_len = get_leader_len(s, null, false, true);
;               else
;                   lead_len = 0;

;               if (dir == FORWARD)
;               {
                    ;; Skip preprocessor directives, unless they are recognised as comments.

;                   if (lead_len == 0 && s.at(0) == (byte)'#')
;                   {
;                       while (s.at(0) == (byte)'#' && 1 < @curwin.w_cursor.lnum)
;                           s = ml_get(--@curwin.w_cursor.lnum);
;                       newindent = get_indent();
;                   }
;                   if ((flags & OPENLINE_DO_COM) != 0)
;                       lead_len = get_leader_len(s, null, false, true);
;                   else
;                       lead_len = 0;
;                   if (0 < lead_len)
;                   {
                        ;; This case gets the following right:
                        ;;      \*
                        ;;       * A comment (read '\' as '/').
                        ;;       *\
                        ;; #define IN_THE_WAY
                        ;;      This should line up here;

;                       Bytes p = skipwhite(s);
;                       if (p.at(0) == (byte)'/' && p.at(1) == (byte)'*')
;                           p = p.plus(1);
;                       if (p.at(0) == (byte)'*')
;                       {
;                           for (p = p.plus(1); p.at(0) != NUL; p = p.plus(1))
;                           {
;                               if (p.at(0) == (byte)'/' && p.at(-1) == (byte)'*')
;                               {
                                    ;; End of C comment, indent should line up with
                                    ;; the line containing the start of the comment.

;                                   @curwin.w_cursor.col = BDIFF(p, s);
;                                   pos_C pos = findmatch(null, NUL);
;                                   if (pos != null)
;                                   {
;                                       @curwin.w_cursor.lnum = pos.lnum;
;                                       newindent = get_indent();
;                                   }
;                               }
;                           }
;                       }
;                   }
;                   else    ;; Not a comment line.
;                   {
                        ;; Find last non-blank in line.
;                       Bytes p = s.plus(STRLEN(s) - 1);
;                       while (BLT(s, p) && vim_iswhite(p.at(0)))
;                           p = p.minus(1);
;                       byte last_char = p.at(0);

                        ;; find the character just before the '{' or ';'

;                       if (last_char == '{' || last_char == ';')
;                       {
;                           if (BLT(s, p))
;                               p = p.minus(1);
;                           while (BLT(s, p) && vim_iswhite(p.at(0)))
;                               p = p.minus(1);
;                       }

                        ;; Try to catch lines that are split over multiple
                        ;; lines.  eg:
                        ;;      if (condition &&
                        ;;                  condition) {
                        ;;          Should line up here!
                        ;;      }

;                       if (p.at(0) == (byte)')')
;                       {
;                           @curwin.w_cursor.col = BDIFF(p, s);
;                           pos_C pos = findmatch(null, '(');
;                           if (pos != null)
;                           {
;                               @curwin.w_cursor.lnum = pos.lnum;
;                               newindent = get_indent();
;                               s = ml_get_curline();
;                           }
;                       }

                        ;; If last character is '{' do indent, without checking for "if" and the like.

;                       if (last_char == '{')
;                       {
;                           @did_si = true;  ;; do indent
;                           no_si = true;   ;; don't delete it when '{' typed
;                       }

                        ;; Look for "if" and the like, use 'cinwords'.
                        ;; Don't do this if the previous line ended in ';' or '}'.

;                       else if (last_char != ';' && last_char != '}' && cin_is_cinword(s))
;                           @did_si = true;
;                   }
;               }
;               else ;; dir == BACKWARD
;               {
                    ;; Skip preprocessor directives, unless they are recognised as comments.

;                   if (lead_len == 0 && s.at(0) == (byte)'#')
;                   {
;                       boolean was_backslashed = false;

;                       while ((s.at(0) == (byte)'#' || was_backslashed)
;                           && @curwin.w_cursor.lnum < @curbuf.b_ml.ml_line_count)
;                       {
;                           was_backslashed = (s.at(0) != NUL && s.at(STRLEN(s) - 1) == '\\');
;                           s = ml_get(++@curwin.w_cursor.lnum);
;                       }
;                       if (was_backslashed)
;                           newindent = 0;              ;; got to end of file
;                       else
;                           newindent = get_indent();
;                   }
;                   Bytes p = skipwhite(s);
;                   if (p.at(0) == (byte)'}')                      ;; if line starts with '}': do indent
;                       @did_si = true;
;                   else                                ;; can delete indent when '{' typed
;                       @can_si_back = true;
;               }

;               COPY_pos(@curwin.w_cursor, old_cursor);
;           }
;           if (do_si)
;               @can_si = true;

;           @did_ai = true;
;       }

;       Bytes allocated = null;            ;; allocated memory

;       int lead_len;                       ;; length of comment leader
;       Bytes[] lead_flags = new Bytes[1];                  ;; position in 'comments' for comment leader
;       Bytes leader = null;               ;; copy of comment leader

;       int newcol = 0;                     ;; new cursor column

        ;; Find out if the current line starts with a comment leader.
        ;; This may then be inserted in front of the new line.

;       @end_comment_pending = NUL;
;       if ((flags & OPENLINE_DO_COM) != 0)
;           lead_len = get_leader_len(saved_line, lead_flags, dir == BACKWARD, true);
;       else
;           lead_len = 0;
;       if (0 < lead_len)
;       {
;           Bytes lead_repl = null;                    ;; replaces comment leader
;           int lead_repl_len = 0;                      ;; length of *lead_repl
;           Bytes lead_middle = new Bytes(COM_MAX_LEN); ;; middle-comment string
;           Bytes lead_end = new Bytes(COM_MAX_LEN);    ;; end-comment string
;           Bytes comment_end = null;                  ;; where lead_end has been found
;           boolean extra_space = false;                ;; append extra space
;           boolean require_blank = false;              ;; requires blank after middle

            ;; If the comment leader has the start, middle or end flag,
            ;; it may not be used or may be replaced with the middle leader.

;           for (Bytes[] p = { lead_flags[0] }; p[0].at(0) != NUL && p[0].at(0) != (byte)':'; p[0] = p[0].plus(1))
;           {
;               if (p[0].at(0) == COM_BLANK)
;               {
;                   require_blank = true;
;                   continue;
;               }
;               if (p[0].at(0) == COM_START || p[0].at(0) == COM_MIDDLE)
;               {
;                   byte current_flag = p[0].at(0);
;                   if (p[0].at(0) == COM_START)
;                   {
                        ;; Doing "O" on a start of comment does not insert leader.

;                       if (dir == BACKWARD)
;                       {
;                           lead_len = 0;
;                           break;
;                       }

                        ;; find start of middle part
;                       copy_option_part(p, lead_middle, COM_MAX_LEN, u8(","));
;                       require_blank = false;
;                   }

                    ;; Isolate the strings of the middle and end leader.

;                   while (p[0].at(0) != NUL && p[0].at(-1) != (byte)':')          ;; find end of middle flags
;                   {
;                       if (p[0].at(0) == COM_BLANK)
;                           require_blank = true;
;                       p[0] = p[0].plus(1);
;                   }
;                   copy_option_part(p, lead_middle, COM_MAX_LEN, u8(","));

;                   while (p[0].at(0) != NUL && p[0].at(-1) != (byte)':')          ;; find end of end flags
;                   {
                        ;; Check whether we allow automatic ending of comments.
;                       if (p[0].at(0) == COM_AUTO_END)
;                           @end_comment_pending = -1;   ;; means we want to set it
;                       p[0] = p[0].plus(1);
;                   }
;                   int n = copy_option_part(p, lead_end, COM_MAX_LEN, u8(","));

;                   if (@end_comment_pending == -1)      ;; we can set it now
;                       @end_comment_pending = lead_end.at(n - 1);

                    ;; If the end of the comment is in the same line, don't use the comment leader.

;                   if (dir == FORWARD)
;                   {
;                       for (p[0] = saved_line.plus(lead_len); p[0].at(0) != NUL; p[0] = p[0].plus(1))
;                           if (STRNCMP(p[0], lead_end, n) == 0)
;                           {
;                               comment_end = p[0];
;                               lead_len = 0;
;                               break;
;                           }
;                   }

                    ;; Doing "o" on a start of comment inserts the middle leader.

;                   if (0 < lead_len)
;                   {
;                       if (current_flag == COM_START)
;                       {
;                           lead_repl = lead_middle;
;                           lead_repl_len = STRLEN(lead_middle);
;                       }

                        ;; If we have hit RETURN immediately after the start comment leader,
                        ;; then put a space after the middle comment leader on the next line.

;                       if (!vim_iswhite(saved_line.at(lead_len - 1))
;                               && ((p_extra != null && @curwin.w_cursor.col == lead_len)
;                                   || (p_extra == null && saved_line.at(lead_len) == NUL)
;                                   || require_blank))
;                           extra_space = true;
;                   }
;                   break;
;               }
;               if (p[0].at(0) == COM_END)
;               {
                    ;; Doing "o" on the end of a comment does not insert leader.
                    ;; Remember where the end is, might want to use it to find the
                    ;; start (for C-comments).

;                   if (dir == FORWARD)
;                   {
;                       comment_end = skipwhite(saved_line);
;                       lead_len = 0;
;                       break;
;                   }

                    ;; Doing "O" on the end of a comment inserts the middle leader.
                    ;; Find the string for the middle leader, searching backwards.

;                   while (BLT(@curbuf.@b_p_com, p[0]) && p[0].at(0) != (byte)',')
;                       p[0] = p[0].minus(1);
;                   for (lead_repl = p[0]; BLT(@curbuf.@b_p_com, lead_repl) && lead_repl.at(-1) != (byte)':'; lead_repl = lead_repl.minus(1))
                    ;
;                   lead_repl_len = BDIFF(p[0], lead_repl);

                    ;; We can probably always add an extra space when doing "O" on the comment-end.
;                   extra_space = true;

                    ;; Check whether we allow automatic ending of comments.
;                   Bytes p2;
;                   for (p2 = p[0]; p2.at(0) != NUL && p2.at(0) != (byte)':'; p2 = p2.plus(1))
;                   {
;                       if (p2.at(0) == COM_AUTO_END)
;                           @end_comment_pending = -1;   ;; means we want to set it
;                   }
;                   if (@end_comment_pending == -1)
;                   {
                        ;; Find last character in end-comment string.
;                       while (p2.at(0) != NUL && p2.at(0) != (byte)',')
;                           p2 = p2.plus(1);
;                       @end_comment_pending = p2.at(-1);
;                   }
;                   break;
;               }
;               if (p[0].at(0) == COM_FIRST)
;               {
                    ;; Comment leader for first line only:
                    ;; don't repeat leader when using "O",
                    ;; blank out leader when using "o".

;                   if (dir == BACKWARD)
;                       lead_len = 0;
;                   else
;                   {
;                       lead_repl = u8("");
;                       lead_repl_len = 0;
;                   }
;                   break;
;               }
;           }

;           if (0 < lead_len)
;           {
                ;; allocate buffer (may concatenate "p_extra" later)
;               leader = new Bytes(lead_len + lead_repl_len + (extra_space ? 1 : 0) + extra_len + (0 < second_line_indent ? second_line_indent : 0) + 1);
;               allocated = leader;             ;; remember to free it later

;               if (leader == null)
;                   lead_len = 0;
;               else
;               {
;                   vim_strncpy(leader, saved_line, lead_len);

                    ;; Replace leader with "lead_repl", right or left adjusted.

;                   if (lead_repl != null)
;                   {
;                       int c = 0;
;                       int off = 0;

;                       for (Bytes p = lead_flags[0]; p.at(0) != NUL && p.at(0) != (byte)':'; )
;                       {
;                           if (p.at(0) == COM_RIGHT || p.at(0) == COM_LEFT)
;                               c = (p = p.plus(1)).at(-1);
;                           else if (asc_isdigit(p.at(0)) || p.at(0) == (byte)'-')
;                           {
;                               Bytes[] __ = { p }; off = (int)getdigits(__); p = __[0];
;                           }
;                           else
;                               p = p.plus(1);
;                       }
;                       if (c == COM_RIGHT)     ;; right adjusted leader
;                       {
                            ;; find last non-white in the leader to line up with
;                           Bytes p;
;                           for (p = leader.plus(lead_len - 1); BLT(leader, p) && vim_iswhite(p.at(0)); p = p.minus(1))
                            ;
;                           p = p.plus(1);

                            ;; Compute the length of the replaced characters in
                            ;; screen characters, not bytes.
;                           {
;                               int repl_size = mb_string2cells(lead_repl, lead_repl_len);
;                               int old_size = 0;
;                               Bytes endp = p;

;                               while (old_size < repl_size && BLT(leader, p))
;                               {
;                                   p = p.minus(us_ptr_back(leader, p));
;                                   old_size += mb_ptr2cells(p);
;                               }
;                               int l = lead_repl_len - BDIFF(endp, p);
;                               if (l != 0)
;                                   BCOPY(endp, l, endp, 0, BDIFF(leader, endp) + lead_len);
;                               lead_len += l;
;                           }
;                           BCOPY(p, lead_repl, lead_repl_len);
;                           if (BLT(leader.plus(lead_len), p.plus(lead_repl_len)))
;                               p.be(lead_repl_len, NUL);

                            ;; Blank-out any other chars from the old leader.
;                           for (p = p.minus(1); BLE(leader, p); p = p.minus(1))
;                           {
;                               int l = us_head_off(leader, p);

;                               if (1 < l)
;                               {
;                                   p = p.minus(l);
;                                   if (1 < mb_ptr2cells(p))
;                                   {
;                                       p.be(1, (byte)' ');
;                                       --l;
;                                   }
;                                   Bytes pl = p.plus(l);
;                                   BCOPY(p, 1, pl, 1, BDIFF(leader.plus(lead_len), pl.plus(1)));
;                                   lead_len -= l;
;                                   p.be(0, (byte)' ');
;                               }
;                               else if (!vim_iswhite(p.at(0)))
;                                   p.be(0, (byte)' ');
;                           }
;                       }
;                       else                    ;; left adjusted leader
;                       {
;                           Bytes p = skipwhite(leader);
                            ;; Compute the length of the replaced characters in screen characters,
                            ;; not bytes.  Move the part that is not to be overwritten.
;                           {
;                               int repl_size = mb_string2cells(lead_repl, lead_repl_len);

;                               int i, l;
;                               for (i = 0; p.at(i) != NUL && i < lead_len; i += l)
;                               {
;                                   l = us_ptr2len_cc(p.plus(i));
;                                   if (repl_size < mb_string2cells(p, i + l))
;                                       break;
;                               }
;                               if (i != lead_repl_len)
;                               {
;                                   BCOPY(p, lead_repl_len, p, i, BDIFF(leader.plus(lead_len), p.plus(i)));
;                                   lead_len += lead_repl_len - i;
;                               }
;                           }
;                           BCOPY(p, lead_repl, lead_repl_len);

                            ;; Replace any remaining non-white chars in the old leader by spaces.
                            ;; Keep Tabs, the indent must remain the same.
;                           for (p = p.plus(lead_repl_len); BLT(p, leader.plus(lead_len)); p = p.plus(1))
;                               if (!vim_iswhite(p.at(0)))
;                               {
                                    ;; Don't put a space before a TAB.
;                                   if (BLT(p.plus(1), leader.plus(lead_len)) && p.at(1) == TAB)
;                                   {
;                                       --lead_len;
;                                       BCOPY(p, 0, p, 1, BDIFF(leader.plus(lead_len), p));
;                                   }
;                                   else
;                                   {
;                                       int l = us_ptr2len_cc(p);

;                                       if (1 < l)
;                                       {
;                                           if (1 < mb_ptr2cells(p))
;                                           {
                                                ;; Replace a double-wide char with two spaces.
;                                               --l;
;                                               (p = p.plus(1)).be(-1, (byte)' ');
;                                           }
;                                           BCOPY(p, 1, p, l, BDIFF(leader.plus(lead_len), p));
;                                           lead_len -= l - 1;
;                                       }
;                                       p.be(0, (byte)' ');
;                                   }
;                               }
;                           p.be(0, NUL);
;                       }

                        ;; Recompute the indent, it may have changed.
;                       if (@curbuf.@b_p_ai || do_si)
;                           newindent = get_indent_str(leader, (int)@curbuf.@b_p_ts, false);

                        ;; Add the indent offset.
;                       if (newindent + off < 0)
;                       {
;                           off = -newindent;
;                           newindent = 0;
;                       }
;                       else
;                           newindent += off;

                        ;; Correct trailing spaces for the shift,
                        ;; so that alignment remains equal.
;                       while (0 < off && 0 < lead_len && leader.at(lead_len - 1) == (byte)' ')
;                       {
                            ;; Don't do it when there is a tab before the space.
;                           if (vim_strchr(skipwhite(leader), '\t') != null)
;                               break;
;                           --lead_len;
;                           --off;
;                       }

                        ;; If the leader ends in white space, don't add an extra space.
;                       if (0 < lead_len && vim_iswhite(leader.at(lead_len - 1)))
;                           extra_space = false;
;                       leader.be(lead_len, NUL);
;                   }

;                   if (extra_space)
;                   {
;                       leader.be(lead_len++, (byte)' ');
;                       leader.be(lead_len, NUL);
;                   }

;                   newcol = lead_len;

                    ;; If a new indent will be set below,
                    ;; remove the indent that is in the comment leader.

;                   if (newindent != 0 || @did_si)
;                   {
;                       while (0 < lead_len && vim_iswhite(leader.at(0)))
;                       {
;                           --lead_len;
;                           --newcol;
;                           leader = leader.plus(1);
;                       }
;                   }
;               }
;               @did_si = @can_si = false;
;           }
;           else if (comment_end != null)
;           {
                ;; We have finished a comment, so we don't use the leader.
                ;; If this was a C-comment and 'ai' or 'si' is set do a normal
                ;; indent to align with the line containing the start of the comment.

;               if (comment_end.at(0) == (byte)'*' && comment_end.at(1) == (byte)'/' && (@curbuf.@b_p_ai || do_si))
;               {
;                   COPY_pos(old_cursor, @curwin.w_cursor);
;                   @curwin.w_cursor.col = BDIFF(comment_end, saved_line);
;                   pos_C pos = findmatch(null, NUL);
;                   if (pos != null)
;                   {
;                       @curwin.w_cursor.lnum = pos.lnum;
;                       newindent = get_indent();
;                   }
;                   COPY_pos(@curwin.w_cursor, old_cursor);
;               }
;           }
;       }

;       int less_cols_off = 0;              ;; columns to skip for mark adjust
;       int less_cols = 0;                  ;; less columns for mark in new line

        ;; (State == INSERT || State == REPLACE), only when dir == FORWARD
;       if (p_extra != null)
;       {
;           p_extra.be(0, saved_char);          ;; restore char that NUL replaced

            ;; When 'ai' set or "flags" has OPENLINE_DELSPACES, skip to the first non-blank.
            ;;
            ;; When in REPLACE mode, put the deleted blanks on the replace stack,
            ;; preceded by a NUL, so they can be put back when a BS is entered.

;           if ((@State & REPLACE_FLAG) != 0 && (@State & VREPLACE_FLAG) == 0)
;               replace_push(NUL);      ;; end of extra blanks
;           if (@curbuf.@b_p_ai || (flags & OPENLINE_DELSPACES) != 0)
;           {
;               while ((p_extra.at(0) == (byte)' ' || p_extra.at(0) == (byte)'\t') && !utf_iscomposing(us_ptr2char(p_extra.plus(1))))
;               {
;                   if ((@State & REPLACE_FLAG) != 0 && (@State & VREPLACE_FLAG) == 0)
;                       replace_push(p_extra.at(0));
;                   p_extra = p_extra.plus(1);
;                   less_cols_off++;
;               }
;           }
;           if (p_extra.at(0) != NUL)
;               @did_ai = false;             ;; append some text, don't truncate now

            ;; columns for marks adjusted for removed columns
;           less_cols = BDIFF(p_extra, saved_line);
;       }

;       if (p_extra == null)
;           p_extra = u8("");                   ;; append empty line

        ;; concatenate leader and "p_extra", if there is a leader
;       if (0 < lead_len)
;       {
;           if ((flags & OPENLINE_COM_LIST) != 0 && 0 < second_line_indent)
;           {
;               int i;
;               int padding = second_line_indent - (newindent + STRLEN(leader));

                ;; Here whitespace is inserted after the comment char.
                ;; Below, set_indent(newindent, SIN_INSERT) will insert
                ;; the whitespace needed before the comment char.
;               for (i = 0; i < padding; i++)
;               {
;                   STRCAT(leader, u8(" "));
;                   less_cols--;
;                   newcol++;
;               }
;           }
;           STRCAT(leader, p_extra);
;           p_extra = leader;
;           @did_ai = true;                  ;; so truncating blanks works with comments
;           less_cols -= lead_len;
;       }
;       else
;           @end_comment_pending = NUL;      ;; turns out there was no leader

;       COPY_pos(old_cursor, @curwin.w_cursor);
;       if (dir == BACKWARD)
;           --@curwin.w_cursor.lnum;

;       theend:
;       {
;           boolean did_append;
;           if ((@State & VREPLACE_FLAG) == 0 || @orig_line_count <= old_cursor.lnum)
;           {
;               if (!ml_append(@curwin.w_cursor.lnum, p_extra, 0, false))
;                   break theend;
                ;; Postpone calling changed_lines(), because it would mess up folding with markers.
;               mark_adjust(@curwin.w_cursor.lnum + 1, MAXLNUM, 1L, 0L);
;               did_append = true;
;           }
;           else
;           {
                ;; In VREPLACE mode we are starting to replace the next line.

;               @curwin.w_cursor.lnum++;
;               if (@insStart.lnum + @vr_lines_changed <= @curwin.w_cursor.lnum)
;               {
                    ;; In case we NL to a new line, BS to the previous one, and NL
                    ;; again, we don't want to save the new line for undo twice.

;                   u_save_cursor();            ;; errors are ignored!
;                   @vr_lines_changed++;
;               }
;               ml_replace(@curwin.w_cursor.lnum, p_extra, true);
;               changed_bytes(@curwin.w_cursor.lnum, 0);
;               --@curwin.w_cursor.lnum;
;               did_append = false;
;           }

;           if (newindent != 0 || @did_si)
;           {
;               @curwin.w_cursor.lnum++;
;               if (@did_si)
;               {
;                   int sw = (int)get_sw_value(@curbuf);

;                   if (@p_sr)
;                       newindent -= newindent % sw;
;                   newindent += sw;
;               }
                ;; Copy the indent.
;               if (@curbuf.@b_p_ci)
;               {
;                   copy_indent(newindent, saved_line);

                    ;; Set the 'preserveindent' option so that any further screwing
                    ;; with the line doesn't entirely destroy our efforts to preserve it.
                    ;; It gets restored at the function end.

;                   @curbuf.@b_p_pi = true;
;               }
;               else
;                   set_indent(newindent, SIN_INSERT);
;               less_cols -= @curwin.w_cursor.col;

;               @ai_col = @curwin.w_cursor.col;

                ;; In REPLACE mode, for each character in the new indent, there must
                ;; be a NUL on the replace stack, for when it is deleted with BS.

;               if ((@State & REPLACE_FLAG) != 0 && (@State & VREPLACE_FLAG) == 0)
;                   for (int n = 0; n < @curwin.w_cursor.col; n++)
;                       replace_push(NUL);
;               newcol += @curwin.w_cursor.col;
;               if (no_si)
;                   @did_si = false;
;           }

            ;; In REPLACE mode, for each character in the extra leader, there must
            ;; be a NUL on the replace stack, for when it is deleted with BS.

;           if ((@State & REPLACE_FLAG) != 0 && (@State & VREPLACE_FLAG) == 0)
;               while (0 < lead_len--)
;                   replace_push(NUL);

;           COPY_pos(@curwin.w_cursor, old_cursor);

;           if (dir == FORWARD)
;           {
;               if (trunc_line || (@State & INSERT) != 0)
;               {
                    ;; truncate current line at cursor
;                   saved_line.be(@curwin.w_cursor.col, NUL);
                    ;; Remove trailing white space, unless OPENLINE_KEEPTRAIL used.
;                   if (trunc_line && (flags & OPENLINE_KEEPTRAIL) == 0)
;                       truncate_spaces(saved_line);
;                   ml_replace(@curwin.w_cursor.lnum, saved_line, false);
;                   saved_line = null;
;                   if (did_append)
;                   {
;                       changed_lines(@curwin.w_cursor.lnum, @curwin.w_cursor.col, @curwin.w_cursor.lnum + 1, 1L);
;                       did_append = false;

                        ;; Move marks after the line break to the new line.
;                       if ((flags & OPENLINE_MARKFIX) != 0)
;                           mark_col_adjust(@curwin.w_cursor.lnum,
;                                           @curwin.w_cursor.col + less_cols_off, 1L, (long)-less_cols);
;                   }
;                   else
;                       changed_bytes(@curwin.w_cursor.lnum, @curwin.w_cursor.col);
;               }

                ;; Put the cursor on the new line.
                ;; Careful: the scrollup() above may have moved w_cursor, we must use old_cursor.

;               @curwin.w_cursor.lnum = old_cursor.lnum + 1;
;           }
;           if (did_append)
;               changed_lines(@curwin.w_cursor.lnum, 0, @curwin.w_cursor.lnum, 1L);

;           @curwin.w_cursor.col = newcol;
;           @curwin.w_cursor.coladd = 0;

            ;; In VREPLACE mode, we are handling the replace stack ourselves,
            ;; so stop fixthisline() from doing it (via change_indent()) by
            ;; telling it we're in normal INSERT mode.

;           int vreplace_mode;
;           if ((@State & VREPLACE_FLAG) != 0)
;           {
;               vreplace_mode = @State;          ;; so we know to put things right later
;               @State = INSERT;
;           }
;           else
;               vreplace_mode = 0;

            ;; May do lisp indenting.

;           if (!@p_paste && leader == null && @curbuf.@b_p_lisp && @curbuf.@b_p_ai)
;           {
;               fixthisline(get_lisp_indent);
;               Bytes p = ml_get_curline();
;               @ai_col = BDIFF(skipwhite(p), p);
;           }

            ;; May do indenting after opening a new line.

;           if (!@p_paste
;                   && @curbuf.@b_p_cin
;                   && in_cinkeys(dir == FORWARD
;                       ? KEY_OPEN_FORW
;                       : KEY_OPEN_BACK, ' ', linewhite(@curwin.w_cursor.lnum)))
;           {
;               do_c_expr_indent();
;               Bytes p = ml_get_curline();
;               @ai_col = BDIFF(skipwhite(p), p);
;           }
;           if (vreplace_mode != 0)
;               @State = vreplace_mode;

            ;; Finally, VREPLACE gets the stuff on the new line, then puts back the
            ;; original line, and inserts the new stuff char by char, pushing old stuff
            ;; onto the replace stack (via ins_char()).

;           if ((@State & VREPLACE_FLAG) != 0)
;           {
                ;; Put new line in "p_extra".
;               p_extra = STRDUP(ml_get_curline());

                ;; Put back original line.
;               ml_replace(@curwin.w_cursor.lnum, next_line, false);

                ;; Insert new stuff into line again.
;               @curwin.w_cursor.col = 0;
;               @curwin.w_cursor.coladd = 0;
;               ins_bytes(p_extra);             ;; will call changed_bytes()
;               next_line = null;
;           }

;           retval = true;              ;; success!
;       }

;       @curbuf.@b_p_pi = saved_pi;
;       return retval;
    ))

;; get_leader_len() returns the length in bytes of the prefix of the given string,
;; which introduces a comment.  If this string is not a comment then 0 is returned.
;; When "flags" is not null, it is set to point to the flags of the recognized comment leader.
;; "backward" must be true for the "O" command.
;; If "include_space" is set, include trailing whitespace while calculating the length.

(defn- #_int get_leader_len [#_Bytes line, #_Bytes* flags, #_boolean backward, #_boolean include_space]
    (§
;       int length = 0;

;       int i = length;
;       while (vim_iswhite(line.at(i)))                ;; leading white space is ignored
;           i++;

;       Bytes part_buf = new Bytes(COM_MAX_LEN);    ;; buffer for one option part

;       boolean got_com = false;
;       int middle_match_len = 0;
;       Bytes saved_flags = null;

        ;; Repeat to match several nested comment strings.

;       while (line.at(i) != NUL)
;       {
            ;; Scan through the 'comments' option for a match.

;           boolean found_one = false;
;           for (Bytes[] p = { @curbuf.@b_p_com }; p[0].at(0) != NUL; )
;           {
;               if (!got_com && flags != null)
;                   flags[0] = p[0];                ;; remember where flags started
;               Bytes q = p[0];
;               copy_option_part(p, part_buf, COM_MAX_LEN, u8(","));

;               Bytes s = vim_strchr(part_buf, ':');
;               if (s == null)              ;; missing ':', ignore this part
;                   continue;
;               (s = s.plus(1)).be(-1, NUL);        ;; isolate flags from string

                ;; If we found a middle match previously, use that match when this is not a middle or end.
;               if (middle_match_len != 0
;                       && vim_strchr(part_buf, COM_MIDDLE) == null
;                       && vim_strchr(part_buf, COM_END) == null)
;                   break;

                ;; When we already found a nested comment, only accept further nested comments.
;               if (got_com && vim_strchr(part_buf, COM_NEST) == null)
;                   continue;

                ;; When 'O' flag present and using "O" command skip this one.
;               if (backward && vim_strchr(part_buf, COM_NOBACK) != null)
;                   continue;

                ;; Line contents and string must match.
                ;; When "s" starts with white space, must have some white space
                ;; (but the amount does not need to match, there might be a mix of TABs and spaces).
;               if (vim_iswhite(s.at(0)))
;               {
;                   if (i == 0 || !vim_iswhite(line.at(i - 1)))
;                       continue;           ;; missing white space
;                   while (vim_iswhite(s.at(0)))
;                       s = s.plus(1);
;               }
;               int j;
;               for (j = 0; s.at(j) != NUL && s.at(j) == line.at(i + j); j++)
                ;
;               if (s.at(j) != NUL)
;                   continue;               ;; string doesn't match

                ;; When 'b' flag used, there must be white space
                ;; or an end-of-line after the string in the line.
;               if (vim_strchr(part_buf, COM_BLANK) != null && !vim_iswhite(line.at(i + j)) && line.at(i + j) != NUL)
;                   continue;

                ;; We have found a match, stop searching unless this is a middle
                ;; comment.  The middle comment can be a substring of the end
                ;; comment in which case it's better to return the length of the
                ;; end comment and its flags.  Thus we keep searching with middle
                ;; and end matches and use an end match if it matches better.
;               if (vim_strchr(part_buf, COM_MIDDLE) != null)
;               {
;                   if (middle_match_len == 0)
;                   {
;                       middle_match_len = j;
;                       saved_flags = q;
;                   }
;                   continue;
;               }
;               if (middle_match_len != 0 && middle_match_len < j)
                    ;; Use this match instead of the middle match, since it's a longer thus better match.
;                   middle_match_len = 0;

;               if (middle_match_len == 0)
;                   i += j;
;               found_one = true;
;               break;
;           }

;           if (middle_match_len != 0)
;           {
                ;; Use the previously found middle match after failing to find a match with an end.
;               if (!got_com && flags != null)
;                   flags[0] = saved_flags;
;               i += middle_match_len;
;               found_one = true;
;           }

            ;; No match found, stop scanning.
;           if (!found_one)
;               break;

;           length = i;

            ;; Include any trailing white space.
;           while (vim_iswhite(line.at(i)))
;               i++;

;           if (include_space)
;               length = i;

            ;; If this comment doesn't nest, stop here.
;           got_com = true;
;           if (vim_strchr(part_buf, COM_NEST) == null)
;               break;
;       }

;       return length;
    ))

;; Return the offset at which the last comment in line starts.
;; If there is no comment in the whole line, -1 is returned.
;;
;; When "flags" is not null,
;; it is set to point to the flags describing the recognized comment leader.

(defn- #_int get_last_leader_offset [#_Bytes line, #_Bytes* flags]
    (§
;       int offset = -1;

;       Bytes com_leader = null, com_flags = null;	// %% anno dunno

        ;; Repeat to match several nested comment strings.

;       for (int lower_check_bound = 0, n = STRLEN(line); lower_check_bound <= --n; )
;       {
;           boolean found_one = false;

;           Bytes part_buf = new Bytes(COM_MAX_LEN);    ;; buffer for one option part

            ;; Scan through the 'comments' option for a match.

;           for (Bytes[] p = { @curbuf.@b_p_com }; p[0].at(0) != NUL; )
;           {
;               Bytes flags_save = p[0];

;               copy_option_part(p, part_buf, COM_MAX_LEN, u8(","));

;               Bytes s = vim_strchr(part_buf, ':');
;               if (s == null)      ;; if everything is fine, this cannot actually happen
;                   continue;
;               (s = s.plus(1)).be(-1, NUL);            ;; isolate flags from string

;               com_leader = s;

                ;; Line contents and string must match.
                ;; When "s" starts with white space, must have some white space
                ;; (but the amount does not need to match, there might be a mix of TABs and spaces).

;               if (vim_iswhite(s.at(0)))
;               {
;                   if (n == 0 || !vim_iswhite(line.at(n - 1)))
;                       continue;
;                   while (vim_iswhite(s.at(0)))
;                       s = s.plus(1);
;               }

;               int i;
;               for (i = 0; s.at(i) != NUL && s.at(i) == line.at(n + i); i++)
;                   /* do nothing */;
;               if (s.at(i) != NUL)
;                   continue;

                ;; When 'b' flag used, there must be white space
                ;; or an end-of-line after the string in the line.

;               if (vim_strchr(part_buf, COM_BLANK) != null && !vim_iswhite(line.at(n + i)) && line.at(n + i) != NUL)
;                   continue;

                ;; We have found a match, stop searching.

;               found_one = true;

;               if (flags != null)
;                   flags[0] = flags_save;

;               com_flags = flags_save;
;               break;
;           }

;           if (found_one)
;           {
;               offset = n;

                ;; If this comment nests, continue searching.

;               if (vim_strchr(part_buf, COM_NEST) != null)
;                   continue;

;               lower_check_bound = n;

                ;; Let's verify whether the comment leader found is a substring of other comment leaders.
                ;; If it is, let's adjust the lower_check_bound so that we make sure that we have determined
                ;; the comment leader correctly.

;               while (vim_iswhite(com_leader.at(0)))
;                   com_leader = com_leader.plus(1);
;               int len1 = STRLEN(com_leader);

;               Bytes part_buf2 = new Bytes(COM_MAX_LEN);   ;; buffer for one option part

;               for (Bytes[] p = { @curbuf.@b_p_com }; p[0].at(0) != NUL; )
;               {
;                   Bytes flags_save = p[0];

;                   copy_option_part(p, part_buf2, COM_MAX_LEN, u8(","));

;                   if (BEQ(flags_save, com_flags))
;                       continue;

;                   Bytes s = vim_strchr(part_buf2, ':');
;                   s = s.plus(1);
;                   while (vim_iswhite(s.at(0)))
;                       s = s.plus(1);
;                   int len2 = STRLEN(s);
;                   if (len2 == 0)
;                       continue;

                    ;; Now we have to verify whether "s" ends with a substring beginning the "com_leader".
;                   for (int off = (n < len2) ? n : len2; 0 < off && len2 < off + len1; )
;                   {
;                       --off;
;                       if (STRNCMP(s.plus(off), com_leader, len2 - off) == 0)
;                       {
;                           if (n - off < lower_check_bound)
;                               lower_check_bound = n - off;
;                       }
;                   }
;               }
;           }
;       }

;       return offset;
    ))

;; Return the number of window lines occupied by buffer line "lnum".

(defn- #_int plines [#_long lnum]
    (§
;       return plines_win(@curwin, lnum, true);
    ))

(defn- #_int plines_win [#_window_C wp, #_long lnum, #_boolean winheight]
    ;; winheight: when true limit to window height
    (§
;       if (!wp.w_onebuf_opt.@wo_wrap)
;           return 1;

;       if (wp.w_width == 0)
;           return 1;

;       int lines = plines_win_nofold(wp, lnum);
;       if (winheight && wp.w_height < lines)
;           return wp.w_height;

;       return lines;
    ))

;; Return number of window lines physical line "lnum" will occupy in window "wp".
;; Does not care about folding, 'wrap' or 'diff'.

(defn- #_int plines_win_nofold [#_window_C wp, #_long lnum]
    (§
;       Bytes s = ml_get_buf(wp.w_buffer, lnum, false);
;       if (s.at(0) == NUL)     ;; empty line
;           return 1;

;       int col = win_linetabsize(wp, s, MAXCOL);

        ;; If list mode is on, then the '$' at the end of the line may take up one extra column.

;       if (wp.w_onebuf_opt.@wo_list && @lcs_eol != NUL)
;           col += 1;

        ;; Add column offset for 'number', 'relativenumber' and 'foldcolumn'.

;       int width = wp.w_width - win_col_off(wp);
;       if (width <= 0)
;           return 32000;

;       if (col <= width)
;           return 1;

;       col -= width;
;       width += win_col_off2(wp);
;       return (col + (width - 1)) / width + 1;
    ))

;; Like plines_win(), but only reports the number of physical screen lines
;; used from the start of the line to the given column number.

(defn- #_int plines_win_col [#_window_C wp, #_long lnum, #_long column]
    (§
;       int lines = 0;

;       if (!wp.w_onebuf_opt.@wo_wrap)
;           return lines + 1;

;       if (wp.w_width == 0)
;           return lines + 1;

;       Bytes line = ml_get_buf(wp.w_buffer, lnum, false);
;       Bytes s = line;

;       long col = 0;
;       while (s.at(0) != NUL && 0 <= --column)
;       {
;           col += win_lbr_chartabsize(wp, line, s, (int)col, null);
;           s = s.plus(us_ptr2len_cc(s));
;       }

        ;; If s[0] is a TAB, and the TAB is not displayed as ^I, and we're not in INSERT mode,
        ;; then col must be adjusted so that it represents the last screen position of the TAB.
        ;; This only fixes an error when the TAB wraps from one screen line to the next
        ;; (when 'columns' is not a multiple of 'ts').

;       if (s.at(0) == TAB && (@State & NORMAL) != 0 && (!wp.w_onebuf_opt.@wo_list || lcs_tab1[0] != NUL))
;           col += win_lbr_chartabsize(wp, line, s, (int)col, null) - 1;

        ;; Add column offset for 'number', 'relativenumber', 'foldcolumn', etc.

;       int width = wp.w_width - win_col_off(wp);
;       if (width <= 0)
;           return 9999;

;       lines += 1;
;       if (width < col)
;           lines += (col - width) / (width + win_col_off2(wp)) + 1;
;       return lines;
    ))

(defn- #_int plines_m_win [#_window_C wp, #_long first, #_long last]
    (§
;       int count = 0;

;       while (first <= last)
;       {
;           count += plines_win(wp, first, true);
;           first++;
;       }

;       return count;
    ))

;; Insert string "p" at the cursor position.  Stops at a NUL byte.
;; Handles Replace mode and multi-byte characters.

(defn- #_void ins_bytes [#_Bytes p]
    (§
;       ins_bytes_len(p, STRLEN(p));
    ))

;; Insert string "p" with length "len" at the cursor position.
;; Handles Replace mode and multi-byte characters.

(defn- #_void ins_bytes_len [#_Bytes p, #_int len]
    (§
;       for (int i = 0, n; i < len; i += n)
;       {
            ;; avoid reading past p[len]
;           n = us_ptr2len_cc_len(p.plus(i), len - i);
;           ins_char_bytes(p.plus(i), n);
;       }
    ))

;; Insert or replace a single character at the cursor position.
;; When in REPLACE or VREPLACE mode, replace any existing character.
;; Caller must have prepared for undo.
;; For multi-byte characters we get the whole character,
;; the caller must convert bytes to a character.

(defn- #_void ins_char [#_int c]
    (§
;       Bytes buf = new Bytes(MB_MAXBYTES + 1);
;       int n = utf_char2bytes(c, buf);

        ;; When "c" is 0x100, 0x200, etc. we don't want to insert a NUL byte.
        ;; Happens for CTRL-Vu9900.
;       if (buf.at(0) == 0)
;           buf.be(0, (byte)'\n');

;       ins_char_bytes(buf, n);
    ))

(defn- #_void ins_char_bytes [#_Bytes buf, #_int charlen]
    (§
;       long lnum = @curwin.w_cursor.lnum;

        ;; Break tabs if needed.
;       if (virtual_active() && 0 < @curwin.w_cursor.coladd)
;           coladvance_force(getviscol());

;       int col = @curwin.w_cursor.col;
;       Bytes oldp = ml_get(lnum);
;       int linelen = STRLEN(oldp) + 1;        ;; length of old line including NUL

        ;; The lengths default to the values for when not replacing.
;       int oldlen = 0;                             ;; nr of bytes deleted (0 when not replacing)
;       int newlen = charlen;                       ;; nr of bytes inserted

;       if ((@State & REPLACE_FLAG) != 0)
;       {
;           if ((@State & VREPLACE_FLAG) != 0)
;           {
                ;; Disable 'list' temporarily, unless 'cpo' contains the 'L' flag.
                ;; Returns the old value of list, so when finished,
                ;; curwin.w_onebuf_opt.wo_list should be set back to this.

;               boolean old_list = @curwin.w_onebuf_opt.@wo_list;
;               if (old_list && vim_strbyte(@p_cpo, CPO_LISTWM) == null)
;                   @curwin.w_onebuf_opt.@wo_list = false;

                ;; In virtual replace mode each character may replace one or more
                ;; characters (zero if it's a TAB).  Count the number of bytes to
                ;; be deleted to make room for the new character, counting screen
                ;; cells.  May result in adding spaces to fill a gap.

;               int[] vcol = new int[1];
;               getvcol(@curwin, @curwin.w_cursor, null, vcol, null);

;               int new_vcol = vcol[0] + chartabsize(buf, vcol[0]);
;               while (oldp.at(col + oldlen) != NUL && vcol[0] < new_vcol)
;               {
;                   vcol[0] += chartabsize(oldp.plus(col + oldlen), vcol[0]);
                    ;; Don't need to remove a TAB that takes us to the right position.
;                   if (new_vcol < vcol[0] && oldp.at(col + oldlen) == TAB)
;                       break;
;                   oldlen += us_ptr2len_cc(oldp.plus(col + oldlen));
                    ;; Deleted a bit too much, insert spaces.
;                   if (new_vcol < vcol[0])
;                       newlen += vcol[0] - new_vcol;
;               }

;               @curwin.w_onebuf_opt.@wo_list = old_list;
;           }
;           else if (oldp.at(col) != NUL)
;           {
                ;; normal replace
;               oldlen = us_ptr2len_cc(oldp.plus(col));
;           }

            ;; Push the replaced bytes onto the replace stack, so that they can be
            ;; put back when BS is used.  The bytes of a multi-byte character are
            ;; done the other way around, so that the first byte is popped off
            ;; first (it tells the byte length of the character).
;           replace_push(NUL);
;           for (int i = 0; i < oldlen; i++)
;               i += replace_push_mb(oldp.plus(col + i)) - 1;
;       }

;       Bytes newp = new Bytes(linelen + newlen - oldlen);

        ;; Copy bytes before the cursor.
;       if (0 < col)
;           BCOPY(newp, oldp, col);

        ;; Copy bytes after the changed character(s).
;       Bytes p = newp.plus(col);
;       BCOPY(p, newlen, oldp, col + oldlen, linelen - col - oldlen);

        ;; Insert or overwrite the new character.
;       BCOPY(p, buf, charlen);
;       int i = charlen;

        ;; Fill with spaces when necessary.
;       while (i < newlen)
;           p.be(i++, (byte)' ');

        ;; Replace the line in the buffer.
;       ml_replace(lnum, newp, false);

        ;; mark the buffer as changed and prepare for displaying
;       changed_bytes(lnum, col);

        ;; If we're in Insert or Replace mode and 'showmatch' is set,
        ;; then briefly show the match for right parens and braces.

;       if (@p_sm && (@State & INSERT) != 0 && @msg_silent == 0)
;       {
;           showmatch(us_ptr2char(buf));
;       }

;       if (!@p_ri || (@State & REPLACE_FLAG) != 0)
;       {
            ;; Normal insert: move cursor right.
;           @curwin.w_cursor.col += charlen;
;       }

        ;; TODO: should try to update w_row here, to avoid recomputing it later.

    ))

;; Insert a string at the cursor position.
;; Note: Does NOT handle Replace mode.
;; Caller must have prepared for undo.

(defn- #_void ins_str [#_Bytes s]
    (§
;       int newlen = STRLEN(s);
;       long lnum = @curwin.w_cursor.lnum;

;       if (virtual_active() && 0 < @curwin.w_cursor.coladd)
;           coladvance_force(getviscol());

;       int col = @curwin.w_cursor.col;
;       Bytes oldp = ml_get(lnum);
;       int oldlen = STRLEN(oldp);

;       Bytes newp = new Bytes(oldlen + newlen + 1);

;       if (0 < col)
;           BCOPY(newp, oldp, col);
;       BCOPY(newp, col, s, 0, newlen);
;       BCOPY(newp, col + newlen, oldp, col, oldlen - col + 1);
;       ml_replace(lnum, newp, false);
;       changed_bytes(lnum, col);
;       @curwin.w_cursor.col += newlen;
    ))

;; Delete one character under the cursor.
;; If "fixpos" is true, don't leave the cursor on the NUL after the line.
;; Caller must have prepared for undo.
;;
;; Return false for failure, true otherwise.

(defn- #_boolean del_char [#_boolean fixpos]
    (§
        ;; Make sure the cursor is at the start of a character.
;       mb_adjust_pos(@curbuf, @curwin.w_cursor);
;       if (ml_get_cursor().at(0) == NUL)
;           return false;

;       return del_chars(1, fixpos);
    ))

;; Like del_bytes(), but delete characters instead of bytes.

(defn- #_boolean del_chars [#_int count, #_boolean fixpos]
    (§
;       int bytes = 0;

;       Bytes p = ml_get_cursor();
;       for (int i = 0; i < count && p.at(0) != NUL; i++)
;       {
;           int l = us_ptr2len_cc(p);
;           bytes += l;
;           p = p.plus(l);
;       }

;       return del_bytes(bytes, fixpos, true);
    ))

;; Delete "count" bytes under the cursor.
;; If "fixpos" is true, don't leave the cursor on the NUL after the line.
;; Caller must have prepared for undo.
;;
;; return false for failure, true otherwise

(defn- #_boolean del_bytes [#_int count, #_boolean fixpos, #_boolean use_delcombine]
    ;; use_delcombine: 'delcombine' option applies
    (§
;       long lnum = @curwin.w_cursor.lnum;
;       int col = @curwin.w_cursor.col;

;       Bytes oldp = ml_get(lnum);
;       int oldlen = STRLEN(oldp);

        ;; Can't do anything when the cursor is on the NUL after the line.

;       if (oldlen <= col)
;           return false;

        ;; If 'delcombine' is set and deleting (less than) one character,
        ;; only delete the last combining character.
;       if (@p_deco && use_delcombine && count <= us_ptr2len_cc(oldp.plus(col)))
;       {
;           int[] cc = new int[MAX_MCO];

;           us_ptr2char_cc(oldp.plus(col), cc);
;           if (cc[0] != NUL)
;           {
                ;; Find the last composing char, there can be several.
;               int n = col;
;               do
;               {
;                   col = n;
;                   count = us_ptr2len(oldp.plus(n));
;                   n += count;
;               } while (utf_iscomposing(us_ptr2char(oldp.plus(n))));
;               fixpos = false;
;           }
;       }

        ;; When count is too big, reduce it.

;       int movelen = oldlen - col - count + 1; ;; includes trailing NUL
;       if (movelen <= 1)
;       {
            ;; If we just took off the last character of a non-blank line, and
            ;; fixpos is true, we don't want to end up positioned at the NUL,
            ;; unless "restart_edit" is set or 'virtualedit' contains "onemore".

;           if (0 < col && fixpos && @restart_edit == 0 && (@ve_flags & VE_ONEMORE) == 0)
;           {
;               --@curwin.w_cursor.col;
;               @curwin.w_cursor.coladd = 0;
;               @curwin.w_cursor.col -= us_head_off(oldp, oldp.plus(@curwin.w_cursor.col));
;           }
;           count = oldlen - col;
;           movelen = 1;
;       }

        ;; If the old line has been allocated the deletion can be done in the existing line.
        ;; Otherwise a new line has to be allocated.

;       boolean was_alloced = ml_line_alloced();    ;; check if "oldp" was allocated
;       Bytes newp;
;       if (was_alloced)
;           newp = oldp;                            ;; use same allocated memory
;       else
;       {                                           ;; need to allocate a new line
;           newp = new Bytes(oldlen + 1 - count);
;           BCOPY(newp, oldp, col);
;       }
;       BCOPY(newp, col, oldp, col + count, movelen);
;       if (!was_alloced)
;           ml_replace(lnum, newp, false);

        ;; mark the buffer as changed and prepare for displaying
;       changed_bytes(lnum, @curwin.w_cursor.col);

;       return true;
    ))

;; Delete from cursor to end of line.
;; Caller must have prepared for undo.

(defn- #_void truncate_line [#_boolean fixpos]
    ;; fixpos: if true fix the cursor position when done
    (§
;       long lnum = @curwin.w_cursor.lnum;
;       int col = @curwin.w_cursor.col;

;       Bytes newp;
;       if (col == 0)
;           newp = STRDUP(u8(""));
;       else
;           newp = STRNDUP(ml_get(lnum), col);

;       ml_replace(lnum, newp, false);

        ;; mark the buffer as changed and prepare for displaying
;       changed_bytes(lnum, @curwin.w_cursor.col);

        ;; If "fixpos" is true we don't want to end up positioned at the NUL.

;       if (fixpos && 0 < @curwin.w_cursor.col)
;           --@curwin.w_cursor.col;
    ))

;; Delete "nlines" lines at the cursor.
;; Saves the lines for undo first if "undo" is true.

(defn- #_void del_lines [#_long nlines, #_boolean undo]
    ;; nlines: number of lines to delete
    ;; undo: if true, prepare for undo
    (§
;       long first = @curwin.w_cursor.lnum;

;       if (nlines <= 0)
;           return;

        ;; save the deleted lines for undo
;       if (undo && u_savedel(first, nlines) == false)
;           return;

;       long n;
;       for (n = 0; n < nlines; )
;       {
;           if ((@curbuf.b_ml.ml_flags & ML_EMPTY) != 0) ;; nothing to delete
;               break;

;           ml_delete(first, true);
;           n++;

            ;; If we delete the last line in the file, stop.
;           if (@curbuf.b_ml.ml_line_count < first)
;               break;
;       }

        ;; Correct the cursor position before calling deleted_lines_mark(),
        ;; it may trigger a callback to display the cursor.
;       @curwin.w_cursor.col = 0;
;       check_cursor_lnum();

        ;; Adjust marks, mark the buffer as changed and prepare for displaying.
;       deleted_lines_mark(first, n);
    ))

(defn- #_int gchar_pos [#_pos_C pos]
    (§
;       Bytes ptr = ml_get_pos(pos);

;       return us_ptr2char(ptr);
    ))

(defn- #_int gchar_cursor []
    (§
;       return us_ptr2char(ml_get_cursor());
    ))

;; Write a character at the current cursor position.
;; It is directly written into the block.

(defn- #_void pchar_cursor [#_int c]
    (§
;       ml_get_buf(@curbuf, @curwin.w_cursor.lnum, true).be(@curwin.w_cursor.col, c);
    ))

;; When extra == 0: Return true if the cursor is before or on the first non-blank in the line.
;; When extra == 1: Return true if the cursor is before the first non-blank in the line.

(defn- #_boolean inindent [#_int extra]
    (§
;       int col = 0;

;       for (Bytes p = ml_get_curline(); vim_iswhite(p.at(0)); col++)
;           p = p.plus(1);

;       return (@curwin.w_cursor.col + extra <= col);
    ))

;; Skip to next part of an option argument: Skip space and comma.

(defn- #_Bytes skip_to_option_part [#_Bytes p]
    (§
;       if (p.at(0) == (byte)',')
;           p = p.plus(1);
;       while (p.at(0) == (byte)' ')
;           p = p.plus(1);
;       return p;
    ))

;; Call this function when something in the current buffer is changed.
;;
;; Most often called through changed_bytes() and changed_lines(),
;; which also mark the area of the display to be redrawn.
;;
;; Careful: may trigger autocommands that reload the buffer.

(defn- #_void changed []
    (§
;       if (!@curbuf.@b_changed)
;       {
            ;; Give a warning about changing a read-only file.
            ;; This may also check-out the file, thus change "curbuf"!
;           change_warning(0);

;           changed_int();
;       }
;       @curbuf.b_changedtick++;
    ))

;; Internal part of changed(), no user interaction.

(defn- #_void changed_int []
    (§
;       @curbuf.@b_changed = true;
;       ml_setflags(@curbuf);
;       check_status(@curbuf);
;       @redraw_tabline = true;
    ))

;; Changed bytes within a single line for the current buffer.
;; - marks the windows on this buffer to be redisplayed
;; - marks the buffer changed by calling changed()
;; - invalidates cached values
;; Careful: may trigger autocommands that reload the buffer.

(defn- #_void changed_bytes [#_long lnum, #_int col]
    (§
;       changedOneline(@curbuf, lnum);
;       changed_common(lnum, col, lnum + 1, 0L);
    ))

(defn- #_void changedOneline [#_buffer_C buf, #_long lnum]
    (§
;       if (buf.b_mod_set)
;       {
            ;; find the maximum area that must be redisplayed
;           if (lnum < buf.b_mod_top)
;               buf.b_mod_top = lnum;
;           else if (buf.b_mod_bot <= lnum)
;               buf.b_mod_bot = lnum + 1;
;       }
;       else
;       {
            ;; set the area that must be redisplayed to one line
;           buf.b_mod_set = true;
;           buf.b_mod_top = lnum;
;           buf.b_mod_bot = lnum + 1;
;           buf.b_mod_xlines = 0;
;       }
    ))

;; Appended "count" lines below line "lnum" in the current buffer.
;; Must be called AFTER the change and after mark_adjust().
;; Takes care of marking the buffer to be redrawn and sets the changed flag.

(defn- #_void appended_lines [#_long lnum, #_long count]
    (§
;       changed_lines(lnum + 1, 0, lnum + 1, count);
    ))

;; Like appended_lines(), but adjust marks first.

(defn- #_void appended_lines_mark [#_long lnum, #_long count]
    (§
;       mark_adjust(lnum + 1, MAXLNUM, count, 0L);
;       changed_lines(lnum + 1, 0, lnum + 1, count);
    ))

;; Deleted "count" lines at line "lnum" in the current buffer.
;; Must be called AFTER the change and after mark_adjust().
;; Takes care of marking the buffer to be redrawn and sets the changed flag.

(defn- #_void deleted_lines [#_long lnum, #_long count]
    (§
;       changed_lines(lnum, 0, lnum + count, -count);
    ))

;; Like deleted_lines(), but adjust marks first.
;; Make sure the cursor is on a valid line before calling,
;; a GUI callback may be triggered to display the cursor.

(defn- #_void deleted_lines_mark [#_long lnum, #_long count]
    (§
;       mark_adjust(lnum, lnum + count - 1, MAXLNUM, -count);
;       changed_lines(lnum, 0, lnum + count, -count);
    ))

;; Changed lines for the current buffer.
;; Must be called AFTER the change and after mark_adjust().
;; - mark the buffer changed by calling changed()
;; - mark the windows on this buffer to be redisplayed
;; - invalidate cached values
;; "lnum" is the first line that needs displaying,
;; "lnume" the first line below the changed lines (BEFORE the change).
;; When only inserting lines, "lnum" and "lnume" are equal.
;; Takes care of calling changed() and updating b_mod_*.
;; Careful: may trigger autocommands that reload the buffer.

(defn- #_void changed_lines [#_long lnum, #_int col, #_long lnume, #_long xtra]
    ;; lnum: first line with change
    ;; col: column in first line with change
    ;; lnume: line below last changed line
    ;; xtra: number of extra lines (negative when deleting)
    (§
;       changed_lines_buf(@curbuf, lnum, lnume, xtra);

;       changed_common(lnum, col, lnume, xtra);
    ))

(defn- #_void changed_lines_buf [#_buffer_C buf, #_long lnum, #_long lnume, #_long xtra]
    ;; lnum: first line with change
    ;; lnume: line below last changed line
    ;; xtra: number of extra lines (negative when deleting)
    (§
;       if (buf.b_mod_set)
;       {
            ;; find the maximum area that must be redisplayed
;           if (lnum < buf.b_mod_top)
;               buf.b_mod_top = lnum;
;           if (lnum < buf.b_mod_bot)
;           {
                ;; adjust old bot position for xtra lines
;               buf.b_mod_bot += xtra;
;               if (buf.b_mod_bot < lnum)
;                   buf.b_mod_bot = lnum;
;           }
;           if (buf.b_mod_bot < lnume + xtra)
;               buf.b_mod_bot = lnume + xtra;
;           buf.b_mod_xlines += xtra;
;       }
;       else
;       {
            ;; set the area that must be redisplayed
;           buf.b_mod_set = true;
;           buf.b_mod_top = lnum;
;           buf.b_mod_bot = lnume + xtra;
;           buf.b_mod_xlines = xtra;
;       }
    ))

;; Common code for when a change is was made.
;; See changed_lines() for the arguments.
;; Careful: may trigger autocommands that reload the buffer.

(defn- #_void changed_common [#_long lnum, #_int col, #_long lnume, #_long xtra]
    (§
        ;; mark the buffer as modified
;       changed();

        ;; set the '. mark
;       if (!@cmdmod.keepjumps)
;       {
;           @curbuf.b_last_change.lnum = lnum;
;           @curbuf.b_last_change.col = col;

            ;; Create a new entry if a new undo-able change was started
            ;; or we don't have an entry yet.
;           if (@curbuf.b_new_change || @curbuf.b_changelistlen == 0)
;           {
;               boolean add;
;               if (@curbuf.b_changelistlen == 0)
;                   add = true;
;               else
;               {
                    ;; Don't create a new entry when the line number is the
                    ;; same as the last one and the column is not too far away.
                    ;; Avoids creating many entries for typing "xxxxx".
;                   pos_C p = @curbuf.b_changelist[@curbuf.b_changelistlen - 1];
;                   if (p.lnum != lnum)
;                       add = true;
;                   else
;                   {
;                       int cols = comp_textwidth(false);
;                       if (cols == 0)
;                           cols = 79;
;                       add = (p.col + cols < col || col + cols < p.col);
;                   }
;               }
;               if (add)
;               {
                    ;; This is the first of a new sequence of undo-able changes
                    ;; and it's at some distance of the last change.  Use a new
                    ;; position in the changelist.
;                   @curbuf.b_new_change = false;

;                   if (@curbuf.b_changelistlen == JUMPLISTSIZE)
;                   {
                        ;; changelist is full: remove oldest entry
;                       @curbuf.b_changelistlen = JUMPLISTSIZE - 1;
;                       for (int i = 0; i < JUMPLISTSIZE - 1; i++)
;                           COPY_pos(@curbuf.b_changelist[i], @curbuf.b_changelist[i + 1]);
;                       for (tabpage_C tp = @first_tabpage; tp != null; tp = null)
;                           for (window_C wp = (tp == @curtab) ? @firstwin : tp.tp_firstwin; wp != null; wp = wp.w_next)
;                           {
                                ;; Correct position in changelist for other windows on this buffer.
;                               if (wp.w_buffer == @curbuf && 0 < wp.w_changelistidx)
;                                   --wp.w_changelistidx;
;                           }
;                   }
;                   for (tabpage_C tp = @first_tabpage; tp != null; tp = null)
;                       for (window_C wp = (tp == @curtab) ? @firstwin : tp.tp_firstwin; wp != null; wp = wp.w_next)
;                       {
                            ;; For other windows, if the position in the changelist is at the end,
                            ;; it stays at the end.
;                           if (wp.w_buffer == @curbuf && wp.w_changelistidx == @curbuf.b_changelistlen)
;                               wp.w_changelistidx++;
;                       }
;                   @curbuf.b_changelistlen++;
;               }
;           }
;           COPY_pos(@curbuf.b_changelist[@curbuf.b_changelistlen - 1], @curbuf.b_last_change);
            ;; The current window is always after the last change, so that "g," takes you back to it.
;           @curwin.w_changelistidx = @curbuf.b_changelistlen;
;       }

;       for (tabpage_C tp = @first_tabpage; tp != null; tp = null)
;           for (window_C wp = (tp == @curtab) ? @firstwin : tp.tp_firstwin; wp != null; wp = wp.w_next)
;           {
;               if (wp.w_buffer == @curbuf)
;               {
                    ;; Mark this window to be redrawn later.
;                   if (wp.w_redr_type < VALID)
;                       wp.w_redr_type = VALID;

                    ;; Check if a change in the buffer has invalidated
                    ;; the cached values for the cursor.
;                   if (lnum < wp.w_cursor.lnum)
;                       changed_line_abv_curs_win(wp);
;                   else if (wp.w_cursor.lnum == lnum && col <= wp.w_cursor.col)
;                       changed_cline_bef_curs_win(wp);
;                   if (lnum <= wp.w_botline)
;                   {
                        ;; Assume that botline doesn't change
                        ;; (inserted lines make other lines scroll down below botline).
;                       approximate_botline_win(wp);
;                   }

                    ;; Check if any w_lines[] entries have become invalid.
                    ;; For entries below the change: Correct the lnums for inserted/deleted lines.
                    ;; Makes it possible to stop displaying after the change.
;                   for (int i = 0; i < wp.w_lines_valid; i++)
;                       if (wp.w_lines[i].wl_valid)
;                       {
;                           if (lnum <= wp.w_lines[i].wl_lnum)
;                           {
;                               if (wp.w_lines[i].wl_lnum < lnume)
;                               {
                                    ;; line included in change
;                                   wp.w_lines[i].wl_valid = false;
;                               }
;                               else if (xtra != 0)
;                               {
                                    ;; line below change
;                                   wp.w_lines[i].wl_lnum += xtra;
;                               }
;                           }
;                       }

                    ;; relative numbering may require updating more
;                   if (wp.w_onebuf_opt.@wo_rnu)
;                       redraw_win_later(wp, SOME_VALID);
;               }
;           }

        ;; Call update_screen() later, which checks out what needs to be redrawn,
        ;; since it notices b_mod_set and then uses b_mod_*.
;       if (@must_redraw < VALID)
;           @must_redraw = VALID;

        ;; When the cursor line is changed, always trigger CursorMoved.
;       if (lnum <= @curwin.w_cursor.lnum && @curwin.w_cursor.lnum < lnume + (xtra < 0 ? -xtra : xtra))
;           @last_cursormoved.lnum = 0;
    ))

;; unchanged() is called when the changed flag must be reset for buffer 'buf'

(defn- #_void unchanged [#_buffer_C buf, #_boolean ff]
    ;; ff: also reset 'fileformat'
    (§
;       if (buf.@b_changed || (ff && file_ff_differs(buf, false)))
;       {
;           buf.@b_changed = false;
;           ml_setflags(buf);
;           check_status(buf);
;           @redraw_tabline = true;
;       }
;       buf.b_changedtick++;
    ))

;; check_status: called when the status bars for the buffer 'buf' need to be updated

(defn- #_void check_status [#_buffer_C buf]
    (§
;       for (window_C wp = @firstwin; wp != null; wp = wp.w_next)
;           if (wp.w_buffer == buf && wp.w_status_height != 0)
;           {
;               wp.w_redr_status = true;
;               if (@must_redraw < VALID)
;                   @must_redraw = VALID;
;           }
    ))

(final Bytes w_readonly (u8 "W10: Warning: Changing a readonly file"))

;; If the file is readonly, give a warning message with the first change.
;; Don't do this for autocommands.
;; Don't use emsg(), because it flushes the macro buffer.
;; If we have undone all changes "b_changed" will be false, but "b_did_warn" will be true.
;; Careful: may trigger autocommands that reload the buffer.

(defn- #_void change_warning [#_int col]
    ;; col: column for message; non-zero when in insert mode and 'showmode' is on
    (§
;       if (!@curbuf.b_did_warn && !curbufIsChanged() && @curbuf.@b_p_ro)
;       {
            ;; Do what msg() does, but with a column offset
            ;; if the warning should be after the mode message.

;           msg_start();
;           if (@msg_row == (int)@Rows - 1)
;               @msg_col = col;
;           msg_puts_attr(w_readonly, hl_attr(HLF_W) | MSG_HIST);
;           msg_clr_eos();
;           msg_end();

;           if (@msg_silent == 0 && !@silent_mode)
;           {
;               out_flush();
;               ui_delay(1000L, true);  ;; give the user time to think about it
;           }
;           @curbuf.b_did_warn = true;
;           @redraw_cmdline = false;     ;; don't redraw and erase the message
;           if (@msg_row < @Rows - 1)
;               showmode();
;       }
    ))

;; Ask for a reply from the user, a 'y' or a 'n'.
;; No other characters are accepted, the message is repeated
;; until a valid reply is entered or CTRL-C is hit.
;; If direct is true, don't use vgetc() but ui_inchar(),
;; don't get characters from any buffers but directly from the user.
;;
;; Answer 'y' or 'n'.

(defn- #_int ask_yesno [#_Bytes q, #_boolean direct]
    (§
;       int c = ' ';

;       int save_State = @State;

;       if (@exiting)                ;; put terminal in raw mode for this question
;           settmode(TMODE_RAW);

;       @no_wait_return++;
;       @State = CONFIRM;            ;; mouse behaves like with :confirm
;       setmouse();                 ;; disables mouse for xterm
;       @no_mapping++;
;       @allow_keys++;               ;; no mapping here, but recognize keys

;       while (c != 'y' && c != 'n')
;       {
            ;; same highlighting as for wait_return
;           smsg_attr(hl_attr(HLF_R), u8("%s (y/n)?"), q);

;           c = (direct) ? get_keystroke() : plain_vgetc();
;           if (c == Ctrl_C || c == ESC)
;               c = 'n';

;           msg_putchar(c);         ;; show what you typed
;           out_flush();
;       }

;       --@no_wait_return;
;       @State = save_State;
;       setmouse();
;       --@no_mapping;
;       --@allow_keys;

;       return c;
    ))

;; Return true if "c" is a mouse key.

(defn- #_boolean is_mouse_key [#_int c]
    (§
;       return c == K_LEFTMOUSE
;           || c == K_LEFTMOUSE_NM
;           || c == K_LEFTDRAG
;           || c == K_LEFTRELEASE
;           || c == K_LEFTRELEASE_NM
;           || c == K_MIDDLEMOUSE
;           || c == K_MIDDLEDRAG
;           || c == K_MIDDLERELEASE
;           || c == K_RIGHTMOUSE
;           || c == K_RIGHTDRAG
;           || c == K_RIGHTRELEASE
;           || c == K_MOUSEDOWN
;           || c == K_MOUSEUP
;           || c == K_MOUSELEFT
;           || c == K_MOUSERIGHT
;           || c == K_X1MOUSE
;           || c == K_X1DRAG
;           || c == K_X1RELEASE
;           || c == K_X2MOUSE
;           || c == K_X2DRAG
;           || c == K_X2RELEASE;
    ))

;; Get a key stroke directly from the user.
;; Ignores mouse clicks and scrollbar events, except a click for the left button (used at the more prompt).
;; Doesn't use vgetc(), because it syncs undo and eats mapped characters.
;; Disadvantage: typeahead is ignored.
;; Translates the interrupt character for unix to ESC.

(defn- #_int get_keystroke []
    (§
;       int c;

;       int save_mapped_ctrl_c = @mapped_ctrl_c;

;       @mapped_ctrl_c = 0;      ;; mappings are not used here

;       Bytes buf = null;

;       int buflen = 150;
;       int[] len = { 0 };
;       int waited = 0;

;       for ( ; ; )
;       {
;           cursor_on();
;           out_flush();

            ;; Leave some room for check_termcode() to insert a key code into (max 5 chars plus NUL).
            ;; And fix_input_buffer() can triple the number of bytes.
;           int maxlen = (buflen - 6 - len[0]) / 3;
;           if (buf == null)
;               buf = new Bytes(buflen);
;           else if (maxlen < 10)
;           {
                ;; Need some more space.
                ;; This might happen when receiving a long escape sequence.
;               buflen += 100;
;               Bytes p = new Bytes(buflen);
;               BCOPY(p, buf, len[0]);
;               buf = p;
;               maxlen = (buflen - 6 - len[0]) / 3;
;           }

            ;; First time: blocking wait.
            ;; Second time: wait up to 100ms for a terminal code to complete.
;           int n = ui_inchar(buf.plus(len[0]), maxlen, (len[0] == 0) ? -1L : 100L, 0);
;           if (0 < n)
;           {
                ;; Replace zero and CSI by a special key code.
;               n = fix_input_buffer(buf.plus(len[0]), n, false);
;               len[0] += n;
;               waited = 0;
;           }
;           else if (0 < len[0])
;               waited++;                   ;; keep track of the waiting time

            ;; Incomplete termcode and not timed out yet: get more characters.
;           n = check_termcode(1, buf, buflen, len);
;           if (n < 0 && (!@p_ttimeout || waited * 100L < (@p_ttm < 0 ? @p_tm : @p_ttm)))
;               continue;

;           if (n == KEYLEN_REMOVED)        ;; key code removed
;           {
;               if (@must_redraw != 0 && !@need_wait_return && (@State & CMDLINE) == 0)
;               {
                    ;; Redrawing was postponed, do it now.
;                   update_screen(0);
;                   setcursor();            ;; put cursor back where it belongs
;               }
;               continue;
;           }
;           if (0 < n)                      ;; found a termcode: adjust length
;               len[0] = n;
;           if (len[0] == 0)                   ;; nothing typed yet
;               continue;

            ;; Handle modifier and/or special key code.
;           if (buf.at(0) == KB_SPECIAL)
;           {
;               c = toSpecial(buf.at(1), buf.at(2));
;               if (buf.at(1) == KS_MODIFIER || c == K_IGNORE || (is_mouse_key(c) && c != K_LEFTMOUSE))
;               {
;                   if (buf.at(1) == KS_MODIFIER)
;                       @mod_mask = char_u(buf.at(2));
;                   len[0] -= 3;
;                   if (0 < len[0])
;                       BCOPY(buf, 0, buf, 3, len[0]);
;                   continue;
;               }
;               break;
;           }

;           if (len[0] < mb_byte2len(char_u(buf.at(0))))
;               continue;                   ;; more bytes to get

;           buf.be(buflen <= len[0] ? buflen - 1 : len[0], NUL);
;           c = us_ptr2char(buf);

;           if (c == @intr_char)
;               c = ESC;
;           break;
;       }

;       @mapped_ctrl_c = save_mapped_ctrl_c;

;       return c;
    ))

;; Get a number from the user.
;; When "mouse_used" is not null allow using the mouse.

(defn- #_int get_number [#_boolean colon, #_boolean* mouse_used]
    ;; colon: allow colon to abort
    (§
;       int n = 0;
;       int typed = 0;

;       if (mouse_used != null)
;           mouse_used[0] = false;

        ;; When not printing messages, the user won't know what to type,
        ;; return a zero (as if CR was hit).
;       if (@msg_silent != 0)
;           return 0;

;       @no_mapping++;
;       @allow_keys++;               ;; no mapping here, but recognize keys

;       for ( ; ; )
;       {
;           windgoto(@msg_row, @msg_col);
;           int c = safe_vgetc();
;           if (asc_isdigit(c))
;           {
;               n = n * 10 + c - '0';
;               msg_putchar(c);
;               typed++;
;           }
;           else if (c == K_DEL || c == K_KDEL || c == K_BS || c == Ctrl_H)
;           {
;               if (0 < typed)
;               {
;                   msg_puts(u8("\b \b"));
;                   --typed;
;               }
;               n /= 10;
;           }
;           else if (mouse_used != null && c == K_LEFTMOUSE)
;           {
;               mouse_used[0] = true;
;               n = @mouse_row + 1;
;               break;
;           }
;           else if (n == 0 && c == ':' && colon)
;           {
;               stuffcharReadbuff(':');
;               if (@exmode_active == 0)
;                   @cmdline_row = @msg_row;
;               @skip_redraw = true;     ;; skip redraw once
;               @do_redraw = false;
;               break;
;           }
;           else if (c == CAR || c == NL || c == Ctrl_C || c == ESC)
;               break;
;       }

;       --@no_mapping;
;       --@allow_keys;
;       return n;
    ))

;; Ask the user to enter a number.
;; When "mouse_used" is not null allow using the mouse and in that case return the line number.

(defn- #_int prompt_for_number [#_boolean* mouse_used]
    (§
        ;; When using ":silent" assume that <CR> was entered.
;       if (mouse_used != null)
;           msg_puts(u8("Type number and <Enter> or click with mouse (empty cancels): "));
;       else
;           msg_puts(u8("Type number and <Enter> (empty cancels): "));

        ;; Set the state such that text can be selected/copied/pasted and we still get mouse events.
;       int save_cmdline_row = @cmdline_row;
;       @cmdline_row = 0;
;       int save_State = @State;
;       @State = CMDLINE;

;       int i = get_number(true, mouse_used);
;       if (@keyTyped)
;       {
            ;; don't call wait_return() now
            ;; msg_putchar('\n');
;           @cmdline_row = @msg_row - 1;
;           @need_wait_return = false;
;           @msg_didany = false;
;           @msg_didout = false;
;       }
;       else
;           @cmdline_row = save_cmdline_row;
;       @State = save_State;

;       return i;
    ))

(defn- #_void msgmore [#_long n]
    (§
;       if (@global_busy != 0            ;; no messages now, wait until global is finished
;               || !messaging())        ;; 'lazyredraw' set, don't do messages now
;           return;

        ;; We don't want to overwrite another important message, but do overwrite
        ;; a previous "more lines" or "fewer lines" message, so that "5dd" and
        ;; then "put" reports the last action.
;       if (@keep_msg != null && !@keep_msg_more)
;           return;

;       long pn;
;       if (0 < n)
;           pn = n;
;       else
;           pn = -n;

;       if (@p_report < pn)
;       {
;           if (pn == 1)
;           {
;               if (0 < n)
;                   vim_strncpy(msg_buf, u8("1 more line"), MSG_BUF_LEN - 1);
;               else
;                   vim_strncpy(msg_buf, u8("1 line less"), MSG_BUF_LEN - 1);
;           }
;           else
;           {
;               if (0 < n)
;                   vim_snprintf(msg_buf, MSG_BUF_LEN, u8("%ld more lines"), pn);
;               else
;                   vim_snprintf(msg_buf, MSG_BUF_LEN, u8("%ld fewer lines"), pn);
;           }
;           if (@got_int)
;               vim_strcat(msg_buf, u8(" (Interrupted)"), MSG_BUF_LEN);
;           if (msg(msg_buf))
;           {
;               set_keep_msg(msg_buf, 0);
;               @keep_msg_more = true;
;           }
;       }
    ))

;; flush map and typeahead buffers and give a warning for an error

(defn- #_void beep_flush []
    (§
;       if (@emsg_silent == 0)
;       {
;           flush_buffers(false);
;           vim_beep();
;       }
    ))

;; give a warning for an error

(defn- #_void vim_beep []
    (§
;       if (@emsg_silent == 0)
;       {
;           if (@p_vb)
;               out_str(@T_VB);
;           else
;               out_char(BELL);
;       }
    ))

;; Get the tail of a path: the file name.
;; When the path ends in a path separator the tail is the NUL after it.
;; Fail safe: never returns null.

(defn- #_Bytes gettail [#_Bytes fname]
    (§
;       if (fname == null)
;           return u8("");

;       Bytes p1, p2;
;       for (p1 = p2 = get_past_head(fname); p2.at(0) != NUL; )     ;; find last part of path
;       {
;           if (vim_ispathsep_nocolon(p2.at(0)))
;               p1 = p2.plus(1);
;           p2 = p2.plus(us_ptr2len_cc(p2));
;       }
;       return p1;
    ))

;; Get pointer to tail of "fname", including path separators.
;; Putting a NUL here leaves the directory name.
;; Takes care of "c:/" and "//".
;; Always returns a valid pointer.

(defn- #_Bytes gettail_sep [#_Bytes fname]
    (§
;       Bytes p = get_past_head(fname); ;; don't remove the '/' from "c:/file"
;       Bytes t = gettail(fname);
;       while (BLT(p, t) && after_pathsep(fname, t))
;           t = t.minus(1);
;       return t;
    ))

;; get the next path component (just after the next path separator).

(defn- #_Bytes getnextcomp [#_Bytes fname]
    (§
;       while (fname.at(0) != NUL && !vim_ispathsep(fname.at(0)))
;           fname = fname.plus(us_ptr2len_cc(fname));
;       if (fname.at(0) != NUL)
;           fname = fname.plus(1);
;       return fname;
    ))

;; Get a pointer to one character past the head of a path name.
;; Unix: after "/"; DOS: after "c:\"; Amiga: after "disk:/"; Mac: no head.
;; If there is no head, path is returned.

(defn- #_Bytes get_past_head [#_Bytes path]
    (§
;       Bytes retval = path;

;       while (vim_ispathsep(retval.at(0)))
;           retval = retval.plus(1);

;       return retval;
    ))

;; Return true if 'c' is a path separator.
;; Note that for MS-Windows this includes the colon.

(defn- #_boolean vim_ispathsep [#_int c]
    (§
;       return (c == '/');      ;; UNIX has ':' inside file names
    ))

;; Like vim_ispathsep(c), but exclude the colon for MS-Windows.

(defn- #_boolean vim_ispathsep_nocolon [#_int c]
    (§
;       return vim_ispathsep(c);
    ))

;; Shorten the path of a file from "~/foo/../.bar/fname" to "~/f/../.b/fname"
;; It's done in-place.

(defn- #_void shorten_dir [#_Bytes str]
    (§
;       boolean skip = false;

;       Bytes tail = gettail(str);
;       Bytes d = str;
;       for (Bytes s = str; ; s = s.plus(1))
;       {
;           if (BLE(tail, s))                      ;; copy the whole tail
;           {
;               (d = d.plus(1)).be(-1, s.at(0));
;               if (s.at(0) == NUL)
;                   break;
;           }
;           else if (vim_ispathsep(s.at(0)))            ;; copy '/' and next char
;           {
;               (d = d.plus(1)).be(-1, s.at(0));
;               skip = false;
;           }
;           else if (!skip)
;           {
;               (d = d.plus(1)).be(-1, s.at(0));                      ;; copy next char
;               if (s.at(0) != (byte)'~' && s.at(0) != (byte)'.')     ;; and leading "~" and "."
;                   skip = true;

;               for (int l = us_ptr2len_cc(s); 0 < --l; )
;                   (d = d.plus(1)).be(-1, (s = s.plus(1)).at(0));
;           }
;       }
    ))

;; Concatenate file names fname1 and fname2 into allocated memory.
;; Only add a '/' or '\\' when 'sep' is true and it is necessary.

(defn- #_Bytes concat_fnames [#_Bytes fname1, #_Bytes fname2, #_boolean sep]
    (§
;       Bytes dest = new Bytes(STRLEN(fname1) + STRLEN(fname2) + 3);

;       STRCPY(dest, fname1);
;       if (sep)
;           add_pathsep(dest);
;       STRCAT(dest, fname2);

;       return dest;
    ))

;; Concatenate two strings and return the result in allocated memory.

(defn- #_Bytes concat_str [#_Bytes str1, #_Bytes str2]
    (§
;       int len = STRLEN(str1);

;       Bytes dest = new Bytes(len + STRLEN(str2) + 1);

;       STRCPY(dest, str1);
;       STRCPY(dest.plus(len), str2);

;       return dest;
    ))

;; Add a path separator to a file name, unless it already ends in a path separator.

(defn- #_void add_pathsep [#_Bytes p]
    (§
;       if (p.at(0) != NUL && !after_pathsep(p, p.plus(STRLEN(p))))
;           STRCAT(p, u8("/"));
    ))

;; Make an allocated copy of a full file name.
;; Returns null when out of memory.

(defn- #_Bytes fullName_save [#_Bytes fname, #_boolean force]
    ;; force: force expansion, even when it already looks like a full path name
    (§
;       if (fname == null)
;           return null;

;       Bytes buf = new Bytes(MAXPATHL);

;       Bytes new_fname;
;       if (vim_fullName(fname, buf, MAXPATHL, force) != false)
;           new_fname = STRDUP(buf);
;       else
;           new_fname = STRDUP(fname);

;       return new_fname;
    ))

;; Find the start of a comment, not knowing if we are in a comment right now.
;; Search starts at w_cursor.lnum and goes backwards.

(defn- #_pos_C ind_find_start_comment []
    (§
;       return find_start_comment(@curbuf.b_ind_maxcomment);
    ))

(defn- #_pos_C find_start_comment [#_int ind_maxcomment]
    (§
;       pos_C pos;
;       Bytes line;
;       Bytes p;
;       int cur_maxcomment = ind_maxcomment;

;       for ( ; ; )
;       {
;           pos = findmatchlimit(null, '*', FM_BACKWARD, cur_maxcomment);
;           if (pos == null)
;               break;

            ;; Check if the comment start we found is inside a string.
            ;; If it is then restrict the search to below this line and try again.

;           line = ml_get(pos.lnum);
;           for (p = line; p.at(0) != NUL && BDIFF(p, line) < pos.col; p = p.plus(1))
;               p = skip_string(p);
;           if (BDIFF(p, line) <= pos.col)
;               break;
;           cur_maxcomment = (int)(@curwin.w_cursor.lnum - pos.lnum - 1);
;           if (cur_maxcomment <= 0)
;           {
;               pos = null;
;               break;
;           }
;       }
;       return pos;
    ))

;; Skip to the end of a "string" and a 'c' character.
;; If there is no string or character, return argument unmodified.

(defn- #_Bytes skip_string [#_Bytes p]
    (§
        ;; We loop, because strings may be concatenated: "date""time".

;       for ( ; ; p = p.plus(1))
;       {
;           if (p.at(0) == (byte)'\'')                  ;; 'c' or '\n' or '\000'
;           {
;               if (p.at(1) == NUL)                     ;; ' at end of line
;                   break;
;               int i = 2;
;               if (p.at(1) == (byte)'\\')              ;; '\n' or '\000'
;               {
;                   i++;
;                   while (asc_isdigit(p.at(i - 1)))    ;; '\000'
;                       i++;
;               }
;               if (p.at(i) == (byte)'\'')              ;; check for trailing '
;               {
;                   p = p.plus(i);
;                   continue;
;               }
;           }
;           else if (p.at(0) == (byte)'"')              ;; start of string
;           {
;               for (p = p.plus(1); p.at(0) != NUL; p = p.plus(1))
;               {
;                   if (p.at(0) == (byte)'\\' && p.at(1) != NUL)
;                       p = p.plus(1);
;                   else if (p.at(0) == (byte)'"')      ;; end of string
;                       break;
;               }
;               if (p.at(0) == (byte)'"')
;                   continue;
;           }
;           break;                                  ;; no string found
;       }
;       if (p.at(0) == NUL)
;           p = p.minus(1);                                    ;; backup from NUL
;       return p;
    ))

;; Do C or expression indenting on the current line.

(defn- #_void do_c_expr_indent []
    (§
;       fixthisline(get_c_indent);
    ))

;; Functions for C-indenting.
;; Most of this originally comes from Eric Fischer.

;; Skip over white space and C comments within the line.
;; Also skip over Perl/shell comments if desired.

(defn- #_Bytes cin_skipcomment [#_Bytes s]
    (§
;       while (s.at(0) != NUL)
;       {
;           Bytes prev_s = s;

;           s = skipwhite(s);

            ;; Perl/shell # comment continues until eol.
            ;; Require a space before # to avoid recognizing $#array.
;           if (@curbuf.b_ind_hash_comment != 0 && BNE(s, prev_s) && s.at(0) == (byte)'#')
;           {
;               s = s.plus(STRLEN(s));
;               break;
;           }
;           if (s.at(0) != (byte)'/')
;               break;
;           s = s.plus(1);
;           if (s.at(0) == (byte)'/')          ;; slash-slash comment continues till eol
;           {
;               s = s.plus(STRLEN(s));
;               break;
;           }
;           if (s.at(0) != (byte)'*')
;               break;
;           for (s = s.plus(1); s.at(0) != NUL; s = s.plus(1))      ;; skip slash-star comment
;               if (s.at(0) == (byte)'*' && s.at(1) == (byte)'/')
;               {
;                   s = s.plus(2);
;                   break;
;               }
;       }
;       return s;
    ))

;; Return true if there is no code at s[0].  White space and comments are not considered code.

(defn- #_boolean cin_nocode [#_Bytes s]
    (§
;       return (cin_skipcomment(s).at(0) == NUL);
    ))

(atom! pos_C _3_pos (§_pos_C))

;; Check previous lines for a "//" line comment, skipping over blank lines.

(defn- #_pos_C find_line_comment []
    (§
;       COPY_pos(@_3_pos, @curwin.w_cursor);

;       while (0 < --@_3_pos.lnum)
;       {
;           Bytes line = ml_get(@_3_pos.lnum);
;           Bytes p = skipwhite(line);
;           if (cin_islinecomment(p))
;           {
;               @_3_pos.col = BDIFF(p, line);
;               return @_3_pos;
;           }
;           if (p.at(0) != NUL)
;               break;
;       }

;       return null;
    ))

;; Return true if "text" starts with "key:".

(defn- #_boolean cin_has_js_key [#_Bytes text]
    (§
;       Bytes s = skipwhite(text);
;       int quote = -1;

;       if (s.at(0) == (byte)'\'' || s.at(0) == (byte)'"')
;       {
            ;; can be 'key': or "key":
;           quote = s.at(0);
;           s = s.plus(1);
;       }
;       if (!vim_isIDc(s.at(0)))    ;; need at least one ID character
;           return false;

;       while (vim_isIDc(s.at(0)))
;           s = s.plus(1);
;       if (s.at(0) == quote)
;           s = s.plus(1);

;       s = cin_skipcomment(s);

        ;; "::" is not a label, it's C++
;       return (s.at(0) == (byte)':' && s.at(1) != (byte)':');
    ))

;; Check if string matches "label:"; move to character after ':' if true.
;; "*s" must point to the start of the label, if there is one.

(defn- #_boolean cin_islabel_skip [#_Bytes* s]
    (§
;       if (!vim_isIDc(s[0].at(0)))            ;; need at least one ID character
;           return false;

;       while (vim_isIDc(s[0].at(0)))
;           s[0] = s[0].plus(1);

;       s[0] = cin_skipcomment(s[0]);

        ;; "::" is not a label, it's C++
;       return (s[0].at(0) == (byte)':' && (s[0] = s[0].plus(1)).at(0) != (byte)':');
    ))

;; Recognize a label: "label:".
;; Note: curwin.w_cursor must be where we are looking for the label.

(defn- #_boolean cin_islabel []
    (§
;       Bytes[] s = { cin_skipcomment(ml_get_curline()) };

        ;; Exclude "default" from labels, since it should be indented
        ;; like a switch label.  Same for C++ scope declarations.

;       if (cin_isdefault(s[0]))
;           return false;
;       if (cin_isscopedecl(s[0]))
;           return false;

;       if (cin_islabel_skip(s))
;       {
;           pos_C cursor_save = §_pos_C();
;           COPY_pos(cursor_save, @curwin.w_cursor);

            ;; Only accept a label if the previous line is terminated or is a case label.

;           while (1 < @curwin.w_cursor.lnum)
;           {
;               --@curwin.w_cursor.lnum;

                ;; If we're in a comment now, skip to the start of the comment.

;               @curwin.w_cursor.col = 0;
;               pos_C trypos = ind_find_start_comment();
;               if (trypos != null)
;                   COPY_pos(@curwin.w_cursor, trypos);

;               Bytes[] line = { ml_get_curline() };
;               if (cin_ispreproc(line[0]))    ;; ignore #defines, #if, etc.
;                   continue;
;               line[0] = cin_skipcomment(line[0]);
;               if (line[0].at(0) == NUL)
;                   continue;

;               COPY_pos(@curwin.w_cursor, cursor_save);
;               return (cin_isterminated(line[0], true, false) != NUL
;                       || cin_isscopedecl(line[0])
;                       || cin_iscase(line[0], true)
;                       || (cin_islabel_skip(line) && cin_nocode(line[0])));
;           }

;           COPY_pos(@curwin.w_cursor, cursor_save);
;           return true;            ;; label at start of file???
;       }

;       return false;
    ))

(final Bytes* cin__skip [ (u8 "static"), (u8 "public"), (u8 "protected"), (u8 "private") ])

;; Recognize structure initialization and enumerations:
;; "[typedef] [static|public|protected|private] enum"
;; "[typedef] [static|public|protected|private] = {"

(defn- #_boolean cin_isinit []
    (§
;       Bytes s = cin_skipcomment(ml_get_curline());

;       if (cin_starts_with(s, u8("typedef")))
;           s = cin_skipcomment(s.plus(7));

;       for ( ; ; )
;       {
;           int len = 0;	// %% anno dunno
;           for (int i = 0; i < cin__skip.length; i++)
;           {
;               len = STRLEN(cin__skip[i]);
;               if (cin_starts_with(s, cin__skip[i]))
;               {
;                   s = cin_skipcomment(s.plus(len));
;                   len = 0;
;                   break;
;               }
;           }
;           if (len != 0)
;               break;
;       }

;       if (cin_starts_with(s, u8("enum")))
;           return true;

;       if (cin_ends_in(s, u8("="), u8("{")))
;           return true;

;       return false;
    ))

;; Recognize a switch label: "case .*:" or "default:".

(defn- #_boolean cin_iscase [#_Bytes s, #_boolean strict]
    ;; strict: Allow relaxed check of case statement for JS
    (§
;       s = cin_skipcomment(s);

;       if (cin_starts_with(s, u8("case")))
;       {
;           for (s = s.plus(4); s.at(0) != NUL; s = s.plus(1))
;           {
;               s = cin_skipcomment(s);
;               if (s.at(0) == (byte)':')
;               {
;                   if (s.at(1) == (byte)':')       ;; skip over "::" for C++
;                       s = s.plus(1);
;                   else
;                       return true;
;               }
;               if (s.at(0) == (byte)'\'' && s.at(1) != NUL && s.at(2) == (byte)'\'')
;                   s = s.plus(2);                 ;; skip over ':'
;               else if (s.at(0) == (byte)'/' && (s.at(1) == (byte)'*' || s.at(1) == (byte)'/'))
;                   return false;           ;; stop at comment
;               else if (s.at(0) == (byte)'"')
;               {
                    ;; JS etc.
;                   if (strict)
;                       return false;       ;; stop at string
;                   else
;                       return true;
;               }
;           }
;           return false;
;       }

;       if (cin_isdefault(s))
;           return true;

;       return false;
    ))

;; Recognize a "default" switch label.

(defn- #_boolean cin_isdefault [#_Bytes s]
    (§
;       return (STRNCMP(s, u8("default"), 7) == 0 && (s = cin_skipcomment(s.plus(7))).at(0) == (byte)':' && s.at(1) != (byte)':');
    ))

;; Recognize a "public/private/protected" scope declaration label.

(defn- #_boolean cin_isscopedecl [#_Bytes s]
    (§
;       int i;

;       s = cin_skipcomment(s);
;       if (STRNCMP(s, u8("public"), 6) == 0)
;           i = 6;
;       else if (STRNCMP(s, u8("protected"), 9) == 0)
;           i = 9;
;       else if (STRNCMP(s, u8("private"), 7) == 0)
;           i = 7;
;       else
;           return false;

;       return ((s = cin_skipcomment(s.plus(i))).at(0) == (byte)':' && s.at(1) != (byte)':');
    ))

;; Maximum number of lines to search back for a "namespace" line.
(final int FIND_NAMESPACE_LIM 20)

;; Recognize a "namespace" scope declaration.

(defn- #_boolean cin_is_cpp_namespace [#_Bytes s]
    (§
;       s = cin_skipcomment(s);

;       if (STRNCMP(s, u8("namespace"), 9) == 0 && (s.at(9) == NUL || !us_iswordb(s.at(9), @curbuf)))
;       {
;           boolean has_name = false;

;           for (Bytes p = cin_skipcomment(skipwhite(s.plus(9))); p.at(0) != NUL; )
;           {
;               if (vim_iswhite(p.at(0)))
;               {
;                   has_name = true;                        ;; found end of a name
;                   p = cin_skipcomment(skipwhite(p));
;               }
;               else if (p.at(0) == (byte)'{')
;               {
;                   break;
;               }
;               else if (us_iswordb(p.at(0), @curbuf))
;               {
;                   if (has_name)
;                       return false;               ;; word character after skipping past name
;                   p = p.plus(1);
;               }
;               else
;                   return false;
;           }

;           return true;
;       }

;       return false;
    ))

;; Return a pointer to the first non-empty non-comment character after a ':'.
;; Return null if not found.
;;        case 234:    a = b;
;;                     ^

(defn- #_Bytes after_label [#_Bytes s]
    (§
;       for ( ; s.at(0) != NUL; s = s.plus(1))
;       {
;           if (s.at(0) == (byte)':')
;           {
;               if (s.at(1) == (byte)':')       ;; skip over "::" for C++
;                   s = s.plus(1);
;               else if (!cin_iscase(s.plus(1), false))
;                   break;
;           }
;           else if (s.at(0) == (byte)'\'' && s.at(1) != NUL && s.at(2) == (byte)'\'')
;               s = s.plus(2);                 ;; skip over 'x'
;       }
;       if (s.at(0) == NUL)
;           return null;
;       s = cin_skipcomment(s.plus(1));
;       if (s.at(0) == NUL)
;           return null;

;       return s;
    ))

;; Get indent of line "lnum", skipping a label.
;; Return 0 if there is nothing after the label.

(defn- #_int get_indent_nolabel [#_long lnum]
    (§
;       Bytes line = ml_get(lnum);
;       Bytes p = after_label(line);
;       if (p == null)
;           return 0;

;       pos_C fp = §_pos_C();
;       fp.col = BDIFF(p, line);
;       fp.lnum = lnum;

;       int[] col = new int[1];
;       getvcol(@curwin, fp, col, null, null);
;       return col[0];
    ))

;; Find indent for line "lnum", ignoring any case or jump label.
;; Also return a pointer to the text (after the label) in "pp".
;;   label:     if (asdf && asdfasdf)
;;              ^

(defn- #_int skip_label [#_long lnum, #_Bytes* pp]
    (§
;       int amount;
;       pos_C cursor_save = §_pos_C();
;       COPY_pos(cursor_save, @curwin.w_cursor);

;       @curwin.w_cursor.lnum = lnum;
;       Bytes p = ml_get_curline();

;       if (cin_iscase(p, false) || cin_isscopedecl(p) || cin_islabel())
;       {
;           amount = get_indent_nolabel(lnum);
;           p = after_label(ml_get_curline());
;           if (p == null)                      ;; just in case
;               p = ml_get_curline();
;       }
;       else
;       {
;           amount = get_indent();
;           p = ml_get_curline();
;       }
;       pp[0] = p;

;       COPY_pos(@curwin.w_cursor, cursor_save);
;       return amount;
    ))

;; Return the indent of the first variable name after a type in a declaration.
;;  int     a,                  indent of "a"
;;  static struct foo    b,     indent of "b"
;;  enum bla    c,              indent of "c"
;; Returns zero when it doesn't look like a declaration.

(defn- #_int cin_first_id_amount []
    (§
;       Bytes line = ml_get_curline();

;       Bytes p = skipwhite(line);
;       int len = BDIFF(skiptowhite(p), p);
;       if (len == 6 && STRNCMP(p, u8("static"), 6) == 0)
;       {
;           p = skipwhite(p.plus(6));
;           len = BDIFF(skiptowhite(p), p);
;       }

;       if (len == 6 && STRNCMP(p, u8("struct"), 6) == 0)
;           p = skipwhite(p.plus(6));
;       else if (len == 4 && STRNCMP(p, u8("enum"), 4) == 0)
;           p = skipwhite(p.plus(4));
;       else if ((len == 8 && STRNCMP(p, u8("unsigned"), 8) == 0)
;             || (len == 6 && STRNCMP(p, u8("signed"), 6) == 0))
;       {
;           Bytes s = skipwhite(p.plus(len));
;           if ((STRNCMP(s, u8("int"), 3) == 0 && vim_iswhite(s.at(3)))
;            || (STRNCMP(s, u8("long"), 4) == 0 && vim_iswhite(s.at(4)))
;            || (STRNCMP(s, u8("short"), 5) == 0 && vim_iswhite(s.at(5)))
;            || (STRNCMP(s, u8("char"), 4) == 0 && vim_iswhite(s.at(4))))
;               p = s;
;       }

;       for (len = 0; vim_isIDc(p.at(len)); len++)
        ;
;       if (len == 0 || !vim_iswhite(p.at(len)) || cin_nocode(p))
;           return 0;

;       p = skipwhite(p.plus(len));

;       pos_C fp = §_pos_C();
;       fp.lnum = @curwin.w_cursor.lnum;
;       fp.col = BDIFF(p, line);

;       int[] col = new int[1];
;       getvcol(@curwin, fp, col, null, null);
;       return col[0];
    ))

;; Return the indent of the first non-blank after an equal sign.
;;       char *foo = "here";
;; Return zero if no (useful) equal sign found.
;; Return -1 if the line above "lnum" ends in a backslash.
;;      foo = "asdf\
;;             asdf\
;;             here";

(defn- #_int cin_get_equal_amount [#_long lnum]
    (§
;       if (1 < lnum)
;       {
;           Bytes line = ml_get(lnum - 1);
;           if (line.at(0) != NUL && line.at(STRLEN(line) - 1) == '\\')
;               return -1;
;       }

;       Bytes line = ml_get(lnum);

;       Bytes s = line;
;       while (s.at(0) != NUL && vim_strbyte(u8("=;{}\"'"), s.at(0)) == null)
;       {
;           if (cin_iscomment(s))   ;; ignore comments
;               s = cin_skipcomment(s);
;           else
;               s = s.plus(1);
;       }
;       if (s.at(0) != (byte)'=')
;           return 0;

;       s = skipwhite(s.plus(1));
;       if (cin_nocode(s))
;           return 0;

;       if (s.at(0) == (byte)'"')      ;; nice alignment for continued strings
;           s = s.plus(1);

;       pos_C fp = §_pos_C();
;       fp.lnum = lnum;
;       fp.col = BDIFF(s, line);

;       int[] col = new int[1];
;       getvcol(@curwin, fp, col, null, null);
;       return col[0];
    ))

;; Recognize a preprocessor statement: Any line that starts with '#'.

(defn- #_boolean cin_ispreproc [#_Bytes s]
    (§
;       return (skipwhite(s).at(0) == (byte)'#');
    ))

;; Return true if line "*pp" at "*lnump" is a preprocessor statement or a
;; continuation line of a preprocessor statement.  Decrease "*lnump" to the
;; start and return the line in "*pp".

(defn- #_boolean cin_ispreproc_cont [#_Bytes* pp, #_long* lnump]
    (§
;       boolean retval = false;

;       Bytes line = pp[0];
;       long lnum = lnump[0];

;       for ( ; ; )
;       {
;           if (cin_ispreproc(line))
;           {
;               retval = true;
;               lnump[0] = lnum;
;               break;
;           }
;           if (lnum == 1)
;               break;
;           line = ml_get(--lnum);
;           if (line.at(0) == NUL || line.at(STRLEN(line) - 1) != '\\')
;               break;
;       }

;       if (lnum != lnump[0])
;           pp[0] = ml_get(lnump[0]);

;       return retval;
    ))

;; Recognize the start of a C or C++ comment.

(defn- #_boolean cin_iscomment [#_Bytes p]
    (§
;       return (p.at(0) == (byte)'/' && (p.at(1) == (byte)'*' || p.at(1) == (byte)'/'));
    ))

;; Recognize the start of a "//" comment.

(defn- #_boolean cin_islinecomment [#_Bytes p]
    (§
;       return (p.at(0) == (byte)'/' && p.at(1) == (byte)'/');
    ))

;; Recognize a line that starts with '{' or '}', or ends with ';', ',', '{' or '}'.
;; Don't consider "} else" a terminated line.
;; If a line begins with an "else", only consider it terminated if no unmatched
;; opening braces follow (handle "else { foo();" correctly).
;; Return the character terminating the line (ending char's have precedence if
;; both apply in order to determine initializations).

(defn- #_byte cin_isterminated [#_Bytes s, #_boolean incl_open, #_boolean incl_comma]
    ;; incl_open: include '{' at the end as terminator
    ;; incl_comma: recognize a trailing comma
    (§
;       byte found_start = NUL;
;       int n_open = 0;
;       boolean is_else = false;

;       s = cin_skipcomment(s);

;       if (s.at(0) == (byte)'{' || (s.at(0) == (byte)'}' && !cin_iselse(s)))
;           found_start = s.at(0);

;       if (found_start == NUL)
;           is_else = cin_iselse(s);

;       while (s.at(0) != NUL)
;       {
            ;; skip over comments, "" strings and 'c'haracters
;           s = skip_string(cin_skipcomment(s));
;           if (s.at(0) == (byte)'}' && 0 < n_open)
;               --n_open;
;           if ((!is_else || n_open == 0)
;                   && (s.at(0) == (byte)';' || s.at(0) == (byte)'}' || (incl_comma && s.at(0) == (byte)','))
;                   && cin_nocode(s.plus(1)))
;               return s.at(0);
;           else if (s.at(0) == (byte)'{')
;           {
;               if (incl_open && cin_nocode(s.plus(1)))
;                   return s.at(0);
;               else
;                   n_open++;
;           }

;           if (s.at(0) != NUL)
;               s = s.plus(1);
;       }

;       return found_start;
    ))

;; Recognize the basic picture of a function declaration -- it needs to have
;; an open paren somewhere and a close paren at the end of the line and no semicolons anywhere.
;; When a line ends in a comma, we continue looking in the next line.
;; "sp" points to a string with the line.  When looking at other lines,
;; it must be restored to the line.  When it's null, fetch lines here.
;; "lnum" is where we start looking.
;; "min_lnum" is the line before which we will not be looking.

(defn- #_boolean cin_isfuncdecl [#_Bytes* sp, #_long first_lnum, #_long min_lnum]
    (§
;       long lnum = first_lnum;

;       Bytes s;
;       if (sp == null)
;           s = ml_get(lnum);
;       else
;           s = sp[0];

;       pos_C trypos;
;       if (find_last_paren(s, '(', ')') && (trypos = find_match_paren(@curbuf.b_ind_maxparen)) != null)
;       {
;           lnum = trypos.lnum;
;           if (lnum < min_lnum)
;               return false;

;           s = ml_get(lnum);
;       }

        ;; Ignore line starting with #.
;       if (cin_ispreproc(s))
;           return false;

;       while (s.at(0) != NUL && s.at(0) != (byte)'(' && s.at(0) != (byte)';' && s.at(0) != (byte)'\'' && s.at(0) != (byte)'"')
;       {
;           if (cin_iscomment(s))           ;; ignore comments
;               s = cin_skipcomment(s);
;           else
;               s = s.plus(1);
;       }
;       if (s.at(0) != (byte)'(')
;           return false;           ;; ';', ' or "  before any () or no '('

;       boolean just_started = true;
;       boolean retval = false;

;       while (s.at(0) != NUL && s.at(0) != (byte)';' && s.at(0) != (byte)'\'' && s.at(0) != (byte)'"')
;       {
;           if (s.at(0) == (byte)')' && cin_nocode(s.plus(1)))
;           {
                ;; ')' at the end: may have found a match
                ;; Check for he previous line not to end in a backslash:
                ;;       #if defined(x) && \
                ;;           defined(y)

;               lnum = first_lnum - 1;
;               s = ml_get(lnum);
;               if (s.at(0) == NUL || s.at(STRLEN(s) - 1) != '\\')
;                   retval = true;
;               break;
;           }

;           if ((s.at(0) == (byte)',' && cin_nocode(s.plus(1))) || s.at(1) == NUL || cin_nocode(s))
;           {
;               boolean comma = (s.at(0) == (byte)',');

                ;; ',' at the end: continue looking in the next line.
                ;; At the end: check for ',' in the next line, for this style:
                ;; func(arg1
                ;;       , arg2)
;               for ( ; ; )
;               {
;                   if (@curbuf.b_ml.ml_line_count <= lnum)
;                       break;
;                   s = ml_get(++lnum);
;                   if (!cin_ispreproc(s))
;                       break;
;               }
;               if (@curbuf.b_ml.ml_line_count <= lnum)
;                   break;
                ;; Require a comma at end of the line or a comma or ')' at the start of next line.
;               s = skipwhite(s);
;               if (!just_started && (!comma && s.at(0) != (byte)',' && s.at(0) != (byte)')'))
;                   break;
;               just_started = false;
;           }
;           else if (cin_iscomment(s))      ;; ignore comments
;               s = cin_skipcomment(s);
;           else
;           {
;               s = s.plus(1);
;               just_started = false;
;           }
;       }

;       if (lnum != first_lnum && sp != null)
;           sp[0] = ml_get(first_lnum);

;       return retval;
    ))

(defn- #_boolean cin_isif [#_Bytes p]
    (§
;       return (STRNCMP(p, u8("if"), 2) == 0 && !vim_isIDc(p.at(2)));
    ))

(defn- #_boolean cin_iselse [#_Bytes p]
    (§
;       if (p.at(0) == (byte)'}')          ;; accept "} else"
;           p = cin_skipcomment(p.plus(1));

;       return (STRNCMP(p, u8("else"), 4) == 0 && !vim_isIDc(p.at(4)));
    ))

(defn- #_boolean cin_isdo [#_Bytes p]
    (§
;       return (STRNCMP(p, u8("do"), 2) == 0 && !vim_isIDc(p.at(2)));
    ))

;; Check if this is a "while" that should have a matching "do".
;; We only accept a "while (condition) ;", with only white space between the ')' and ';'.
;; The condition may be spread over several lines.

(defn- #_boolean cin_iswhileofdo [#_Bytes p, #_long lnum]
    (§
;       boolean retval = false;

;       p = cin_skipcomment(p);
;       if (p.at(0) == (byte)'}')                      ;; accept "} while (cond);"
;           p = cin_skipcomment(p.plus(1));

;       if (cin_starts_with(p, u8("while")))
;       {
;           pos_C cursor_save = §_pos_C();
;           COPY_pos(cursor_save, @curwin.w_cursor);
;           @curwin.w_cursor.lnum = lnum;
;           @curwin.w_cursor.col = 0;

            ;; skip any '}', until the 'w' of the "while"
;           for (p = ml_get_curline(); p.at(0) != NUL && p.at(0) != (byte)'w'; p = p.plus(1))
;               @curwin.w_cursor.col++;

;           pos_C trypos = findmatchlimit(null, 0, 0, @curbuf.b_ind_maxparen);
;           if (trypos != null && cin_skipcomment(ml_get_pos(trypos).plus(1)).at(0) == (byte)';')
;               retval = true;

;           COPY_pos(@curwin.w_cursor, cursor_save);
;       }

;       return retval;
    ))

;; Check whether in "p" there is an "if", "for" or "while" before "*poffset".
;; Return false if there is none.
;; Otherwise return true and update "*poffset" to point to the place where the string was found.

(defn- #_boolean cin_is_if_for_while_before_offset [#_Bytes line, #_int* poffset]
    (§
;       int offset = poffset[0];

;       if (offset-- < 2)
;           return false;
;       while (2 < offset && vim_iswhite(line.at(offset)))
;           --offset;

;       probablyFound:
;       {
;           offset -= 1;
;           if (STRNCMP(line.plus(offset), u8("if"), 2) == 0)
;               break probablyFound;

;           if (1 <= offset)
;           {
;               offset -= 1;
;               if (STRNCMP(line.plus(offset), u8("for"), 3) == 0)
;                   break probablyFound;

;               if (2 <= offset)
;               {
;                   offset -= 2;
;                   if (STRNCMP(line.plus(offset), u8("while"), 5) == 0)
;                       break probablyFound;
;               }
;           }
;           return false;
;       }

;       if (offset == 0 || !vim_isIDc(line.at(offset - 1)))
;       {
;           poffset[0] = offset;
;           return true;
;       }
;       return false;
    ))

;; Return true if we are at the end of a do-while.
;;    do
;;       nothing;
;;    while (foo
;;             && bar);  <-- here
;; Adjust the cursor to the line with "while".

(defn- #_boolean cin_iswhileofdo_end [#_int terminated]
    (§
;       if (terminated != ';')      ;; there must be a ';' at the end
;           return false;

;       Bytes line = ml_get_curline();
;       for (Bytes p = line; p.at(0) != NUL; )
;       {
;           p = cin_skipcomment(p);
;           if (p.at(0) == (byte)')')
;           {
;               Bytes s = skipwhite(p.plus(1));
;               if (s.at(0) == (byte)';' && cin_nocode(s.plus(1)))
;               {
                    ;; Found ");" at end of the line,
                    ;; now check there is "while" before the matching '('.
;                   int i = BDIFF(p, line);
;                   @curwin.w_cursor.col = i;
;                   pos_C trypos = find_match_paren(@curbuf.b_ind_maxparen);
;                   if (trypos != null)
;                   {
;                       s = cin_skipcomment(ml_get(trypos.lnum));
;                       if (s.at(0) == (byte)'}')              ;; accept "} while (cond);"
;                           s = cin_skipcomment(s.plus(1));
;                       if (cin_starts_with(s, u8("while")))
;                       {
;                           @curwin.w_cursor.lnum = trypos.lnum;
;                           return true;
;                       }
;                   }

                    ;; Searching may have made "line" invalid, get it again.
;                   line = ml_get_curline();
;                   p = line.plus(i);
;               }
;           }
;           if (p.at(0) != NUL)
;               p = p.plus(1);
;       }

;       return false;
    ))

(defn- #_boolean cin_isbreak [#_Bytes p]
    (§
;       return (STRNCMP(p, u8("break"), 5) == 0 && !vim_isIDc(p.at(5)));
    ))

;; Find the position of a C++ base-class declaration or
;; constructor-initialization. eg:
;;
;; class MyClass :
;;      baseClass               <-- here
;; class MyClass : public baseClass,
;;      anotherBaseClass        <-- here (should probably lineup ??)
;; MyClass::MyClass(...) :
;;      baseClass(...)          <-- here (constructor-initialization)
;;
;; This is a lot of guessing.  Watch out for "cond ? func() : foo".

(defn- #_boolean cin_is_cpp_baseclass [#_int* col]
    ;; col: return: column to align with
    (§
;       long lnum = @curwin.w_cursor.lnum;
;       Bytes line = ml_get_curline();

;       col[0] = 0;

;       Bytes s = skipwhite(line);
;       if (s.at(0) == (byte)'#')              ;; skip #define FOO x ? (x) : x
;           return false;
;       s = cin_skipcomment(s);
;       if (s.at(0) == NUL)
;           return false;

;       boolean class_or_struct = false;
;       boolean lookfor_ctor_init = false;
;       boolean cpp_base_class = false;

        ;; Search for a line starting with '#', empty, ending in ';' or containing
        ;; '{' or '}' and start below it.  This handles the following situations:
        ;;  a = cond ?
        ;;        func() :
        ;;             asdf;
        ;;  func::foo()
        ;;        : something
        ;;  {}
        ;;  Foo::Foo (int one, int two)
        ;;          : something(4),
        ;;          somethingelse(3)
        ;;  {}

;       while (1 < lnum)
;       {
;           line = ml_get(lnum - 1);
;           s = skipwhite(line);
;           if (s.at(0) == (byte)'#' || s.at(0) == NUL)
;               break;
;           while (s.at(0) != NUL)
;           {
;               s = cin_skipcomment(s);
;               if (s.at(0) == (byte)'{' || s.at(0) == (byte)'}' || (s.at(0) == (byte)';' && cin_nocode(s.plus(1))))
;                   break;
;               if (s.at(0) != NUL)
;                   s = s.plus(1);
;           }
;           if (s.at(0) != NUL)
;               break;
;           --lnum;
;       }

;       line = ml_get(lnum);
;       s = cin_skipcomment(line);
;       for ( ; ; )
;       {
;           if (s.at(0) == NUL)
;           {
;               if (lnum == @curwin.w_cursor.lnum)
;                   break;
                ;; Continue in the cursor line.
;               line = ml_get(++lnum);
;               s = cin_skipcomment(line);
;               if (s.at(0) == NUL)
;                   continue;
;           }

;           if (s.at(0) == (byte)'"')
;               s = skip_string(s).plus(1);
;           else if (s.at(0) == (byte)':')
;           {
;               if (s.at(1) == (byte)':')
;               {
                    ;; Skip double colon: it can't be a constructor initialization any more.
;                   lookfor_ctor_init = false;
;                   s = cin_skipcomment(s.plus(2));
;               }
;               else if (lookfor_ctor_init || class_or_struct)
;               {
                    ;; We have found something, that looks like the start of
                    ;; cpp-base-class-declaration or constructor-initialization.
;                   cpp_base_class = true;
;                   lookfor_ctor_init = class_or_struct = false;
;                   col[0] = 0;
;                   s = cin_skipcomment(s.plus(1));
;               }
;               else
;                   s = cin_skipcomment(s.plus(1));
;           }
;           else if ((STRNCMP(s, u8("class"), 5) == 0 && !vim_isIDc(s.at(5)))
;                 || (STRNCMP(s, u8("struct"), 6) == 0 && !vim_isIDc(s.at(6))))
;           {
;               class_or_struct = true;
;               lookfor_ctor_init = false;

;               if (s.at(0) == (byte)'c')
;                   s = cin_skipcomment(s.plus(5));
;               else
;                   s = cin_skipcomment(s.plus(6));
;           }
;           else
;           {
;               if (s.at(0) == (byte)'{' || s.at(0) == (byte)'}' || s.at(0) == (byte)';')
;               {
;                   cpp_base_class = lookfor_ctor_init = class_or_struct = false;
;               }
;               else if (s.at(0) == (byte)')')
;               {
                    ;; Constructor-initialization is assumed if we come across something like "):".
;                   class_or_struct = false;
;                   lookfor_ctor_init = true;
;               }
;               else if (s.at(0) == (byte)'?')
;               {
                    ;; Avoid seeing '() :' after '?' as constructor init.
;                   return false;
;               }
;               else if (!vim_isIDc(s.at(0)))
;               {
                    ;; if it is not an identifier, we are wrong
;                   class_or_struct = false;
;                   lookfor_ctor_init = false;
;               }
;               else if (col[0] == 0)
;               {
                    ;; it can't be a constructor-initialization any more
;                   lookfor_ctor_init = false;

                    ;; the first statement starts here: lineup with this one...
;                   if (cpp_base_class)
;                       col[0] = BDIFF(s, line);
;               }

                ;; When the line ends in a comma don't align with it.
;               if (lnum == @curwin.w_cursor.lnum && s.at(0) == (byte)',' && cin_nocode(s.plus(1)))
;                   col[0] = 0;

;               s = cin_skipcomment(s.plus(1));
;           }
;       }

;       return cpp_base_class;
    ))

(defn- #_int get_baseclass_amount [#_int col]
    (§
;       int amount;

;       if (col == 0)
;       {
;           amount = get_indent();
;           pos_C trypos;
;           if (find_last_paren(ml_get_curline(), '(', ')')
;                   && (trypos = find_match_paren(@curbuf.b_ind_maxparen)) != null)
;               amount = get_indent_lnum(trypos.lnum);
;           if (!cin_ends_in(ml_get_curline(), u8(","), null))
;               amount += @curbuf.b_ind_cpp_baseclass;
;       }
;       else
;       {
;           @curwin.w_cursor.col = col;
;           int[] vcol = new int[1];
;           getvcol(@curwin, @curwin.w_cursor, vcol, null, null);
;           amount = vcol[0];
;       }

;       if (amount < @curbuf.b_ind_cpp_baseclass)
;           amount = @curbuf.b_ind_cpp_baseclass;

;       return amount;
    ))

;; Return true if string "s" ends with the string "find",
;; possibly followed by white space and comments.  Skip strings and comments.
;; Ignore "ignore" after "find" if it's not null.

(defn- #_boolean cin_ends_in [#_Bytes s, #_Bytes find, #_Bytes ignore]
    (§
;       int len = STRLEN(find);

;       for (Bytes p = s; p.at(0) != NUL; )
;       {
;           p = cin_skipcomment(p);
;           if (STRNCMP(p, find, len) == 0)
;           {
;               Bytes r = skipwhite(p.plus(len));
;               if (ignore != null && STRNCMP(r, ignore, STRLEN(ignore)) == 0)
;                   r = skipwhite(r.plus(STRLEN(ignore)));
;               if (cin_nocode(r))
;                   return true;
;           }
;           if (p.at(0) != NUL)
;               p = p.plus(1);
;       }

;       return false;
    ))

;; Return true when "s" starts with "word" and then a non-ID character.

(defn- #_boolean cin_starts_with [#_Bytes s, #_Bytes word]
    (§
;       int len = STRLEN(word);

;       return (STRNCMP(s, word, len) == 0 && !vim_isIDc(s.at(len)));
    ))

;; Skip strings, chars and comments until at or past "trypos".
;; Return the column found.

(defn- #_int cin_skip2pos [#_pos_C trypos]
    (§
;       Bytes line = ml_get(trypos.lnum);

;       Bytes p = line;
;       while (p.at(0) != NUL && BDIFF(p, line) < trypos.col)
;       {
;           if (cin_iscomment(p))
;               p = cin_skipcomment(p);
;           else
;           {
;               p = skip_string(p);
;               p = p.plus(1);
;           }
;       }

;       return BDIFF(p, line);
    ))

(atom! pos_C _2_pos_copy    (§_pos_C))

;; Find the '{' at the start of the block we are in.
;; Return null if no match found.
;; Ignore a '{' that is in a comment, makes indenting the next three lines work.
;; foo()
;; {
;; }

(defn- #_pos_C find_start_brace []
    (§
;       pos_C trypos;
;       pos_C cursor_save = §_pos_C();
;       COPY_pos(cursor_save, @curwin.w_cursor);

;       while ((trypos = findmatchlimit(null, '{', FM_BLOCKSTOP, 0)) != null)
;       {
;           COPY_pos(@_2_pos_copy, trypos); ;; copy pos_C, next findmatch will change it
;           trypos = @_2_pos_copy;
;           COPY_pos(@curwin.w_cursor, trypos);
;           pos_C pos = null;
            ;; ignore the { if it's in a // or / *  * / comment
;           if (cin_skip2pos(trypos) == trypos.col && (pos = ind_find_start_comment()) == null)
;               break;
;           if (pos != null)
;               @curwin.w_cursor.lnum = pos.lnum;
;       }

;       COPY_pos(@curwin.w_cursor, cursor_save);
;       return trypos;
    ))

;; Find the matching '(', ignoring it if it is in a comment.
;; Return null if no match found.

(defn- #_pos_C find_match_paren [#_int ind_maxparen]
    (§
;       return find_match_char('(', ind_maxparen);
    ))

(atom! pos_C _3_pos_copy    (§_pos_C))

(defn- #_pos_C find_match_char [#_int c, #_int ind_maxparen]
    (§
;       pos_C trypos;

;       pos_C cursor_save = §_pos_C();
;       COPY_pos(cursor_save, @curwin.w_cursor);
;       int ind_maxp_wk = ind_maxparen;

;       retry:
;       for ( ; ; )
;       {
;           if ((trypos = findmatchlimit(null, c, 0, ind_maxp_wk)) != null)
;           {
                ;; check if the ( is in a // comment
;               if (trypos.col < cin_skip2pos(trypos))
;               {
;                   ind_maxp_wk = ind_maxparen - (int)(cursor_save.lnum - trypos.lnum);
;                   if (0 < ind_maxp_wk)
;                   {
;                       COPY_pos(@curwin.w_cursor, trypos);
;                       @curwin.w_cursor.col = 0;
;                       continue retry;
;                   }
;                   trypos = null;
;               }
;               else
;               {
;                   COPY_pos(@_3_pos_copy, trypos); ;; copy trypos, findmatch will change it
;                   trypos = @_3_pos_copy;
;                   COPY_pos(@curwin.w_cursor, trypos);

;                   pos_C trypos_wk = ind_find_start_comment();
;                   if (trypos_wk != null)
;                   {
;                       ind_maxp_wk = ind_maxparen - (int)(cursor_save.lnum - trypos_wk.lnum);
;                       if (0 < ind_maxp_wk)
;                       {
;                           COPY_pos(@curwin.w_cursor, trypos_wk);
;                           continue retry;
;                       }
;                       trypos = null;
;                   }
;               }
;           }

;           break;
;       }

;       COPY_pos(@curwin.w_cursor, cursor_save);
;       return trypos;
    ))

;; Find the matching '(', ignoring it if it is in a comment or before an unmatched {.
;; Return null if no match found.

(defn- #_pos_C find_match_paren_after_brace [#_int ind_maxparen]
    (§
;       pos_C trypos = find_match_paren(ind_maxparen);

;       if (trypos != null)
;       {
;           pos_C brace = find_start_brace();

            ;; If both an unmatched '(' and '{' is found, ignore the '(' position if the '{' is further down.
;           if (brace != null
;                   && (trypos.lnum != brace.lnum ? trypos.lnum < brace.lnum : trypos.col < brace.col))
;               trypos = null;
;       }

;       return trypos;
    ))

;; Return ind_maxparen corrected for the difference in line number between the
;; cursor position and "startpos".  This makes sure that searching for a
;; matching paren above the cursor line doesn't find a match because of
;; looking a few lines further.

(defn- #_int corr_ind_maxparen [#_pos_C startpos]
    (§
;       long n = startpos.lnum - @curwin.w_cursor.lnum;

;       if (0 < n && n < @curbuf.b_ind_maxparen / 2)
;           return @curbuf.b_ind_maxparen - (int)n;

;       return @curbuf.b_ind_maxparen;
    ))

;; Set w_cursor.col to the column number of the last unmatched ')' or '{' in line "p".
;; "p" must point to the start of the line.

(defn- #_boolean find_last_paren [#_Bytes p, #_int start, #_int end]
    (§
;       boolean retval = false;
;       int open_count = 0;

;       @curwin.w_cursor.col = 0;                        ;; default is start of line

;       for (int i = 0; p.at(i) != NUL; i++)
;       {
;           i = BDIFF(cin_skipcomment(p.plus(i)), p);      ;; ignore parens in comments
;           i = BDIFF(skip_string(p.plus(i)), p);          ;; ignore parens in quotes
;           if (p.at(i) == start)
;               open_count++;
;           else if (p.at(i) == end)
;           {
;               if (0 < open_count)
;                   --open_count;
;               else
;               {
;                   @curwin.w_cursor.col = i;
;                   retval = true;
;               }
;           }
;       }

;       return retval;
    ))

;; Parse 'cinoptions' and set the values in "curbuf".
;; Must be called when 'cinoptions', 'shiftwidth' and/or 'tabstop' changes.

(defn- #_void parse_cino [#_buffer_C buf]
    (§
;       int sw = (int)get_sw_value(buf);

        ;; Set the default values.

        ;; Spaces from a block's opening brace the prevailing indent for that block should be.
;       buf.b_ind_level = sw;

        ;; Spaces from the edge of the line an open brace that's at the end of a line is imagined to be.
;       buf.b_ind_open_imag = 0;

        ;; Spaces from the prevailing indent for a line that is not preceded by an opening brace.
;       buf.b_ind_no_brace = 0;

        ;; Column where the first { of a function should be located }.
;       buf.b_ind_first_open = 0;

        ;; Spaces from the prevailing indent a leftmost open brace should be located.
;       buf.b_ind_open_extra = 0;

        ;; Spaces from the matching open brace (real location for one at the left edge;
        ;; imaginary location from one that ends a line) the matching close brace should be located.
;       buf.b_ind_close_extra = 0;

        ;; Spaces from the edge of the line an open brace sitting in the leftmost column is imagined to be.
;       buf.b_ind_open_left_imag = 0;

        ;; Spaces jump labels should be shifted to the left if N is non-negative,
        ;; otherwise the jump label will be put to column 1.
;       buf.b_ind_jump_label = -1;

        ;; Spaces from the switch() indent a "case xx" label should be located.
;       buf.b_ind_case = sw;

        ;; Spaces from the "case xx:" code after a switch() should be located.
;       buf.b_ind_case_code = sw;

        ;; Lineup break at end of case in switch() with case label.
;       buf.b_ind_case_break = 0;

        ;; Spaces from the class declaration indent a scope declaration label should be located.
;       buf.b_ind_scopedecl = sw;

        ;; Spaces from the scope declaration label code should be located.
;       buf.b_ind_scopedecl_code = sw;

        ;; Amount K&R-style parameters should be indented.
;       buf.b_ind_param = sw;

        ;; Amount a function type spec should be indented.
;       buf.b_ind_func_type = sw;

        ;; Amount a cpp base class declaration or constructor initialization should be indented.
;       buf.b_ind_cpp_baseclass = sw;

        ;; additional spaces beyond the prevailing indent a continuation line should be located.
;       buf.b_ind_continuation = sw;

        ;; Spaces from the indent of the line with an unclosed parentheses.
;       buf.b_ind_unclosed = sw * 2;

        ;; Spaces from the indent of the line with an unclosed parentheses, which itself is also unclosed.
;       buf.b_ind_unclosed2 = sw;

        ;; Suppress ignoring spaces from the indent of a line starting with an unclosed parentheses.
;       buf.b_ind_unclosed_noignore = 0;

        ;; If the opening paren is the last nonwhite character on the line, and b_ind_unclosed_wrapped
        ;; is nonzero, use this indent relative to the outer context (for very long lines).
;       buf.b_ind_unclosed_wrapped = 0;

        ;; Suppress ignoring white space when lining up with the character after an unclosed parentheses.
;       buf.b_ind_unclosed_whiteok = 0;

        ;; Indent a closing parentheses under the line start of the matching opening parentheses.
;       buf.b_ind_matching_paren = 0;

        ;; Indent a closing parentheses under the previous line.
;       buf.b_ind_paren_prev = 0;

        ;; Extra indent for comments.
;       buf.b_ind_comment = 0;

        ;; Spaces from the comment opener when there is nothing after it.
;       buf.b_ind_in_comment = 3;

        ;; Boolean: if non-zero, use b_ind_in_comment even if there is something after the comment opener.
;       buf.b_ind_in_comment2 = 0;

        ;; Max lines to search for an open paren.
;       buf.b_ind_maxparen = 20;

        ;; Max lines to search for an open comment.
;       buf.b_ind_maxcomment = 70;

        ;; Handle braces for java code.
;       buf.b_ind_java = 0;

        ;; Not to confuse JS object properties with labels.
;       buf.b_ind_js = 0;

        ;; Handle blocked cases correctly.
;       buf.b_ind_keep_case_label = 0;

        ;; Handle C++ namespace.
;       buf.b_ind_cpp_namespace = 0;

        ;; Handle continuation lines containing conditions of if(), for() and while().
;       buf.b_ind_if_for_while = 0;

;       int fraction = 0;

;       for (Bytes p = buf.@b_p_cino; p.at(0) != NUL; )
;       {
;           Bytes l = p;
;           p = p.plus(1);
;           if (p.at(0) == (byte)'-')
;               p = p.plus(1);
;           Bytes digits = p;              ;; remember where the digits start
;           int n;
;           { Bytes[] __ = { p }; n = (int)getdigits(__); p = __[0]; }
;           int divider = 0;
;           if (p.at(0) == (byte)'.')                  ;; ".5s" means a fraction
;           {
;               fraction = libC.atoi(p = p.plus(1));
;               while (asc_isdigit(p.at(0)))
;               {
;                   p = p.plus(1);
;                   if (divider != 0)
;                       divider *= 10;
;                   else
;                       divider = 10;
;               }
;           }
;           if (p.at(0) == (byte)'s')                  ;; "2s" means two times 'shiftwidth'
;           {
;               if (BEQ(p, digits))
;                   n = sw;                 ;; just "s" is one 'shiftwidth'
;               else
;               {
;                   n *= sw;
;                   if (divider != 0)
;                       n += (sw * fraction + divider / 2) / divider;
;               }
;               p = p.plus(1);
;           }
;           if (l.at(1) == (byte)'-')
;               n = -n;

            ;; When adding an entry here, also update the default 'cinoptions'
            ;; in doc/indent.txt, and add explanation for it!
;           switch (l.at(0))
;           {
;               case '>': buf.b_ind_level = n; break;
;               case 'e': buf.b_ind_open_imag = n; break;
;               case 'n': buf.b_ind_no_brace = n; break;
;               case 'f': buf.b_ind_first_open = n; break;
;               case '{': buf.b_ind_open_extra = n; break;
;               case '}': buf.b_ind_close_extra = n; break;
;               case '^': buf.b_ind_open_left_imag = n; break;
;               case 'L': buf.b_ind_jump_label = n; break;
;               case ':': buf.b_ind_case = n; break;
;               case '=': buf.b_ind_case_code = n; break;
;               case 'b': buf.b_ind_case_break = n; break;
;               case 'p': buf.b_ind_param = n; break;
;               case 't': buf.b_ind_func_type = n; break;
;               case '/': buf.b_ind_comment = n; break;
;               case 'c': buf.b_ind_in_comment = n; break;
;               case 'C': buf.b_ind_in_comment2 = n; break;
;               case 'i': buf.b_ind_cpp_baseclass = n; break;
;               case '+': buf.b_ind_continuation = n; break;
;               case '(': buf.b_ind_unclosed = n; break;
;               case 'u': buf.b_ind_unclosed2 = n; break;
;               case 'U': buf.b_ind_unclosed_noignore = n; break;
;               case 'W': buf.b_ind_unclosed_wrapped = n; break;
;               case 'w': buf.b_ind_unclosed_whiteok = n; break;
;               case 'm': buf.b_ind_matching_paren = n; break;
;               case 'M': buf.b_ind_paren_prev = n; break;
;               case ')': buf.b_ind_maxparen = n; break;
;               case '*': buf.b_ind_maxcomment = n; break;
;               case 'g': buf.b_ind_scopedecl = n; break;
;               case 'h': buf.b_ind_scopedecl_code = n; break;
;               case 'j': buf.b_ind_java = n; break;
;               case 'J': buf.b_ind_js = n; break;
;               case 'l': buf.b_ind_keep_case_label = n; break;
;               case '#': buf.b_ind_hash_comment = n; break;
;               case 'N': buf.b_ind_cpp_namespace = n; break;
;               case 'k': buf.b_ind_if_for_while = n; break;
;           }
;           if (p.at(0) == (byte)',')
;               p = p.plus(1);
;       }
    ))

(final int
    LOOKFOR_INITIAL 0,
    LOOKFOR_IF 1,
    LOOKFOR_DO 2,
    LOOKFOR_CASE 3,
    LOOKFOR_ANY 4,
    LOOKFOR_TERM 5,
    LOOKFOR_UNTERM 6,
    LOOKFOR_SCOPEDECL 7,
    LOOKFOR_NOBREAK 8,
    LOOKFOR_CPP_BASECLASS 9,
    LOOKFOR_ENUM_OR_INIT 10,
    LOOKFOR_JS_KEY 11,
    LOOKFOR_COMMA 12)

(defn- #_int get_c_indent []
    (§
;       int amount;

;       int cur_amount = MAXCOL;

;       int cont_amount = 0;                ;; amount for continuation line
;       int added_to_amount = 0;

            ;; make a copy, value is changed below
;       int ind_continuation = @curbuf.b_ind_continuation;

            ;; remember where the cursor was when we started
;       pos_C cur_curpos = §_pos_C();
;       COPY_pos(cur_curpos, @curwin.w_cursor);

            ;; if we are at line 1 0 is fine, right?
;       if (cur_curpos.lnum == 1)
;           return 0;

            ;; Get a copy of the current contents of the line.
            ;; This is required, because only the most recent line obtained with ml_get() is valid!
;       Bytes linecopy = STRDUP(ml_get(cur_curpos.lnum));

            ;; In insert mode and the cursor is on a ')' truncate the line at the cursor position.
            ;; We don't want to line up with the matching '(' when inserting new stuff.
            ;; For unknown reasons the cursor might be past the end of the line, thus check for that.

;       if ((@State & INSERT) != 0
;               && @curwin.w_cursor.col < STRLEN(linecopy)
;               && linecopy.at(@curwin.w_cursor.col) == (byte)')')
;           linecopy.be(@curwin.w_cursor.col, NUL);

;       Bytes theline = skipwhite(linecopy);

            ;; move the cursor to the start of the line

;       @curwin.w_cursor.col = 0;

;       boolean original_line_islabel = cin_islabel();

;       pos_C trypos;
;       pos_C tryposBrace = null;

;       theend:
;       {
                ;; #defines and so on always go at the left when included in 'cinkeys'.

;           if (theline.at(0) == (byte)'#' && (linecopy.at(0) == (byte)'#' || in_cinkeys('#', ' ', true)))
;           {
;               amount = @curbuf.b_ind_hash_comment;
;           }

                ;; Is it a non-case label?  Then that goes at the left margin too unless:
                ;;  - JS flag is set.
                ;;  - 'L' item has a positive value.

;           else if (original_line_islabel && @curbuf.b_ind_js == 0 && @curbuf.b_ind_jump_label < 0)
;           {
;               amount = 0;
;           }

                ;; If we're inside a "//" comment and there is a "//" comment in a previous line,
                ;; lineup with that one.

;           else if (cin_islinecomment(theline) && (trypos = find_line_comment()) != null)
;           {
                    ;; find how indented the line beginning the comment is
;               int[] col = new int[1];
;               getvcol(@curwin, trypos, col, null, null);
;               amount = col[0];
;           }

                ;; If we're inside a comment and not looking at the start of the comment,
                ;; try using the 'comments' option.

;           else if (!cin_iscomment(theline) && (trypos = ind_find_start_comment()) != null)
;           {
;               int lead_start_len = 2;
;               int lead_middle_len = 1;
;               Bytes lead_start = new Bytes(COM_MAX_LEN);  ;; start-comment string
;               Bytes lead_middle = new Bytes(COM_MAX_LEN); ;; middle-comment string
;               Bytes lead_end = new Bytes(COM_MAX_LEN);    ;; end-comment string
;               int start_align = 0;
;               int start_off = 0;
;               boolean done = false;

                    ;; find how indented the line beginning the comment is
;               int[] col = new int[1];
;               getvcol(@curwin, trypos, col, null, null);
;               amount = col[0];
;               lead_start.be(0, NUL);
;               lead_middle.be(0, NUL);

;               for (Bytes[] p = { @curbuf.@b_p_com }; p[0].at(0) != NUL; )
;               {
;                   int align = 0;
;                   int off = 0;
;                   int what = 0;

;                   while (p[0].at(0) != NUL && p[0].at(0) != (byte)':')
;                   {
;                       if (p[0].at(0) == COM_START || p[0].at(0) == COM_END || p[0].at(0) == COM_MIDDLE)
;                           what = (p[0] = p[0].plus(1)).at(-1);
;                       else if (p[0].at(0) == COM_LEFT || p[0].at(0) == COM_RIGHT)
;                           align = (p[0] = p[0].plus(1)).at(-1);
;                       else if (asc_isdigit(p[0].at(0)) || p[0].at(0) == (byte)'-')
;                           off = (int)getdigits(p);
;                       else
;                           p[0] = p[0].plus(1);
;                   }

;                   if (p[0].at(0) == (byte)':')
;                       p[0] = p[0].plus(1);
;                   copy_option_part(p, lead_end, COM_MAX_LEN, u8(","));
;                   if (what == COM_START)
;                   {
;                       STRCPY(lead_start, lead_end);
;                       lead_start_len = STRLEN(lead_start);
;                       start_off = off;
;                       start_align = align;
;                   }
;                   else if (what == COM_MIDDLE)
;                   {
;                       STRCPY(lead_middle, lead_end);
;                       lead_middle_len = STRLEN(lead_middle);
;                   }
;                   else if (what == COM_END)
;                   {
                            ;; If our line starts with the middle comment string,
                            ;; line it up with the comment opener per the 'comments' option.
;                       if (STRNCMP(theline, lead_middle, lead_middle_len) == 0
;                        && STRNCMP(theline, lead_end, STRLEN(lead_end)) != 0)
;                       {
;                           done = true;
;                           if (1 < @curwin.w_cursor.lnum)
;                           {
                                    ;; If the start comment string matches in the previous line,
                                    ;; use the indent of that line plus offset.
                                    ;; If the middle comment string matches in the previous line,
                                    ;; use the indent of that line.
;                               Bytes look = skipwhite(ml_get(@curwin.w_cursor.lnum - 1));
;                               if (STRNCMP(look, lead_start, lead_start_len) == 0)
;                                   amount = get_indent_lnum(@curwin.w_cursor.lnum - 1);
;                               else if (STRNCMP(look, lead_middle, lead_middle_len) == 0)
;                               {
;                                   amount = get_indent_lnum(@curwin.w_cursor.lnum - 1);
;                                   break;
;                               }
                                    ;; If the start comment string doesn't match with
                                    ;; the start of the comment, skip this entry.
;                               else if (STRNCMP(ml_get(trypos.lnum).plus(trypos.col), lead_start, lead_start_len) != 0)
;                                   continue;
;                           }
;                           if (start_off != 0)
;                               amount += start_off;
;                           else if (start_align == COM_RIGHT)
;                               amount += mb_string2cells(lead_start, -1) - mb_string2cells(lead_middle, -1);
;                           break;
;                       }

                            ;; If our line starts with the end comment string,
                            ;; line it up with the middle comment.
;                       if (STRNCMP(theline, lead_middle, lead_middle_len) != 0
;                        && STRNCMP(theline, lead_end, STRLEN(lead_end)) == 0)
;                       {
;                           amount = get_indent_lnum(@curwin.w_cursor.lnum - 1);

;                           if (off != 0)
;                               amount += off;
;                           else if (align == COM_RIGHT)
;                               amount += mb_string2cells(lead_start, -1) - mb_string2cells(lead_middle, -1);
;                           done = true;
;                           break;
;                       }
;                   }
;               }

                    ;; If our line starts with an asterisk, line up with the asterisk in the comment opener;
                    ;; otherwise, line up with the first character of the comment text.

;               if (done)
                    ;
;               else if (theline.at(0) == (byte)'*')
;                   amount += 1;
;               else
;               {
                        ;; If we are more than one line away from the comment opener, take the indent
                        ;; of the previous non-empty line.  If 'cino' has "CO" and we are just below
                        ;; the comment opener and there are any white characters after it line up with
                        ;; the text after it; otherwise, add the amount specified by "c" in 'cino'.

;                   amount = -1;
;                   for (long lnum = cur_curpos.lnum - 1; trypos.lnum < lnum; --lnum)
;                   {
;                       if (linewhite(lnum))                        ;; skip blank lines
;                           continue;
;                       amount = get_indent_lnum(lnum);
;                       break;
;                   }
;                   if (amount == -1)                               ;; use the comment opener
;                   {
;                       Bytes look = null;
;                       if (@curbuf.b_ind_in_comment2 == 0)
;                       {
;                           Bytes start = ml_get(trypos.lnum);
;                           look = start.plus(trypos.col + 2);          ;; skip / and *
;                           if (look.at(0) != NUL)                      ;; if something after it
;                               trypos.col = BDIFF(skipwhite(look), start);
;                       }
;                       getvcol(@curwin, trypos, col, null, null);
;                       amount = col[0];
;                       if (@curbuf.b_ind_in_comment2 != 0 || look.at(0) == NUL)
;                           amount += @curbuf.b_ind_in_comment;
;                   }
;               }
;           }

                ;; Are we looking at a ']' that has a match?

;           else if (skipwhite(theline).at(0) == (byte)']'
;                   && (trypos = find_match_char('[', @curbuf.b_ind_maxparen)) != null)
;           {
                    ;; Align with the line containing the '['.
;               amount = get_indent_lnum(trypos.lnum);
;           }

                ;; Are we inside parentheses or braces?

;           else if (((trypos = find_match_paren(@curbuf.b_ind_maxparen)) != null && @curbuf.b_ind_java == 0)
;                   || (tryposBrace = find_start_brace()) != null
;                   || trypos != null)
;           {
;               if (trypos != null && tryposBrace != null)
;               {
                        ;; Both an unmatched '(' and '{' is found.  Use the one which is
                        ;; closer to the current cursor position, set the other to null.
;                   if (trypos.lnum != tryposBrace.lnum
;                           ? trypos.lnum < tryposBrace.lnum
;                           : trypos.col < tryposBrace.col)
;                       trypos = null;
;                   else
;                       tryposBrace = null;
;               }

;               if (trypos != null)
;               {
;                   pos_C our_paren_pos = §_pos_C();

                        ;; If the matching paren is more than one line away,
                        ;; use the indent of a previous non-empty line that matches the same paren.

;                   if (theline.at(0) == (byte)')' && @curbuf.b_ind_paren_prev != 0)
;                   {
                            ;; Line up with the start of the matching paren line.
;                       amount = get_indent_lnum(@curwin.w_cursor.lnum - 1);
;                   }
;                   else
;                   {
;                       amount = -1;
;                       COPY_pos(our_paren_pos, trypos);
;                       for (long[] lnum = { cur_curpos.lnum - 1 }; our_paren_pos.lnum < lnum[0]; --lnum[0])
;                       {
;                           Bytes[] lp = { skipwhite(ml_get(lnum[0])) };
;                           if (cin_nocode(lp[0]))                  ;; skip comment lines
;                               continue;
;                           if (cin_ispreproc_cont(lp, lnum))
;                               continue;                       ;; ignore #define, #if, etc.
;                           @curwin.w_cursor.lnum = lnum[0];

                                ;; Skip a comment.
;                           if ((trypos = ind_find_start_comment()) != null)
;                           {
;                               lnum[0] = trypos.lnum + 1;
;                               continue;
;                           }

;                           if ((trypos = find_match_paren(corr_ind_maxparen(cur_curpos))) != null
;                                   && trypos.lnum == our_paren_pos.lnum
;                                   && trypos.col == our_paren_pos.col)
;                           {
;                               amount = get_indent_lnum(lnum[0]);

;                               if (theline.at(0) == (byte)')')
;                               {
;                                   if (our_paren_pos.lnum != lnum[0] && amount < cur_amount)
;                                       cur_amount = amount;
;                                   amount = -1;
;                               }
;                               break;
;                           }
;                       }
;                   }

                        ;; Line up with line where the matching paren is.
                        ;; If the line starts with a '(' or the indent for unclosed parentheses is zero,
                        ;; line up with the unclosed parentheses.

;                   if (amount == -1)
;                   {
;                       int ignore_paren_col = 0;
;                       boolean is_if_for_while = false;

;                       if (@curbuf.b_ind_if_for_while != 0)
;                       {
                                ;; Look for the outermost opening parenthesis on this line
                                ;; and check whether it belongs to an "if", "for" or "while".

;                           pos_C cursor_save = §_pos_C();
;                           COPY_pos(cursor_save, @curwin.w_cursor);
;                           pos_C outermost = §_pos_C();

;                           trypos = our_paren_pos;
;                           do
;                           {
;                               COPY_pos(outermost, trypos);
;                               @curwin.w_cursor.lnum = outermost.lnum;
;                               @curwin.w_cursor.col = outermost.col;

;                               trypos = find_match_paren(@curbuf.b_ind_maxparen);
;                           } while (trypos != null && trypos.lnum == outermost.lnum);

;                           COPY_pos(@curwin.w_cursor, cursor_save);

;                           Bytes line = ml_get(outermost.lnum);

;                           { int[] __ = { outermost.col }; is_if_for_while = cin_is_if_for_while_before_offset(line, __); outermost.col = __[0]; }
;                       }

;                       Bytes look;

;                       { Bytes[] __ = new Bytes[1]; amount = skip_label(our_paren_pos.lnum, __); look = __[0]; }
;                       look = skipwhite(look);
;                       if (look.at(0) == (byte)'(')
;                       {
;                           long save_lnum = @curwin.w_cursor.lnum;

                                ;; Ignore a '(' in front of the line that has a match before our matching '('.
;                           @curwin.w_cursor.lnum = our_paren_pos.lnum;
;                           Bytes line = ml_get_curline();
;                           int look_col = BDIFF(look, line);
;                           @curwin.w_cursor.col = look_col + 1;
;                           trypos = findmatchlimit(null, ')', 0, @curbuf.b_ind_maxparen);
;                           if (trypos != null
;                                   && trypos.lnum == our_paren_pos.lnum
;                                   && trypos.col < our_paren_pos.col)
;                               ignore_paren_col = trypos.col + 1;

;                           @curwin.w_cursor.lnum = save_lnum;
;                           look = ml_get(our_paren_pos.lnum).plus(look_col);
;                       }

;                       if (theline.at(0) == (byte)')'
;                           || (@curbuf.b_ind_unclosed == 0 && is_if_for_while == false)
;                           || (@curbuf.b_ind_unclosed_noignore == 0 && look.at(0) == (byte)'(' && ignore_paren_col == 0))
;                       {
                                ;; If we're looking at a close paren, line up right there;
                                ;; otherwise, line up with the next (non-white) character.
                                ;; When b_ind_unclosed_wrapped is set and the matching paren is
                                ;; the last nonwhite character of the line, use either the indent
                                ;; of the current line or the indentation of the next outer paren
                                ;; and add b_ind_unclosed_wrapped (for very long lines).

;                           if (theline.at(0) != (byte)')')
;                           {
;                               cur_amount = MAXCOL;
;                               Bytes l = ml_get(our_paren_pos.lnum);
;                               if (@curbuf.b_ind_unclosed_wrapped != 0 && cin_ends_in(l, u8("("), null))
;                               {
                                        ;; look for opening unmatched paren,
                                        ;; indent one level for each additional level
;                                   int n = 1;
;                                   for (int col = 0; col < our_paren_pos.col; col++)
;                                   {
;                                       switch (l.at(col))
;                                       {
;                                           case '(':
;                                           case '{': ++n;
;                                                   break;

;                                           case ')':
;                                           case '}': if (1 < n)
;                                                       --n;
;                                                   break;
;                                       }
;                                   }

;                                   our_paren_pos.col = 0;
;                                   amount += n * @curbuf.b_ind_unclosed_wrapped;
;                               }
;                               else if (@curbuf.b_ind_unclosed_whiteok != 0)
;                                   our_paren_pos.col++;
;                               else
;                               {
;                                   int col = our_paren_pos.col + 1;
;                                   while (vim_iswhite(l.at(col)))
;                                       col++;
;                                   if (l.at(col) != NUL)              ;; in case of trailing space
;                                       our_paren_pos.col = col;
;                                   else
;                                       our_paren_pos.col++;
;                               }
;                           }

                                ;; Find how indented the paren is, or the character after it
                                ;; if we did the above "if".

;                           if (0 < our_paren_pos.col)
;                           {
;                               int[] col = new int[1];
;                               getvcol(@curwin, our_paren_pos, col, null, null);
;                               if (cur_amount > col[0])
;                                   cur_amount = col[0];
;                           }
;                       }

;                       if (theline.at(0) == (byte)')' && @curbuf.b_ind_matching_paren != 0)
;                       {
                                ;; Line up with the start of the matching paren line.
;                       }
;                       else if ((@curbuf.b_ind_unclosed == 0 && is_if_for_while == false)
;                           || (@curbuf.b_ind_unclosed_noignore == 0 && look.at(0) == (byte)'(' && ignore_paren_col == 0))
;                       {
;                           if (cur_amount != MAXCOL)
;                               amount = cur_amount;
;                       }
;                       else
;                       {
                                ;; Add b_ind_unclosed2 for each '(' before our matching one,
                                ;; but ignore (void) before the line (ignore_paren_col).
;                           int col = our_paren_pos.col;
;                           while (ignore_paren_col < our_paren_pos.col)
;                           {
;                               --our_paren_pos.col;
;                               switch (ml_get_pos(our_paren_pos).at(0))
;                               {
;                                   case '(': amount += @curbuf.b_ind_unclosed2;
;                                           col = our_paren_pos.col;
;                                           break;
;                                   case ')': amount -= @curbuf.b_ind_unclosed2;
;                                           col = MAXCOL;
;                                           break;
;                               }
;                           }

                                ;; Use b_ind_unclosed once, when the first '(' is not inside braces.
;                           if (col == MAXCOL)
;                               amount += @curbuf.b_ind_unclosed;
;                           else
;                           {
;                               @curwin.w_cursor.lnum = our_paren_pos.lnum;
;                               @curwin.w_cursor.col = col;
;                               if (find_match_paren_after_brace(@curbuf.b_ind_maxparen) != null)
;                                   amount += @curbuf.b_ind_unclosed2;
;                               else if (is_if_for_while)
;                                   amount += @curbuf.b_ind_if_for_while;
;                               else
;                                   amount += @curbuf.b_ind_unclosed;
;                           }

                                ;; For a line starting with ')' use the minimum of the two
                                ;; positions, to avoid giving it more indent than the previous
                                ;; lines:
                                ;;  func_long_name(                 if (x
                                ;;      arg                                 && yy
                                ;;      )         ^ not here           )    ^ not here

;                           if (cur_amount < amount)
;                               amount = cur_amount;
;                       }
;                   }

                        ;; add extra indent for a comment
;                   if (cin_iscomment(theline))
;                       amount += @curbuf.b_ind_comment;
;               }
;               else
;               {
                        ;; We are inside braces,
                        ;; there is a { before this line at the position stored in tryposBrace.
                        ;; Make a copy of tryposBrace, it may point to pos_copy inside find_start_brace(),
                        ;; which may be changed somewhere.

;                   pos_C tryposBraceCopy = §_pos_C();
;                   COPY_pos(tryposBraceCopy, tryposBrace);
;                   tryposBrace = tryposBraceCopy;
;                   trypos = tryposBrace;
;                   long ourscope = trypos.lnum;
;                   Bytes start = ml_get(ourscope);

;                   final int
;                       BRACE_IN_COL0 = 1,          ;; '{' is in column 0
;                       BRACE_AT_START = 2,         ;; '{' is at start of line
;                       BRACE_AT_END = 3;           ;; '{' is at end of line

;                   int start_brace;

                        ;; Now figure out how indented the line is in general.
                        ;; If the brace was at the start of the line, we use that;
                        ;; otherwise, check out the indentation of the line as
                        ;; a whole and then add the "imaginary indent" to that.

;                   Bytes look = skipwhite(start);
;                   if (look.at(0) == (byte)'{')
;                   {
;                       int[] col = new int[1];
;                       getvcol(@curwin, trypos, col, null, null);
;                       amount = col[0];
;                       if (start.at(0) == (byte)'{')
;                           start_brace = BRACE_IN_COL0;
;                       else
;                           start_brace = BRACE_AT_START;
;                   }
;                   else
;                   {
                            ;; That opening brace might have been on a continuation line.
                            ;; If so, find the start of the line.
;                       @curwin.w_cursor.lnum = ourscope;

                            ;; Position the cursor over the rightmost paren, so that
                            ;; matching it will take us back to the start of the line.
;                       long lnum = ourscope;
;                       if (find_last_paren(start, '(', ')')
;                                   && (trypos = find_match_paren(@curbuf.b_ind_maxparen)) != null)
;                           lnum = trypos.lnum;

                            ;; It could have been something like
                            ;;     case 1: if (asdf &&
                            ;;                  ldfd) {
                            ;;              }

;                       if ((@curbuf.b_ind_js != 0 || @curbuf.b_ind_keep_case_label != 0)
;                                   && cin_iscase(skipwhite(ml_get_curline()), false))
;                           amount = get_indent();
;                       else if (@curbuf.b_ind_js != 0)
;                           amount = get_indent_lnum(lnum);
;                       else
;                       {
;                           Bytes[] lp = new Bytes[1];
;                           amount = skip_label(lnum, lp);
;                       }

;                       start_brace = BRACE_AT_END;
;                   }

                        ;; For Javascript check if the line starts with "key:".
;                   boolean js_cur_has_key = false;
;                   if (@curbuf.b_ind_js != 0)
;                       js_cur_has_key = cin_has_js_key(theline);

                        ;; If we're looking at a closing brace, that's where we want to be.
                        ;; Otherwise, add the amount of room that an indent is supposed to be.

;                   if (theline.at(0) == (byte)'}')
;                   {
                            ;; they may want closing braces to line up with something
                            ;; other than the open brace.  Indulge them, if so.

;                       amount += @curbuf.b_ind_close_extra;
;                   }
;                   else
;                   {
                            ;; If we're looking at an "else", try to find an "if" to match it with.
                            ;; If we're looking at a "while", try to find a "do" to match it with.

;                       int lookfor = LOOKFOR_INITIAL;
;                       if (cin_iselse(theline))
;                           lookfor = LOOKFOR_IF;
;                       else if (cin_iswhileofdo(theline, cur_curpos.lnum))
;                           lookfor = LOOKFOR_DO;
;                       if (lookfor != LOOKFOR_INITIAL)
;                       {
;                           @curwin.w_cursor.lnum = cur_curpos.lnum;
;                           if (find_match(lookfor, ourscope) == true)
;                           {
;                               amount = get_indent();
;                               break theend;
;                           }
;                       }

                            ;; We get here if we are not on an "while-of-do" or "else"
                            ;; (or failed to find a matching "if").
                            ;; Search backwards for something to line up with.
                            ;; First set amount for when we don't find anything.

                            ;; If the '{' is  _really_ at the left margin, use the imaginary location of
                            ;; a left-margin brace.  Otherwise, correct the location for b_ind_open_extra.

;                       boolean lookfor_cpp_namespace = false;

;                       if (start_brace == BRACE_IN_COL0)       ;; '{' is in column 0
;                       {
;                           amount = @curbuf.b_ind_open_left_imag;
;                           lookfor_cpp_namespace = true;
;                       }
;                       else if (start_brace == BRACE_AT_START && lookfor_cpp_namespace)
;                       {                                       ;; '{' is at start
;                           lookfor_cpp_namespace = true;
;                       }
;                       else
;                       {
;                           if (start_brace == BRACE_AT_END)    ;; '{' is at end of line
;                           {
;                               amount += @curbuf.b_ind_open_imag;

;                               Bytes l = skipwhite(ml_get_curline());
;                               if (cin_is_cpp_namespace(l))
;                                   amount += @curbuf.b_ind_cpp_namespace;
;                           }
;                           else
;                           {
                                    ;; Compensate for adding b_ind_open_extra later.
;                               amount -= @curbuf.b_ind_open_extra;
;                               if (amount < 0)
;                                   amount = 0;
;                           }
;                       }

;                       boolean lookfor_break = false;

;                       if (cin_iscase(theline, false))         ;; it's a switch() label
;                       {
;                           lookfor = LOOKFOR_CASE;             ;; find a previous switch() label
;                           amount += @curbuf.b_ind_case;
;                       }
;                       else if (cin_isscopedecl(theline))      ;; private:, ...
;                       {
;                           lookfor = LOOKFOR_SCOPEDECL;        ;; class decl is this block
;                           amount += @curbuf.b_ind_scopedecl;
;                       }
;                       else
;                       {
;                           if (@curbuf.b_ind_case_break != 0 && cin_isbreak(theline))
                                    ;; break; ...
;                               lookfor_break = true;

;                           lookfor = LOOKFOR_INITIAL;
                                ;; b_ind_level from start of block
;                           amount += @curbuf.b_ind_level;
;                       }

;                       int scope_amount = amount;
;                       int whilelevel = 0;

                            ;; Search backwards.  If we find something we recognize, line up with that.
                            ;;
                            ;; If we're looking at an open brace,
                            ;; indent the usual amount relative to the conditional that opens the block.

;                       COPY_pos(@curwin.w_cursor, cur_curpos);
;                       for ( ; ; )
;                       {
;                           @curwin.w_cursor.lnum--;
;                           @curwin.w_cursor.col = 0;

                                ;; If we went all the way back to the start of our scope, line up with it.

;                           if (@curwin.w_cursor.lnum <= ourscope)
;                           {
                                    ;; we reached end of scope:
                                    ;; if looking for a enum or structure initialization
                                    ;; go further back:
                                    ;; if it is an initializer (enum xxx or xxx =), then don't add
                                    ;; ind_continuation, otherwise it is a variable declaration:
                                    ;; int x,
                                    ;;     here; <-- add ind_continuation

;                               if (lookfor == LOOKFOR_ENUM_OR_INIT)
;                               {
;                                   if (@curwin.w_cursor.lnum == 0
;                                           || @curwin.w_cursor.lnum < ourscope - @curbuf.b_ind_maxparen)
;                                   {
                                            ;; nothing found (abuse curbuf.b_ind_maxparen as limit)
                                            ;; assume terminated line (i.e. a variable initialization)
;                                       if (0 < cont_amount)
;                                           amount = cont_amount;
;                                       else if (@curbuf.b_ind_js == 0)
;                                           amount += ind_continuation;
;                                       break;
;                                   }

;                                   Bytes[] lp = { ml_get_curline() };

                                        ;; If we're in a comment now, skip to the start of the comment.

;                                   trypos = ind_find_start_comment();
;                                   if (trypos != null)
;                                   {
;                                       @curwin.w_cursor.lnum = trypos.lnum + 1;
;                                       @curwin.w_cursor.col = 0;
;                                       continue;
;                                   }

                                        ;; Skip preprocessor directives and blank lines.

;                                   boolean b;
;                                   { long[] __ = { @curwin.w_cursor.lnum }; b = cin_ispreproc_cont(lp, __); @curwin.w_cursor.lnum = __[0]; }
;                                   if (b)
;                                       continue;

;                                   if (cin_nocode(lp[0]))
;                                       continue;

;                                   byte terminated = cin_isterminated(lp[0], false, true);

                                        ;; If we are at top level and the line looks like a function
                                        ;; declaration, we are done (it's a variable declaration).

;                                   if (start_brace != BRACE_IN_COL0
;                                       || !cin_isfuncdecl(lp, @curwin.w_cursor.lnum, 0))
;                                   {
                                            ;; if the line is terminated with another ','
                                            ;; it is a continued variable initialization.
                                            ;; don't add extra indent.
                                            ;; TODO: does not work, if a function declaration is split
                                            ;; over multiple lines:
                                            ;; cin_isfuncdecl returns false then.

;                                       if (terminated == ',')
;                                           break;

                                            ;; if it es a enum declaration or an assignment, we are done
;                                       if (terminated != ';' && cin_isinit())
;                                           break;

                                            ;; nothing useful found
;                                       if (terminated == NUL || terminated == '{')
;                                           continue;
;                                   }

;                                   if (terminated != ';')
;                                   {
                                            ;; Skip parens and braces.  Position the cursor
                                            ;; over the rightmost paren, so that matching it
                                            ;; will take us back to the start of the line.

;                                       trypos = null;
;                                       if (find_last_paren(lp[0], '(', ')'))
;                                           trypos = find_match_paren(@curbuf.b_ind_maxparen);

;                                       if (trypos == null && find_last_paren(lp[0], '{', '}'))
;                                           trypos = find_start_brace();

;                                       if (trypos != null)
;                                       {
;                                           @curwin.w_cursor.lnum = trypos.lnum + 1;
;                                           @curwin.w_cursor.col = 0;
;                                           continue;
;                                       }
;                                   }

                                        ;; it's a variable declaration, add indentation
                                        ;; like in
                                        ;; int a,
                                        ;;    b;

;                                   if (0 < cont_amount)
;                                       amount = cont_amount;
;                                   else
;                                       amount += ind_continuation;
;                               }
;                               else if (lookfor == LOOKFOR_UNTERM)
;                               {
;                                   if (0 < cont_amount)
;                                       amount = cont_amount;
;                                   else
;                                       amount += ind_continuation;
;                               }
;                               else
;                               {
;                                   if (lookfor != LOOKFOR_TERM
;                                       && lookfor != LOOKFOR_CPP_BASECLASS
;                                       && lookfor != LOOKFOR_COMMA)
;                                   {
;                                       amount = scope_amount;
;                                       if (theline.at(0) == (byte)'{')
;                                       {
;                                           amount += @curbuf.b_ind_open_extra;
;                                           added_to_amount = @curbuf.b_ind_open_extra;
;                                       }
;                                   }

;                                   if (lookfor_cpp_namespace)
;                                   {
                                            ;; Looking for C++ namespace, need to look further back.

;                                       if (@curwin.w_cursor.lnum == ourscope)
;                                           continue;

;                                       if (@curwin.w_cursor.lnum == 0
;                                               || @curwin.w_cursor.lnum < ourscope - FIND_NAMESPACE_LIM)
;                                           break;

;                                       Bytes[] lp = { ml_get_curline() };

                                            ;; If we're in a comment now, skip to the start of the comment.
;                                       trypos = ind_find_start_comment();
;                                       if (trypos != null)
;                                       {
;                                           @curwin.w_cursor.lnum = trypos.lnum + 1;
;                                           @curwin.w_cursor.col = 0;
;                                           continue;
;                                       }

                                            ;; Skip preprocessor directives and blank lines.
;                                       boolean b;
;                                       { long[] __ = { @curwin.w_cursor.lnum }; b = cin_ispreproc_cont(lp, __); @curwin.w_cursor.lnum = __[0]; }
;                                       if (b)
;                                           continue;

                                            ;; Finally the actual check for "namespace".
;                                       if (cin_is_cpp_namespace(lp[0]))
;                                       {
;                                           amount += @curbuf.b_ind_cpp_namespace - added_to_amount;
;                                           break;
;                                       }

;                                       if (cin_nocode(lp[0]))
;                                           continue;
;                                   }
;                               }
;                               break;
;                           }

                                ;; If we're in a comment now, skip to the start of the comment.

;                           if ((trypos = ind_find_start_comment()) != null)
;                           {
;                               @curwin.w_cursor.lnum = trypos.lnum + 1;
;                               @curwin.w_cursor.col = 0;
;                               continue;
;                           }

;                           Bytes[] lp = { ml_get_curline() };

                                ;; If this is a switch() label, may line up relative to that.
                                ;; If this is a C++ scope declaration, do the same.

;                           boolean iscase = cin_iscase(lp[0], false);
;                           if (iscase || cin_isscopedecl(lp[0]))
;                           {
                                    ;; we are only looking for cpp base class
                                    ;; declaration/initialization any longer
;                               if (lookfor == LOOKFOR_CPP_BASECLASS)
;                                   break;

                                    ;; When looking for a "do" we are not interested in labels.
;                               if (0 < whilelevel)
;                                   continue;

                                    ;;  case xx:
                                    ;;      c = 99 +        <- this indent plus continuation
                                    ;;->           here;

;                               if (lookfor == LOOKFOR_UNTERM || lookfor == LOOKFOR_ENUM_OR_INIT)
;                               {
;                                   if (0 < cont_amount)
;                                       amount = cont_amount;
;                                   else
;                                       amount += ind_continuation;
;                                   break;
;                               }

                                    ;;  case xx:        <- line up with this case
                                    ;;      x = 333;
                                    ;;  case yy:

;                               if ((iscase && lookfor == LOOKFOR_CASE)
;                                   || (iscase && lookfor_break)
;                                   || (!iscase && lookfor == LOOKFOR_SCOPEDECL))
;                               {
                                        ;; Check that this case label is not for another switch()

;                                   if ((trypos = find_start_brace()) == null || trypos.lnum == ourscope)
;                                   {
;                                       amount = get_indent();
;                                       break;
;                                   }
;                                   continue;
;                               }

;                               int n = get_indent_nolabel(@curwin.w_cursor.lnum);

                                    ;;   case xx: if (cond)         <- line up with this if
                                    ;;                y = y + 1;
                                    ;; ->         s = 99;
                                    ;;
                                    ;;   case xx:
                                    ;;       if (cond)          <- line up with this line
                                    ;;           y = y + 1;
                                    ;; ->    s = 99;

;                               if (lookfor == LOOKFOR_TERM)
;                               {
;                                   if (n != 0)
;                                       amount = n;

;                                   if (!lookfor_break)
;                                       break;
;                               }

                                    ;;   case xx: x = x + 1;        <- line up with this x
                                    ;; ->         y = y + 1;
                                    ;;
                                    ;;   case xx: if (cond)         <- line up with this if
                                    ;; ->              y = y + 1;

;                               if (n != 0)
;                               {
;                                   amount = n;
;                                   Bytes l = after_label(ml_get_curline());
;                                   if (l != null && cin_is_cinword(l))
;                                   {
;                                       if (theline.at(0) == (byte)'{')
;                                           amount += @curbuf.b_ind_open_extra;
;                                       else
;                                           amount += @curbuf.b_ind_level + @curbuf.b_ind_no_brace;
;                                   }
;                                   break;
;                               }

                                    ;; Try to get the indent of a statement before the switch
                                    ;; label.  If nothing is found, line up relative to the
                                    ;; switch label.
                                    ;;      break;              <- may line up with this line
                                    ;;   case xx:
                                    ;; ->   y = 1;

;                               scope_amount = get_indent() + (iscase
;                                                   ? @curbuf.b_ind_case_code
;                                                   : @curbuf.b_ind_scopedecl_code);
;                               lookfor = (@curbuf.b_ind_case_break != 0) ? LOOKFOR_NOBREAK : LOOKFOR_ANY;
;                               continue;
;                           }

                                ;; Looking for a switch() label or C++ scope declaration,
                                ;; ignore other lines, skip {}-blocks.

;                           if (lookfor == LOOKFOR_CASE || lookfor == LOOKFOR_SCOPEDECL)
;                           {
;                               if (find_last_paren(lp[0], '{', '}') && (trypos = find_start_brace()) != null)
;                               {
;                                   @curwin.w_cursor.lnum = trypos.lnum + 1;
;                                   @curwin.w_cursor.col = 0;
;                               }
;                               continue;
;                           }

                                ;; Ignore jump labels with nothing after them.

;                           if (@curbuf.b_ind_js == 0 && cin_islabel())
;                           {
;                               Bytes l = after_label(ml_get_curline());
;                               if (l == null || cin_nocode(l))
;                                   continue;
;                           }

                                ;; Ignore #defines, #if, etc.
                                ;; Ignore comment and empty lines.
                                ;; (need to get the line again, cin_islabel() may have unlocked it)

;                           lp[0] = ml_get_curline();
;                           boolean b;
;                           { long[] __ = { @curwin.w_cursor.lnum }; b = cin_ispreproc_cont(lp, __); @curwin.w_cursor.lnum = __[0]; }
;                           if (b || cin_nocode(lp[0]))
;                               continue;

;                           int[] col = new int[1];

                                ;; Are we at the start of a cpp base class declaration
                                ;; or constructor initialization?

;                           /*boolean */b = false;
;                           if (lookfor != LOOKFOR_TERM && 0 < @curbuf.b_ind_cpp_baseclass)
;                           {
;                               b = cin_is_cpp_baseclass(col);
;                               lp[0] = ml_get_curline();
;                           }
;                           if (b)
;                           {
;                               if (lookfor == LOOKFOR_UNTERM)
;                               {
;                                   if (0 < cont_amount)
;                                       amount = cont_amount;
;                                   else
;                                       amount += ind_continuation;
;                               }
;                               else if (theline.at(0) == (byte)'{')
;                               {
                                        ;; Need to find start of the declaration.
;                                   lookfor = LOOKFOR_UNTERM;
;                                   ind_continuation = 0;
;                                   continue;
;                               }
;                               else
;                                   amount = get_baseclass_amount(col[0]);
;                               break;
;                           }
;                           else if (lookfor == LOOKFOR_CPP_BASECLASS)
;                           {
                                    ;; Only look, whether there is a cpp base class declaration
                                    ;; or initialization before the opening brace.

;                               if (cin_isterminated(lp[0], true, false) != NUL)
;                                   break;
;                               else
;                                   continue;
;                           }

                                ;; What happens next depends on the line being terminated.
                                ;; If terminated with a ',' only consider it terminating if
                                ;; there is another unterminated statement behind, eg:
                                ;;   123,
                                ;;   sizeof
                                ;;        here
                                ;; Otherwise check whether it is a enumeration or structure
                                ;; initialisation (not indented) or a variable declaration
                                ;; (indented).

;                           byte terminated = cin_isterminated(lp[0], false, true);

;                           if (js_cur_has_key)
;                           {
;                               js_cur_has_key = false;     ;; only check the first line
;                               if (@curbuf.b_ind_js != 0 && terminated == ',')
;                               {
                                        ;; For Javascript we might be inside an object:
                                        ;;   key: something,  <- align with this
                                        ;;   key: something
                                        ;; or:
                                        ;;   key: something +  <- align with this
                                        ;;       something,
                                        ;;   key: something

;                                   lookfor = LOOKFOR_JS_KEY;
;                               }
;                           }
;                           if (lookfor == LOOKFOR_JS_KEY && cin_has_js_key(lp[0]))
;                           {
;                               amount = get_indent();
;                               break;
;                           }
;                           if (lookfor == LOOKFOR_COMMA)
;                           {
;                               if (tryposBrace != null && @curwin.w_cursor.lnum <= tryposBrace.lnum)
;                                   break;
;                               if (terminated == ',')
                                        ;; line below current line is the one that starts
                                        ;; a (possibly broken) line ending in a comma
;                                   break;
;                               else
;                               {
;                                   amount = get_indent();
;                                   if (@curwin.w_cursor.lnum - 1 == ourscope)
                                            ;; line above is start of the scope, thus current
                                            ;; line is the one that stars a (possibly broken)
                                            ;; line ending in a comma
;                                       break;
;                               }
;                           }

;                           if (terminated == NUL || (lookfor != LOOKFOR_UNTERM && terminated == ','))
;                           {
;                               if (skipwhite(lp[0]).at(0) == (byte)'[' || lp[0].at(STRLEN(lp[0]) - 1) == '[')
;                                   amount += ind_continuation;

                                    ;; if we're in the middle of a paren thing,
                                    ;; go back to the line that starts it so
                                    ;; we can get the right prevailing indent
                                    ;;     if ( foo &&
                                    ;;              bar )

                                    ;; Position the cursor over the rightmost paren, so that
                                    ;; matching it will take us back to the start of the line.
                                    ;; Ignore a match before the start of the block.

;                               find_last_paren(lp[0], '(', ')');
;                               trypos = find_match_paren(corr_ind_maxparen(cur_curpos));
;                               if (trypos != null && (trypos.lnum < tryposBrace.lnum
;                                           || (trypos.lnum == tryposBrace.lnum && trypos.col < tryposBrace.col)))
;                                   trypos = null;

                                    ;; If we are looking for ',', we also look for matching braces.

;                               if (trypos == null && terminated == ',' && find_last_paren(lp[0], '{', '}'))
;                                   trypos = find_start_brace();

;                               if (trypos != null)
;                               {
                                        ;; Check if we are on a case label now.
                                        ;; This is handled above.
                                        ;;     case xx:  if ( asdf &&
                                        ;;                      asdf)

;                                   COPY_pos(@curwin.w_cursor, trypos);
;                                   lp[0] = ml_get_curline();
;                                   if (cin_iscase(lp[0], false) || cin_isscopedecl(lp[0]))
;                                   {
;                                       @curwin.w_cursor.lnum++;
;                                       @curwin.w_cursor.col = 0;
;                                       continue;
;                                   }
;                               }

                                    ;; Skip over continuation lines to find
                                    ;; the one to get the indent from
                                    ;; char *usethis = "bla\
                                    ;;           bla",
                                    ;;      here;

;                               if (terminated == ',')
;                               {
;                                   while (1 < @curwin.w_cursor.lnum)
;                                   {
;                                       lp[0] = ml_get(@curwin.w_cursor.lnum - 1);
;                                       if (lp[0].at(0) == NUL || lp[0].at(STRLEN(lp[0]) - 1) != '\\')
;                                           break;
;                                       --@curwin.w_cursor.lnum;
;                                       @curwin.w_cursor.col = 0;
;                                   }
;                               }

                                    ;; Get indent and pointer to text for current line,
                                    ;; ignoring any jump label.

;                               if (@curbuf.b_ind_js != 0)
;                                   cur_amount = get_indent();
;                               else
;                                   cur_amount = skip_label(@curwin.w_cursor.lnum, lp);

                                    ;; If this is just above the line we are indenting, and it
                                    ;; starts with a '{', line it up with this line.
                                    ;;          while (not)
                                    ;; ->       {
                                    ;;          }

;                               if (terminated != ',' && lookfor != LOOKFOR_TERM && theline.at(0) == (byte)'{')
;                               {
;                                   amount = cur_amount;

                                        ;; Only add b_ind_open_extra when the current line
                                        ;; doesn't start with a '{', which must have a match
                                        ;; in the same line (scope is the same).  Probably:
                                        ;;      { 1, 2 },
                                        ;; ->   { 3, 4 }

;                                   if (skipwhite(lp[0]).at(0) != (byte)'{')
;                                       amount += @curbuf.b_ind_open_extra;

;                                   if (@curbuf.b_ind_cpp_baseclass != 0 && @curbuf.b_ind_js == 0)
;                                   {
                                            ;; have to look back, whether it is a cpp base
                                            ;; class declaration or initialization
;                                       lookfor = LOOKFOR_CPP_BASECLASS;
;                                       continue;
;                                   }
;                                   break;
;                               }

                                    ;; Check if we are after an "if", "while", etc.
                                    ;; Also allow "   } else".

;                               if (cin_is_cinword(lp[0]) || cin_iselse(skipwhite(lp[0])))
;                               {
                                        ;; Found an unterminated line after an if (),
                                        ;; line up with the last one.
                                        ;;   if (cond)
                                        ;;          100 +
                                        ;; ->           here;

;                                   if (lookfor == LOOKFOR_UNTERM || lookfor == LOOKFOR_ENUM_OR_INIT)
;                                   {
;                                       if (0 < cont_amount)
;                                           amount = cont_amount;
;                                       else
;                                           amount += ind_continuation;
;                                       break;
;                                   }

                                        ;; If this is just above the line we are indenting,
                                        ;; we are finished.
                                        ;;          while (not)
                                        ;; ->           here;
                                        ;; Otherwise this indent can be used when the line
                                        ;; before this is terminated.
                                        ;;      yyy;
                                        ;;      if (stat)
                                        ;;          while (not)
                                        ;;              xxx;
                                        ;; ->   here;

;                                   amount = cur_amount;
;                                   if (theline.at(0) == (byte)'{')
;                                       amount += @curbuf.b_ind_open_extra;
;                                   if (lookfor != LOOKFOR_TERM)
;                                   {
;                                       amount += @curbuf.b_ind_level + @curbuf.b_ind_no_brace;
;                                       break;
;                                   }

                                        ;; Special trick: when expecting the while () after a do,
                                        ;; line up with the while()
                                        ;;     do
                                        ;;          x = 1;
                                        ;; ->  here

;                                   lp[0] = skipwhite(ml_get_curline());
;                                   if (cin_isdo(lp[0]))
;                                   {
;                                       if (whilelevel == 0)
;                                           break;
;                                       --whilelevel;
;                                   }

                                        ;; When searching for a terminated line, don't use
                                        ;; the one between the "if" and the matching "else".
                                        ;; Need to use the scope of this "else".
                                        ;; If whilelevel != 0 continue looking for a "do {".

;                                   if (cin_iselse(lp[0]) && whilelevel == 0)
;                                   {
                                            ;; If we're looking at "} else", let's make sure we
                                            ;; find the opening brace of the enclosing scope,
                                            ;; not the one from "if () {".
;                                       if (lp[0].at(0) == (byte)'}')
;                                           @curwin.w_cursor.col = BDIFF(lp[0], ml_get_curline()) + 1;

;                                       if ((trypos = find_start_brace()) == null
;                                               || find_match(LOOKFOR_IF, trypos.lnum) == false)
;                                           break;
;                                   }
;                               }

                                    ;; If we're below an unterminated line that is not an
                                    ;; "if" or something, we may line up with this line or
                                    ;; add something for a continuation line, depending on
                                    ;; the line before this one.

;                               else
;                               {
                                        ;; Found two unterminated lines on a row, line up with
                                        ;; the last one.
                                        ;;   c = 99 +
                                        ;;          100 +
                                        ;; ->       here;

;                                   if (lookfor == LOOKFOR_UNTERM)
;                                   {
                                            ;; When line ends in a comma add extra indent.
;                                       if (terminated == ',')
;                                           amount += ind_continuation;
;                                       break;
;                                   }

;                                   if (lookfor == LOOKFOR_ENUM_OR_INIT)
;                                   {
                                            ;; Found two lines ending in ',', lineup with the lowest one,
                                            ;; but check for cpp base class declaration/initialization,
                                            ;; if it is an opening brace or we are looking just for
                                            ;; enumerations/initializations.
;                                       if (terminated == ',')
;                                       {
;                                           if (@curbuf.b_ind_cpp_baseclass == 0)
;                                               break;

;                                           lookfor = LOOKFOR_CPP_BASECLASS;
;                                           continue;
;                                       }

                                            ;; Ignore unterminated lines in between, but reduce indent.
;                                       if (cur_amount < amount)
;                                           amount = cur_amount;
;                                   }
;                                   else
;                                   {
                                            ;; Found first unterminated line on a row, may
                                            ;; line up with this line, remember its indent
                                            ;;      100 +
                                            ;; ->           here;

;                                       Bytes l = ml_get_curline();
;                                       amount = cur_amount;
;                                       if (skipwhite(l).at(0) == (byte)']' || l.at(STRLEN(l) - 1) == ']')
;                                           break;

                                            ;; If previous line ends in ',', check whether we
                                            ;; are in an initialization or enum
                                            ;; struct xxx =
                                            ;; {
                                            ;;      sizeof a,
                                            ;;      124 };
                                            ;; or a normal possible continuation line.
                                            ;; but only, of no other statement has been found yet.

;                                       if (lookfor == LOOKFOR_INITIAL && terminated == ',')
;                                       {
;                                           if (@curbuf.b_ind_js != 0)
;                                           {
                                                    ;; Search for a line ending in a comma
                                                    ;; and line up with the line below it
                                                    ;; (could be the current line).
                                                    ;; some = [
                                                    ;;     1,     <- line up here
                                                    ;;     2,
                                                    ;; some = [
                                                    ;;     3 +    <- line up here
                                                    ;;       4 *
                                                    ;;        5,
                                                    ;;     6,

;                                               if (cin_iscomment(skipwhite(l)))
;                                                   break;
;                                               lookfor = LOOKFOR_COMMA;
;                                               trypos = find_match_char('[', @curbuf.b_ind_maxparen);
;                                               if (trypos != null)
;                                               {
;                                                   if (trypos.lnum == @curwin.w_cursor.lnum - 1)
;                                                   {
                                                            ;; Current line is first inside [],
                                                            ;; line up with it.
;                                                       break;
;                                                   }
;                                                   ourscope = trypos.lnum;
;                                               }
;                                           }
;                                           else
;                                           {
;                                               lookfor = LOOKFOR_ENUM_OR_INIT;
;                                               cont_amount = cin_first_id_amount();
;                                           }
;                                       }
;                                       else
;                                       {
;                                           if (lookfor == LOOKFOR_INITIAL
;                                                   && l.at(0) != NUL
;                                                   && l.at(STRLEN(l) - 1) == '\\')
;                                               cont_amount = cin_get_equal_amount(@curwin.w_cursor.lnum);
;                                           if (lookfor != LOOKFOR_TERM
;                                               && lookfor != LOOKFOR_JS_KEY
;                                               && lookfor != LOOKFOR_COMMA)
;                                               lookfor = LOOKFOR_UNTERM;
;                                       }
;                                   }
;                               }
;                           }

                                ;; Check if we are after a while (cond);
                                ;; If so: Ignore until the matching "do".

;                           else if (cin_iswhileofdo_end(terminated))
;                           {
                                    ;; Found an unterminated line after a while ();,
                                    ;; line up with the last one.
                                    ;;      while (cond);
                                    ;;      100 +               <- line up with this one
                                    ;; ->           here;

;                               if (lookfor == LOOKFOR_UNTERM || lookfor == LOOKFOR_ENUM_OR_INIT)
;                               {
;                                   if (0 < cont_amount)
;                                       amount = cont_amount;
;                                   else
;                                       amount += ind_continuation;
;                                   break;
;                               }

;                               if (whilelevel == 0)
;                               {
;                                   lookfor = LOOKFOR_TERM;
;                                   amount = get_indent();
;                                   if (theline.at(0) == (byte)'{')
;                                       amount += @curbuf.b_ind_open_extra;
;                               }
;                               whilelevel++;
;                           }

                                ;; We are after a "normal" statement.
                                ;; If we had another statement we can stop now and use the
                                ;; indent of that other statement.
                                ;; Otherwise the indent of the current statement may be used,
                                ;; search backwards for the next "normal" statement.

;                           else
;                           {
                                    ;; Skip single break line, if before a switch label.
                                    ;; It may be lined up with the case label.

;                               if (lookfor == LOOKFOR_NOBREAK && cin_isbreak(skipwhite(ml_get_curline())))
;                               {
;                                   lookfor = LOOKFOR_ANY;
;                                   continue;
;                               }

                                    ;; Handle "do {" line.

;                               if (0 < whilelevel)
;                               {
;                                   lp[0] = cin_skipcomment(ml_get_curline());
;                                   if (cin_isdo(lp[0]))
;                                   {
;                                       amount = get_indent();
;                                       --whilelevel;
;                                       continue;
;                                   }
;                               }

                                    ;; Found a terminated line above an unterminated line.
                                    ;; Add the amount for a continuation line.
                                    ;;   x = 1;
                                    ;;   y = foo +
                                    ;; ->       here;
                                    ;; or
                                    ;;   int x = 1;
                                    ;;   int foo,
                                    ;; ->       here;

;                               if (lookfor == LOOKFOR_UNTERM || lookfor == LOOKFOR_ENUM_OR_INIT)
;                               {
;                                   if (0 < cont_amount)
;                                       amount = cont_amount;
;                                   else
;                                       amount += ind_continuation;
;                                   break;
;                               }

                                    ;; Found a terminated line above a terminated line or "if" etc. line.
                                    ;; Use the amount of the line below us.
                                    ;;   x = 1;                         x = 1;
                                    ;;   if (asdf)                  y = 2;
                                    ;;       while (asdf)         ->here;
                                    ;;          here;
                                    ;; ->foo;

;                               if (lookfor == LOOKFOR_TERM)
;                               {
;                                   if (!lookfor_break && whilelevel == 0)
;                                       break;
;                               }

                                    ;; First line above the one we're indenting is terminated.
                                    ;; To know what needs to be done look further backward
                                    ;; for a terminated line.

;                               else
;                               {
                                        ;; position the cursor over the rightmost paren, so that
                                        ;; matching it will take us back to the start of the line.
                                        ;; Helps for:
                                        ;;     func(asdr,
                                        ;;            asdfasdf);
                                        ;;     here;

;                                   term_again:
;                                   for ( ; ; )
;                                   {
;                                       lp[0] = ml_get_curline();
;                                       if (find_last_paren(lp[0], '(', ')')
;                                               && (trypos = find_match_paren(@curbuf.b_ind_maxparen)) != null)
;                                       {
                                                ;; Check if we are on a case label now.
                                                ;; This is handled above.
                                                ;;     case xx:  if ( asdf &&
                                                ;;                      asdf)

;                                           COPY_pos(@curwin.w_cursor, trypos);
;                                           lp[0] = ml_get_curline();
;                                           if (cin_iscase(lp[0], false) || cin_isscopedecl(lp[0]))
;                                           {
;                                               @curwin.w_cursor.lnum++;
;                                               @curwin.w_cursor.col = 0;
;                                               continue;
;                                           }
;                                       }

                                            ;; When aligning with the case statement, don't align
                                            ;; with a statement after it.
                                            ;;  case 1: {   <-- don't use this { position
                                            ;;      stat;
                                            ;;  }
                                            ;;  case 2:
                                            ;;      stat;
                                            ;; }

;                                       /*boolean */iscase = (@curbuf.b_ind_keep_case_label != 0 && cin_iscase(lp[0], false));

                                            ;; Get indent and pointer to text for current line,
                                            ;; ignoring any jump label.

;                                       amount = skip_label(@curwin.w_cursor.lnum, lp);

;                                       if (theline.at(0) == (byte)'{')
;                                           amount += @curbuf.b_ind_open_extra;
                                            ;; See remark above: "Only add b_ind_open_extra.."
;                                       lp[0] = skipwhite(lp[0]);
;                                       if (lp[0].at(0) == (byte)'{')
;                                           amount -= @curbuf.b_ind_open_extra;
;                                       lookfor = iscase ? LOOKFOR_ANY : LOOKFOR_TERM;

                                            ;; When a terminated line starts with "else" skip to
                                            ;; the matching "if":
                                            ;;       else 3;
                                            ;;           indent this;
                                            ;; Need to use the scope of this "else".
                                            ;; If whilelevel != 0 continue looking for a "do {".

;                                       if (lookfor == LOOKFOR_TERM
;                                               && lp[0].at(0) != (byte)'}'
;                                               && cin_iselse(lp[0])
;                                               && whilelevel == 0)
;                                       {
;                                           if ((trypos = find_start_brace()) == null
;                                                   || find_match(LOOKFOR_IF, trypos.lnum) == false)
;                                               break;
;                                           continue;
;                                       }

                                            ;; If we're at the end of a block, skip to the start of that block.

;                                       Bytes l = ml_get_curline();
;                                       if (find_last_paren(l, '{', '}') && (trypos = find_start_brace()) != null)
;                                       {
;                                           COPY_pos(@curwin.w_cursor, trypos);
                                                ;; if not "else {" check for terminated again,
                                                ;; but skip block for "} else {"
;                                           l = cin_skipcomment(ml_get_curline());
;                                           if (l.at(0) == (byte)'}' || !cin_iselse(l))
;                                               continue term_again;
;                                           @curwin.w_cursor.lnum++;
;                                           @curwin.w_cursor.col = 0;
;                                       }

;                                       break;
;                                   }
;                               }
;                           }
;                       }
;                   }
;               }

                    ;; add extra indent for a comment
;               if (cin_iscomment(theline))
;                   amount += @curbuf.b_ind_comment;

                    ;; subtract extra left-shift for jump labels
;               if (0 < @curbuf.b_ind_jump_label && original_line_islabel)
;                   amount -= @curbuf.b_ind_jump_label;
;           }
;           else
;           {
                    ;; ok -- we're not inside any sort of structure at all!
                    ;;
                    ;; This means we're at the top level, and everything should
                    ;; basically just match where the previous line is, except
                    ;; for the lines immediately following a function declaration,
                    ;; which are K&R-style parameters and need to be indented.
                    ;;
                    ;; If our line starts with an open brace, forget about any
                    ;; prevailing indent and make sure it looks like the start
                    ;; of a function.

;               if (theline.at(0) == (byte)'{')
;               {
;                   amount = @curbuf.b_ind_first_open;
;               }

                    ;; If the NEXT line is a function declaration, the current
                    ;; line needs to be indented as a function type spec.
                    ;; Don't do this if the current line looks like a comment
                    ;; or if the current line is terminated, i.e. ends in ';',
                    ;; or if the current line contains { or }: "void f() {\n if (1)".

;               else if (cur_curpos.lnum < @curbuf.b_ml.ml_line_count
;                       && !cin_nocode(theline)
;                       && vim_strchr(theline, '{') == null
;                       && vim_strchr(theline, '}') == null
;                       && !cin_ends_in(theline, u8(":"), null)
;                       && !cin_ends_in(theline, u8(","), null)
;                       && cin_isfuncdecl(null, cur_curpos.lnum + 1, cur_curpos.lnum + 1)
;                       && cin_isterminated(theline, false, true) == NUL)
;               {
;                   amount = @curbuf.b_ind_func_type;
;               }
;               else
;               {
;                   amount = 0;
;                   COPY_pos(@curwin.w_cursor, cur_curpos);

                        ;; search backwards until we find something we recognize

;                   while (1 < @curwin.w_cursor.lnum)
;                   {
;                       @curwin.w_cursor.lnum--;
;                       @curwin.w_cursor.col = 0;

;                       Bytes[] lp = { ml_get_curline() };

                            ;; If we're in a comment now, skip to the start of the comment.

;                       if ((trypos = ind_find_start_comment()) != null)
;                       {
;                           @curwin.w_cursor.lnum = trypos.lnum + 1;
;                           @curwin.w_cursor.col = 0;
;                           continue;
;                       }

;                       int[] col = new int[1];

                            ;; Are we at the start of a cpp base class declaration or
                            ;; constructor initialization?

;                       boolean b = false;
;                       if (@curbuf.b_ind_cpp_baseclass != 0 && theline.at(0) != (byte)'{')
;                       {
;                           b = cin_is_cpp_baseclass(col);
;                           lp[0] = ml_get_curline();
;                       }
;                       if (b)
;                       {
;                           amount = get_baseclass_amount(col[0]);
;                           break;
;                       }

                            ;; Skip preprocessor directives and blank lines.

                         ;; boolean b;
;                       { long[] __ = { @curwin.w_cursor.lnum }; b = cin_ispreproc_cont(lp, __); @curwin.w_cursor.lnum = __[0]; }
;                       if (b)
;                           continue;

;                       if (cin_nocode(lp[0]))
;                           continue;

                            ;; If the previous line ends in ',', use one level of
                            ;; indentation:
                            ;; int foo,
                            ;;     bar;
                            ;; do this before checking for '}' in case of eg.
                            ;; enum foobar
                            ;; {
                            ;;   ...
                            ;; } foo,
                            ;;   bar;

;                       int n = 0;
;                       if (cin_ends_in(lp[0], u8(","), null) || (lp[0].at(0) != NUL && (n = lp[0].at(STRLEN(lp[0]) - 1)) == '\\'))
;                       {
                                ;; take us back to opening paren
;                           if (find_last_paren(lp[0], '(', ')')
;                                   && (trypos = find_match_paren(@curbuf.b_ind_maxparen)) != null)
;                               COPY_pos(@curwin.w_cursor, trypos);

                                ;; For a line ending in ',' that is a continuation line
                                ;; go back to the first line with a backslash:
                                ;; char *foo = "bla\
                                ;;           bla",
                                ;;      here;

;                           while (n == 0 && 1 < @curwin.w_cursor.lnum)
;                           {
;                               Bytes l = ml_get(@curwin.w_cursor.lnum - 1);
;                               if (l.at(0) == NUL || l.at(STRLEN(l) - 1) != '\\')
;                                   break;
;                               --@curwin.w_cursor.lnum;
;                               @curwin.w_cursor.col = 0;
;                           }

;                           amount = get_indent();

;                           if (amount == 0)
;                               amount = cin_first_id_amount();
;                           if (amount == 0)
;                               amount = ind_continuation;
;                           break;
;                       }

                            ;; If the line looks like a function declaration,
                            ;; and we're not in a comment, put it the left margin.

;                       if (cin_isfuncdecl(null, cur_curpos.lnum, 0))
;                           break;
;                       lp[0] = ml_get_curline();

                            ;; Finding the closing '}' of a previous function.
                            ;; Put current line at the left margin.
                            ;; For when 'cino' has "fs".

;                       if (skipwhite(lp[0]).at(0) == (byte)'}')
;                           break;

                            ;;                          (matching {)
                            ;; If the previous line ends on '};' (maybe followed
                            ;; by comments) align at column 0.  For example:
                            ;; char *string_array[] = { "foo",
                            ;;     / * x * / "b};ar" }; / * foobar * /

;                       if (cin_ends_in(lp[0], u8("};"), null))
;                           break;

                            ;; If the previous line ends on '[' we are probably
                            ;; in an array constant:
                            ;; something = [
                            ;;     234,  <- extra indent

;                       if (cin_ends_in(lp[0], u8("["), null))
;                       {
;                           amount = get_indent() + ind_continuation;
;                           break;
;                       }

                            ;; Find a line only has a semicolon that belongs to
                            ;; a previous line ending in '}', e.g. before an #endif.
                            ;; Don't increase indent then.

;                       Bytes look = skipwhite(lp[0]);
;                       if (look.at(0) == (byte)';' && cin_nocode(look.plus(1)))
;                       {
;                           pos_C curpos_save = §_pos_C();
;                           COPY_pos(curpos_save, @curwin.w_cursor);

;                           while (1 < @curwin.w_cursor.lnum)
;                           {
;                               look = ml_get(--@curwin.w_cursor.lnum);
;                               if (!cin_nocode(look))
;                               {
;                                   boolean _0;
;                                   {
;                                       Bytes[] _1 = { look };
;                                       long[] _2 = { @curwin.w_cursor.lnum };
;                                       _0 = cin_ispreproc_cont(_1, _2);
;                                       look = _1[0];
;                                       @curwin.w_cursor.lnum = _2[0];
;                                   }
;                                   if (!_0)
;                                       break;
;                               }
;                           }
;                           if (0 < @curwin.w_cursor.lnum && cin_ends_in(look, u8("}"), null))
;                               break;

;                           COPY_pos(@curwin.w_cursor, curpos_save);
;                       }

                            ;; If the PREVIOUS line is a function declaration, the current line
                            ;; (and the ones that follow) needs to be indented as parameters.

;                       if (cin_isfuncdecl(lp, @curwin.w_cursor.lnum, 0))
;                       {
;                           amount = @curbuf.b_ind_param;
;                           break;
;                       }

                            ;; If the previous line ends in ';' and the line before the
                            ;; previous line ends in ',' or '\', ident to column zero:
                            ;; int foo,
                            ;;     bar;
                            ;; indent_to_0 here;

;                       if (cin_ends_in(lp[0], u8(";"), null))
;                       {
;                           Bytes l = ml_get(@curwin.w_cursor.lnum - 1);
;                           if (cin_ends_in(l, u8(","), null) || (l.at(0) != NUL && l.at(STRLEN(l) - 1) == '\\'))
;                               break;
;                           lp[0] = ml_get_curline();
;                       }

                            ;; Doesn't look like anything interesting -- so just use
                            ;; the indent of this line.
                            ;;
                            ;; Position the cursor over the rightmost paren, so that
                            ;; matching it will take us back to the start of the line.

;                       find_last_paren(lp[0], '(', ')');

;                       if ((trypos = find_match_paren(@curbuf.b_ind_maxparen)) != null)
;                           COPY_pos(@curwin.w_cursor, trypos);
;                       amount = get_indent();
;                       break;
;                   }

                        ;; add extra indent for a comment
;                   if (cin_iscomment(theline))
;                       amount += @curbuf.b_ind_comment;

                        ;; add extra indent if the previous line ended in a backslash:
                        ;;        "asdfasdf\
                        ;;            here";
                        ;;      char *foo = "asdf\
                        ;;                   here";

;                   if (1 < cur_curpos.lnum)
;                   {
;                       Bytes l = ml_get(cur_curpos.lnum - 1);
;                       if (l.at(0) != NUL && l.at(STRLEN(l) - 1) == '\\')
;                       {
;                           cur_amount = cin_get_equal_amount(cur_curpos.lnum - 1);
;                           if (0 < cur_amount)
;                               amount = cur_amount;
;                           else if (cur_amount == 0)
;                               amount += ind_continuation;
;                       }
;                   }
;               }
;           }
;       }

            ;; put the cursor back where it belongs
;       COPY_pos(@curwin.w_cursor, cur_curpos);

;       if (amount < 0)
;           return 0;

;       return amount;
    ))

(defn- #_boolean find_match [#_int lookfor, #_long ourscope]
    (§
;       int elselevel, whilelevel;
;       if (lookfor == LOOKFOR_IF)
;       {
;           elselevel = 1;
;           whilelevel = 0;
;       }
;       else
;       {
;           elselevel = 0;
;           whilelevel = 1;
;       }

;       @curwin.w_cursor.col = 0;

;       while (ourscope + 1 < @curwin.w_cursor.lnum)
;       {
;           @curwin.w_cursor.lnum--;
;           @curwin.w_cursor.col = 0;

;           Bytes look = cin_skipcomment(ml_get_curline());
;           if (cin_iselse(look)
;                   || cin_isif(look)
;                   || cin_isdo(look)
;                   || cin_iswhileofdo(look, @curwin.w_cursor.lnum))
;           {
                ;; if we've gone outside the braces entirely,
                ;; we must be out of scope...

;               pos_C theirscope = find_start_brace();
;               if (theirscope == null)
;                   break;

                ;; and if the brace enclosing this is further
                ;; back than the one enclosing the else, we're
                ;; out of luck too.

;               if (theirscope.lnum < ourscope)
;                   break;

                ;; and if they're enclosed in a *deeper* brace,
                ;; then we can ignore it because it's in a
                ;; different scope...

;               if (ourscope < theirscope.lnum)
;                   continue;

                ;; if it was an "else" (that's not an "else if")
                ;; then we need to go back to another if, so
                ;; increment elselevel

;               look = cin_skipcomment(ml_get_curline());
;               if (cin_iselse(look))
;               {
;                   Bytes mightbeif = cin_skipcomment(look.plus(4));
;                   if (!cin_isif(mightbeif))
;                       elselevel++;
;                   continue;
;               }

                ;; if it was a "while" then we need to go back to
                ;; another "do", so increment whilelevel.

;               if (cin_iswhileofdo(look, @curwin.w_cursor.lnum))
;               {
;                   whilelevel++;
;                   continue;
;               }

                ;; If it's an "if" decrement elselevel.
;               look = cin_skipcomment(ml_get_curline());
;               if (cin_isif(look))
;               {
;                   elselevel--;

                    ;; When looking for an "if" ignore "while"s that get in the way.

;                   if (elselevel == 0 && lookfor == LOOKFOR_IF)
;                       whilelevel = 0;
;               }

                ;; If it's a "do" decrement whilelevel.
;               if (cin_isdo(look))
;                   whilelevel--;

                ;; if we've used up all the elses, then
                ;; this must be the if that we want!
                ;; match the indent level of that if.

;               if (elselevel <= 0 && whilelevel <= 0)
;                   return true;
;           }
;       }
;       return false;
    ))

(defn- #_boolean lisp_match [#_Bytes p]
    (§
;       final int LSIZE = 512;
;       Bytes buf = new Bytes(LSIZE);

;       Bytes[] word = { (@curbuf.@b_p_lw.at(0) != NUL) ? @curbuf.@b_p_lw : @p_lispwords };
;       while (word[0].at(0) != NUL)
;       {
;           copy_option_part(word, buf, LSIZE, u8(","));
;           int len = STRLEN(buf);
;           if (STRNCMP(buf, p, len) == 0 && p.at(len) == (byte)' ')
;               return true;
;       }

;       return false;
    ))

;; When 'p' is present in 'cpoptions, a Vi compatible method is used.
;; The incompatible newer method is quite a bit better at indenting
;; code in lisp-like languages than the traditional one; it's still
;; mostly heuristics however -- Dirk van Deun, dirk@rave.org
;;
;; TODO:
;; Findmatch() should be adapted for lisp, also to make showmatch
;; work correctly: now (v5.3) it seems all C/C++ oriented:
;; - it does not recognize the #\( and #\) notations as character literals
;; - it doesn't know about comments starting with a semicolon
;; - it incorrectly interprets '(' as a character literal
;; All this messes up get_lisp_indent in some rare cases.
;; Update from Sergey Khorev:
;; I tried to fix the first two issues.

(defn- #_int get_lisp_indent []
    (§
;       int amount;

            ;; Set vi_lisp to use the vi-compatible method.
;       boolean vi_lisp = (vim_strbyte(@p_cpo, CPO_LISP) != null);

;       pos_C realpos = §_pos_C();
;       COPY_pos(realpos, @curwin.w_cursor);
;       @curwin.w_cursor.col = 0;

;       pos_C pos = findmatch(null, '(');
;       if (pos == null)
;           pos = findmatch(null, '[');
;       else
;       {
;           pos_C paren = §_pos_C();
;           COPY_pos(paren, pos);
;           pos = findmatch(null, '[');
;           if (pos == null || ltpos(pos, paren))
;               pos = paren;
;       }
;       if (pos != null)
;       {
                ;; Extra trick: take the indent of the first previous
                ;; non-white line, that is at the same () level.
;           amount = -1;
;           int parencount = 0;

;           while (pos.lnum <= --@curwin.w_cursor.lnum)
;           {
;               if (linewhite(@curwin.w_cursor.lnum))
;                   continue;

;               for (Bytes that = ml_get_curline(); that.at(0) != NUL; that = that.plus(1))
;               {
;                   if (that.at(0) == (byte)';')
;                   {
;                       while (that.at(1) != NUL)
;                           that = that.plus(1);
;                       continue;
;                   }
;                   if (that.at(0) == (byte)'\\')
;                   {
;                       if (that.at(1) != NUL)
;                           that = that.plus(1);
;                       continue;
;                   }
;                   if (that.at(0) == (byte)'"' && that.at(1) != NUL)
;                   {
;                       while ((that = that.plus(1)).at(0) != NUL && that.at(0) != (byte)'"')
;                       {
                                ;; skipping escaped characters in the string
;                           if (that.at(0) == (byte)'\\')
;                           {
;                               if ((that = that.plus(1)).at(0) == NUL)
;                                   break;
;                               if (that.at(1) == NUL)
;                               {
;                                   that = that.plus(1);
;                                   break;
;                               }
;                           }
;                       }
;                   }
;                   if (that.at(0) == (byte)'(' || that.at(0) == (byte)'[')
;                       parencount++;
;                   else if (that.at(0) == (byte)')' || that.at(0) == (byte)']')
;                       --parencount;
;               }

;               if (parencount == 0)
;               {
;                   amount = get_indent();
;                   break;
;               }
;           }

;           if (amount == -1)
;           {
;               @curwin.w_cursor.lnum = pos.lnum;
;               @curwin.w_cursor.col = pos.col;
;               int col = pos.col;

;               Bytes[] that = { ml_get_curline() };

;               if (vi_lisp && get_indent() == 0)
;                   amount = 2;
;               else
;               {
;                   Bytes line = that[0];

;                   amount = 0;
;                   while (that[0].at(0) != NUL && col != 0)
;                   {
;                       amount += lbr_chartabsize_adv(line, that, amount);
;                       col--;
;                   }

                        ;; Some keywords require "body" indenting rules (the
                        ;; non-standard-lisp ones are Scheme special forms):
                        ;;
                        ;; (let ((a 1))    instead    (let ((a 1))
                        ;;   (...))           of           (...))

;                   if (!vi_lisp && (that[0].at(0) == (byte)'(' || that[0].at(0) == (byte)'[') && lisp_match(that[0].plus(1)))
;                       amount += 2;
;                   else
;                   {
;                       that[0] = that[0].plus(1);
;                       amount++;
;                       int firsttry = amount;

;                       while (vim_iswhite(that[0].at(0)))
;                       {
;                           amount += lbr_chartabsize(line, that[0], amount);
;                           that[0] = that[0].plus(1);
;                       }

;                       if (that[0].at(0) != NUL && that[0].at(0) != (byte)';') ;; not a comment line
;                       {
                                ;; test that[0].at(0) != (byte)'(' to accommodate first let/do argument
                                ;; if it is more than one line
;                           if (!vi_lisp && that[0].at(0) != (byte)'(' && that[0].at(0) != (byte)'[')
;                               firsttry++;

;                           parencount = 0;
;                           boolean quotecount = false;

;                           if (vi_lisp
;                                   || (that[0].at(0) != (byte)'"'
;                                       && that[0].at(0) != (byte)'\''
;                                       && that[0].at(0) != (byte)'#'
;                                       && (that[0].at(0) < '0' || '9' < that[0].at(0))))
;                           {
;                               while (that[0].at(0) != NUL
;                                       && (!vim_iswhite(that[0].at(0))
;                                           || quotecount
;                                           || parencount != 0)
;                                       && (!((that[0].at(0) == (byte)'(' || that[0].at(0) == (byte)'[')
;                                               && !quotecount
;                                               && parencount == 0
;                                               && vi_lisp)))
;                               {
;                                   if (that[0].at(0) == (byte)'"')
;                                       quotecount = !quotecount;
;                                   if ((that[0].at(0) == (byte)'(' || that[0].at(0) == (byte)'[') && !quotecount)
;                                       parencount++;
;                                   if ((that[0].at(0) == (byte)')' || that[0].at(0) == (byte)']') && !quotecount)
;                                       --parencount;
;                                   if (that[0].at(0) == (byte)'\\' && that[0].at(1) != NUL)
;                                       amount += lbr_chartabsize_adv(line, that, amount);
;                                   amount += lbr_chartabsize_adv(line, that, amount);
;                               }
;                           }
;                           while (vim_iswhite(that[0].at(0)))
;                           {
;                               amount += lbr_chartabsize(line, that[0], amount);
;                               that[0] = that[0].plus(1);
;                           }
;                           if (that[0].at(0) == NUL || that[0].at(0) == (byte)';')
;                               amount = firsttry;
;                       }
;                   }
;               }
;           }
;       }
;       else
;           amount = 0;     ;; no matching '(' or '[' found, use zero indent

;       COPY_pos(@curwin.w_cursor, realpos);

;       return amount;
    ))

(defn- #_void prepare_to_exit []
    (§
        ;; Ignore SIGHUP, because a dropped connection causes a read error, which
        ;; makes Vim exit and then handling SIGHUP causes various reentrance problems.

;       libC.sigset(SIGHUP, /*SIG_IGN*/null);

;       windgoto((int)@Rows - 1, 0);

        ;; Switch terminal mode back now, so messages end up on the "normal"
        ;; screen (if there are two screens).

;       settmode(TMODE_COOK);
;       stoptermcap();
;       out_flush();
    ))

;; Preserve files and exit.
;; When called ioBuff must contain a message.
;; NOTE: This may be called from deathtrap() in a signal handler,
;; avoid unsafe functions, such as allocating memory.

(defn- #_void preserve_exit []
    (§
;       prepare_to_exit();

;       out_str(@ioBuff);
;       screen_start();                 ;; don't know where cursor is now
;       out_flush();

;       ml_close_all();

;       out_str(u8("Vim: Finished.\n"));

;       getout(1);
    ))

;; Check for CTRL-C pressed, but only once in a while.
;; Should be used instead of ui_breakcheck() for functions that check for each line in the file.
;; Calling ui_breakcheck() each time takes too much time, because it can be a system call.

(final int BREAKCHECK_SKIP 32)

(atom! int      breakcheck_count)

(defn- #_void line_breakcheck []
    (§
;       if (BREAKCHECK_SKIP <= ++@breakcheck_count)
;       {
;           @breakcheck_count = 0;
;           ui_breakcheck();
;       }
    ))

;; Like line_breakcheck() but check 10 times less often.

(defn- #_void fast_breakcheck []
    (§
;       if (BREAKCHECK_SKIP * 10 <= ++@breakcheck_count)
;       {
;           @breakcheck_count = 0;
;           ui_breakcheck();
;       }
    ))

;; Return true when need to go to Insert mode because of 'insertmode'.
;; Don't do this when still processing a command or a mapping.
;; Don't do this when inside a ":normal" command.

(defn- #_boolean goto_im []
    (§
;       return (@p_im && stuff_empty() && typebuf_typed());
    ))

;; Return true if in the current mode we need to use virtual.

(defn- #_boolean virtual_active []
    (§
        ;; While an operator is being executed we return "virtual_op",
        ;; because VIsual_active has already been reset,
        ;; thus we can't check for "block" being used.
;       if (@virtual_op != MAYBE)
;           return (@virtual_op != FALSE);

;       return (@ve_flags == VE_ALL
;               || ((@ve_flags & VE_BLOCK) != 0 && @VIsual_active && @VIsual_mode == Ctrl_V)
;               || ((@ve_flags & VE_INSERT) != 0 && (@State & INSERT) != 0));
    ))

;; Get the screen position of the cursor.

(defn- #_int getviscol []
    (§
;       int[] x = new int[1];
;       getvvcol(@curwin, @curwin.w_cursor, x, null, null);
;       return x[0];
    ))

;; Get the screen position of character col with a coladd in the cursor line.

(defn- #_int getviscol2 [#_int col, #_int coladd]
    (§
;       pos_C pos = §_pos_C();
;       pos.lnum = @curwin.w_cursor.lnum;
;       pos.col = col;
;       pos.coladd = coladd;

;       int[] x = new int[1];
;       getvvcol(@curwin, pos, x, null, null);
;       return x[0];
    ))

;; Go to column "wcol", and add/insert white space as necessary to get the
;; cursor in that column.
;; The caller must have saved the cursor line for undo!

(defn- #_boolean coladvance_force [#_int wcol]
    (§
;       boolean rc = coladvance2(@curwin.w_cursor, true, false, wcol);

;       if (wcol == MAXCOL)
;           @curwin.w_valid &= ~VALID_VIRTCOL;
;       else
;       {
            ;; Virtcol is valid.
;           @curwin.w_valid |= VALID_VIRTCOL;
;           @curwin.w_virtcol = wcol;
;       }
;       return rc;
    ))

;; Try to advance the Cursor to the specified screen column.
;; If virtual editing: fine tune the cursor position.
;; Note that all virtual positions off the end of a line should share
;; a curwin.w_cursor.col value (n.b. this is equal to STRLEN(line)),
;; beginning at coladd 0.
;;
;; return true if desired column is reached, false if not

(defn- #_boolean coladvance [#_int wcol]
    (§
;       boolean rc = getvpos(@curwin.w_cursor, wcol);

;       if (wcol == MAXCOL || rc == false)
;           @curwin.w_valid &= ~VALID_VIRTCOL;
;       else if (ml_get_cursor().at(0) != TAB)
;       {
            ;; Virtcol is valid when not on a TAB.
;           @curwin.w_valid |= VALID_VIRTCOL;
;           @curwin.w_virtcol = wcol;
;       }
;       return rc;
    ))

;; Return in "pos" the position of the cursor advanced to screen column "wcol".
;; return true if desired column is reached, false if not

(defn- #_boolean getvpos [#_pos_C pos, #_int wcol]
    (§
;       return coladvance2(pos, false, virtual_active(), wcol);
    ))

(defn- #_boolean coladvance2 [#_pos_C pos, #_boolean addspaces, #_boolean finetune, #_int wcol]
    ;; addspaces: change the text to achieve our goal?
    ;; finetune: change char offset for the exact column
    ;; wcol: column to move to
    (§
;       int col = 0;
;       int csize = 0;
;       int[] head = { 0 };

;       boolean one_more = (@State & INSERT) != 0
;                       || @restart_edit != NUL
;                       || (@VIsual_active && @p_sel.at(0) != (byte)'o')
;                       || ((@ve_flags & VE_ONEMORE) != 0 && wcol < MAXCOL);

;       Bytes line = ml_get_buf(@curbuf, pos.lnum, false);

;       int idx;
;       if (MAXCOL <= wcol)
;       {
;           idx = STRLEN(line) - 1 + (one_more ? 1 : 0);
;           col = wcol;

;           if ((addspaces || finetune) && !@VIsual_active)
;           {
;               @curwin.w_curswant = linetabsize(line) + (one_more ? 1 : 0);
;               if (0 < @curwin.w_curswant)
;                   --@curwin.w_curswant;
;           }
;       }
;       else
;       {
;           int width = @curwin.w_width - win_col_off(@curwin);

;           if (finetune
;                   && @curwin.w_onebuf_opt.@wo_wrap
;                   && @curwin.w_width != 0
;                   && width <= wcol)
;           {
;               csize = linetabsize(line);
;               if (0 < csize)
;                   csize--;

;               if (csize / width < wcol / width && ((@State & INSERT) == 0 || csize + 1 < wcol))
;               {
                    ;; In case of line wrapping don't move the cursor beyond the
                    ;; right screen edge.  In Insert mode allow going just beyond
                    ;; the last character (like what happens when typing and
                    ;; reaching the right window edge).
;                   wcol = (csize / width + 1) * width - 1;
;               }
;           }

;           Bytes ptr = line;
;           while (col <= wcol && ptr.at(0) != NUL)
;           {
                ;; Count a tab for what it's worth (if list mode not on).
;               csize = win_lbr_chartabsize(@curwin, line, ptr, col, head);
;               ptr = ptr.plus(us_ptr2len_cc(ptr));
;               col += csize;
;           }
;           idx = BDIFF(ptr, line);

            ;; Handle all the special cases.  The virtual_active() check
            ;; is needed to ensure that a virtual position off the end of
            ;; a line has the correct indexing.  The one_more comparison
            ;; replaces an explicit add of one_more later on.

;           if (wcol < col || (!virtual_active() && !one_more))
;           {
;               idx -= 1;
                ;; Don't count the chars from 'showbreak'.
;               csize -= head[0];
;               col -= csize;
;           }

;           if (virtual_active() && addspaces && ((col != wcol && col != wcol + 1) || 1 < csize))
;           {
                ;; 'virtualedit' is set: The difference between wcol and col is filled with spaces.

;               if (line.at(idx) == NUL)
;               {
                    ;; Append spaces.
;                   int correct = wcol - col;
;                   Bytes newline = new Bytes(idx + correct + 1);

;                   for (int t = 0; t < idx; t++)
;                       newline.be(t, line.at(t));

;                   for (int t = 0; t < correct; t++)
;                       newline.be(t + idx, (byte)' ');

;                   newline.be(idx + correct, NUL);

;                   ml_replace(pos.lnum, newline, false);
;                   changed_bytes(pos.lnum, idx);
;                   idx += correct;
;                   col = wcol;
;               }
;               else
;               {
                    ;; Break a tab.
;                   int linelen = STRLEN(line);
;                   int correct = wcol - col - csize + 1; ;; negative!!

;                   if (csize < -correct)
;                       return false;

;                   Bytes newline = new Bytes(linelen + csize);

;                   int s = 0;
;                   for (int t = 0; t < linelen; t++)
;                   {
;                       if (t != idx)
;                           newline.be(s++, line.at(t));
;                       else
;                           for (int v = 0; v < csize; v++)
;                               newline.be(s++, (byte)' ');
;                   }

;                   newline.be(linelen + csize - 1, NUL);

;                   ml_replace(pos.lnum, newline, false);
;                   changed_bytes(pos.lnum, idx);
;                   idx += (csize - 1 + correct);
;                   col += correct;
;               }
;           }
;       }

;       if (idx < 0)
;           pos.col = 0;
;       else
;           pos.col = idx;

;       pos.coladd = 0;

;       if (finetune)
;       {
;           if (wcol == MAXCOL)
;           {
                ;; The width of the last character is used to set coladd.
;               if (!one_more)
;               {
;                   int[] scol = new int[1];
;                   int[] ecol = new int[1];

;                   getvcol(@curwin, pos, scol, null, ecol);
;                   pos.coladd = ecol[0] - scol[0];
;               }
;           }
;           else
;           {
;               int b = wcol - col;

                ;; The difference between wcol and col is used to set coladd.
;               if (0 < b && b < (MAXCOL - 2 * @curwin.w_width))
;                   pos.coladd = b;

;               col += b;
;           }
;       }

        ;; prevent from moving onto a trail byte
;       mb_adjust_pos(@curbuf, pos);

;       if (col < wcol)
;           return false;

;       return true;
    ))

;; Increment the cursor position.  See incp() for return values.

(defn- #_int inc_cursor []
    (§
;       return incp(@curwin.w_cursor);
    ))

;; Increment the line pointer "lp" crossing line boundaries as necessary.
;; Return 1 when going to the next line.
;; Return 2 when moving forward onto a NUL at the end of the line).
;; Return -1 when at the end of file.
;; Return 0 otherwise.

(defn- #_int incp [#_pos_C lp]
    (§
;       Bytes p = ml_get_pos(lp);

;       if (p.at(0) != NUL)     ;; still within line, move to next char (may be NUL)
;       {
;           int l = us_ptr2len_cc(p);

;           lp.col += l;
;           return ((p.at(l) != NUL) ? 0 : 2);
;       }
;       if (lp.lnum != @curbuf.b_ml.ml_line_count)   ;; there is a next line
;       {
;           lp.col = 0;
;           lp.lnum++;
;           lp.coladd = 0;
;           return 1;
;       }
;       return -1;
    ))

;; incl(lp): same as incp(), but skip the NUL at the end of non-empty lines

(defn- #_int incl [#_pos_C lp]
    (§
;       int r = incp(lp);

;       if (1 <= r && lp.col != 0)
;           r = incp(lp);

;       return r;
    ))

;; decp(p)
;;
;; Decrement the line pointer 'p' crossing line boundaries as necessary.
;; Return 1 when crossing a line, -1 when at start of file, 0 otherwise.

(defn- #_int dec_cursor []
    (§
;       return decp(@curwin.w_cursor);
    ))

(defn- #_int decp [#_pos_C lp]
    (§
;       lp.coladd = 0;

;       if (0 < lp.col)         ;; still within line
;       {
;           lp.col--;
;           Bytes p = ml_get(lp.lnum);
;           lp.col -= us_head_off(p, p.plus(lp.col));
;           return 0;
;       }

;       if (1 < lp.lnum)        ;; there is a prior line
;       {
;           lp.lnum--;
;           Bytes p = ml_get(lp.lnum);
;           lp.col = STRLEN(p);
;           lp.col -= us_head_off(p, p.plus(lp.col));
;           return 1;
;       }

;       return -1;                  ;; at start of file
    ))

;; decl(lp): same as decp(), but skip the NUL at the end of non-empty lines

(defn- #_int decl [#_pos_C lp]
    (§
;       int r = decp(lp);

;       if (r == 1 && lp.col != 0)
;           r = decp(lp);

;       return r;
    ))

;; Get the line number relative to the current cursor position,
;; i.e. the difference between line number and cursor position.
;; Only look for lines that can be visible, folded lines don't count.

(defn- #_long get_cursor_rel_lnum [#_window_C wp, #_long lnum]
    ;; lnum: line number to get the result for
    (§
;       return lnum - wp.w_cursor.lnum;
    ))

;; Make sure curwin.w_cursor.lnum is valid.

(defn- #_void check_cursor_lnum []
    (§
;       if (@curwin.w_cursor.lnum > @curbuf.b_ml.ml_line_count)
;           @curwin.w_cursor.lnum = @curbuf.b_ml.ml_line_count;

;       if (@curwin.w_cursor.lnum <= 0)
;           @curwin.w_cursor.lnum = 1;
    ))

;; Make sure curwin.w_cursor.col is valid.

(defn- #_void check_cursor_col []
    (§
;       check_cursor_col_win(@curwin);
    ))

;; Make sure win.w_cursor.col is valid.

(defn- #_void check_cursor_col_win [#_window_C win]
    (§
;       int oldcol = win.w_cursor.col;
;       int oldcoladd = win.w_cursor.col + win.w_cursor.coladd;

;       int len = STRLEN(ml_get_buf(win.w_buffer, win.w_cursor.lnum, false));
;       if (len == 0)
;           win.w_cursor.col = 0;
;       else if (len <= win.w_cursor.col)
;       {
            ;; Allow cursor past end-of-line when:
            ;; - in Insert mode or restarting Insert mode
            ;; - in Visual mode and 'selection' isn't "old"
            ;; - 'virtualedit' is set
;           if ((@State & INSERT) != 0 || @restart_edit != 0
;                   || (@VIsual_active && @p_sel.at(0) != (byte)'o')
;                   || (@ve_flags & VE_ONEMORE) != 0
;                   || virtual_active())
;               win.w_cursor.col = len;
;           else
;           {
;               win.w_cursor.col = len - 1;
                ;; Move the cursor to the head byte.
;               mb_adjust_pos(win.w_buffer, win.w_cursor);
;           }
;       }
;       else if (win.w_cursor.col < 0)
;           win.w_cursor.col = 0;

        ;; If virtual editing is on, we can leave the cursor on the old position,
        ;; only we must set it to virtual.  But don't do it when at the end of the line.
;       if (oldcol == MAXCOL)
;           win.w_cursor.coladd = 0;
;       else if (@ve_flags == VE_ALL)
;       {
;           if (win.w_cursor.col < oldcoladd)
;               win.w_cursor.coladd = oldcoladd - win.w_cursor.col;
;           else
                ;; avoid weird number when there is a miscalculation or overflow
;               win.w_cursor.coladd = 0;
;       }
    ))

;; make sure curwin.w_cursor in on a valid character

(defn- #_void check_cursor []
    (§
;       check_cursor_lnum();
;       check_cursor_col();
    ))

;; Make sure curwin.w_cursor is not on the NUL at the end of the line.
;; Allow it when in Visual mode and 'selection' is not "old".

(defn- #_void adjust_cursor_col []
    (§
;       if (0 < @curwin.w_cursor.col
;               && (!@VIsual_active || @p_sel.at(0) == (byte)'o')
;               && gchar_cursor() == NUL)
;           --@curwin.w_cursor.col;
    ))

;; When curwin.w_leftcol has changed, adjust the cursor position.
;; Return true if the cursor was moved.

(defn- #_boolean leftcol_changed []
    (§
;       boolean retval = false;

;       changed_cline_bef_curs();
;       long lastcol = @curwin.w_leftcol + @curwin.w_width - curwin_col_off() - 1;
;       validate_virtcol();

        ;; If the cursor is right or left of the screen, move it to last or first character.

;       if ((int)(lastcol - @p_siso) < @curwin.w_virtcol)
;       {
;           retval = true;
;           coladvance((int)(lastcol - @p_siso));
;       }
;       else if (@curwin.w_virtcol < @curwin.w_leftcol + @p_siso)
;       {
;           retval = true;
;           coladvance((int)(@curwin.w_leftcol + @p_siso));
;       }

        ;; If the start of the character under the cursor is not on the screen,
        ;; advance the cursor one more char.  If this fails (last char of the line),
        ;; adjust the scrolling.

;       int[] s = new int[1];
;       int[] e = new int[1];
;       getvvcol(@curwin, @curwin.w_cursor, s, null, e);
;       if ((int)lastcol < e[0])
;       {
;           retval = true;
;           coladvance(s[0] - 1);
;       }
;       else if (s[0] < @curwin.w_leftcol)
;       {
;           retval = true;
;           if (coladvance(e[0] + 1) == false)     ;; there isn't another character
;           {
;               @curwin.w_leftcol = s[0];           ;; adjust w_leftcol instead
;               changed_cline_bef_curs();
;           }
;       }

;       if (retval)
;           @curwin.w_set_curswant = true;
;       redraw_later(NOT_VALID);
;       return retval;
    ))

;; Various routines dealing with allocation and deallocation of memory.

;; Copy "string" into newly allocated memory.

(defn- #_Bytes STRDUP [#_Bytes string]
    (§
;       int len = STRLEN(string) + 1;
;       Bytes s = new Bytes(len);
;       BCOPY(s, string, len);
;       return s;
    ))

;; Copy up to "len" bytes of "string" into newly allocated memory and terminate with a NUL.
;; The allocated memory always has size "len + 1", also when "string" is shorter.

(defn- #_Bytes STRNDUP [#_Bytes string, #_int len]
    (§
;       Bytes s = new Bytes(len + 1);
;       STRNCPY(s, string, len);
;       s.be(len, NUL);
;       return s;
    ))

;; Same as STRDUP(), but any characters found in esc_chars are preceded by a backslash.

(defn- #_Bytes vim_strsave_escaped [#_Bytes string, #_Bytes esc_chars]
    (§
;       return vim_strsave_escaped_ext(string, esc_chars, '\\');
    ))

;; Same as vim_strsave_escaped().
;; Escape the characters with "cc".

(defn- #_Bytes vim_strsave_escaped_ext [#_Bytes string, #_Bytes esc_chars, #_int cc]
    (§
        ;; First count the number of backslashes required.
        ;; Then allocate the memory and insert them.

;       int length = 1;                         ;; count the trailing NUL
;       for (Bytes p = string; p.at(0) != NUL; p = p.plus(1))
;       {
;           int l = us_ptr2len_cc(p);
;           if (1 < l)
;           {
;               length += l;                    ;; count a multibyte char
;               p = p.plus(l - 1);
;               continue;
;           }
;           if (vim_strchr(esc_chars, p.at(0)) != null)
;               length++;                       ;; count a backslash
;           length++;                           ;; count an ordinary char
;       }

;       Bytes escaped_string = new Bytes(length);

;       Bytes p2 = escaped_string;
;       for (Bytes p = string; p.at(0) != NUL; p = p.plus(1))
;       {
;           int l = us_ptr2len_cc(p);
;           if (1 < l)
;           {
;               BCOPY(p2, p, l);
;               p2 = p2.plus(l);
;               p = p.plus(l - 1);                     ;; skip multibyte char
;               continue;
;           }
;           if (vim_strchr(esc_chars, p.at(0)) != null)
;               (p2 = p2.plus(1)).be(-1, cc);
;           (p2 = p2.plus(1)).be(-1, p.at(0));
;       }
;       p2.be(0, NUL);

;       return escaped_string;
    ))

;; ASCII lower-to-upper case translation, language independent.

(defn- #_void vim_strup [#_Bytes p]
    (§
;       if (p != null)
;           for (int c; (c = p.at(0)) != NUL; )
;               (p = p.plus(1)).be(-1, (c < 'a' || 'z' < c) ? c : (c - 0x20));
    ))

;; Like STRDUP(), but make all characters uppercase.
;; This uses ASCII lower-to-upper case translation, language independent.

(defn- #_Bytes vim_strsave_up [#_Bytes string]
    (§
;       Bytes p = STRDUP(string);
;       vim_strup(p);
;       return p;
    ))

;; Like STRNDUP(), but make all characters uppercase.
;; This uses ASCII lower-to-upper case translation, language independent.

(defn- #_Bytes vim_strnsave_up [#_Bytes string, #_int len]
    (§
;       Bytes p = STRNDUP(string, len);
;       vim_strup(p);
;       return p;
    ))

;; Make string "s" all upper-case and return it in allocated memory.
;; Handles multi-byte characters as well as possible.

(defn- #_Bytes strup_save [#_Bytes orig]
    (§
;       Bytes res = STRDUP(orig);

;       for (Bytes p = res; p.at(0) != NUL; )
;       {
;           int c = us_ptr2char(p);
;           int uc = utf_toupper(c);

            ;; Reallocate string when byte count changes.
            ;; This is rare, thus it's OK to do another calloc()/free().
;           int l = us_ptr2len(p);
;           int newl = utf_char2len(uc);
;           if (newl != l)
;           {
;               Bytes s = new Bytes(STRLEN(res) + 1 + newl - l);

;               BCOPY(s, res, BDIFF(p, res));
;               STRCPY(s.plus(BDIFF(p, res) + newl), p.plus(l));
;               p = s.plus(BDIFF(p, res));
;               res = s;
;           }

;           utf_char2bytes(uc, p);
;           p = p.plus(newl);
;       }

;       return res;
    ))

;; copy a space a number of times

(defn- #_void copy_spaces [#_Bytes s, #_int n]
    (§
;       for (int i = 0; i < n; i++)
;           s.be(i, (byte)' ');
    ))

;; Copy a character a number of times.
;; Does not work for multi-byte characters!

(defn- #_void copy_chars [#_Bytes s, #_int n, #_int c]
    (§
;       for (int i = 0; i < n; i++)
;           s.be(i, c);
    ))

;; delete spaces at the end of a string

(defn- #_void del_trailing_spaces [#_Bytes p]
    (§
;       for (int i = STRLEN(p); 0 < --i && vim_iswhite(p.at(i)) && p.at(i - 1) != (byte)'\\' && p.at(i - 1) != Ctrl_V; )
;           p.be(i, NUL);
    ))

;; Like strncpy(), but always terminate the result with one NUL.
;; "dst" must be "len + 1" long!

(defn- #_void vim_strncpy [#_Bytes dst, #_Bytes src, #_int len]
    (§
;       STRNCPY(dst, src, len);
;       dst.be(len, NUL);
    ))

;; Like strcat(), but make sure the result fits in "size" bytes
;; and is always NUL terminated.

(defn- #_void vim_strcat [#_Bytes dst, #_Bytes src, #_int size]
    (§
;       int dlen = STRLEN(dst), slen = STRLEN(src);

;       if (size < dlen + slen + 1)
;       {
;           BCOPY(dst, dlen, src, 0, size - dlen - 1);
;           dst.be(size - 1, NUL);
;       }
;       else
;           STRCPY(dst.plus(dlen), src);
    ))

;; Isolate one part of a string option where parts are separated with "sep_chars".
;; The part is copied into "buf[maxlen]".
;; "*option" is advanced to the next part.
;; The length is returned.

(defn- #_int copy_option_part [#_Bytes* option, #_Bytes buf, #_int maxlen, #_Bytes sep_chars]
    (§
;       int len = 0;
;       Bytes p = option[0];

        ;; skip '.' at start of option part, for 'suffixes'
;       if (p.at(0) == (byte)'.')
;           buf.be(len++, (p = p.plus(1)).at(-1));
;       while (p.at(0) != NUL && vim_strchr(sep_chars, p.at(0)) == null)
;       {
            ;; Skip backslash before a separator character and space.

;           if (p.at(0) == (byte)'\\' && vim_strchr(sep_chars, p.at(1)) != null)
;               p = p.plus(1);
;           if (len < maxlen - 1)
;               buf.be(len++, p.at(0));
;           p = p.plus(1);
;       }
;       buf.be(len, NUL);

;       if (p.at(0) != NUL && p.at(0) != (byte)',') ;; skip non-standard separator
;           p = p.plus(1);
;       p = skip_to_option_part(p); ;; "p" points to next file name

;       option[0] = p;
;       return len;
    ))

;; Version of strchr() and strrchr() that handle unsigned char strings
;; with characters from 128 to 255 correctly.  It also doesn't return
;; a pointer to the NUL at the end of the string.

(defn- #_Bytes vim_strchr [#_Bytes string, #_int c]
    (§
;       for (Bytes p = string; p.at(0) != NUL; p = p.plus(us_ptr2len_cc(p)))
;           if (us_ptr2char(p) == c)
;               return p;

;       return null;
    ))

;; Version of strchr() that only works for bytes and handles unsigned char
;; strings with characters above 128 correctly.  It also doesn't return a
;; pointer to the NUL at the end of the string.

(defn- #_Bytes vim_strbyte [#_Bytes string, #_byte b]
    (§
;       for (Bytes p = string; p.at(0) != NUL; p = p.plus(1))
;           if (p.at(0) == b)
;               return p;

;       return null;
    ))

;; Search for last occurrence of "b" in "string".
;; Return null if not found.
;; Does not handle multi-byte char for "b"!

(defn- #_Bytes vim_strrchr [#_Bytes string, #_byte b]
    (§
;       Bytes q = null;

;       for (Bytes p = string; p.at(0) != NUL; p = p.plus(us_ptr2len_cc(p)))
;           if (p.at(0) == b)
;               q = p;

;       return q;
    ))

;; Vim has its own isspace() function, because on some machines isspace()
;; can't handle characters above 128.

(defn- #_boolean vim_isspace [#_int x]
    (§
;       return ((9 <= x && x <= 13) || x == ' ');
    ))

;; Some useful tables.

(class! #_final modmasktable_C
    [
        (field int      mod_mask)       ;; bit-mask for particular key modifier
        (field int      mod_flag)       ;; bit(s) for particular key modifier
        (field byte     name)           ;; single letter name of modifier
    ])

(final modmasktable_C* mod_mask_table
    [
        (->modmasktable_C MOD_MASK_ALT,         MOD_MASK_ALT,    (byte \M)),
        (->modmasktable_C MOD_MASK_META,        MOD_MASK_META,   (byte \T)),
        (->modmasktable_C MOD_MASK_CTRL,        MOD_MASK_CTRL,   (byte \C)),
        (->modmasktable_C MOD_MASK_SHIFT,       MOD_MASK_SHIFT,  (byte \S)),
        (->modmasktable_C MOD_MASK_MULTI_CLICK, MOD_MASK_2CLICK, (byte \2)),
        (->modmasktable_C MOD_MASK_MULTI_CLICK, MOD_MASK_3CLICK, (byte \3)),
        (->modmasktable_C MOD_MASK_MULTI_CLICK, MOD_MASK_4CLICK, (byte \4)),
        ;; 'A' must be the last one
        (->modmasktable_C MOD_MASK_ALT,         MOD_MASK_ALT,    (byte \A))
    ])

;; Shifted key terminal codes and their unshifted equivalent.
;; Don't add mouse codes here, they are handled separately!

(final int MOD_KEYS_ENTRY_SIZE 5)

(final byte* modifier_keys_table
    [
     ;; mod mask            with modifier           without modifier
        MOD_MASK_SHIFT,     (byte \&), (byte \9),   (byte \@), (byte \1),   ;; begin
        MOD_MASK_SHIFT,     (byte \&), (byte \0),   (byte \@), (byte \2),   ;; cancel
        MOD_MASK_SHIFT,     (byte \*), (byte \1),   (byte \@), (byte \4),   ;; command
        MOD_MASK_SHIFT,     (byte \*), (byte \2),   (byte \@), (byte \5),   ;; copy
        MOD_MASK_SHIFT,     (byte \*), (byte \3),   (byte \@), (byte \6),   ;; create
        MOD_MASK_SHIFT,     (byte \*), (byte \4),   (byte \k), (byte \D),   ;; delete char
        MOD_MASK_SHIFT,     (byte \*), (byte \5),   (byte \k), (byte \L),   ;; delete line
        MOD_MASK_SHIFT,     (byte \*), (byte \7),   (byte \@), (byte \7),   ;; end
        MOD_MASK_CTRL,      KS_EXTRA, KE_C_END,     (byte \@), (byte \7),   ;; end
        MOD_MASK_SHIFT,     (byte \*), (byte \9),   (byte \@), (byte \9),   ;; exit
        MOD_MASK_SHIFT,     (byte \*), (byte \0),   (byte \@), (byte \0),   ;; find
        MOD_MASK_SHIFT,     (byte \#), (byte \1),   (byte \%), (byte \1),   ;; help
        MOD_MASK_SHIFT,     (byte \#), (byte \2),   (byte \k), (byte \h),   ;; home
        MOD_MASK_CTRL,      KS_EXTRA, KE_C_HOME,    (byte \k), (byte \h),   ;; home
        MOD_MASK_SHIFT,     (byte \#), (byte \3),   (byte \k), (byte \I),   ;; insert
        MOD_MASK_SHIFT,     (byte \#), (byte \4),   (byte \k), (byte \l),   ;; left arrow
        MOD_MASK_CTRL,      KS_EXTRA, KE_C_LEFT,    (byte \k), (byte \l),   ;; left arrow
        MOD_MASK_SHIFT,     (byte \%), (byte \a),   (byte \%), (byte \3),   ;; message
        MOD_MASK_SHIFT,     (byte \%), (byte \b),   (byte \%), (byte \4),   ;; move
        MOD_MASK_SHIFT,     (byte \%), (byte \c),   (byte \%), (byte \5),   ;; next
        MOD_MASK_SHIFT,     (byte \%), (byte \d),   (byte \%), (byte \7),   ;; options
        MOD_MASK_SHIFT,     (byte \%), (byte \e),   (byte \%), (byte \8),   ;; previous
        MOD_MASK_SHIFT,     (byte \%), (byte \f),   (byte \%), (byte \9),   ;; print
        MOD_MASK_SHIFT,     (byte \%), (byte \g),   (byte \%), (byte \0),   ;; redo
        MOD_MASK_SHIFT,     (byte \%), (byte \h),   (byte \&), (byte \3),   ;; replace
        MOD_MASK_SHIFT,     (byte \%), (byte \i),   (byte \k), (byte \r),   ;; right arrow
        MOD_MASK_CTRL,      KS_EXTRA, KE_C_RIGHT,   (byte \k), (byte \r),   ;; right arrow
        MOD_MASK_SHIFT,     (byte \%), (byte \j),   (byte \&), (byte \5),   ;; resume
        MOD_MASK_SHIFT,     (byte \!), (byte \1),   (byte \&), (byte \6),   ;; save
        MOD_MASK_SHIFT,     (byte \!), (byte \2),   (byte \&), (byte \7),   ;; suspend
        MOD_MASK_SHIFT,     (byte \!), (byte \3),   (byte \&), (byte \8),   ;; undo
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_UP,      (byte \k), (byte \u),   ;; up arrow
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_DOWN,    (byte \k), (byte \d),   ;; down arrow

                                                                            ;; vt100 F1
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_XF1,     KS_EXTRA, KE_XF1,
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_XF2,     KS_EXTRA, KE_XF2,
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_XF3,     KS_EXTRA, KE_XF3,
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_XF4,     KS_EXTRA, KE_XF4,

        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F1,      (byte \k), (byte \1),   ;; F1
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F2,      (byte \k), (byte \2),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F3,      (byte \k), (byte \3),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F4,      (byte \k), (byte \4),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F5,      (byte \k), (byte \5),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F6,      (byte \k), (byte \6),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F7,      (byte \k), (byte \7),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F8,      (byte \k), (byte \8),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F9,      (byte \k), (byte \9),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F10,     (byte \k), (byte \;),   ;; F10

        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F11,     (byte \F), (byte \1),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F12,     (byte \F), (byte \2),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F13,     (byte \F), (byte \3),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F14,     (byte \F), (byte \4),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F15,     (byte \F), (byte \5),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F16,     (byte \F), (byte \6),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F17,     (byte \F), (byte \7),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F18,     (byte \F), (byte \8),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F19,     (byte \F), (byte \9),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F20,     (byte \F), (byte \A),

        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F21,     (byte \F), (byte \B),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F22,     (byte \F), (byte \C),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F23,     (byte \F), (byte \D),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F24,     (byte \F), (byte \E),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F25,     (byte \F), (byte \F),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F26,     (byte \F), (byte \G),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F27,     (byte \F), (byte \H),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F28,     (byte \F), (byte \I),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F29,     (byte \F), (byte \J),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F30,     (byte \F), (byte \K),

        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F31,     (byte \F), (byte \L),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F32,     (byte \F), (byte \M),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F33,     (byte \F), (byte \N),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F34,     (byte \F), (byte \O),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F35,     (byte \F), (byte \P),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F36,     (byte \F), (byte \Q),
        MOD_MASK_SHIFT,     KS_EXTRA, KE_S_F37,     (byte \F), (byte \R),

                                                                            ;; TAB pseudo code
        MOD_MASK_SHIFT,     (byte \k), (byte \B),   KS_EXTRA, KE_TAB,

        NUL
    ])

(class! #_final key_name_C
    [
        (field int      key)        ;; special key code or ascii value
        (field Bytes    name)       ;; name of key
    ])

(final key_name_C* key_names_table
    [
        (->key_name_C (int \space),     (u8 "Space")           ),
        (->key_name_C TAB,              (u8 "Tab")             ),
        (->key_name_C K_TAB,            (u8 "Tab")             ),
        (->key_name_C NL,               (u8 "NL")              ),
        (->key_name_C NL,               (u8 "NewLine")         ),  ;; alternative name
        (->key_name_C NL,               (u8 "LineFeed")        ),  ;; alternative name
        (->key_name_C NL,               (u8 "LF")              ),  ;; alternative name
        (->key_name_C CAR,              (u8 "CR")              ),
        (->key_name_C CAR,              (u8 "Return")          ),  ;; alternative name
        (->key_name_C CAR,              (u8 "Enter")           ),  ;; alternative name
        (->key_name_C K_BS,             (u8 "BS")              ),
        (->key_name_C K_BS,             (u8 "BackSpace")       ),  ;; alternative name
        (->key_name_C ESC,              (u8 "Esc")             ),
;       new key_name_C(char_u(CSI),      u8("CSI")             ),
        (->key_name_C K_CSI,            (u8 "xCSI")            ),
        (->key_name_C (int \|),         (u8 "Bar")             ),
        (->key_name_C (int \\),         (u8 "Bslash")          ),
        (->key_name_C K_DEL,            (u8 "Del")             ),
        (->key_name_C K_DEL,            (u8 "Delete")          ),  ;; alternative name
        (->key_name_C K_KDEL,           (u8 "kDel")            ),
        (->key_name_C K_UP,             (u8 "Up")              ),
        (->key_name_C K_DOWN,           (u8 "Down")            ),
        (->key_name_C K_LEFT,           (u8 "Left")            ),
        (->key_name_C K_RIGHT,          (u8 "Right")           ),
        (->key_name_C K_XUP,            (u8 "xUp")             ),
        (->key_name_C K_XDOWN,          (u8 "xDown")           ),
        (->key_name_C K_XLEFT,          (u8 "xLeft")           ),
        (->key_name_C K_XRIGHT,         (u8 "xRight")          ),

        (->key_name_C K_F1,             (u8 "F1")              ),
        (->key_name_C K_F2,             (u8 "F2")              ),
        (->key_name_C K_F3,             (u8 "F3")              ),
        (->key_name_C K_F4,             (u8 "F4")              ),
        (->key_name_C K_F5,             (u8 "F5")              ),
        (->key_name_C K_F6,             (u8 "F6")              ),
        (->key_name_C K_F7,             (u8 "F7")              ),
        (->key_name_C K_F8,             (u8 "F8")              ),
        (->key_name_C K_F9,             (u8 "F9")              ),
        (->key_name_C K_F10,            (u8 "F10")             ),

        (->key_name_C K_F11,            (u8 "F11")             ),
        (->key_name_C K_F12,            (u8 "F12")             ),
        (->key_name_C K_F13,            (u8 "F13")             ),
        (->key_name_C K_F14,            (u8 "F14")             ),
        (->key_name_C K_F15,            (u8 "F15")             ),
        (->key_name_C K_F16,            (u8 "F16")             ),
        (->key_name_C K_F17,            (u8 "F17")             ),
        (->key_name_C K_F18,            (u8 "F18")             ),
        (->key_name_C K_F19,            (u8 "F19")             ),
        (->key_name_C K_F20,            (u8 "F20")             ),

        (->key_name_C K_F21,            (u8 "F21")             ),
        (->key_name_C K_F22,            (u8 "F22")             ),
        (->key_name_C K_F23,            (u8 "F23")             ),
        (->key_name_C K_F24,            (u8 "F24")             ),
        (->key_name_C K_F25,            (u8 "F25")             ),
        (->key_name_C K_F26,            (u8 "F26")             ),
        (->key_name_C K_F27,            (u8 "F27")             ),
        (->key_name_C K_F28,            (u8 "F28")             ),
        (->key_name_C K_F29,            (u8 "F29")             ),
        (->key_name_C K_F30,            (u8 "F30")             ),

        (->key_name_C K_F31,            (u8 "F31")             ),
        (->key_name_C K_F32,            (u8 "F32")             ),
        (->key_name_C K_F33,            (u8 "F33")             ),
        (->key_name_C K_F34,            (u8 "F34")             ),
        (->key_name_C K_F35,            (u8 "F35")             ),
        (->key_name_C K_F36,            (u8 "F36")             ),
        (->key_name_C K_F37,            (u8 "F37")             ),

        (->key_name_C K_XF1,            (u8 "xF1")             ),
        (->key_name_C K_XF2,            (u8 "xF2")             ),
        (->key_name_C K_XF3,            (u8 "xF3")             ),
        (->key_name_C K_XF4,            (u8 "xF4")             ),

        (->key_name_C K_HELP,           (u8 "Help")            ),
        (->key_name_C K_UNDO,           (u8 "Undo")            ),
        (->key_name_C K_INS,            (u8 "Insert")          ),
        (->key_name_C K_INS,            (u8 "Ins")             ),  ;; alternative name
        (->key_name_C K_KINS,           (u8 "kInsert")         ),
        (->key_name_C K_HOME,           (u8 "Home")            ),
        (->key_name_C K_KHOME,          (u8 "kHome")           ),
        (->key_name_C K_XHOME,          (u8 "xHome")           ),
        (->key_name_C K_ZHOME,          (u8 "zHome")           ),
        (->key_name_C K_END,            (u8 "End")             ),
        (->key_name_C K_KEND,           (u8 "kEnd")            ),
        (->key_name_C K_XEND,           (u8 "xEnd")            ),
        (->key_name_C K_ZEND,           (u8 "zEnd")            ),
        (->key_name_C K_PAGEUP,         (u8 "PageUp")          ),
        (->key_name_C K_PAGEDOWN,       (u8 "PageDown")        ),
        (->key_name_C K_KPAGEUP,        (u8 "kPageUp")         ),
        (->key_name_C K_KPAGEDOWN,      (u8 "kPageDown")       ),

        (->key_name_C K_KPLUS,          (u8 "kPlus")           ),
        (->key_name_C K_KMINUS,         (u8 "kMinus")          ),
        (->key_name_C K_KDIVIDE,        (u8 "kDivide")         ),
        (->key_name_C K_KMULTIPLY,      (u8 "kMultiply")       ),
        (->key_name_C K_KENTER,         (u8 "kEnter")          ),
        (->key_name_C K_KPOINT,         (u8 "kPoint")          ),

        (->key_name_C K_K0,             (u8 "k0")              ),
        (->key_name_C K_K1,             (u8 "k1")              ),
        (->key_name_C K_K2,             (u8 "k2")              ),
        (->key_name_C K_K3,             (u8 "k3")              ),
        (->key_name_C K_K4,             (u8 "k4")              ),
        (->key_name_C K_K5,             (u8 "k5")              ),
        (->key_name_C K_K6,             (u8 "k6")              ),
        (->key_name_C K_K7,             (u8 "k7")              ),
        (->key_name_C K_K8,             (u8 "k8")              ),
        (->key_name_C K_K9,             (u8 "k9")              ),

        (->key_name_C (int \<),         (u8 "lt")              ),

        (->key_name_C K_MOUSE,          (u8 "Mouse")           ),
        (->key_name_C K_LEFTMOUSE,      (u8 "LeftMouse")       ),
        (->key_name_C K_LEFTMOUSE_NM,   (u8 "LeftMouseNM")     ),
        (->key_name_C K_LEFTDRAG,       (u8 "LeftDrag")        ),
        (->key_name_C K_LEFTRELEASE,    (u8 "LeftRelease")     ),
        (->key_name_C K_LEFTRELEASE_NM, (u8 "LeftReleaseNM")   ),
        (->key_name_C K_MIDDLEMOUSE,    (u8 "MiddleMouse")     ),
        (->key_name_C K_MIDDLEDRAG,     (u8 "MiddleDrag")      ),
        (->key_name_C K_MIDDLERELEASE,  (u8 "MiddleRelease")   ),
        (->key_name_C K_RIGHTMOUSE,     (u8 "RightMouse")      ),
        (->key_name_C K_RIGHTDRAG,      (u8 "RightDrag")       ),
        (->key_name_C K_RIGHTRELEASE,   (u8 "RightRelease")    ),
        (->key_name_C K_MOUSEDOWN,      (u8 "ScrollWheelUp")   ),
        (->key_name_C K_MOUSEUP,        (u8 "ScrollWheelDown") ),
        (->key_name_C K_MOUSELEFT,      (u8 "ScrollWheelRight")),
        (->key_name_C K_MOUSERIGHT,     (u8 "ScrollWheelLeft") ),
        (->key_name_C K_MOUSEDOWN,      (u8 "MouseDown")       ),  ;; OBSOLETE: use
        (->key_name_C K_MOUSEUP,        (u8 "MouseUp")         ),  ;; ScrollWheelXXX instead
        (->key_name_C K_X1MOUSE,        (u8 "X1Mouse")         ),
        (->key_name_C K_X1DRAG,         (u8 "X1Drag")          ),
        (->key_name_C K_X1RELEASE,      (u8 "X1Release")       ),
        (->key_name_C K_X2MOUSE,        (u8 "X2Mouse")         ),
        (->key_name_C K_X2DRAG,         (u8 "X2Drag")          ),
        (->key_name_C K_X2RELEASE,      (u8 "X2Release")       ),
        (->key_name_C K_DROP,           (u8 "Drop")            ),
        (->key_name_C K_ZERO,           (u8 "Nul")             ),
        (->key_name_C K_SNR,            (u8 "SNR")             ),
        (->key_name_C K_PLUG,           (u8 "Plug")            ),
        (->key_name_C K_CURSORHOLD,     (u8 "CursorHold")      ),
    ])

(class! #_final mousetable_C
    [
        (field int      pseudo_code)    ;; Code for pseudo mouse event.
        (field int      button)         ;; Which mouse button is it?
        (field boolean  is_click)       ;; Is it a mouse button click event?
        (field boolean  is_drag)        ;; Is it a mouse drag event?
    ])

(final mousetable_C* mouse_table
    [
        (->mousetable_C KE_LEFTMOUSE,     MOUSE_LEFT,    true,  false),
        (->mousetable_C KE_LEFTDRAG,      MOUSE_LEFT,    false, true ),
        (->mousetable_C KE_LEFTRELEASE,   MOUSE_LEFT,    false, false),
        (->mousetable_C KE_MIDDLEMOUSE,   MOUSE_MIDDLE,  true,  false),
        (->mousetable_C KE_MIDDLEDRAG,    MOUSE_MIDDLE,  false, true ),
        (->mousetable_C KE_MIDDLERELEASE, MOUSE_MIDDLE,  false, false),
        (->mousetable_C KE_RIGHTMOUSE,    MOUSE_RIGHT,   true,  false),
        (->mousetable_C KE_RIGHTDRAG,     MOUSE_RIGHT,   false, true ),
        (->mousetable_C KE_RIGHTRELEASE,  MOUSE_RIGHT,   false, false),
        (->mousetable_C KE_X1MOUSE,       MOUSE_X1,      true,  false),
        (->mousetable_C KE_X1DRAG,        MOUSE_X1,      false, true ),
        (->mousetable_C KE_X1RELEASE,     MOUSE_X1,      false, false),
        (->mousetable_C KE_X2MOUSE,       MOUSE_X2,      true,  false),
        (->mousetable_C KE_X2DRAG,        MOUSE_X2,      false, true ),
        (->mousetable_C KE_X2RELEASE,     MOUSE_X2,      false, false),
        ;; DRAG without CLICK
        (->mousetable_C KE_IGNORE,        MOUSE_RELEASE, false, true ),
        ;; RELEASE without CLICK
        (->mousetable_C KE_IGNORE,        MOUSE_RELEASE, false, false),
    ])

;; Return the modifier mask bit (MOD_MASK_*) which corresponds to the given
;; modifier name ('S' for Shift, 'C' for Ctrl etc).

(defn- #_int name_to_mod_mask [#_int c]
    (§
;       c = asc_toupper(c);

;       for (int i = 0; i < mod_mask_table.length; i++)
;           if (mod_mask_table[i].name == c)
;               return mod_mask_table[i].mod_flag;

;       return 0;
    ))

;; Check if if there is a special key code for "key" that includes the modifiers specified.

(defn- #_int simplify_key [#_int key, #_int* modifiers]
    (§
;       if ((modifiers[0] & (MOD_MASK_SHIFT | MOD_MASK_CTRL | MOD_MASK_ALT)) != 0)
;       {
            ;; TAB is a special case.
;           if (key == TAB && (modifiers[0] & MOD_MASK_SHIFT) != 0)
;           {
;               modifiers[0] &= ~MOD_MASK_SHIFT;
;               return K_S_TAB;
;           }

;           byte[] mkt = modifier_keys_table;
;           byte key0 = KEY2TERMCAP0(key), key1 = KEY2TERMCAP1(key);

;           for (int i = 0; mkt[i] != NUL; i += MOD_KEYS_ENTRY_SIZE)
;               if (key0 == mkt[i + 3] && key1 == mkt[i + 4] && (modifiers[0] & char_u(mkt[i])) != 0)
;               {
;                   modifiers[0] &= ~char_u(mkt[i]);
;                   return TERMCAP2KEY(mkt[i + 1], mkt[i + 2]);
;               }
;       }

;       return key;
    ))

;; Change <xHome> to <Home>, <xUp> to <Up>, etc.

(defn- #_int handle_x_keys [#_int key]
    (§
;       switch (key)
;       {
;           case K_XUP:     return K_UP;
;           case K_XDOWN:   return K_DOWN;
;           case K_XLEFT:   return K_LEFT;
;           case K_XRIGHT:  return K_RIGHT;
;           case K_XHOME:   return K_HOME;
;           case K_ZHOME:   return K_HOME;
;           case K_XEND:    return K_END;
;           case K_ZEND:    return K_END;
;           case K_XF1:     return K_F1;
;           case K_XF2:     return K_F2;
;           case K_XF3:     return K_F3;
;           case K_XF4:     return K_F4;
;           case K_S_XF1:   return K_S_F1;
;           case K_S_XF2:   return K_S_F2;
;           case K_S_XF3:   return K_S_F3;
;           case K_S_XF4:   return K_S_F4;
;       }
;       return key;
    ))

(final Bytes key__name (Bytes. (inc MAX_KEY_NAME_LEN)))

;; Return a string which contains the name of the given key when the given modifiers are down.

(defn- #_Bytes get_special_key_name [#_int c, #_int modifiers]
    (§
;       key__name.be(0, (byte)'<');
;       int idx = 1;

        ;; Key that stands for a normal character.
;       if (is_special(c) && KEY2TERMCAP0(c) == KS_KEY)
;           c = char_u(KEY2TERMCAP1(c));

        ;; Translate shifted special keys into unshifted keys and set modifier.
        ;; Same for CTRL and ALT modifiers.

;       if (is_special(c))
;       {
;           byte[] mkt = modifier_keys_table;
;           byte key0 = KEY2TERMCAP0(c), key1 = KEY2TERMCAP1(c);

;           for (int i = 0; mkt[i] != NUL; i += MOD_KEYS_ENTRY_SIZE)
;               if (key0 == mkt[i + 1] && key1 == mkt[i + 2])
;               {
;                   modifiers |= char_u(mkt[i]);
;                   c = TERMCAP2KEY(mkt[i + 3], mkt[i + 4]);
;                   break;
;               }
;       }

        ;; try to find the key in the special key table
;       int table_idx = find_special_key_in_table(c);

        ;; When not a known special key, and not a printable character, try to extract modifiers.

;       if (0 < c && utf_char2len(c) == 1)
;       {
;           if (table_idx < 0 && (!vim_isprintc(c) || (c & 0x7f) == ' ') && (c & 0x80) != 0)
;           {
;               c &= 0x7f;
;               modifiers |= MOD_MASK_ALT;
                ;; try again, to find the un-alted key in the special key table
;               table_idx = find_special_key_in_table(c);
;           }
;           if (table_idx < 0 && !vim_isprintc(c) && c < ' ')
;           {
;               c += '@';
;               modifiers |= MOD_MASK_CTRL;
;           }
;       }

        ;; translate the modifier into a string
;       for (int i = 0; i < mod_mask_table.length && mod_mask_table[i].name != 'A'; i++)
;           if ((modifiers & mod_mask_table[i].mod_mask) == mod_mask_table[i].mod_flag)
;           {
;               key__name.be(idx++, mod_mask_table[i].name);
;               key__name.be(idx++, (byte)'-');
;           }

;       if (table_idx < 0)          ;; unknown special key, may output t_xx
;       {
;           if (is_special(c))
;           {
;               key__name.be(idx++, (byte)'t');
;               key__name.be(idx++, (byte)'_');
;               key__name.be(idx++, KEY2TERMCAP0(c));
;               key__name.be(idx++, KEY2TERMCAP1(c));
;           }
            ;; Not a special key, only modifiers, output directly.
;           else
;           {
;               if (1 < utf_char2len(c))
;                   idx += utf_char2bytes(c, key__name.plus(idx));
;               else if (vim_isprintc(c))
;                   key__name.be(idx++, c);
;               else
;               {
;                   Bytes s = transchar(c);
;                   while (s.at(0) != NUL)
;                       key__name.be(idx++, (s = s.plus(1)).at(-1));
;               }
;           }
;       }
;       else                        ;; use name of special key
;       {
;           STRCPY(key__name.plus(idx), key_names_table[table_idx].name);
;           idx = STRLEN(key__name);
;       }
;       key__name.be(idx++, (byte)'>');
;       key__name.be(idx, NUL);
;       return key__name;
    ))

;; Try translating a <> name at (*srcp)[] to dst[].
;; Return the number of characters added to dst[], zero for no match.
;; If there is a match, srcp is advanced to after the <> name.
;; dst[] must be big enough to hold the result (up to six characters)!

(defn- #_int trans_special [#_Bytes* srcp, #_Bytes dst, #_boolean keycode]
    ;; keycode: prefer key code, e.g. K_DEL instead of DEL
    (§
;       int dlen = 0;

;       int[] modifiers = { 0 };
;       int key = find_special_key(srcp, modifiers, keycode, false);
;       if (key == 0)
;           return 0;

        ;; Put the appropriate modifier in a string.
;       if (modifiers[0] != 0)
;       {
;           dst.be(dlen++, KB_SPECIAL);
;           dst.be(dlen++, KS_MODIFIER);
;           dst.be(dlen++, modifiers[0]);
;       }

;       if (is_special(key))
;       {
;           dst.be(dlen++, KB_SPECIAL);
;           dst.be(dlen++, KEY2TERMCAP0(key));
;           dst.be(dlen++, KEY2TERMCAP1(key));
;       }
;       else if (!keycode)
;           dlen += utf_char2bytes(key, dst.plus(dlen));
;       else if (keycode)
;           dlen = BDIFF(add_char2buf(key, dst.plus(dlen)), dst);
;       else
;           dst.be(dlen++, key);

;       return dlen;
    ))

;; Try translating a <> name at (*srcp)[], return the key and modifiers.
;; srcp is advanced to after the <> name.
;; returns 0 if there is no match.

(defn- #_int find_special_key [#_Bytes* srcp, #_int* modp, #_boolean keycode, #_boolean keep_x_key]
    ;; keycode: prefer key code, e.g. K_DEL instead of DEL
    ;; keep_x_key: don't translate xHome to Home key
    (§
;       Bytes src = srcp[0];
;       if (src.at(0) != (byte)'<')
;           return 0;

        ;; Find end of modifier list.
;       Bytes last_dash = src;
;       Bytes bp;
;       for (bp = src.plus(1); bp.at(0) == (byte)'-' || vim_isIDc(bp.at(0)); bp = bp.plus(1))
;       {
;           if (bp.at(0) == (byte)'-')
;           {
;               last_dash = bp;
;               if (bp.at(1) != NUL)
;               {
;                   int l = us_ptr2len_cc(bp.plus(1));
;                   if (bp.at(l + 1) == (byte)'>')
;                       bp = bp.plus(l);    ;; anything accepted, like <C-?>
;               }
;           }
;           if (bp.at(0) == (byte)'t' && bp.at(1) == (byte)'_' && bp.at(2) != NUL && bp.at(3) != NUL)
;               bp = bp.plus(3);    ;; skip t_xx, xx may be '-' or '>'
;           else if (STRNCASECMP(bp, u8("char-"), 5) == 0)
;           {
;               int[] l = new int[1];
;               vim_str2nr(bp.plus(5), null, l, TRUE, TRUE, null);
;               bp = bp.plus(l[0] + 5);
;               break;
;           }
;       }

;       if (bp.at(0) == (byte)'>')     ;; found matching '>'
;       {
;           Bytes end_of_name = bp.plus(1);

            ;; Which modifiers are given?
;           int[] modifiers = { 0 };
;           for (bp = src.plus(1); BLT(bp, last_dash); bp = bp.plus(1))
;           {
;               if (bp.at(0) != (byte)'-')
;               {
;                   int bit = name_to_mod_mask(bp.at(0));
;                   if (bit == 0x0)
;                       break;      ;; Illegal modifier name
;                   modifiers[0] |= bit;
;               }
;           }

            ;; Legal modifier name.

;           if (BLE(last_dash, bp))
;           {
;               int key;
;               if (STRNCASECMP(last_dash.plus(1), u8("char-"), 5) == 0 && asc_isdigit(last_dash.at(6)))
;               {
                    ;; <Char-123> or <Char-033> or <Char-0x33>
;                   long[] n = new long[1];
;                   vim_str2nr(last_dash.plus(6), null, null, TRUE, TRUE, n);
;                   final long roof = 0x7fffffffL;
;                   if (n[0] < 0 || roof < n[0])
;                       n[0] = 0;
;                   key = (int)n[0];
;               }
;               else
;               {
                    ;; Modifier with single letter, or special key name.

;                   int l = us_ptr2len_cc(last_dash.plus(1));
;                   if (modifiers[0] != 0 && last_dash.at(l + 1) == (byte)'>')
;                       key = us_ptr2char(last_dash.plus(1));
;                   else
;                   {
;                       key = get_special_key_code(last_dash.plus(1));
;                       if (!keep_x_key)
;                           key = handle_x_keys(key);
;                   }
;               }

                ;; get_special_key_code() may return NUL for invalid special key name.

;               if (key != NUL)
;               {
                    ;; Only use a modifier when there is no special key code that
                    ;; includes the modifier.

;                   key = simplify_key(key, modifiers);

;                   if (!keycode)
;                   {
                        ;; don't want keycode, use single byte code
;                       if (key == K_BS)
;                           key = BS;
;                       else if (key == K_DEL || key == K_KDEL)
;                           key = DEL;
;                   }

                    ;; Normal Key with modifier: Try to make a single byte code.

;                   if (!is_special(key))
;                       key = extract_modifiers(key, modifiers);

;                   modp[0] = modifiers[0];
;                   srcp[0] = end_of_name;
;                   return key;
;               }
;           }
;       }

;       return 0;
    ))

;; Try to include modifiers in the key.
;; Changes "Shift-a" to 'A', "Alt-A" to 0xc0, etc.

(defn- #_int extract_modifiers [#_int key, #_int* modp]
    (§
;       int modifiers = modp[0];

;       if ((modifiers & MOD_MASK_SHIFT) != 0 && asc_isalpha(key))
;       {
;           key = asc_toupper(key);
;           modifiers &= ~MOD_MASK_SHIFT;
;       }
;       if ((modifiers & MOD_MASK_CTRL) != 0 && (('?' <= key && key <= '_') || asc_isalpha(key)))
;       {
;           key = ctrl_key((byte)key);
;           modifiers &= ~MOD_MASK_CTRL;
            ;; <C-@> is <Nul>
;           if (key == 0)
;               key = K_ZERO;
;       }
;       if ((modifiers & MOD_MASK_ALT) != 0 && key < 0x80)  ;; avoid creating a lead byte
;       {
;           key |= 0x80;
;           modifiers &= ~MOD_MASK_ALT;                     ;; remove the META modifier
;       }

;       modp[0] = modifiers;
;       return key;
    ))

;; Try to find key "c" in the special key table.
;; Return the index when found, -1 when not found.

(defn- #_int find_special_key_in_table [#_int c]
    (§
;       for (int i = 0; i < key_names_table.length; i++)
;           if (key_names_table[i].key == c)
;               return i;

;       return -1;
    ))

;; Find the special key with the given name (the given string does not have to
;; end with NUL, the name is assumed to end before the first non-idchar).
;; If the name starts with "t_" the next two characters are interpreted as a termcap name.
;; Return the key code, or 0 if not found.

(defn- #_int get_special_key_code [#_Bytes name]
    (§
        ;; If it's <t_xx> we get the code for xx from the termcap

;       if (name.at(0) == (byte)'t' && name.at(1) == (byte)'_' && name.at(2) != NUL && name.at(3) != NUL)
;       {
;           Bytes string = new Bytes(3);

;           string.be(0, name.at(2));
;           string.be(1, name.at(3));
;           string.be(2, NUL);

;           if (add_termcap_entry(string, false) == true)
;               return TERMCAP2KEY(name.at(2), name.at(3));
;       }
;       else
;           for (int i = 0; i < key_names_table.length; i++)
;           {
;               Bytes key_name = key_names_table[i].name;
;               int j;
;               for (j = 0; vim_isIDc(name.at(j)) && key_name.at(j) != NUL; j++)
;                   if (asc_tolower(key_name.at(j)) != asc_tolower(name.at(j)))
;                       break;
;               if (!vim_isIDc(name.at(j)) && key_name.at(j) == NUL)
;                   return key_names_table[i].key;
;           }

;       return 0;
    ))

(defn- #_Bytes get_key_name [#_int i]
    (§
;       if (i < key_names_table.length)
;           return key_names_table[i].name;

;       return null;
    ))

;; Look up the given mouse code to return the relevant information in the other arguments.
;; Return which button is down or was released.

(defn- #_int get_mouse_button [#_int code, #_boolean* is_click, #_boolean* is_drag]
    (§
;       is_click[0] = is_drag[0] = false;

;       for (int i = 0; i < mouse_table.length; i++)
;           if (code == mouse_table[i].pseudo_code)
;           {
;               is_click[0] = mouse_table[i].is_click;
;               is_drag[0] = mouse_table[i].is_drag;

;               return mouse_table[i].button;
;           }

;       return 0;       ;; Shouldn't get here.
    ))

;; Return the appropriate pseudo mouse event token (KE_LEFTMOUSE, etc.)
;; based on which mouse button is down, and whether it was clicked, dragged or released.

(defn- #_int get_pseudo_mouse_code [#_int button, #_boolean is_click, #_boolean is_drag]
    ;; button: e.g. MOUSE_LEFT
    (§
;       for (int i = 0; i < mouse_table.length; i++)
;           if (mouse_table[i].button == button
;                   && mouse_table[i].is_click == is_click && mouse_table[i].is_drag == is_drag)
;               return mouse_table[i].pseudo_code;

;       return KE_IGNORE;          ;; not recognized, ignore it
    ))

;; VISUAL, SELECTMODE and OP_PENDING State are never set, they are equal to
;; NORMAL State with a condition.  This function returns the real State.

(defn- #_int get_real_state []
    (§
;       if ((@State & NORMAL) != 0)
;       {
;           if (@VIsual_active)
;           {
;               if (@VIsual_select)
;                   return SELECTMODE;

;               return VISUAL;
;           }
;           else if (@finish_op)
;               return OP_PENDING;
;       }
;       return @State;
    ))

;; Return true if "p" points to just after a path separator.
;; Takes care of multi-byte characters.
;; "b" must point to the start of the file name

(defn- #_boolean after_pathsep [#_Bytes b, #_Bytes p]
    (§
;       return (BLT(b, p) && vim_ispathsep(p.at(-1)) && us_head_off(b, p.minus(1)) == 0);
    ))

;; Sort an array of strings.

;   static final Comparator<Bytes> sort__compare = new Comparator<Bytes>()
;   {
;       public int compare(Bytes s1, Bytes s2)
;       {
;           return STRCMP(s1, s2);
;       }
;   };

(defn- #_void sort_strings [#_Bytes* files, #_int count]
    (§
;       Arrays.sort(files, 0, count, sort__compare);
    ))

;; Print an error message with one or two "%s" and one or two string arguments.
;; This is not in message.c to avoid a warning for prototypes.

(defn- #_boolean emsg3 [#_Bytes s, #_Bytes a1, #_Bytes a2]
    (§
;       if (emsg_not_now())
;           return true;            ;; no error messages at the moment

;       vim_snprintf(@ioBuff, IOSIZE, s, a1, a2);
;       return emsg(@ioBuff);
    ))

;; Print an error message with one "%ld" and one long int argument.
;; This is not in message.c to avoid a warning for prototypes.

(defn- #_boolean emsgn [#_Bytes s, #_long n]
    (§
;       if (emsg_not_now())
;           return true;            ;; no error messages at the moment

;       vim_snprintf(@ioBuff, IOSIZE, s, n);
;       return emsg(@ioBuff);
    ))

;; Read 2 bytes from "fd" and turn them into an int, MSB first.

(defn- #_int get2c [#_file_C fd]
    (§
;       int        n = libc.getc(fd);
;       n = (n << 8) + libc.getc(fd);
;       return n;
    ))

;; Read 4 bytes from "fd" and turn them into an int, MSB first.

(defn- #_int get4c [#_file_C fd]
    (§
        ;; Use long rather than int otherwise result is undefined when left-shift sets the MSB.
;       long       n = libc.getc(fd);
;       n = (n << 8) + libc.getc(fd);
;       n = (n << 8) + libc.getc(fd);
;       n = (n << 8) + libc.getc(fd);
;       return (int)n;
    ))

;; Read 8 bytes from "fd" and turn them into a time_t, MSB first.

(defn- #_long get8c [#_file_C fd]
    (§
;       long n = 0;
;       for (int i = 0; i < 8; i++)
;           n = (n << 8) + libc.getc(fd);
;       return n;
    ))

;;; ============================================================================================== VimT

;; fileio.c: read from and write to a file --------------------------------------------------------

;; Set default or forced 'binary'.

(defn- #_void set_file_options [#_exarg_C eap]
    (§
        ;; set or reset 'binary'
;       if (eap != null && eap.force_bin != 0)
;       {
;           boolean oldval = @curbuf.@b_p_bin;

;           @curbuf.@b_p_bin = (eap.force_bin == FORCE_BIN);
;           set_options_bin(oldval, @curbuf.@b_p_bin, OPT_LOCAL);
;       }
    ))

(defn- #_void buf_store_time [#_buffer_C buf, #_stat_C st]
    (§
;       buf.b_mtime = st.st_mtime();
;       buf.b_orig_size = st.st_size();
;       buf.b_orig_mode = st.st_mode();
    ))

;; Adjust the line with missing eol, used for the next write.
;; Used for do_filter(), when the input lines for the filter are deleted.

(defn- #_void write_lnum_adjust [#_long offset]
    (§
;       if (@curbuf.b_no_eol_lnum != 0)      ;; only if there is a missing eol
;           @curbuf.b_no_eol_lnum += offset;
    ))

;; Return true when there is a CursorHold autocommand defined.

(defn- #_boolean has_cursorhold []
    (§
;       return false;
    ))

;; Return true if the CursorHold event can be triggered.

(defn- #_boolean trigger_cursorhold []
    (§
;       if (!@did_cursorhold && has_cursorhold() && !@Recording && @typebuf.tb_len == 0)
;       {
;           int state = get_real_state();
;           if (state == NORMAL_BUSY || (state & INSERT) != 0)
;               return true;
;       }
;       return false;
    ))

;; Version of read() that retries when interrupted by EINTR (possibly by a SIGWINCH).

(defn- #_int read_eintr [#_int fd, #_Bytes buf, #_int bufsize]
    (§
;       int ret;

;       for ( ; ; )
;       {
;           ret = (int)libC.read(fd, buf, bufsize);
;           if (0 <= ret || libC.errno() != EINTR)
;               break;
;       }

;       return ret;
    ))

;; Version of write() that retries when interrupted by EINTR (possibly by a SIGWINCH).

(defn- #_int write_eintr [#_int fd, #_Bytes buf, #_int bufsize]
    (§
;       int ret = 0;

        ;; Repeat the write() so long it didn't fail, other than being interrupted by a signal.
;       while (ret < bufsize)
;       {
;           int wlen = (int)libC.write(fd, buf.plus(ret), bufsize - ret);
;           if (wlen < 0)
;           {
;               if (libC.errno() != EINTR)
;                   break;
;           }
;           else
;               ret += wlen;
;       }

;       return ret;
    ))

;;; ============================================================================================== VimU

;; undo.c: multi level undo facility
;;
;; The saved lines are stored in a list of lists (one for each buffer):
;;
;; b_u_oldhead------------------------------------------------+
;;                                                            |
;;                                                            V
;;                +--------------+    +--------------+    +--------------+
;; b_u_newhead--->| u_header     |    | u_header     |    | u_header     |
;;                |     uh_next------>|     uh_next------>|     uh_next---->null
;;         null<--------uh_prev  |<---------uh_prev  |<---------uh_prev  |
;;                |     uh_entry |    |     uh_entry |    |     uh_entry |
;;                +--------|-----+    +--------|-----+    +--------|-----+
;;                         |                   |                   |
;;                         V                   V                   V
;;                +--------------+    +--------------+    +--------------+
;;                | u_entry      |    | u_entry      |    | u_entry      |
;;                |     ue_next  |    |     ue_next  |    |     ue_next  |
;;                +--------|-----+    +--------|-----+    +--------|-----+
;;                         |                   |                   |
;;                         V                   V                   V
;;                +--------------+            null                null
;;                | u_entry      |
;;                |     ue_next  |
;;                +--------|-----+
;;                         |
;;                         V
;;                        etc.
;;
;; Each u_entry list contains the information for one undo or redo.
;; curbuf.b_u_curhead points to the header of the last undo (the next redo),
;; or is null if nothing has been undone (end of the branch).
;;
;; For keeping alternate undo/redo branches the uh_alt field is used.  Thus at
;; each point in the list a branch may appear for an alternate to redo.  The
;; uh_seq field is numbered sequentially to be able to find a newer or older
;; branch.
;;
;;                 +---------------+    +---------------+
;; b_u_oldhead --->| u_header      |    | u_header      |
;;                 |   uh_alt_next ---->|   uh_alt_next ----> null
;;         null <----- uh_alt_prev |<------ uh_alt_prev |
;;                 |   uh_prev     |    |   uh_prev     |
;;                 +-----|---------+    +-----|---------+
;;                       |                    |
;;                       V                    V
;;                 +---------------+    +---------------+
;;                 | u_header      |    | u_header      |
;;                 |   uh_alt_next |    |   uh_alt_next |
;; b_u_newhead --->|   uh_alt_prev |    |   uh_alt_prev |
;;                 |   uh_prev     |    |   uh_prev     |
;;                 +-----|---------+    +-----|---------+
;;                       |                    |
;;                       V                    V
;;                     null             +---------------+    +---------------+
;;                                      | u_header      |    | u_header      |
;;                                      |   uh_alt_next ---->|   uh_alt_next |
;;                                      |   uh_alt_prev |<------ uh_alt_prev |
;;                                      |   uh_prev     |    |   uh_prev     |
;;                                      +-----|---------+    +-----|---------+
;;                                            |                    |
;;                                           etc.                 etc.
;;
;; All data is allocated and will all be freed when the buffer is unloaded.

;; used in undo_end() to report number of added and deleted lines
(atom! long     u_newcount)
(atom! long     u_oldcount)

;; When 'u' flag included in 'cpoptions', we behave like vi.
;; Need to remember the action that "u" should do.

(atom! boolean  undo_undoes)

(atom! int      lastmark)

;; Save the current line for both the "u" and "U" command.
;; Careful: may trigger autocommands that reload the buffer.
;; Returns true or false.

(defn- #_boolean u_save_cursor []
    (§
;       return u_save(@curwin.w_cursor.lnum - 1, @curwin.w_cursor.lnum + 1);
    ))

;; Save the lines between "top" and "bot" for both the "u" and "U" command.
;; "top" may be 0 and bot may be curbuf.b_ml.ml_line_count + 1.
;; Careful: may trigger autocommands that reload the buffer.
;; Returns false when lines could not be saved, true otherwise.

(defn- #_boolean u_save [#_long top, #_long bot]
    (§
;       if (@undo_off)
;           return true;

;       if (@curbuf.b_ml.ml_line_count < top || bot <= top || @curbuf.b_ml.ml_line_count + 1 < bot)
;           return false;   ;; rely on caller to do error messages

;       if (top + 2 == bot)
;           u_saveline(top + 1);

;       return u_savecommon(top, bot, 0, false);
    ))

;; Save the line "lnum" (used by ":s" and "~" command).
;; The line is replaced, so the new bottom line is lnum + 1.
;; Careful: may trigger autocommands that reload the buffer.
;; Returns false when lines could not be saved, true otherwise.

(defn- #_boolean u_savesub [#_long lnum]
    (§
;       if (@undo_off)
;           return true;

;       return u_savecommon(lnum - 1, lnum + 1, lnum + 1, false);
    ))

;; A new line is inserted before line "lnum" (used by :s command).
;; The line is inserted, so the new bottom line is lnum + 1.
;; Careful: may trigger autocommands that reload the buffer.
;; Returns false when lines could not be saved, true otherwise.

(defn- #_boolean u_inssub [#_long lnum]
    (§
;       if (@undo_off)
;           return true;

;       return u_savecommon(lnum - 1, lnum, lnum + 1, false);
    ))

;; Save the lines "lnum" - "lnum" + nlines (used by delete command).
;; The lines are deleted, so the new bottom line is lnum, unless the buffer becomes empty.
;; Careful: may trigger autocommands that reload the buffer.
;; Returns false when lines could not be saved, true otherwise.

(defn- #_boolean u_savedel [#_long lnum, #_long nlines]
    (§
;       if (@undo_off)
;           return true;

;       return u_savecommon(lnum - 1, lnum + nlines, (nlines == @curbuf.b_ml.ml_line_count) ? 2 : lnum, false);
    ))

;; Return true when undo is allowed.
;; Otherwise give an error message and return false.

(defn- #_boolean undo_allowed []
    (§
        ;; Don't allow changes when 'modifiable' is off.
;       if (!@curbuf.@b_p_ma)
;       {
;           emsg(e_modifiable);
;           return false;
;       }

        ;; In the sandbox it's not allowed to change the text.
;       if (@sandbox != 0)
;       {
;           emsg(e_sandbox);
;           return false;
;       }

        ;; Don't allow changes in the buffer while editing the cmdline.
        ;; The caller of getcmdline() may get confused.
;       if (@textlock != 0)
;       {
;           emsg(e_secure);
;           return false;
;       }

;       return true;
    ))

;; Get the undolevle value for the current buffer.

(defn- #_long get_undolevel []
    (§
;       if (@curbuf.@b_p_ul == NO_LOCAL_UNDOLEVEL)
;           return @p_ul;

;       return @curbuf.@b_p_ul;
    ))

;; Common code for various ways to save text before a change.
;; "top" is the line above the first changed line.
;; "bot" is the line below the last changed line.
;; "newbot" is the new bottom line.  Use zero when not known.
;; "reload" is true when saving for a buffer reload.
;; Careful: may trigger autocommands that reload the buffer.
;; Returns false when lines could not be saved, true otherwise.

(defn- #_boolean u_savecommon [#_long top, #_long bot, #_long newbot, #_boolean reload]
    (§
;       if (!reload)
;       {
            ;; When making changes is not allowed, return false.
            ;; It's a crude way to make all change commands fail.
;           if (!undo_allowed())
;               return false;

            ;; Saving text for undo means we are going to make a change.
            ;; Give a warning for a read-only file before making the change,
            ;; so that the FileChangedRO event can replace the buffer with
            ;; a read-write version (e.g., obtained from a source control system).

;           change_warning(0);
;           if (@curbuf.b_ml.ml_line_count + 1 < bot)
;           {
                ;; This happens when the FileChangedRO autocommand changes
                ;; the file in a way it becomes shorter.
;               emsg(u8("E881: Line count changed unexpectedly"));
;               return false;
;           }
;       }

;       long size = bot - top - 1;

        ;; If curbuf.b_u_synced == true make a new header.

;       if (@curbuf.b_u_synced)
;       {
            ;; Need to create new entry in b_changelist.
;           @curbuf.b_new_change = true;

;           u_header_C uhp;
;           if (0 <= get_undolevel())
;               uhp = §_u_header_C();
;           else
;               uhp = null;

            ;; If we undid more than we redid, move the entry lists before
            ;; and including curbuf.b_u_curhead to an alternate branch.

;           u_header_C[] old_curhead = { @curbuf.b_u_curhead };
;           if (old_curhead[0] != null)
;           {
;               @curbuf.b_u_newhead = old_curhead[0].uh_next.ptr;
;               @curbuf.b_u_curhead = null;
;           }

            ;; free headers to keep the size right

;           while (get_undolevel() < @curbuf.b_u_numhead && @curbuf.b_u_oldhead != null)
;           {
;               u_header_C uhfree = @curbuf.b_u_oldhead;

;               if (uhfree == old_curhead[0])
                    ;; Can't reconnect the branch, delete all of it.
;                   u_freebranch(@curbuf, uhfree, old_curhead);
;               else if (uhfree.uh_alt_next.ptr == null)
                    ;; There is no branch, only free one header.
;                   u_freeheader(@curbuf, uhfree, old_curhead);
;               else
;               {
                    ;; Free the oldest alternate branch as a whole.
;                   while (uhfree.uh_alt_next.ptr != null)
;                       uhfree = uhfree.uh_alt_next.ptr;
;                   u_freebranch(@curbuf, uhfree, old_curhead);
;               }
;           }

;           if (uhp == null)                ;; no undo at all
;           {
;               if (old_curhead[0] != null)
;                   u_freebranch(@curbuf, old_curhead[0], null);
;               @curbuf.b_u_synced = false;
;               return true;
;           }

;           uhp.uh_prev.ptr = null;
;           uhp.uh_next.ptr = @curbuf.b_u_newhead;
;           uhp.uh_alt_next.ptr = old_curhead[0];
;           if (old_curhead[0] != null)
;           {
;               uhp.uh_alt_prev.ptr = old_curhead[0].uh_alt_prev.ptr;
;               if (uhp.uh_alt_prev.ptr != null)
;                   uhp.uh_alt_prev.ptr.uh_alt_next.ptr = uhp;
;               old_curhead[0].uh_alt_prev.ptr = uhp;
;               if (@curbuf.b_u_oldhead == old_curhead[0])
;                   @curbuf.b_u_oldhead = uhp;
;           }
;           else
;               uhp.uh_alt_prev.ptr = null;
;           if (@curbuf.b_u_newhead != null)
;               @curbuf.b_u_newhead.uh_prev.ptr = uhp;

;           uhp.uh_seq = ++@curbuf.b_u_seq_last;
;           @curbuf.b_u_seq_cur = uhp.uh_seq;
;           uhp.uh_time = libC._time();
;           uhp.uh_save_nr = 0;
;           @curbuf.b_u_time_cur = uhp.uh_time + 1;

;           uhp.uh_walk = 0;
;           uhp.uh_entry = null;
;           uhp.uh_getbot_entry = null;
;           COPY_pos(uhp.uh_cursor, @curwin.w_cursor); ;; save cursor pos. for undo
;           if (virtual_active() && 0 < @curwin.w_cursor.coladd)
;               uhp.uh_cursor_vcol = getviscol();
;           else
;               uhp.uh_cursor_vcol = -1;

            ;; save changed and buffer empty flag for undo
;           uhp.uh_flags = (@curbuf.@b_changed ? UH_CHANGED : 0) +
;                          ((@curbuf.b_ml.ml_flags & ML_EMPTY) != 0 ? UH_EMPTYBUF : 0);

            ;; save named marks and Visual marks for undo
;           for (int i = 0; i < NMARKS; i++)
;               COPY_pos(uhp.uh_namedm[i], @curbuf.b_namedm[i]);
;           COPY_visualinfo(uhp.uh_visual, @curbuf.b_visual);

;           @curbuf.b_u_newhead = uhp;
;           if (@curbuf.b_u_oldhead == null)
;               @curbuf.b_u_oldhead = uhp;
;           @curbuf.b_u_numhead++;
;       }
;       else
;       {
;           if (get_undolevel() < 0)        ;; no undo at all
;               return true;

            ;; When saving a single line, and it has been saved just before, it
            ;; doesn't make sense saving it again.  Saves a lot of memory when
            ;; making lots of changes inside the same line.
            ;; This is only possible if the previous change didn't increase or
            ;; decrease the number of lines.
            ;; Check the ten last changes.  More doesn't make sense and takes too long.

;           if (size == 1)
;           {
;               u_entry_C uep = u_get_headentry();
;               u_entry_C prev_uep = null;
;               for (int i = 0; i < 10; i++)
;               {
;                   if (uep == null)
;                       break;

                    ;; If lines have been inserted/deleted we give up.
                    ;; Also when the line was included in a multi-line save.
;                   if ((@curbuf.b_u_newhead.uh_getbot_entry != uep
;                               ? (uep.ue_top + uep.ue_size + 1
;                                   != (uep.ue_bot == 0
;                                       ? @curbuf.b_ml.ml_line_count + 1
;                                       : uep.ue_bot))
;                               : uep.ue_lcount != @curbuf.b_ml.ml_line_count)
;                           || (1 < uep.ue_size
;                               && uep.ue_top <= top
;                               && top + 2 <= uep.ue_top + uep.ue_size + 1))
;                       break;

                    ;; If it's the same line we can skip saving it again.
;                   if (uep.ue_size == 1 && uep.ue_top == top)
;                   {
;                       if (0 < i)
;                       {
                            ;; It's not the last entry: get ue_bot for the last entry now.
                            ;; Following deleted/inserted lines go to the re-used entry.
;                           u_getbot();
;                           @curbuf.b_u_synced = false;

                            ;; Move the found entry to become the last entry.
                            ;; The order of undo/redo doesn't matter for the entries we move it over,
                            ;; since they don't change the line count and don't include this line.
                            ;; It does matter for the found entry if the line count is changed
                            ;; by the executed command.
;                           prev_uep.ue_next = uep.ue_next;
;                           uep.ue_next = @curbuf.b_u_newhead.uh_entry;
;                           @curbuf.b_u_newhead.uh_entry = uep;
;                       }

                        ;; The executed command may change the line count.
;                       if (newbot != 0)
;                           uep.ue_bot = newbot;
;                       else if (@curbuf.b_ml.ml_line_count < bot)
;                           uep.ue_bot = 0;
;                       else
;                       {
;                           uep.ue_lcount = @curbuf.b_ml.ml_line_count;
;                           @curbuf.b_u_newhead.uh_getbot_entry = uep;
;                       }
;                       return true;
;                   }
;                   prev_uep = uep;
;                   uep = uep.ue_next;
;               }
;           }

            ;; find line number for ue_bot for previous u_save()
;           u_getbot();
;       }

        ;; add lines in front of entry list

;       u_entry_C uep = §_u_entry_C();

;       uep.ue_size = size;
;       uep.ue_top = top;
;       if (newbot != 0)
;           uep.ue_bot = newbot;

        ;; Use 0 for ue_bot if bot is below last line.
        ;; Otherwise we have to compute ue_bot later.

;       else if (@curbuf.b_ml.ml_line_count < bot)
;           uep.ue_bot = 0;
;       else
;       {
;           uep.ue_lcount = @curbuf.b_ml.ml_line_count;
;           @curbuf.b_u_newhead.uh_getbot_entry = uep;
;       }

;       if (0 < size)
;       {
;           uep.ue_array = new Bytes[(int)size];
;           long lnum = top + 1;
;           for (int i = 0; i < size; i++)
;           {
;               fast_breakcheck();
;               if (@got_int)
;                   return false;
;               uep.ue_array[i] = STRDUP(ml_get(lnum++));
;           }
;       }
;       else
;           uep.ue_array = null;
;       uep.ue_next = @curbuf.b_u_newhead.uh_entry;
;       @curbuf.b_u_newhead.uh_entry = uep;
;       @curbuf.b_u_synced = false;
;       @undo_undoes = false;

;       return true;
    ))

;; If 'cpoptions' contains 'u': Undo the previous undo or redo (vi compatible).
;; If 'cpoptions' does not contain 'u': Always undo.

(defn- #_void u_undo [#_int count]
    (§
        ;; If we get an undo command while executing a macro, we behave like the original vi.
        ;; If this happens twice in one macro the result will not be compatible.

;       if (@curbuf.b_u_synced == false)
;       {
;           u_sync(true);
;           count = 1;
;       }

;       if (vim_strbyte(@p_cpo, CPO_UNDO) == null)
;           @undo_undoes = true;
;       else
;           @undo_undoes = !@undo_undoes;

;       u_doit(count);
    ))

;; If 'cpoptions' contains 'u': Repeat the previous undo or redo.
;; If 'cpoptions' does not contain 'u': Always redo.

(defn- #_void u_redo [#_int count]
    (§
;       if (vim_strbyte(@p_cpo, CPO_UNDO) == null)
;           @undo_undoes = false;

;       u_doit(count);
    ))

;; Undo or redo, depending on 'undo_undoes', 'count' times.

(defn- #_void u_doit [#_int startcount]
    (§
;       if (!undo_allowed())
;           return;

;       @u_newcount = 0;
;       @u_oldcount = 0;
;       if ((@curbuf.b_ml.ml_flags & ML_EMPTY) != 0)
;           @u_oldcount = -1;

;       for (int count = startcount; 0 < count--; )
;       {
            ;; Do the change warning now, so that it triggers FileChangedRO when
            ;; needed.  This may cause the file to be reloaded, that must happen
            ;; before we do anything, because it may change curbuf.b_u_curhead
            ;; and more.
;           change_warning(0);

;           if (@undo_undoes)
;           {
;               if (@curbuf.b_u_curhead == null)             ;; first undo
;                   @curbuf.b_u_curhead = @curbuf.b_u_newhead;
;               else if (0 < get_undolevel())               ;; multi level undo
                    ;; get next undo
;                   @curbuf.b_u_curhead = @curbuf.b_u_curhead.uh_next.ptr;
                ;; nothing to undo
;               if (@curbuf.b_u_numhead == 0 || @curbuf.b_u_curhead == null)
;               {
                    ;; stick curbuf.b_u_curhead at end
;                   @curbuf.b_u_curhead = @curbuf.b_u_oldhead;
;                   beep_flush();
;                   if (count == startcount - 1)
;                   {
;                       msg(u8("Already at oldest change"));
;                       return;
;                   }
;                   break;
;               }

;               u_undoredo(true);
;           }
;           else
;           {
;               if (@curbuf.b_u_curhead == null || get_undolevel() <= 0)
;               {
;                   beep_flush();   ;; nothing to redo
;                   if (count == startcount - 1)
;                   {
;                       msg(u8("Already at newest change"));
;                       return;
;                   }
;                   break;
;               }

;               u_undoredo(false);

                ;; Advance for next redo.
                ;; Set "newhead" when at the end of the redoable changes.
;               if (@curbuf.b_u_curhead.uh_prev.ptr == null)
;                   @curbuf.b_u_newhead = @curbuf.b_u_curhead;
;               @curbuf.b_u_curhead = @curbuf.b_u_curhead.uh_prev.ptr;
;           }
;       }

;       u_undo_end(@undo_undoes, false);
    ))

;; Undo or redo over the timeline.
;; When "step" is negative go back in time, otherwise goes forward in time.
;; When "sec" is false make "step" steps, when "sec" is true use "step" as seconds.
;; When "file" is true use "step" as a number of file writes.
;; When "absolute" is true use "step" as the sequence number to jump to.
;; "sec" must be false then.

(defn- #_void undo_time [#_long step, #_boolean sec, #_boolean file, #_boolean absolute]
    (§
;       boolean dosec = sec;
;       boolean dofile = file;
;       boolean above = false;
;       boolean did_undo = true;

        ;; First make sure the current undoable change is synced.
;       if (@curbuf.b_u_synced == false)
;           u_sync(true);

;       @u_newcount = 0;
;       @u_oldcount = 0;
;       if ((@curbuf.b_ml.ml_flags & ML_EMPTY) != 0)
;           @u_oldcount = -1;

;       u_header_C uhp = null;	// %% anno dunno

;       long target;
;       long closest;
        ;; "target" is the node below which we want to be.
        ;; Init "closest" to a value we can't reach.
;       if (absolute)
;       {
;           target = step;
;           closest = -1;
;       }
;       else
;       {
            ;; When doing computations with time_t subtract starttime, because
            ;; time_t converted to a long may result in a wrong number.
;           if (dosec)
;               target = @curbuf.b_u_time_cur - @starttime + step;
;           else if (dofile)
;           {
;               if (step < 0)
;               {
                    ;; Going back to a previous write.  If there were changes after
                    ;; the last write, count that as moving one file-write, so
                    ;; that ":earlier 1f" undoes all changes since the last save.
;                   uhp = @curbuf.b_u_curhead;
;                   if (uhp != null)
;                       uhp = uhp.uh_next.ptr;
;                   else
;                       uhp = @curbuf.b_u_newhead;
;                   if (uhp != null && uhp.uh_save_nr != 0)
                        ;; "uh_save_nr" was set in the last block, that means
                        ;; there were no changes since the last write
;                       target = @curbuf.b_u_save_nr_cur + step;
;                   else
                        ;; count the changes since the last write as one step
;                       target = @curbuf.b_u_save_nr_cur + step + 1;
;                   if (target <= 0)
                        ;; Go to before first write: before the oldest change.
                        ;; Use the sequence number for that.
;                       dofile = false;
;               }
;               else
;               {
                    ;; Moving forward to a newer write.
;                   target = @curbuf.b_u_save_nr_cur + step;
;                   if (@curbuf.b_u_save_nr_last < target)
;                   {
                        ;; Go to after last write: after the latest change.
                        ;; Use the sequence number for that.
;                       target = @curbuf.b_u_seq_last + 1;
;                       dofile = false;
;                   }
;               }
;           }
;           else
;               target = @curbuf.b_u_seq_cur + step;
;           if (step < 0)
;           {
;               if (target < 0)
;                   target = 0;
;               closest = -1;
;           }
;           else
;           {
;               if (dosec)
;                   closest = libC._time() - @starttime + 1;
;               else if (dofile)
;                   closest = @curbuf.b_u_save_nr_last + 2;
;               else
;                   closest = @curbuf.b_u_seq_last + 2;
;               if (closest <= target)
;                   target = closest - 1;
;           }
;       }
;       long closest_start = closest;
;       long closest_seq = @curbuf.b_u_seq_cur;

;       int mark = 0, nomark = 0;	// %% anno dunno

        ;; May do this twice:
        ;; 1. Search for "target", update "closest" to the best match found.
        ;; 2. If "target" not found search for "closest".
        ;;
        ;; When using the closest time we use the sequence number in the second
        ;; round, because there may be several entries with the same time.

;       for (int round = 1; round <= 2; round++)
;       {
            ;; Find the path from the current state to where we want to go.  The
            ;; desired state can be anywhere in the undo tree, need to go all over
            ;; it.  We put "nomark" in uh_walk where we have been without success,
            ;; "mark" where it could possibly be.
;           mark = ++@lastmark;
;           nomark = ++@lastmark;

;           if (@curbuf.b_u_curhead == null)     ;; at leaf of the tree
;               uhp = @curbuf.b_u_newhead;
;           else
;               uhp = @curbuf.b_u_curhead;

;           while (uhp != null)
;           {
;               uhp.uh_walk = mark;
;               long val;
;               if (dosec)
;                   val = uhp.uh_time - @starttime;
;               else if (dofile)
;                   val = uhp.uh_save_nr;
;               else
;                   val = uhp.uh_seq;

;               if (round == 1 && !(dofile && val == 0))
;               {
                    ;; Remember the header that is closest to the target.
                    ;; It must be at least in the right direction (checked with "b_u_seq_cur").
                    ;; When the timestamp is equal find the highest/lowest sequence number.
;                   if ((step < 0 ? uhp.uh_seq <= @curbuf.b_u_seq_cur
;                                 : uhp.uh_seq > @curbuf.b_u_seq_cur)
;                           && ((dosec && val == closest)
;                               ? (step < 0
;                                   ? uhp.uh_seq < closest_seq
;                                   : uhp.uh_seq > closest_seq)
;                               : closest == closest_start
;                                   || (target < val
;                                       ? (target < closest
;                                           ? val - target <= closest - target
;                                           : val - target <= target - closest)
;                                       : (target < closest
;                                           ? target - val <= closest - target
;                                           : target - val <= target - closest))))
;                   {
;                       closest = val;
;                       closest_seq = uhp.uh_seq;
;                   }
;               }

                ;; Quit searching when we found a match.  But when searching for a time,
                ;; we need to continue looking for the best uh_seq.
;               if (target == val && !dosec)
;               {
;                   target = uhp.uh_seq;
;                   break;
;               }

                ;; go down in the tree if we haven't been there
;               if (uhp.uh_prev.ptr != null && uhp.uh_prev.ptr.uh_walk != nomark
;                                             && uhp.uh_prev.ptr.uh_walk != mark)
;                   uhp = uhp.uh_prev.ptr;

                ;; go to alternate branch if we haven't been there
;               else if (uhp.uh_alt_next.ptr != null
;                       && uhp.uh_alt_next.ptr.uh_walk != nomark
;                       && uhp.uh_alt_next.ptr.uh_walk != mark)
;                   uhp = uhp.uh_alt_next.ptr;

                ;; Go up in the tree if we haven't been there and we are at
                ;; the start of alternate branches.
;               else if (uhp.uh_next.ptr != null && uhp.uh_alt_prev.ptr == null
;                       && uhp.uh_next.ptr.uh_walk != nomark
;                       && uhp.uh_next.ptr.uh_walk != mark)
;               {
                    ;; If still at the start we don't go through this change.
;                   if (uhp == @curbuf.b_u_curhead)
;                       uhp.uh_walk = nomark;
;                   uhp = uhp.uh_next.ptr;
;               }

;               else
;               {
                    ;; need to backtrack; mark this node as useless
;                   uhp.uh_walk = nomark;
;                   if (uhp.uh_alt_prev.ptr != null)
;                       uhp = uhp.uh_alt_prev.ptr;
;                   else
;                       uhp = uhp.uh_next.ptr;
;               }
;           }

;           if (uhp != null)    ;; found it
;               break;

;           if (absolute)
;           {
;               emsgn(u8("E830: Undo number %ld not found"), step);
;               return;
;           }

;           if (closest == closest_start)
;           {
;               if (step < 0)
;                   msg(u8("Already at oldest change"));
;               else
;                   msg(u8("Already at newest change"));
;               return;
;           }

;           target = closest_seq;
;           dosec = false;
;           dofile = false;
;           if (step < 0)
;               above = true;       ;; stop above the header
;       }

        ;; If we found it: Follow the path to go to where we want to be.
;       if (uhp != null)
;       {
            ;; First go up the tree as much as needed.

;           while (!@got_int)
;           {
                ;; Do the change warning now, for the same reason as above.
;               change_warning(0);

;               uhp = @curbuf.b_u_curhead;
;               if (uhp == null)
;                   uhp = @curbuf.b_u_newhead;
;               else
;                   uhp = uhp.uh_next.ptr;
;               if (uhp == null || uhp.uh_walk != mark || (uhp.uh_seq == target && !above))
;                   break;
;               @curbuf.b_u_curhead = uhp;
;               u_undoredo(true);
;               uhp.uh_walk = nomark;   ;; don't go back down here
;           }

            ;; And now go down the tree (redo), branching off where needed.

;           while (!@got_int)
;           {
                ;; Do the change warning now, for the same reason as above.
;               change_warning(0);

;               uhp = @curbuf.b_u_curhead;
;               if (uhp == null)
;                   break;

                ;; Go back to the first branch with a mark.
;               while (uhp.uh_alt_prev.ptr != null && uhp.uh_alt_prev.ptr.uh_walk == mark)
;                   uhp = uhp.uh_alt_prev.ptr;

                ;; Find the last branch with a mark, that's the one.
;               u_header_C last = uhp;
;               while (last.uh_alt_next.ptr != null && last.uh_alt_next.ptr.uh_walk == mark)
;                   last = last.uh_alt_next.ptr;
;               if (last != uhp)
;               {
                    ;; Make the used branch the first entry in the list of
                    ;; alternatives to make "u" and CTRL-R take this branch.
;                   while (uhp.uh_alt_prev.ptr != null)
;                       uhp = uhp.uh_alt_prev.ptr;
;                   if (last.uh_alt_next.ptr != null)
;                       last.uh_alt_next.ptr.uh_alt_prev.ptr = last.uh_alt_prev.ptr;
;                   last.uh_alt_prev.ptr.uh_alt_next.ptr = last.uh_alt_next.ptr;
;                   last.uh_alt_prev.ptr = null;
;                   last.uh_alt_next.ptr = uhp;
;                   uhp.uh_alt_prev.ptr = last;

;                   if (@curbuf.b_u_oldhead == uhp)
;                       @curbuf.b_u_oldhead = last;
;                   uhp = last;
;                   if (uhp.uh_next.ptr != null)
;                       uhp.uh_next.ptr.uh_prev.ptr = uhp;
;               }
;               @curbuf.b_u_curhead = uhp;

;               if (uhp.uh_walk != mark)
;                   break;      ;; must have reached the target

                ;; Stop when going backwards in time and didn't find
                ;; the exact header we were looking for.
;               if (uhp.uh_seq == target && above)
;               {
;                   @curbuf.b_u_seq_cur = target - 1;
;                   break;
;               }

;               u_undoredo(false);

                ;; Advance "curhead" to below the header we last used.
                ;; If it becomes null, then we need to set "newhead" to this leaf.
;               if (uhp.uh_prev.ptr == null)
;                   @curbuf.b_u_newhead = uhp;
;               @curbuf.b_u_curhead = uhp.uh_prev.ptr;
;               did_undo = false;

;               if (uhp.uh_seq == target)   ;; found it!
;                   break;

;               uhp = uhp.uh_prev.ptr;
;               if (uhp == null || uhp.uh_walk != mark)
;               {
                    ;; Need to redo more but can't find it...
;                   emsg2(e_intern2, u8("undo_time()"));
;                   break;
;               }
;           }
;       }

;       u_undo_end(did_undo, absolute);
    ))

;; u_undoredo: common code for undo and redo
;;
;; The lines in the file are replaced by the lines in the entry list at
;; curbuf.b_u_curhead.  The replaced lines in the file are saved in the entry
;; list for the next undo/redo.
;;
;; When "undo" is true we go up in the tree, when false we go down.

(defn- #_void u_undoredo [#_boolean undo]
    (§
;       Bytes[] newarray = null;
;       long newlnum = MAXLNUM;
;       u_entry_C newlist = null;
;       u_header_C curhead = @curbuf.b_u_curhead;

;       int old_flags = curhead.uh_flags;
;       int new_flags = (@curbuf.@b_changed ? UH_CHANGED : 0)
;                     + ((@curbuf.b_ml.ml_flags & ML_EMPTY) != 0 ? UH_EMPTYBUF : 0);
;       setpcmark();

        ;; save marks before undo/redo

;       pos_C[] namedm = ARRAY_pos(NMARKS);
;       for (int i = 0; i < NMARKS; i++)
;           COPY_pos(namedm[i], @curbuf.b_namedm[i]);

;       visualinfo_C visualinfo = §_visualinfo_C();
;       COPY_visualinfo(visualinfo, @curbuf.b_visual);

;       @curbuf.b_op_start.lnum = @curbuf.b_ml.ml_line_count;
;       @curbuf.b_op_start.col = 0;
;       @curbuf.b_op_end.lnum = 0;
;       @curbuf.b_op_end.col = 0;

;       for (u_entry_C uep = curhead.uh_entry, nuep; uep != null; uep = nuep)
;       {
;           long top = uep.ue_top;
;           long bot = uep.ue_bot;
;           if (bot == 0)
;               bot = @curbuf.b_ml.ml_line_count + 1;
;           if (top > @curbuf.b_ml.ml_line_count || bot <= top || bot > @curbuf.b_ml.ml_line_count + 1)
;           {
;               emsg(u8("E438: u_undo: line numbers wrong"));
;               changed();          ;; don't want UNCHANGED now
;               return;
;           }

;           int oldsize = (int)(bot - top - 1);       ;; number of lines before undo
;           int newsize = (int)uep.ue_size;         ;; number of lines after undo

;           if (top < newlnum)
;           {
                ;; If the saved cursor is somewhere in this undo block,
                ;; move it to the remembered position.
                ;; Makes "gwap" put the cursor back where it was.
;               long lnum = curhead.uh_cursor.lnum;
;               if (top <= lnum && lnum <= top + newsize + 1)
;               {
;                   COPY_pos(@curwin.w_cursor, curhead.uh_cursor);
;                   newlnum = @curwin.w_cursor.lnum - 1;
;               }
;               else
;               {
                    ;; Use the first line that actually changed.
                    ;; Avoids that undoing auto-formatting puts the cursor in the previous line.
;                   int i;
;                   for (i = 0; i < newsize && i < oldsize; i++)
;                       if (STRCMP(uep.ue_array[i], ml_get(top + 1 + i)) != 0)
;                           break;
;                   if (i == newsize && newlnum == MAXLNUM && uep.ue_next == null)
;                   {
;                       newlnum = top;
;                       @curwin.w_cursor.lnum = newlnum + 1;
;                   }
;                   else if (i < newsize)
;                   {
;                       newlnum = top + i;
;                       @curwin.w_cursor.lnum = newlnum + 1;
;                   }
;               }
;           }

;           boolean empty_buffer = false;   ;; buffer became empty

            ;; delete the lines between top and bot and save them in "newarray"
;           if (0 < oldsize)
;           {
;               newarray = new Bytes[oldsize];

                ;; delete backwards, it goes faster in most cases
;               long lnum = bot - 1;
;               for (int i = oldsize; 0 < i--; lnum--)
;               {
;                   newarray[i] = STRDUP(ml_get(lnum));
                    ;; remember we deleted the last line in the buffer,
                    ;; and a dummy empty line will be inserted
;                   if (@curbuf.b_ml.ml_line_count == 1)
;                       empty_buffer = true;
;                   ml_delete(lnum, false);
;               }
;           }
;           else
;               newarray = null;

            ;; insert the lines in u_array between top and bot
;           long lnum = top;
;           for (int i = 0; i < newsize; i++, lnum++)
;           {
                ;; If the file is empty, there is an empty line 1 that we
                ;; should get rid of, by replacing it with the new line.

;               if (empty_buffer && lnum == 0)
;                   ml_replace(1, uep.ue_array[i], true);
;               else
;                   ml_append(lnum, uep.ue_array[i], 0, false);
;           }

            ;; adjust marks
;           if (oldsize != newsize)
;           {
;               mark_adjust(top + 1, top + oldsize, MAXLNUM, newsize - oldsize);
;               if (@curbuf.b_op_start.lnum > top + oldsize)
;                   @curbuf.b_op_start.lnum += newsize - oldsize;
;               if (@curbuf.b_op_end.lnum > top + oldsize)
;                   @curbuf.b_op_end.lnum += newsize - oldsize;
;           }

;           changed_lines(top + 1, 0, bot, newsize - oldsize);

            ;; set '[ and '] mark
;           if (top + 1 < @curbuf.b_op_start.lnum)
;               @curbuf.b_op_start.lnum = top + 1;
;           if (newsize == 0 && @curbuf.b_op_end.lnum < top + 1)
;               @curbuf.b_op_end.lnum = top + 1;
;           else if (@curbuf.b_op_end.lnum < top + newsize)
;               @curbuf.b_op_end.lnum = top + newsize;

;           @u_newcount += newsize;
;           @u_oldcount += oldsize;
;           uep.ue_size = oldsize;
;           uep.ue_array = newarray;
;           uep.ue_bot = top + newsize + 1;

            ;; insert this entry in front of the new entry list

;           nuep = uep.ue_next;
;           uep.ue_next = newlist;
;           newlist = uep;
;       }

;       curhead.uh_entry = newlist;
;       curhead.uh_flags = new_flags;
;       if ((old_flags & UH_EMPTYBUF) != 0 && bufempty())
;           @curbuf.b_ml.ml_flags |= ML_EMPTY;
;       if ((old_flags & UH_CHANGED) != 0)
;           changed();
;       else
;           unchanged(@curbuf, false);

        ;; restore marks from before undo/redo

;       for (int i = 0; i < NMARKS; i++)
;       {
;           if (curhead.uh_namedm[i].lnum != 0)
;               COPY_pos(@curbuf.b_namedm[i], curhead.uh_namedm[i]);
;           if (namedm[i].lnum != 0)
;               COPY_pos(curhead.uh_namedm[i], namedm[i]);
;           else
;               curhead.uh_namedm[i].lnum = 0;
;       }
;       if (curhead.uh_visual.vi_start.lnum != 0)
;       {
;           COPY_visualinfo(@curbuf.b_visual, curhead.uh_visual);
;           COPY_visualinfo(curhead.uh_visual, visualinfo);
;       }

        ;; If the cursor is only off by one line,
        ;; put it at the same position as before starting the change (for the "o" command).
        ;; Otherwise the cursor should go to the first undone line.

;       if (curhead.uh_cursor.lnum + 1 == @curwin.w_cursor.lnum && 1 < @curwin.w_cursor.lnum)
;           --@curwin.w_cursor.lnum;
;       if (@curwin.w_cursor.lnum <= @curbuf.b_ml.ml_line_count)
;       {
;           if (curhead.uh_cursor.lnum == @curwin.w_cursor.lnum)
;           {
;               @curwin.w_cursor.col = curhead.uh_cursor.col;
;               if (virtual_active() && 0 <= curhead.uh_cursor_vcol)
;                   coladvance((int)curhead.uh_cursor_vcol);
;               else
;                   @curwin.w_cursor.coladd = 0;
;           }
;           else
;               beginline(BL_SOL | BL_FIX);
;       }
;       else
;       {
            ;; We get here with the current cursor line being past the end (eg
            ;; after adding lines at the end of the file, and then undoing it).
            ;; check_cursor() will move the cursor to the last line.  Move it to
            ;; the first column here.
;           @curwin.w_cursor.col = 0;
;           @curwin.w_cursor.coladd = 0;
;       }

        ;; Make sure the cursor is on an existing line and column.
;       check_cursor();

        ;; Remember where we are for "g-" and ":earlier 10s".
;       @curbuf.b_u_seq_cur = curhead.uh_seq;
;       if (undo)
            ;; We are below the previous undo.  However, to make ":earlier 1s"
            ;; work we compute this as being just above the just undone change.
;           --@curbuf.b_u_seq_cur;

        ;; Remember where we are for ":earlier 1f" and ":later 1f".
;       if (curhead.uh_save_nr != 0)
;       {
;           if (undo)
;               @curbuf.b_u_save_nr_cur = curhead.uh_save_nr - 1;
;           else
;               @curbuf.b_u_save_nr_cur = curhead.uh_save_nr;
;       }

        ;; The timestamp can be the same for multiple changes,
        ;; just use the one of the undone/redone change.
;       @curbuf.b_u_time_cur = curhead.uh_time;
    ))

;; If we deleted or added lines, report the number of less/more lines.
;; Otherwise, report the number of changes
;; (this may be incorrect in some cases, but it's better than nothing).

(defn- #_void u_undo_end [#_boolean did_undo, #_boolean absolute]
    ;; did_undo: just did an undo
    ;; absolute: used ":undo N"
    (§
;       if (@global_busy != 0            ;; no messages now, wait until global is finished
;               || !messaging())        ;; 'lazyredraw' set, don't do messages now
;           return;

;       if ((@curbuf.b_ml.ml_flags & ML_EMPTY) != 0)
;           --@u_newcount;

;       @u_oldcount -= @u_newcount;

;       Bytes msgstr;
;       if (@u_oldcount == -1)
;           msgstr = u8("more line");
;       else if (@u_oldcount < 0)
;           msgstr = u8("more lines");
;       else if (@u_oldcount == 1)
;           msgstr = u8("line less");
;       else if (1 < @u_oldcount)
;           msgstr = u8("fewer lines");
;       else
;       {
;           @u_oldcount = @u_newcount;

;           if (@u_newcount == 1)
;               msgstr = u8("change");
;           else
;               msgstr = u8("changes");
;       }

;       u_header_C uhp;
;       if (@curbuf.b_u_curhead != null)
;       {
            ;; For ":undo N" we prefer a "after #N" message.
;           if (absolute && @curbuf.b_u_curhead.uh_next.ptr != null)
;           {
;               uhp = @curbuf.b_u_curhead.uh_next.ptr;
;               did_undo = false;
;           }
;           else if (did_undo)
;               uhp = @curbuf.b_u_curhead;
;           else
;               uhp = @curbuf.b_u_curhead.uh_next.ptr;
;       }
;       else
;           uhp = @curbuf.b_u_newhead;

;       Bytes msgbuf = new Bytes(80);
;       if (uhp == null)
;           msgbuf.be(0, NUL);
;       else
;           u_add_time(msgbuf, msgbuf.size(), uhp.uh_time);

;       for (window_C wp = @firstwin; wp != null; wp = wp.w_next)
;           if (wp.w_buffer == @curbuf && 0 < wp.w_onebuf_opt.@wo_cole)
;               redraw_win_later(wp, NOT_VALID);

;       smsg(u8("%ld %s; %s #%ld  %s"),
;               (@u_oldcount < 0) ? -@u_oldcount : @u_oldcount,
;               msgstr,
;               did_undo ? u8("before") : u8("after"),
;               (uhp == null) ? 0L : uhp.uh_seq,
;               msgbuf);
    ))

;; u_sync: stop adding to the current entry list

(defn- #_void u_sync [#_boolean force]
    ;; force: Also sync when no_u_sync is set.
    (§
        ;; Skip it when already synced or syncing is disabled.
;       if (@curbuf.b_u_synced || (!force && 0 < @no_u_sync))
;           return;

;       if (get_undolevel() < 0)
;           @curbuf.b_u_synced = true;   ;; no entries, nothing to do
;       else
;       {
;           u_getbot();                 ;; compute ue_bot of previous u_save()
;           @curbuf.b_u_curhead = null;
;       }
    ))

;; ":undolist": List the leafs of the undo tree

(defn- #_void ex_undolist [#_exarg_C _eap]
    (§
;       int changes = 1;

            ;; 1: walk the tree to find all leafs, put the info in "ga".
            ;; 2: sort the lines
            ;; 3: display the list

;       int mark = ++@lastmark;
;       int nomark = ++@lastmark;

;       Growing<Bytes> ga = new Growing<Bytes>(Bytes.class, 20);

;       for (u_header_C uhp = @curbuf.b_u_oldhead; uhp != null; )
;       {
;           if (uhp.uh_prev.ptr == null && uhp.uh_walk != nomark && uhp.uh_walk != mark)
;           {
;               vim_snprintf(@ioBuff, IOSIZE, u8("%6ld %7ld  "), uhp.uh_seq, changes);
;               u_add_time(@ioBuff.plus(STRLEN(@ioBuff)), IOSIZE - STRLEN(@ioBuff), uhp.uh_time);
;               if (0 < uhp.uh_save_nr)
;               {
;                   while (STRLEN(@ioBuff) < 33)
;                       STRCAT(@ioBuff, u8(" "));
;                   vim_snprintf_add(@ioBuff, IOSIZE, u8("  %3ld"), uhp.uh_save_nr);
;               }

;               ga.ga_grow(1);
;               ga.ga_data[ga.ga_len++] = STRDUP(@ioBuff);
;           }

;           uhp.uh_walk = mark;

                ;; go down in the tree if we haven't been there
;           if (uhp.uh_prev.ptr != null
;                   && uhp.uh_prev.ptr.uh_walk != nomark
;                   && uhp.uh_prev.ptr.uh_walk != mark)
;           {
;               uhp = uhp.uh_prev.ptr;
;               changes++;
;           }
                ;; go to alternate branch if we haven't been there
;           else if (uhp.uh_alt_next.ptr != null
;                   && uhp.uh_alt_next.ptr.uh_walk != nomark
;                   && uhp.uh_alt_next.ptr.uh_walk != mark)
;           {
;               uhp = uhp.uh_alt_next.ptr;
;           }
                ;; go up in the tree if we haven't been there and we are at the start of alternate branches
;           else if (uhp.uh_next.ptr != null && uhp.uh_alt_prev.ptr == null
;                   && uhp.uh_next.ptr.uh_walk != nomark
;                   && uhp.uh_next.ptr.uh_walk != mark)
;           {
;               uhp = uhp.uh_next.ptr;
;               --changes;
;           }
;           else
;           {
                    ;; need to backtrack; mark this node as done
;               uhp.uh_walk = nomark;
;               if (uhp.uh_alt_prev.ptr != null)
;                   uhp = uhp.uh_alt_prev.ptr;
;               else
;               {
;                   uhp = uhp.uh_next.ptr;
;                   --changes;
;               }
;           }
;       }

;       if (ga.ga_len == 0)
;           msg(u8("Nothing to undo"));
;       else
;       {
;           sort_strings(ga.ga_data, ga.ga_len);

;           msg_start();
;           msg_puts_attr(u8("number changes  when               saved"), hl_attr(HLF_T));
;           for (int i = 0; i < ga.ga_len && !@got_int; i++)
;           {
;               msg_putchar('\n');
;               if (@got_int)
;                   break;
;               msg_puts(ga.ga_data[i]);
;           }
;           msg_end();

;           ga.ga_clear();
;       }
    ))

;; Put the timestamp of an undo header in "buf[buflen]" in a nice format.

(defn- #_void u_add_time [#_Bytes buf, #_int buflen, #_long seconds]
    (§
;       if (100 <= libC._time() - seconds)
;       {
;           tm_C curtime = libC._localtime(seconds);
;           if (libC._time() - seconds < (60L * 60L * 12L))
                ;; within 12 hours
;               libC.strftime(buf, buflen, u8("%H:%M:%S"), curtime);
;           else
                ;; longer ago
;               libC.strftime(buf, buflen, u8("%Y/%m/%d %H:%M:%S"), curtime);
;       }
;       else
;           vim_snprintf(buf, buflen, u8("%ld seconds ago"), libC._time() - seconds);
    ))

;; ":undojoin": continue adding to the last entry list

(defn- #_void ex_undojoin [#_exarg_C _eap]
    (§
;       if (@curbuf.b_u_newhead == null)
;           return;                             ;; nothing changed before
;       if (@curbuf.b_u_curhead != null)
;       {
;           emsg(u8("E790: undojoin is not allowed after undo"));
;           return;
;       }
;       if (!@curbuf.b_u_synced)
;           return;                             ;; already unsynced
;       if (get_undolevel() < 0)
;           return;                             ;; no entries, nothing to do
;       else
;       {
                ;; Go back to the last entry.
;           @curbuf.b_u_curhead = @curbuf.b_u_newhead;
;           @curbuf.b_u_synced = false;          ;; no entries, nothing to do
;       }
    ))

;; Called after writing or reloading the file and setting "b_changed" to false.
;; Now an undo means that the buffer is modified.

(defn- #_void u_unchanged [#_buffer_C buf]
    (§
;       u_unch_branch(buf.b_u_oldhead);
;       buf.b_did_warn = false;
    ))

(defn- #_void u_unch_branch [#_u_header_C uhp]
    (§
;       for (u_header_C uh = uhp; uh != null; uh = uh.uh_prev.ptr)
;       {
;           uh.uh_flags |= UH_CHANGED;
;           if (uh.uh_alt_next.ptr != null)
;               u_unch_branch(uh.uh_alt_next.ptr);  ;; recursive
;       }
    ))

;; Get pointer to last added entry.
;; If it's not valid, give an error message and return null.

(defn- #_u_entry_C u_get_headentry []
    (§
;       if (@curbuf.b_u_newhead == null || @curbuf.b_u_newhead.uh_entry == null)
;       {
;           emsg(u8("E439: undo list corrupt"));
;           return null;
;       }
;       return @curbuf.b_u_newhead.uh_entry;
    ))

;; u_getbot(): compute the line number of the previous u_save()
;;              It is called only when b_u_synced is false.

(defn- #_void u_getbot []
    (§
;       u_entry_C uep = u_get_headentry(); ;; check for corrupt undo list
;       if (uep == null)
;           return;

;       uep = @curbuf.b_u_newhead.uh_getbot_entry;
;       if (uep != null)
;       {
            ;; the new ue_bot is computed from the number of lines that has been
            ;; inserted (0 - deleted) since calling u_save().  This is equal to the
            ;; old line count subtracted from the current line count.

;           long extra = @curbuf.b_ml.ml_line_count - uep.ue_lcount;
;           uep.ue_bot = uep.ue_top + uep.ue_size + 1 + extra;
;           if (uep.ue_bot < 1 || @curbuf.b_ml.ml_line_count < uep.ue_bot)
;           {
;               emsg(u8("E440: undo line missing"));
;               uep.ue_bot = uep.ue_top + 1;    ;; assume all lines deleted, will
                                                ;; get all the old lines back
                                                ;; without deleting the current ones
;           }

;           @curbuf.b_u_newhead.uh_getbot_entry = null;
;       }

;       @curbuf.b_u_synced = true;
    ))

;; Free one header "uhp" and its entry list and adjust the pointers.

(defn- #_void u_freeheader [#_buffer_C buf, #_u_header_C uhp, #_u_header_C* uhpp]
    ;; uhpp: if not null reset when freeing this header
    (§
        ;; When there is an alternate redo list free that branch completely,
        ;; because we can never go there.
;       if (uhp.uh_alt_next.ptr != null)
;           u_freebranch(buf, uhp.uh_alt_next.ptr, uhpp);

;       if (uhp.uh_alt_prev.ptr != null)
;           uhp.uh_alt_prev.ptr.uh_alt_next.ptr = null;

        ;; Update the links in the list to remove the header.
;       if (uhp.uh_next.ptr == null)
;           buf.b_u_oldhead = uhp.uh_prev.ptr;
;       else
;           uhp.uh_next.ptr.uh_prev.ptr = uhp.uh_prev.ptr;

;       if (uhp.uh_prev.ptr == null)
;           buf.b_u_newhead = uhp.uh_next.ptr;
;       else
;           for (u_header_C uhap = uhp.uh_prev.ptr; uhap != null; uhap = uhap.uh_alt_next.ptr)
;               uhap.uh_next.ptr = uhp.uh_next.ptr;

;       u_freeentries(buf, uhp, uhpp);
    ))

;; Free an alternate branch and any following alternate branches.

(defn- #_void u_freebranch [#_buffer_C buf, #_u_header_C uhp, #_u_header_C* uhpp]
    ;; uhpp: if not null reset when freeing this header
    (§
        ;; If this is the top branch we may need to use u_freeheader() to update all the pointers.
;       if (uhp == buf.b_u_oldhead)
;       {
;           while (buf.b_u_oldhead != null)
;               u_freeheader(buf, buf.b_u_oldhead, uhpp);
;           return;
;       }

;       if (uhp.uh_alt_prev.ptr != null)
;           uhp.uh_alt_prev.ptr.uh_alt_next.ptr = null;

;       for (u_header_C next = uhp; next != null; )
;       {
;           u_header_C tofree = next;
;           if (tofree.uh_alt_next.ptr != null)
;               u_freebranch(buf, tofree.uh_alt_next.ptr, uhpp);    ;; recursive
;           next = tofree.uh_prev.ptr;
;           u_freeentries(buf, tofree, uhpp);
;       }
    ))

;; Free all the undo entries for one header and the header itself.
;; This means that "uhp" is invalid when returning.

(defn- #_void u_freeentries [#_buffer_C buf, #_u_header_C uhp, #_u_header_C* uhpp]
    ;; uhpp: if not null reset when freeing this header
    (§
        ;; Check for pointers to the header that become invalid now.
;       if (buf.b_u_curhead == uhp)
;           buf.b_u_curhead = null;
;       if (buf.b_u_newhead == uhp)
;           buf.b_u_newhead = null;         ;; freeing the newest entry
;       if (uhpp != null && uhp == uhpp[0])
;           uhpp[0] = null;

;       --buf.b_u_numhead;
    ))

;; invalidate the undo buffer; called when storage has already been released

(defn- #_void u_clearall [#_buffer_C buf]
    (§
;       buf.b_u_newhead = buf.b_u_oldhead = buf.b_u_curhead = null;
;       buf.b_u_synced = true;
;       buf.b_u_numhead = 0;
;       buf.b_u_line_ptr = null;
;       buf.b_u_line_lnum = 0;
    ))

;; save the line "lnum" for the "U" command

(defn- #_void u_saveline [#_long lnum]
    (§
;       if (lnum == @curbuf.b_u_line_lnum)                   ;; line is already saved
;           return;
;       if (lnum < 1 || @curbuf.b_ml.ml_line_count < lnum)   ;; should never happen
;           return;

;       u_clearline();

;       @curbuf.b_u_line_lnum = lnum;
;       if (@curwin.w_cursor.lnum == lnum)
;           @curbuf.b_u_line_colnr = @curwin.w_cursor.col;
;       else
;           @curbuf.b_u_line_colnr = 0;
;       @curbuf.b_u_line_ptr = STRDUP(ml_get(lnum));
    ))

;; clear the line saved for the "U" command
;; (this is used externally for crossing a line while in insert mode)

(defn- #_void u_clearline []
    (§
;       if (@curbuf.b_u_line_ptr != null)
;       {
;           @curbuf.b_u_line_ptr = null;
;           @curbuf.b_u_line_lnum = 0;
;       }
    ))

;; Implementation of the "U" command.
;; Differentiation from vi: "U" can be undone with the next "U".
;; We also allow the cursor to be in another line.
;; Careful: may trigger autocommands that reload the buffer.

(defn- #_void u_undoline []
    (§
;       if (@undo_off)
;           return;

;       if (@curbuf.b_u_line_ptr == null || @curbuf.b_ml.ml_line_count < @curbuf.b_u_line_lnum)
;       {
;           beep_flush();
;           return;
;       }

        ;; first save the line for the 'u' command
;       if (u_savecommon(@curbuf.b_u_line_lnum - 1, @curbuf.b_u_line_lnum + 1, 0, false) == false)
;           return;

;       Bytes oldp = STRDUP(ml_get(@curbuf.b_u_line_lnum));

;       ml_replace(@curbuf.b_u_line_lnum, @curbuf.b_u_line_ptr, true);
;       changed_bytes(@curbuf.b_u_line_lnum, 0);
;       @curbuf.b_u_line_ptr = oldp;

;       int t = @curbuf.b_u_line_colnr;
;       if (@curwin.w_cursor.lnum == @curbuf.b_u_line_lnum)
;           @curbuf.b_u_line_colnr = @curwin.w_cursor.col;
;       @curwin.w_cursor.col = t;
;       @curwin.w_cursor.lnum = @curbuf.b_u_line_lnum;
;       check_cursor_col();
    ))

;; Free all allocated memory blocks for the buffer 'buf'.

(defn- #_void u_blockfree [#_buffer_C buf]
    (§
;       while (buf.b_u_oldhead != null)
;           u_freeheader(buf, buf.b_u_oldhead, null);
;       buf.b_u_line_ptr = null;
    ))

;; Check if the 'modified' flag is set, or 'ff' has changed (only need to
;; check the first character, because it can only be "dos", "unix" or "mac").
;; "nofile" and "scratch" type buffers are considered to always be unchanged.

(defn- #_boolean bufIsChanged [#_buffer_C buf]
    (§
;       return (buf.@b_changed || file_ff_differs(buf, true));
    ))

(defn- #_boolean curbufIsChanged []
    (§
;       return (@curbuf.@b_changed || file_ff_differs(@curbuf, true));
    ))

;;; ============================================================================================== VimV

;; term.c: functions for controlling the terminal -------------------------------------------------
;;
;; NOTE: padding and variable substitution is not performed.

;; Here are the builtin termcap entries.  They are not stored as complete
;; structures with all entries, as such a structure is too big.
;;
;; The entries are compact, therefore they normally are included even when
;; HAVE_TGETENT is defined.  When HAVE_TGETENT is defined, the builtin entries
;; can be accessed with "builtin_ansi", etc.
;;
;; Each termcap is a list of btcap_C structures.  It always starts with KS_NAME,
;; which separates the entries.  See parse_builtin_tcap() for all details.
;; 'bt_key' is either a KS_xxx code (>= 0), or a K_xxx code.
;;
;; Entries marked with "guessed" may be wrong.

(class! #_final btcap_C
    [
        (field int      bt_key)
        (field Bytes    bt_seq)
    ])

;; start of keys that are not directly used by Vim but can be mapped
(final int BT_EXTRA_KEYS   0x101)

;; Request Terminal Version status:
(final int CRV_GET       1)         ;; send T_CRV when switched to RAW mode
(final int CRV_SENT      2)         ;; did send T_CRV, waiting for answer
(final int CRV_GOT       3)         ;; received T_CRV response
(atom! int crv_status CRV_GET)

;; Request Cursor position report:
(final int U7_GET        1)         ;; send T_U7 when switched to RAW mode
(final int U7_SENT       2)         ;; did send T_U7, waiting for answer
(final int U7_GOT        3)         ;; received T_U7 response
(atom! int u7_status U7_GET)

(atom! boolean detected_8bit)   ;; detected 8-bit terminal

(defn- #_final #_btcap_C tcap [#_int key, #_Bytes seq]
    (§
;       return new btcap_C(key, seq);
    ))

(final btcap_C* builtin_termcaps
    [
        ;; standard ANSI terminal, default for unix

        (tcap KS_NAME,      (u8 "ansi")                 ),
        (tcap KS_CE,        (u8 "\033[K")               ),
        (tcap KS_AL,        (u8 "\033[L")               ),
        (tcap KS_CAL,       (u8 "\033[%p1%dL")          ),
        (tcap KS_DL,        (u8 "\033[M")               ),
        (tcap KS_CDL,       (u8 "\033[%p1%dM")          ),
        (tcap KS_CL,        (u8 "\033[H\033[2J")        ),
        (tcap KS_ME,        (u8 "\033[0m")              ),
        (tcap KS_MR,        (u8 "\033[7m")              ),
        (tcap KS_MS,        (u8 "y")                    ),
        (tcap KS_UT,        (u8 "y")                    ),      ;; guessed
        (tcap KS_LE,        (u8 "\b")                   ),
        (tcap KS_CM,        (u8 "\033[%i%p1%d;%p2%dH")  ),
        (tcap KS_CRI,       (u8 "\033[%p1%dC")          ),

        ;; xterm

        (tcap KS_NAME,      (u8 "xterm")                ),
        (tcap KS_CE,        (u8 "\033[K")               ),
        (tcap KS_AL,        (u8 "\033[L")               ),
        (tcap KS_CAL,       (u8 "\033[%p1%dL")          ),
        (tcap KS_DL,        (u8 "\033[M")               ),
        (tcap KS_CDL,       (u8 "\033[%p1%dM")          ),
        (tcap KS_CS,        (u8 "\033[%i%p1%d;%p2%dr")  ),
        (tcap KS_CL,        (u8 "\033[H\033[2J")        ),
        (tcap KS_CD,        (u8 "\033[J")               ),
        (tcap KS_ME,        (u8 "\033[m")               ),
        (tcap KS_MR,        (u8 "\033[7m")              ),
        (tcap KS_MD,        (u8 "\033[1m")              ),
        (tcap KS_UE,        (u8 "\033[m")               ),
        (tcap KS_US,        (u8 "\033[4m")              ),
        (tcap KS_MS,        (u8 "y")                    ),
        (tcap KS_UT,        (u8 "y")                    ),
        (tcap KS_LE,        (u8 "\b")                   ),
        (tcap KS_CM,        (u8 "\033[%i%p1%d;%p2%dH")  ),
        (tcap KS_SR,        (u8 "\033M")                ),
        (tcap KS_CRI,       (u8 "\033[%p1%dC")          ),
        (tcap KS_KS,        (u8 "\033[?1h\033=")        ),
        (tcap KS_KE,        (u8 "\033[?1l\033>")        ),
        (tcap KS_TI,        (u8 "\0337\033[?47h")       ),
        (tcap KS_TE,        (u8 "\033[2J\033[?47l\0338")),
        (tcap KS_CIS,       (u8 "\033]1;")              ),
        (tcap KS_CIE,       (u8 "\007")                 ),
        (tcap KS_TS,        (u8 "\033]2;")              ),
        (tcap KS_FS,        (u8 "\007")                 ),
        (tcap KS_CWS,       (u8 "\033[8;%p1%d;%p2%dt")  ),
        (tcap KS_CWP,       (u8 "\033[3;%p1%d;%p2%dt")  ),
        (tcap KS_CRV,       (u8 "\033[>c")              ),
        (tcap KS_U7,        (u8 "\033[6n")              ),

        (tcap K_UP,         (u8 "\033O*A")              ),
        (tcap K_DOWN,       (u8 "\033O*B")              ),
        (tcap K_RIGHT,      (u8 "\033O*C")              ),
        (tcap K_LEFT,       (u8 "\033O*D")              ),
        ;; An extra set of cursor keys for vt100 mode.
        (tcap K_XUP,        (u8 "\033[1;*A")            ),
        (tcap K_XDOWN,      (u8 "\033[1;*B")            ),
        (tcap K_XRIGHT,     (u8 "\033[1;*C")            ),
        (tcap K_XLEFT,      (u8 "\033[1;*D")            ),
        ;; An extra set of function keys for vt100 mode.
        (tcap K_XF1,        (u8 "\033O*P")              ),
        (tcap K_XF2,        (u8 "\033O*Q")              ),
        (tcap K_XF3,        (u8 "\033O*R")              ),
        (tcap K_XF4,        (u8 "\033O*S")              ),
        (tcap K_F1,         (u8 "\033[11;*~")           ),
        (tcap K_F2,         (u8 "\033[12;*~")           ),
        (tcap K_F3,         (u8 "\033[13;*~")           ),
        (tcap K_F4,         (u8 "\033[14;*~")           ),
        (tcap K_F5,         (u8 "\033[15;*~")           ),
        (tcap K_F6,         (u8 "\033[17;*~")           ),
        (tcap K_F7,         (u8 "\033[18;*~")           ),
        (tcap K_F8,         (u8 "\033[19;*~")           ),
        (tcap K_F9,         (u8 "\033[20;*~")           ),
        (tcap K_F10,        (u8 "\033[21;*~")           ),
        (tcap K_F11,        (u8 "\033[23;*~")           ),
        (tcap K_F12,        (u8 "\033[24;*~")           ),
        (tcap K_S_TAB,      (u8 "\033[Z")               ),
        (tcap K_HELP,       (u8 "\033[28;*~")           ),
        (tcap K_UNDO,       (u8 "\033[26;*~")           ),
        (tcap K_INS,        (u8 "\033[2;*~")            ),
        (tcap K_HOME,       (u8 "\033[1;*H")            ),
     ;; (tcap K_S_HOME,     (u8 "\033O2H")              ),
     ;; (tcap K_C_HOME,     (u8 "\033O5H")              ),
        (tcap K_KHOME,      (u8 "\033[1;*~")            ),
        (tcap K_XHOME,      (u8 "\033O*H")              ),      ;; other Home
        (tcap K_ZHOME,      (u8 "\033[7;*~")            ),      ;; other Home
        (tcap K_END,        (u8 "\033[1;*F")            ),
     ;; (tcap K_S_END,      (u8 "\033O2F")              ),
     ;; (tcap K_C_END,      (u8 "\033O5F")              ),
        (tcap K_KEND,       (u8 "\033[4;*~")            ),
        (tcap K_XEND,       (u8 "\033O*F")              ),      ;; other End
        (tcap K_ZEND,       (u8 "\033[8;*~")            ),
        (tcap K_PAGEUP,     (u8 "\033[5;*~")            ),
        (tcap K_PAGEDOWN,   (u8 "\033[6;*~")            ),
        (tcap K_KPLUS,      (u8 "\033O*k")              ),      ;; keypad plus
        (tcap K_KMINUS,     (u8 "\033O*m")              ),      ;; keypad minus
        (tcap K_KDIVIDE,    (u8 "\033O*o")              ),      ;; keypad /
        (tcap K_KMULTIPLY,  (u8 "\033O*j")              ),      ;; keypad *
        (tcap K_KENTER,     (u8 "\033O*M")              ),      ;; keypad Enter
        (tcap K_KPOINT,     (u8 "\033O*n")              ),      ;; keypad .
        (tcap K_KDEL,       (u8 "\033[3;*~")            ),      ;; keypad Del

        (tcap BT_EXTRA_KEYS, (u8 "")                    ),

        (tcap K_F0,         (u8 "\033[10;*~")           ),
        (tcap K_F13,        (u8 "\033[25;*~")           ),
        ;; F14 and F15 are missing, because they send the same codes as the undo and help key,
        ;; although they don't work on all keyboards.
        (tcap K_F16,        (u8 "\033[29;*~")           ),
        (tcap K_F17,        (u8 "\033[31;*~")           ),
        (tcap K_F18,        (u8 "\033[32;*~")           ),
        (tcap K_F19,        (u8 "\033[33;*~")           ),
        (tcap K_F20,        (u8 "\033[34;*~")           ),

        (tcap K_F21,        (u8 "\033[42;*~")           ),
        (tcap K_F22,        (u8 "\033[43;*~")           ),
        (tcap K_F23,        (u8 "\033[44;*~")           ),
        (tcap K_F24,        (u8 "\033[45;*~")           ),
        (tcap K_F25,        (u8 "\033[46;*~")           ),
        (tcap K_F26,        (u8 "\033[47;*~")           ),
        (tcap K_F27,        (u8 "\033[48;*~")           ),
        (tcap K_F28,        (u8 "\033[49;*~")           ),
        (tcap K_F29,        (u8 "\033[50;*~")           ),
        (tcap K_F30,        (u8 "\033[51;*~")           ),

        (tcap K_F31,        (u8 "\033[52;*~")           ),
        (tcap K_F32,        (u8 "\033[53;*~")           ),
        (tcap K_F33,        (u8 "\033[54;*~")           ),
        (tcap K_F34,        (u8 "\033[55;*~")           ),
        (tcap K_F35,        (u8 "\033[56;*~")           ),
        (tcap K_F36,        (u8 "\033[57;*~")           ),
        (tcap K_F37,        (u8 "\033[58;*~")           ),

        ;; The most minimal terminal: only clear screen and cursor positioning; always included.

        (tcap KS_NAME,      (u8 "dumb")                 ),
        (tcap KS_CL,        (u8 "\014")                 ),
        (tcap KS_CM,        (u8 "\033[%i%p1%d;%p2%dH")  ),

        ;; end marker

        (tcap KS_NAME,      null                        )
    ])

;; DEFAULT_TERM is used, when no terminal is specified with -T option or $TERM.

(final Bytes DEFAULT_TERM (u8 "ansi"))

(atom! boolean need_gather)                     ;; need to fill termleader[]
(final Bytes termleader (Bytes. (inc 256)))     ;; for check_termcode()
(atom! boolean check_for_codes)                 ;; check for key code response

(defn- #_int find_builtin_term [#_Bytes term]
    (§
;       if (vim_is_xterm(term))
;           term = u8("xterm");

;       btcap_C[] bts = builtin_termcaps;
;       for (int i = 0; bts[i].bt_seq != null; i++)
;           if (bts[i].bt_key == KS_NAME && STRCMP(bts[i].bt_seq, term) == 0)
;               return i;

;       return -1;
    ))

;; Parsing of the builtin termcap entries.
;; Caller should check if 'name' is a valid builtin term.
;; The terminal's name is not set, as this is already done in termcapinit().

(defn- #_void parse_builtin_tcap [#_Bytes term]
    (§
;       btcap_C[] bts = builtin_termcaps;
;       int i = find_builtin_term(term);
;       if (i < 0)
;           return;

;       boolean term_8bit = term_is_8bit(term);

;       for (++i; bts[i].bt_key != KS_NAME && bts[i].bt_key != BT_EXTRA_KEYS; i++)
;       {
;           if (bts[i].bt_key < 0)
;           {
;               Bytes name = new Bytes(2);
;               name.be(0, KEY2TERMCAP0(bts[i].bt_key));
;               name.be(1, KEY2TERMCAP1(bts[i].bt_key));

;               if (find_termcode(name) == null)
;                   add_termcode(name, bts[i].bt_seq, term_8bit ? TRUE : FALSE);
;           }
;           else ;; KS_xx entry
;           {
                ;; Only set the value if it wasn't set yet.
;               if (term_strings[bts[i].bt_key][0] == null || term_strings[bts[i].bt_key][0] == EMPTY_OPTION)
;               {
                    ;; 8bit terminal: use CSI instead of <Esc>[
;                   if (term_8bit && term_7to8bit(bts[i].bt_seq) != NUL)
;                   {
;                       Bytes s = STRDUP(bts[i].bt_seq);
;                       for (Bytes t = s; t.at(0) != NUL; t = t.plus(1))
;                       {
;                           byte b = term_7to8bit(t);
;                           if (b != NUL)
;                           {
;                               t.be(0, b);
;                               STRCPY(t.plus(1), t.plus(2));
;                           }
;                       }
;                       term_strings[bts[i].bt_key][0] = s;
;                   }
;                   else
;                       term_strings[bts[i].bt_key][0] = bts[i].bt_seq;
;               }
;           }
;       }
    ))

;; Set number of colors.
;; Store it as a number in t_colors.
;; Store it as a string in T_CCO (using nr_colors[]).

(defn- #_void set_color_count [#_int nr]
    (§
;       @t_colors = nr;

;       Bytes nr_colors = new Bytes(20);
;       if (1 < @t_colors)
;           libC.sprintf(nr_colors, u8("%d"), @t_colors);
;       else
;           nr_colors.be(0, NUL);

;       set_string_option_direct(u8("t_Co"), -1, nr_colors, OPT_FREE);
    ))

(final Bytes* key_names
    [
        ;; Do this one first, it may cause a screen redraw.
        (u8 "Co"),
        (u8 "ku"), (u8 "kd"), (u8 "kr"), (u8 "kl"),
        (u8 "#2"), (u8 "#4"), (u8 "%i"), (u8 "*7"),
        (u8 "k1"), (u8 "k2"), (u8 "k3"), (u8 "k4"), (u8 "k5"), (u8 "k6"),
        (u8 "k7"), (u8 "k8"), (u8 "k9"), (u8 "k;"), (u8 "F1"), (u8 "F2"),
        (u8 "%1"), (u8 "&8"), (u8 "kb"), (u8 "kI"), (u8 "kD"), (u8 "kh"),
        (u8 "@7"), (u8 "kP"), (u8 "kN"), (u8 "K1"), (u8 "K3"), (u8 "K4"), (u8 "K5"), (u8 "kB"),
        null
    ])

(class! #_final tcname_C
    [
        (field int      dest)       ;; index in term_strings[]
        (field Bytes    name)       ;; termcap name for string
    ])

(defn- #_final #_tcname_C tcname [#_int dest, #_Bytes name]
    (§
;       return new tcname_C(dest, name);
    ))

(final tcname_C* tcap_names
    [
        (tcname KS_CE,  (u8 "ce")), (tcname KS_AL,  (u8 "al")), (tcname KS_CAL, (u8 "AL")),
        (tcname KS_DL,  (u8 "dl")), (tcname KS_CDL, (u8 "DL")), (tcname KS_CS,  (u8 "cs")),
        (tcname KS_CL,  (u8 "cl")), (tcname KS_CD,  (u8 "cd")),
        (tcname KS_VI,  (u8 "vi")), (tcname KS_VE,  (u8 "ve")), (tcname KS_MB,  (u8 "mb")),
        (tcname KS_VS,  (u8 "vs")), (tcname KS_ME,  (u8 "me")), (tcname KS_MR,  (u8 "mr")),
        (tcname KS_MD,  (u8 "md")), (tcname KS_SE,  (u8 "se")), (tcname KS_SO,  (u8 "so")),
        (tcname KS_CZH, (u8 "ZH")), (tcname KS_CZR, (u8 "ZR")), (tcname KS_UE,  (u8 "ue")),
        (tcname KS_US,  (u8 "us")), (tcname KS_UCE, (u8 "Ce")), (tcname KS_UCS, (u8 "Cs")),
        (tcname KS_CM,  (u8 "cm")), (tcname KS_SR,  (u8 "sr")),
        (tcname KS_CRI, (u8 "RI")), (tcname KS_VB,  (u8 "vb")), (tcname KS_KS,  (u8 "ks")),
        (tcname KS_KE,  (u8 "ke")), (tcname KS_TI,  (u8 "ti")), (tcname KS_TE,  (u8 "te")),
        (tcname KS_BC,  (u8 "bc")), (tcname KS_CSB, (u8 "Sb")), (tcname KS_CSF, (u8 "Sf")),
        (tcname KS_CAB, (u8 "AB")), (tcname KS_CAF, (u8 "AF")), (tcname KS_LE,  (u8 "le")),
        (tcname KS_ND,  (u8 "nd")), (tcname KS_OP,  (u8 "op")), (tcname KS_CRV, (u8 "RV")),
        (tcname KS_CIS, (u8 "IS")), (tcname KS_CIE, (u8 "IE")),
        (tcname KS_TS,  (u8 "ts")), (tcname KS_FS,  (u8 "fs")),
        (tcname KS_CWP, (u8 "WP")), (tcname KS_CWS, (u8 "WS")),
        (tcname KS_CSI, (u8 "SI")), (tcname KS_CEI, (u8 "EI")),
        (tcname KS_U7,  (u8 "u7"))
    ])

;; Set terminal options for terminal "term".
;; Return true if terminal 'term' was found in a termcap, false otherwise.
;;
;; While doing this, until ttest(), some options may be null, be careful.

(defn- #_boolean set_termname [#_Bytes term]
    (§
        ;; In silent mode (ex -s) we don't use the 'term' option.
;       if (@silent_mode)
;           return true;

;       @detected_8bit = false;                  ;; reset 8-bit detection

;       if (STRNCMP(term, u8("builtin_"), 8) == 0)
;           term = term.plus(8);

        ;; If HAVE_TGETENT is not defined, only the builtin termcap is used.

;       {
;           if (find_builtin_term(term) < 0)
;           {
;               libC.fprintf(stderr, u8("\r\n"));
;               libC.fprintf(stderr, u8("'%s' not known. Available builtin terminals are:\r\n"), term);
;               btcap_C[] bts = builtin_termcaps;
;               for (int i = 0; bts[i].bt_seq != null; i++)
;               {
;                   if (bts[i].bt_key == KS_NAME)
;                       libC.fprintf(stderr, u8("    builtin_%s\r\n"), bts[i].bt_seq);
;               }
                ;; when user typed :set term=xxx, quit here
;               if (@starting != NO_SCREEN)
;               {
;                   screen_start();         ;; don't know where cursor is now
;                   wait_return(TRUE);
;                   return false;
;               }
;               term = DEFAULT_TERM;
;               libC.fprintf(stderr, u8("defaulting to '%s'\r\n"), term);
;               if (@emsg_silent == 0)
;               {
;                   screen_start();         ;; don't know where cursor is now
;                   out_flush();
;                   ui_delay(2000L, true);
;               }
;               set_string_option_direct(u8("term"), -1, term, OPT_FREE);
;               libc.fflush(stderr);
;           }
;           out_flush();
;           clear_termoptions();            ;; clear old options
;           parse_builtin_tcap(term);
;       }

        ;; special: There is no info in the termcap about whether the cursor positioning
        ;; is relative to the start of the screen or to the start of the scrolling region.
        ;; We just guess here.  Only msdos pcterm is known to do it relative.

;       if (STRCMP(term, u8("pcterm")) == 0)
;           @T_CCS = u8("yes");
;       else
;           @T_CCS = EMPTY_OPTION;

        ;; Any "stty" settings override the default for t_kb from the termcap.
        ;; Don't do this when the GUI is active, it uses "t_kb" and "t_kD" directly.

;       get_stty();

        ;; If the termcap has no entry for 'bs' and/or 'del' and the ioctl()
        ;; also didn't work, use the default CTRL-H.
        ;; The default for t_kD is DEL, unless t_kb is DEL.
        ;; The vim_strsave'd strings are probably lost forever, well it's only two bytes.
        ;; Don't do this when the GUI is active, it uses "t_kb" and "t_kD" directly.

;       Bytes bs_p = find_termcode(u8("kb"));
;       if (bs_p == null || bs_p.at(0) == NUL)
;           add_termcode(u8("kb"), (bs_p = CTRL_H_STR), FALSE);
;       Bytes del_p = find_termcode(u8("kD"));
;       if ((del_p == null || del_p.at(0) == NUL) && (bs_p == null || bs_p.at(0) != DEL))
;           add_termcode(u8("kD"), DEL_STR, FALSE);

;       @term_is_xterm = vim_is_xterm(term);

        ;; For Unix, set the 'ttymouse' option to the type of mouse to be used.
        ;; The termcode for the mouse is added as a side effect in option.c.

;       {
;           clip_init(false);

;           Bytes ttym;
;           if (use_xterm_like_mouse(term))
;           {
;               if (use_xterm_mouse() != 0)
;                   ttym = null;        ;; keep existing value, might be "xterm2"
;               else
;                   ttym = u8("xterm");
;           }
;           else
;               ttym = u8("");

;           if (ttym != null)
;           {
;               set_option_value(u8("ttym"), 0L, ttym, 0);
                ;; Reset the WAS_SET flag, 'ttymouse' can be set to "xterm2" in check_termcode().
;               reset_option_was_set(u8("ttym"));
;           }
;           else
;               check_mouse_termcode();     ;; set mouse termcode anyway
;       }

        ;; 'ttyfast' is default on for xterm and a few others.

;       if (vim_is_fastterm(term))
;           @p_tf = true;

;       ttest(true);                ;; make sure we have a valid set of terminal codes

;       @full_screen = true;             ;; we can use termcap codes from now on
;       set_term_defaults();            ;; use current values as defaults
;       @crv_status = CRV_GET;           ;; get terminal version later

        ;; Initialize the terminal with the appropriate termcap codes.
        ;; Set the mouse and window title if possible.
        ;; Don't do this when starting, need to parse the .vimrc first,
        ;; because it may redefine t_TI etc.

;       if (@starting != NO_SCREEN)
;       {
;           starttermcap();             ;; may change terminal mode
;           setmouse();                 ;; may start using the mouse
;       }

;       int width = 80, height = 24;    ;; most terminals are 24 lines

;       set_shellsize(width, height, false);    ;; may change Rows

;       if (@starting != NO_SCREEN)
;       {
;           if (@scroll_region)
;               scroll_region_reset();          ;; in case Rows changed

;           check_map_keycodes();       ;; check mappings for terminal codes used
;       }

;       may_req_termresponse();

;       return true;
    ))

(atom! boolean has_mouse_termcode)

(defn- #_void set_mouse_termcode [#_byte n, #_Bytes s]
    ;; n: KS_MOUSE
    (§
;       Bytes name = new Bytes(2);

;       name.be(0, n);
;       name.be(1, KE_FILLER);
;       add_termcode(name, s, FALSE);
;       @has_mouse_termcode = true;
    ))

(defn- #_void del_mouse_termcode [#_byte n]
    ;; n: KS_MOUSE
    (§
;       Bytes name = new Bytes(2);

;       name.be(0, n);
;       name.be(1, KE_FILLER);
;       del_termcode(name);
;       @has_mouse_termcode = false;
    ))

;; Get a string entry from the termcap and add it to the list of termcodes.
;; Used for <t_xx> special keys.
;; Give an error message for failure when not sourcing.
;; If force given, replace an existing entry.
;; Return false if the entry was not found, true if the entry was added.

(defn- #_boolean add_termcap_entry [#_Bytes name, #_boolean force]
    (§
;       if (!force && find_termcode(name) != null)      ;; it's already there
;           return true;

;       Bytes term = @T_NAME;
;       if (term == null || term.at(0) == NUL)          ;; 'term' not defined yet
;           return false;

;       if (STRNCMP(term, u8("builtin_"), 8) == 0)
;           term = term.plus(8);

        ;; Search in builtin termcap.

;       btcap_C[] bts = builtin_termcaps;
;       int i = find_builtin_term(term);
;       if (0 <= i)
;       {
;           int key = TERMCAP2KEY(name.at(0), name.at(1));

;           for (++i; bts[i].bt_key != KS_NAME; i++)
;               if (bts[i].bt_key == key)
;               {
;                   add_termcode(name, bts[i].bt_seq, term_is_8bit(term) ? TRUE : FALSE);
;                   return true;
;               }
;       }

;       emsg2(u8("E436: No \"%s\" entry in termcap"), name);

;       return false;
    ))

;; Return true if terminal "name" uses CSI instead of <Esc>[.
;; Assume that the terminal is using 8-bit controls when the name contains "8bit", like in "xterm-8bit".

(defn- #_boolean term_is_8bit [#_Bytes name]
    (§
;       return (@detected_8bit || STRSTR(name, u8("8bit")) != null);
    ))

;; Translate terminal control chars from 7-bit to 8-bit:
;; <Esc>[ -> CSI
;; <Esc>] -> <M-C-]>
;; <Esc>O -> <M-C-O>

(defn- #_byte term_7to8bit [#_Bytes p]
    (§
;       if (p.at(0) == ESC)
;           switch (p.at(1))
;           {
;               case '[': return CSI;
;               case ']': return (byte)0x9d;
;               case 'O': return (byte)0x8f;
;           }
;       return NUL;
    ))

;; Set the terminal name and initialize the terminal options.
;; If "name" is null or empty, get the terminal name from the environment.
;; If that fails, use the default terminal name.

(defn- #_void termcapinit [#_Bytes name]
    (§
;       if (name != null && name.at(0) == NUL)
;           name = null;        ;; empty name is equal to no name

;       Bytes term = name;
;       if (term == null)
;           term = libC.getenv(u8("TERM"));
;       if (term == null || term.at(0) == NUL)
;           term = DEFAULT_TERM;

;       set_string_option_direct(u8("term"), -1, term, OPT_FREE);

        ;; Set the default terminal name.
;       set_string_default(u8("term"), term);

        ;; Avoid using "term" here, because the next mch_getenv() may overwrite it.

;       set_termname(@T_NAME != null ? @T_NAME : term);
    ))

;; the number of calls to ui_write is reduced by using the buffer "out_buf"

(final int OUT_SIZE      2047)

(final Bytes out_buf (Bytes. (inc OUT_SIZE)))
(atom! int out_pos)         ;; number of chars in "out_buf"

;; out_flush(): flush the output buffer

(defn- #_void out_flush []
    (§
;       if (@out_pos != 0)
;       {
            ;; set out_pos to 0 before ui_write, to avoid recursiveness
;           int len = @out_pos;
;           @out_pos = 0;
;           ui_write(out_buf, len);
;       }
    ))

;; Sometimes a byte out of a multi-byte character is written with out_char().
;; To avoid flushing half of the character, call this function first.

(defn- #_void out_flush_check []
    (§
    ))

;; out_char(c): put a byte into the output buffer.
;;              Flush it if it becomes full.
;; This should not be used for outputting text on the screen
;; (use functions like msg_puts() and screen_putchar() for that).

(defn- #_void out_char [#_byte c]
    (§
;       if (c == '\n')      ;; turn LF into CR-LF (CRMOD doesn't seem to do this)
;           out_char((byte)'\r');

;       out_buf.be(@out_pos++, c);

        ;; For testing we flush each time.
;       if (OUT_SIZE <= @out_pos || @p_wd != 0)
;           out_flush();
    ))

;; out_char_nf(c): like out_char(), but don't flush when "p_wd" is set

(defn- #_void out_char_nf [#_byte c]
    (§
;       if (c == '\n')      ;; turn LF into CR-LF (CRMOD doesn't seem to do this)
;           out_char_nf((byte)'\r');

;       out_buf.be(@out_pos++, c);

;       if (OUT_SIZE <= @out_pos)
;           out_flush();
    ))

(defn- #_Bytes _addfmt [#_Bytes buf, #_Bytes fmt, #_int val]
    (§
;       libC.sprintf(buf, fmt, val);
;       while (buf.at(0) != NUL)
;           buf = buf.plus(1);
;       return buf;
    ))

(final Bytes tgoto_UP)	;; %% nada!
(final Bytes tgoto_BC)	;; %% nada!
(final Bytes tgoto_buffer (Bytes. 32))

;; Decode cm cursor motion string.
;; cm is cursor motion string, row and col are the desired destination.
;; Returns a pointer to the decoded string, or "OOPS" if it cannot be decoded.
;;
;; Accepted escapes are:
;;      %d       as in printf, 0 origin.
;;      %2, %3   like %02d, %03d in printf.
;;      %.       like %c
;;      %+x      adds <x> to value, then %.
;;      %>xy     if value > x, adds y. No output.
;;      %i       increments row & col. No output.
;;      %r       reverses order of row & col. No output.
;;      %%       prints as a single %.
;;      %n       exclusive or row & col with 0140.
;;      %B       BCD, no output.
;;      %D       reverse coding (x-2*(x%16)), no output.

(defn- #_Bytes _tgoto [#_Bytes cm, #_int col, #_int row]
    ;; cm: string, from termcap
    ;; col: x position
    ;; row: y position
    (§
;       if (cm == null)
;           return u8("OOPS");                          ;; kludge, but standard

;       boolean reverse = false;                    ;; reverse flag
;       boolean addup = false;                      ;; add upline
;       boolean addbak = false;                     ;; add backup

;       Bytes p = tgoto_buffer;                    ;; pointer in returned string

;       while (cm.at(0) != NUL)
;       {
;           byte b = (cm = cm.plus(1)).at(-1);
;           if (b != '%')                           ;; normal char
;           {
;               (p = p.plus(1)).be(-1, b);
;               continue;
;           }

;           b = (cm = cm.plus(1)).at(-1);
;           switch (b)                              ;; % escape
;           {
;               case 'd':                           ;; decimal
;                   p = _addfmt(p, u8("%d"), row);
;                   row = col;
;                   break;

;               case '2':                           ;; 2 digit decimal
;                   p = _addfmt(p, u8("%02d"), row);
;                   row = col;
;                   break;

;               case '3':                           ;; 3 digit decimal
;                   p = _addfmt(p, u8("%03d"), row);
;                   row = col;
;                   break;

;               case '>':                           ;; %>xy: if >x, add y
;               {
;                   byte x = (cm = cm.plus(1)).at(-1), y = (cm = cm.plus(1)).at(-1);
;                   if (col > x)
;                       col += y;
;                   if (row > x)
;                       row += y;
;                   break;
;               }

;               case '+':                           ;; %+c: add c
;                   row += (cm = cm.plus(1)).at(-1);

;               case '.':                           ;; print x/y
;                   if (row == '\t'                 ;; these are
;                    || row == '\n'                 ;; chars that
;                    || row == '\004'               ;; UNIX hates
;                    || row == '\000')
;                   {
;                       row++;                      ;; so go to next pos
;                       if (reverse == (row == col))
;                           addup = true;           ;; and mark UP
;                       else
;                           addbak = true;          ;; or BC
;                   }
;                   (p = p.plus(1)).be(-1, row);
;                   row = col;
;                   break;

;               case 'r':                           ;; r: reverse
;               {
;                   int r = row;
;                   row = col;
;                   col = r;
;                   reverse = true;
;                   break;
;               }

;               case 'i':                           ;; increment (1-origin screen)
;                   col++;
;                   row++;
;                   break;

;               case '%':                           ;; %%=% literally
;                   (p = p.plus(1)).be(-1, (byte)'%');
;                   break;

;               case 'n':                           ;; magic DM2500 code
;                   row ^= 0140;
;                   col ^= 0140;
;                   break;

;               case 'B':                           ;; bcd encoding
;                   row = ((row / 10) << 4) + (row % 10);
;                   col = ((col / 10) << 4) + (col % 10);
;                   break;

;               case 'D':                           ;; magic Delta Data code
;                   row -= 2 * (row & 15);
;                   col -= 2 * (col & 15);
;                   break;

;               case 'p':                           ;; so, what?
;               {
;                   byte d = (cm = cm.plus(1)).at(-1);
;                   if (d == '1' || d == '2')       ;; ignore %p1 and %p2
;                       break;
                    ;; FALLTHROUGH
;               }

;               default:                            ;; unknown escape
;                   return u8("OOPS");
;           }
;       }

;       if (addup)                                  ;; add upline
;       {
;           if (tgoto_UP != null)
;           {
;               cm = tgoto_UP;
;               while (asc_isdigit(cm.at(0)) || cm.at(0) == (byte)'.')
;                   cm = cm.plus(1);
;               if (cm.at(0) == (byte)'*')
;                   cm = cm.plus(1);
;               while (cm.at(0) != NUL)
;                   (p = p.plus(1)).be(-1, (cm = cm.plus(1)).at(-1));
;           }
;       }

;       if (addbak)                                 ;; add backspace
;       {
;           if (tgoto_BC != null)
;           {
;               cm = tgoto_BC;
;               while (asc_isdigit(cm.at(0)) || cm.at(0) == (byte)'.')
;                   cm = cm.plus(1);
;               if (cm.at(0) == (byte)'*')
;                   cm = cm.plus(1);
;               while (cm.at(0) != NUL)
;                   (p = p.plus(1)).be(-1, (cm = cm.plus(1)).at(-1));
;           }
;           else
;               (p = p.plus(1)).be(-1, (byte)'\b');
;       }

;       p.be(0, NUL);

;       return tgoto_buffer;
    ))

;; Note: "s" may have padding information ahead of it, in the form of nnnTEXT or nnn*TEXT.
;;  nnn is the number of milliseconds to delay, and may be a decimal fraction (nnn.mmm).
;;  In case an asterisk is given, the delay is to be multiplied by "_affcnt".

(defn- #_int _tputs [#_Bytes s, #_int _affcnt]
    ;; s: string to print
    ;; affcnt: number of lines affected
    (§
;       int i = 0;

;       if (asc_isdigit(s.at(i)))
;       {
;           while (asc_isdigit(s.at(++i)))
            ;
;           if (s.at(i) == (byte)'.')
;               while (asc_isdigit(s.at(++i)))
                ;
;           if (s.at(i) == (byte)'*')
;               i++;
;       }

;       while (s.at(i) != NUL)
;           out_char_nf(s.at(i++));

;       return 0;
    ))

;; A never-padding out_str:
;; use this whenever you don't want to run the string through tputs.
;; tputs above is harmless,
;; but tputs from the termcap library is likely to strip off leading digits,
;; that it mistakes for padding information, and "%i", "%d", etc.
;; This should only be used for writing terminal codes, not for outputting
;; normal text: use functions like msg_puts() and screen_putchar() for that.

(defn- #_void out_str_nf [#_Bytes s]
    (§
;       if (OUT_SIZE - 20 < @out_pos)    ;; avoid terminal strings being split up
;           out_flush();

;       for (int i = 0; s.at(i) != NUL; )
;           out_char_nf(s.at(i++));

        ;; For testing we write one string at a time.
;       if (@p_wd != 0)
;           out_flush();
    ))

;; out_str(s): Put a character string a byte at a time into the output buffer.
;; This should only be used for writing terminal codes, not for outputting
;; normal text: use functions like msg_puts() and screen_putchar() for that.

(defn- #_void out_str [#_Bytes s]
    (§
;       if (s != null && s.at(0) != NUL)
;       {
            ;; avoid terminal strings being split up
;           if (OUT_SIZE - 20 < @out_pos)
;               out_flush();

;           _tputs(s, 1);

            ;; For testing we write one string at a time.
;           if (@p_wd != 0)
;               out_flush();
;       }
    ))

;; cursor positioning using termcap parser

(defn- #_void term_windgoto [#_int row, #_int col]
    (§
;       out_str(_tgoto(@T_CM, col, row));
    ))

(defn- #_void term_cursor_right [#_int i]
    (§
;       out_str(_tgoto(@T_CRI, 0, i));
    ))

(defn- #_void term_append_lines [#_int line_count]
    (§
;       out_str(_tgoto(@T_CAL, 0, line_count));
    ))

(defn- #_void term_delete_lines [#_int line_count]
    (§
;       out_str(_tgoto(@T_CDL, 0, line_count));
    ))

(defn- #_void term_set_winpos [#_int x, #_int y]
    (§
        ;; Can't handle a negative value here.
;       if (x < 0)
;           x = 0;
;       if (y < 0)
;           y = 0;
;       out_str(_tgoto(@T_CWP, y, x));
    ))

(defn- #_void term_set_winsize [#_int width, #_int height]
    (§
;       out_str(_tgoto(@T_CWS, height, width));
    ))

(defn- #_void term_fg_color [#_int n]
    (§
        ;; Use "AF" termcap entry if present, "Sf" entry otherwise.
;       if (@T_CAF.at(0) != NUL)
;           term_color(@T_CAF, n);
;       else if (@T_CSF.at(0) != NUL)
;           term_color(@T_CSF, n);
    ))

(defn- #_void term_bg_color [#_int n]
    (§
        ;; Use "AB" termcap entry if present, "Sb" entry otherwise.
;       if (@T_CAB.at(0) != NUL)
;           term_color(@T_CAB, n);
;       else if (@T_CSB.at(0) != NUL)
;           term_color(@T_CSB, n);
    ))

(defn- #_void term_color [#_Bytes s, #_int n]
    (§
;       int i = 2;  ;; index in s[] just after <Esc>[ or CSI

        ;; Special handling of 16 colors, because termcap can't handle it.
        ;; Also accept "\e[3%dm" for TERMINFO, it is sometimes used.
        ;; Also accept CSI instead of <Esc>[.
;       if (8 <= n && 16 <= @t_colors
;                 && ((s.at(0) == ESC && s.at(1) == (byte)'[') || (s.at(0) == CSI && (i = 1) == 1))
;                 && s.at(i) != NUL
;                 && (STRCMP(s.plus(i + 1), u8("%p1%dm")) == 0 || STRCMP(s.plus(i + 1), u8("%dm")) == 0)
;                 && (s.at(i) == (byte)'3' || s.at(i) == (byte)'4'))
;       {
;           Bytes buf = new Bytes(20);
;           libC.sprintf(buf, u8("%s%s%%p1%%dm"),
;                           (i == 2) ? u8("\033[") : u8("\233"),
;                           (s.at(i) == (byte)'3') ? (16 <= n ? u8("38;5;") : u8("9")) : (16 <= n ? u8("48;5;") : u8("10")));
;           s = buf;
;           n = (16 <= n) ? n : n - 8;
;       }

;       out_str(_tgoto(s, 0, n));
    ))

;; Make sure we have a valid set or terminal options.
;; Replace all entries that are null by EMPTY_OPTION.

(defn- #_void ttest [#_boolean pairs]
    (§
;       check_options();            ;; make sure no options are null

        ;; MUST have "cm": cursor motion.

;       if (@T_CM.at(0) == NUL)
;           emsg(u8("E437: terminal capability \"cm\" required"));

        ;; If "cs" defined, use a scroll region, it's faster.

;       @scroll_region = (@T_CS.at(0) != NUL);

        ;; optional pairs

;       if (pairs)
;       {
            ;; TP goes to normal mode for TI (invert) and TB (bold).
;           if (@T_ME.at(0) == NUL)
;               @T_ME = @T_MR = @T_MD = @T_MB = EMPTY_OPTION;
;           if (@T_SO.at(0) == NUL || @T_SE.at(0) == NUL)
;               @T_SO = @T_SE = EMPTY_OPTION;
;           if (@T_US.at(0) == NUL || @T_UE.at(0) == NUL)
;               @T_US = @T_UE = EMPTY_OPTION;
;           if (@T_CZH.at(0) == NUL || @T_CZR.at(0) == NUL)
;               @T_CZH = @T_CZR = EMPTY_OPTION;

            ;; T_VE is needed even though T_VI is not defined.
;           if (@T_VE.at(0) == NUL)
;               @T_VI = EMPTY_OPTION;

            ;; If 'mr' or 'me' is not defined use 'so' and 'se'.
;           if (@T_ME.at(0) == NUL)
;           {
;               @T_ME = @T_SE;
;               @T_MR = @T_MD = @T_SO;
;           }

            ;; If 'so' or 'se' is not defined use 'mr' and 'me'.
;           if (@T_SO.at(0) == NUL)
;           {
;               @T_SE = @T_ME;
;               @T_SO = (@T_MR.at(0) == NUL) ? @T_MD : @T_MR;
;           }

            ;; If 'ZH' or 'ZR' is not defined use 'mr' and 'me'.
;           if (@T_CZH.at(0) == NUL)
;           {
;               @T_CZR = @T_ME;
;               @T_CZH = (@T_MR.at(0) == NUL) ? @T_MD : @T_MR;
;           }

            ;; "Sb" and "Sf" come in pairs.
;           if (@T_CSB.at(0) == NUL || @T_CSF.at(0) == NUL)
;           {
;               @T_CSB = EMPTY_OPTION;
;               @T_CSF = EMPTY_OPTION;
;           }

            ;; "AB" and "AF" come in pairs.
;           if (@T_CAB.at(0) == NUL || @T_CAF.at(0) == NUL)
;           {
;               @T_CAB = EMPTY_OPTION;
;               @T_CAF = EMPTY_OPTION;
;           }

            ;; If 'Sb' and 'AB' are not defined, reset "Co".
;           if (@T_CSB.at(0) == NUL && @T_CAB.at(0) == NUL)
;               free_one_termoption(T_CCO);
;       }

;       @need_gather = true;

        ;; Set t_colors to the value of t_Co.
;       @t_colors = libC.atoi(@T_CCO);
    ))

;; Read the next num_bytes bytes from buf, and store them in bytes.
;; Assume that buf has been through inchar().
;; Returns the actual number of bytes used from buf (between num_bytes and num_bytes*2),
;; or -1 if not enough bytes were available.

(defn- #_int get_bytes_from_buf [#_Bytes buf, #_Bytes bytes, #_int num_bytes]
    (§
;       int len = 0;

;       for (int i = 0; i < num_bytes; i++)
;       {
;           byte b = buf.at(len++);

;           if (b == NUL)
;               return -1;
;           if (b == KB_SPECIAL)
;           {
;               if (buf.at(len) == NUL || buf.at(len + 1) == NUL)     ;; cannot happen?
;                   return -1;
;               if (buf.at(len++) == KS_ZERO)
;                   b = NUL;
                ;; else it should be KS_SPECIAL; when followed by KE_FILLER
                ;; b is KB_SPECIAL, or followed by KE_CSI and b must be CSI.
;               if (buf.at(len++) == KE_CSI)
;                   b = CSI;
;           }
;           else if (b == CSI && buf.at(len) == KS_EXTRA && buf.at(len + 1) == KE_CSI)
                ;; CSI is stored as CSI KS_SPECIAL KE_CSI to avoid confusion
                ;; with the start of a special key.
;               len += 2;

;           bytes.be(i, b);
;       }

;       return len;
    ))

;; Check if the new shell size is valid, correct it if it's too small or way too big.

(defn- #_void check_shellsize []
    (§
;       int min = min_rows();
;       if (@Rows < min)         ;; need room for one window and command line
;           @Rows = min;
;       limit_screen_size();
    ))

;; Limit Rows and Columns to avoid an overflow in Rows * Columns.

(defn- #_void limit_screen_size []
    (§
;       if (@Columns < MIN_COLUMNS)
;           @Columns = MIN_COLUMNS;
;       else if (10000 < @Columns)
;           @Columns = 10000;

;       if (1000 < @Rows)
;           @Rows = 1000;
    ))

(atom! long old__Rows)
(atom! long old__Columns)

;; Invoked just before the screen structures are going to be (re)allocated.

(defn- #_void win_new_shellsize []
    (§
;       if (@old__Rows != @Rows || @old__Columns != @Columns)
;           ui_new_shellsize();
;       if (@old__Rows != @Rows)
;       {
            ;; if 'window' uses the whole screen, keep it using that
;           if (@p_window == @old__Rows - 1 || @old__Rows == 0)
;               @p_window = @Rows - 1;
;           @old__Rows = @Rows;
;           shell_new_rows();       ;; update window sizes
;       }
;       if (@old__Columns != @Columns)
;       {
;           @old__Columns = @Columns;
;           shell_new_columns();    ;; update window sizes
;       }
    ))

;; Call this function when the Vim shell has been resized in any way.
;; Will obtain the current size and redraw (also when size didn't change).

(defn- #_void shell_resized []
    (§
;       set_shellsize(0, 0, false);
    ))

(atom! int _2_busy)

;; Set size of the Vim shell.
;; If 'mustset' is true, we must set Rows and Columns,
;; do not get the real window size (this is used for the :win command).
;; If 'mustset' is false, we may try to get the real window size
;; and if it fails, use 'width' and 'height'.

(defn- #_void set_shellsize [#_int width, #_int height, #_boolean mustset]
    (§
        ;; Avoid recursiveness, can happen when setting the window size causes
        ;; another window-changed signal.

;       if (@_2_busy != 0)
;           return;

;       if (width < 0 || height < 0)    ;; just checking...
;           return;

;       if (@State == HITRETURN || @State == SETWSIZE)
;       {
            ;; postpone the resizing
;           @State = SETWSIZE;
;           return;
;       }

        ;; curwin.w_buffer can be null when we are closing a window and the buffer
        ;; has already been closed and removing a scrollbar causes a resize event.
        ;; Don't resize then, it will happen after entering another buffer.

;       if (@curwin.w_buffer == null)
;           return;

;       @_2_busy++;

;       if (mustset || (!ui_get_shellsize() && height != 0))
;       {
;           @Rows = height;
;           @Columns = width;
;           check_shellsize();
;           ui_set_shellsize(mustset);
;       }
;       else
;           check_shellsize();

        ;; The window layout used to be adjusted here, but it now happens in
        ;; screenalloc() (also invoked from screenclear()).  That is because
        ;; the "_2_busy" check above may skip this, but not screenalloc().

;       if (@State != ASKMORE && @State != CONFIRM)
;           screenclear();
;       else
;           screen_start();     ;; don't know where cursor is now

;       if (@starting != NO_SCREEN)
;       {
;           changed_line_abv_curs();
;           invalidate_botline();

            ;; We only redraw when it's needed:
            ;; - While at the more prompt or executing an external command, don't
            ;;   redraw, but position the cursor.
            ;; - While editing the command line, only redraw that.
            ;; - in Ex mode, don't redraw anything.
            ;; - Otherwise, redraw right now, and position the cursor.
            ;; Always need to call update_screen() or screenalloc(), to make
            ;; sure Rows/Columns and the size of screenLines[] is correct!

;           if (@State == ASKMORE || @State == CONFIRM || @exmode_active != 0)
;           {
;               screenalloc(false);
;               repeat_message();
;           }
;           else
;           {
;               if (@curwin.w_onebuf_opt.@wo_scb)
;                   do_check_scrollbind(true);
;               if ((@State & CMDLINE) != 0)
;               {
;                   update_screen(NOT_VALID);
;                   redrawcmdline();
;               }
;               else
;               {
;                   update_topline();
;                   update_screen(NOT_VALID);
;                   if (redrawing())
;                       setcursor();
;               }
;           }
;           cursor_on();        ;; redrawing may have switched it off
;       }

;       out_flush();

;       --@_2_busy;
    ))

;; Set the terminal to TMODE_RAW (for Normal mode)
;; or TMODE_COOK (for external commands and Ex mode).

(defn- #_void settmode [#_int tmode]
    (§
;       if (@full_screen)
;       {
            ;; When returning after calling a shell we want to really set the
            ;; terminal to raw mode, even though we think it already is, because
            ;; the shell program may have reset the terminal mode.
            ;; When we think the terminal is normal, don't try to set it to
            ;; normal again, because that causes problems (logout!) on some machines.

;           if (tmode != TMODE_COOK || @cur_tmode != TMODE_COOK)
;           {
                ;; May need to check for T_CRV response and termcodes,
                ;; it doesn't work in Cooked mode, an external program may get them.
;               if (tmode != TMODE_RAW && (@crv_status == CRV_SENT || @u7_status == U7_SENT))
;                   vpeekc_nomap();
;               check_for_codes_from_term();

;               if (tmode != TMODE_RAW)
;                   mch_setmouse(false);            ;; switch mouse off
;               out_flush();
;               mch_settmode(tmode);                ;; machine specific function
;               @cur_tmode = tmode;
;               if (tmode == TMODE_RAW)
;                   setmouse();                     ;; may switch mouse on
;               out_flush();
;           }
;           may_req_termresponse();
;       }
    ))

(defn- #_void starttermcap []
    (§
;       if (@full_screen && !@termcap_active)
;       {
;           out_str(@T_TI);                  ;; start termcap mode
;           out_str(@T_KS);                  ;; start "keypad transmit" mode
;           out_flush();
;           @termcap_active = true;
;           screen_start();                 ;; don't know where cursor is now

;           may_req_termresponse();
            ;; Immediately check for a response.
            ;; If t_Co changes, we don't want to redraw with wrong colors first.
;           if (@crv_status == CRV_SENT)
;               check_for_codes_from_term();
;       }
    ))

(defn- #_void stoptermcap []
    (§
;       screen_stop_highlight();
;       reset_cterm_colors();
;       if (@termcap_active)
;       {
            ;; May need to discard T_CRV or T_U7 response.
;           if (@crv_status == CRV_SENT || @u7_status == U7_SENT)
;           {
                ;; Give the terminal a chance to respond.
;               mch_delay(100L, false);
                ;; Discard data received but not read.
;               if (@exiting)
;                   libc.tcflush(libc.fileno(stdin), TCIFLUSH);
;           }
            ;; Check for termcodes first, otherwise an external program may get them.
;           check_for_codes_from_term();

;           out_str(@T_KE);                  ;; stop "keypad transmit" mode
;           out_flush();
;           @termcap_active = false;
;           cursor_on();                    ;; just in case it is still off
;           out_str(@T_TE);                  ;; stop termcap mode
;           screen_start();                 ;; don't know where cursor is now
;           out_flush();
;       }
    ))

;; Request version string (for xterm) when needed.
;; Only do this after switching to raw mode, otherwise the result will be echoed.
;; Only do this after startup has finished, to avoid that the response comes
;; while executing "-c !cmd" or even after "-c quit".
;; Only do this after termcap mode has been started, otherwise the codes for
;; the cursor keys may be wrong.
;; Only do this when 'esckeys' is on, otherwise the response causes trouble in Insert mode.
;; On Unix only do it when both output and input are a tty (avoid writing
;; request to terminal while reading from a file).
;; The result is caught in check_termcode().

(defn- #_void may_req_termresponse []
    (§
;       if (@crv_status == CRV_GET
;               && @cur_tmode == TMODE_RAW
;               && @starting == 0
;               && @termcap_active
;               && @p_ek
;               && libc.isatty(1) != 0
;               && libc.isatty(@read_cmd_fd) != 0
;               && @T_CRV.at(0) != NUL)
;       {
;           out_str(@T_CRV);
;           @crv_status = CRV_SENT;
            ;; check for the characters now, otherwise they might be eaten by get_keystroke()
;           out_flush();
;           vpeekc_nomap();
;       }
    ))

;; Check how the terminal treats ambiguous character width (UAX #11).
;; First, we move the cursor to (1, 0) and print a test ambiguous character
;; \u25bd (WHITE DOWN-POINTING TRIANGLE) and query current cursor position.
;; If the terminal treats \u25bd as single width, the position is (1, 1),
;; or if it is treated as double width, that will be (1, 2).
;; This function has the side effect that changes cursor position, so
;; it must be called immediately after entering termcap mode.

(defn- #_void may_req_ambiguous_char_width []
    (§
;       if (@u7_status == U7_GET
;               && @cur_tmode == TMODE_RAW
;               && @termcap_active
;               && @p_ek
;               && libc.isatty(1) != 0
;               && libc.isatty(@read_cmd_fd) != 0
;               && @T_U7.at(0) != NUL
;               && !option_was_set(u8("ambiwidth")))
;       {
;           Bytes buf = new Bytes(16);

            ;; Do this in the second row.
            ;; In the first row the returned sequence may be CSI 1;2R, which is the same as <S-F3>.
;           term_windgoto(1, 0);
;           buf.be(utf_char2bytes(0x25bd, buf), 0);
;           out_str(buf);
;           out_str(@T_U7);
;           @u7_status = U7_SENT;
;           out_flush();
;           term_windgoto(1, 0);
;           out_str(u8("  "));
;           term_windgoto(0, 0);
            ;; check for the characters now, otherwise they might be eaten by get_keystroke()
;           out_flush();
;           vpeekc_nomap();
;       }
    ))

;; Return true when saving and restoring the screen.

(defn- #_boolean swapping_screen []
    (§
;       return (@full_screen && @T_TI.at(0) != NUL);
    ))

;; setmouse() - switch mouse on/off depending on current mode and 'mouse'

(defn- #_void setmouse []
    (§
        ;; be quick when mouse is off
;       if (@p_mouse.at(0) == NUL || !@has_mouse_termcode)
;           return;

        ;; don't switch mouse on when not in raw mode (Ex mode)
;       if (@cur_tmode != TMODE_RAW)
;       {
;           mch_setmouse(false);
;           return;
;       }

;       byte checkfor;
;       if (@VIsual_active)
;           checkfor = MOUSE_VISUAL;
;       else if (@State == HITRETURN || @State == ASKMORE || @State == SETWSIZE)
;           checkfor = MOUSE_RETURN;
;       else if ((@State & INSERT) != 0)
;           checkfor = MOUSE_INSERT;
;       else if ((@State & CMDLINE) != 0)
;           checkfor = MOUSE_COMMAND;
;       else if (@State == CONFIRM)
;           checkfor = ' ';     ;; don't use mouse for ":confirm" or ":!cmd"
;       else
;           checkfor = MOUSE_NORMAL;    ;; assume normal mode

;       mch_setmouse(mouse_has(checkfor));
    ))

;; Return true if
;; - "b" is in 'mouse', or
;; - 'a' is in 'mouse' and "b" is in MOUSE_A, or ...

(defn- #_boolean mouse_has [#_byte b]
    (§
;       for (Bytes p = @p_mouse; p.at(0) != NUL; p = p.plus(1))
;           switch (p.at(0))
;           {
;               case 'a':
;                   if (vim_strchr(MOUSE_A, b) != null)
;                       return true;
;                   break;
;               case MOUSE_HELP:
;                   break;
;               default:
;                   if (p.at(0) == b)
;                       return true;
;                   break;
;           }
;       return false;
    ))

;; Return true when 'mousemodel' is set to "popup" or "popup_setpos".

(defn- #_boolean mouse_model_popup []
    (§
;       return (@p_mousem.at(0) == (byte)'p');
    ))

;; By outputting the 'cursor very visible' termcap code, for some windowed
;; terminals this makes the screen scrolled to the correct position.
;; Used when starting Vim or returning from a shell.

(defn- #_void scroll_start []
    (§
;       if (@T_VS.at(0) != NUL)
;       {
;           out_str(@T_VS);
;           out_str(@T_VE);
;           screen_start();                 ;; don't know where cursor is now
;       }
    ))

(atom! boolean cursor_is_off)

;; Enable the cursor.

(defn- #_void cursor_on []
    (§
;       if (@cursor_is_off)
;       {
;           out_str(@T_VE);
;           @cursor_is_off = false;
;       }
    ))

;; Disable the cursor.

(defn- #_void cursor_off []
    (§
;       if (@full_screen)
;       {
;           if (!@cursor_is_off)
;               out_str(@T_VI);          ;; disable cursor
;           @cursor_is_off = true;
;       }
    ))

(atom! int showing_mode NORMAL)

;; Set cursor shape to match Insert or Replace mode.

(defn- #_void term_cursor_shape []
    (§
        ;; Only do something when redrawing the screen and we can restore the mode.
;       if (!@full_screen || @T_CEI.at(0) == NUL)
;           return;

;       if ((@State & REPLACE) == REPLACE)
;       {
;           if (@showing_mode != REPLACE)
;           {
;               Bytes p;
;               if (@T_CSR.at(0) != NUL)
;                   p = @T_CSR;                  ;; Replace mode cursor
;               else
;                   p = @T_CSI;                  ;; fall back to Insert mode cursor
;               if (p.at(0) != NUL)
;               {
;                   out_str(p);
;                   @showing_mode = REPLACE;
;               }
;           }
;       }
;       else if ((@State & INSERT) != 0)
;       {
;           if (@showing_mode != INSERT && @T_CSI.at(0) != NUL)
;           {
;               out_str(@T_CSI);                 ;; Insert mode cursor
;               @showing_mode = INSERT;
;           }
;       }
;       else if (@showing_mode != NORMAL)
;       {
;           out_str(@T_CEI);                     ;; non-Insert mode cursor
;           @showing_mode = NORMAL;
;       }
    ))

;; Set scrolling region for window 'wp'.
;; The region starts 'off' lines from the start of the window.
;; Also set the vertical scroll region for a vertically split window.
;; Always the full width of the window, excluding the vertical separator.

(defn- #_void scroll_region_set [#_window_C wp, #_int off]
    (§
;       out_str(_tgoto(@T_CS, wp.w_winrow + wp.w_height - 1, wp.w_winrow + off));

;       if (@T_CSV.at(0) != NUL && wp.w_width != (int)@Columns)
;           out_str(_tgoto(@T_CSV, wp.w_wincol + wp.w_width - 1, wp.w_wincol));

;       screen_start();                 ;; don't know where cursor is now
    ))

;; Reset scrolling region to the whole screen.

(defn- #_void scroll_region_reset []
    (§
;       out_str(_tgoto(@T_CS, (int)@Rows - 1, 0));

;       if (@T_CSV.at(0) != NUL)
;           out_str(_tgoto(@T_CSV, (int)@Columns - 1, 0));

;       screen_start();                 ;; don't know where cursor is now
    ))

;; List of terminal codes that are currently recognized.

(class! #_final termcode_C
    [
        (field Bytes    name    (Bytes. 2))     ;; termcap name of entry
        (field Bytes    code)                   ;; terminal code (in allocated memory)
        (field int      len)                    ;; STRLEN(code)
        (field int      modlen)                 ;; length of part before ";*~".
    ])

(defn- #_void COPY_termcode [#_termcode_C tc1, #_termcode_C tc0]
    (§
;       BCOPY(tc1.name, tc0.name, 2);
;       tc1.code = tc0.code;
;       tc1.len = tc0.len;
;       tc1.modlen = tc0.modlen;
    ))

(defn- #_termcode_C* ARRAY_termcode [#_int n]
    (vec (repeatedly n §_termcode_C)))

(atom! termcode_C* termcodes)

(atom! int tc_max_len)  ;; number of entries that termcodes[] can hold
(atom! int tc_len)      ;; current number of entries in termcodes[]

(defn- #_void clear_termcodes []
    (§
;       @tc_len = 0;
;       @tc_max_len = 0;
;       @termcodes = null;

;       @need_gather = true;         ;; need to fill termleader[]
    ))

(final int ATC_FROM_TERM 55)

;; Add a new entry to the list of terminal codes.
;; The list is kept alphabetical for ":set termcap"
;; "flags" is true when replacing 7-bit by 8-bit controls is desired.
;; "flags" can also be ATC_FROM_TERM for got_code_from_term().

(defn- #_void add_termcode [#_Bytes name, #_Bytes string, #_int flags]
    (§
;       if (string == null || string.at(0) == NUL)
;       {
;           del_termcode(name);
;           return;
;       }

;       Bytes code = STRDUP(string);

        ;; Change leading <Esc>[ to CSI, change <Esc>O to <M-O>.
;       if (flags != 0 && flags != ATC_FROM_TERM)
;       {
;           byte esc = term_7to8bit(code);
;           if (esc != NUL)
;           {
;               code.be(0, esc);
;               BCOPY(code, 1, code, 2, STRLEN(code, 2) + 1);
;           }
;       }

;       int len = STRLEN(code);

;       @need_gather = true;         ;; need to fill termleader[]

        ;; need to make space for more entries

;       if (@tc_len == @tc_max_len)
;       {
;           @tc_max_len += 20;
;           termcode_C[] new_tc = ARRAY_termcode(@tc_max_len);
;           for (int i = 0; i < @tc_len; i++)
;               COPY_termcode(new_tc[i], @termcodes[i]);
;           @termcodes = new_tc;
;       }

        ;; Look for existing entry with the same name, it is replaced.
        ;; Look for an existing entry that is alphabetical higher, the new entry is inserted in front of it.

;       int i;
;       for (i = 0; i < @tc_len; i++)
;       {
;           if (char_u(@termcodes[i].name.at(0)) < char_u(name.at(0)))
;               continue;
;           if (@termcodes[i].name.at(0) == name.at(0))
;           {
;               if (char_u(@termcodes[i].name.at(1)) < char_u(name.at(1)))
;                   continue;

                ;; Exact match: May replace old code.

;               if (@termcodes[i].name.at(1) == name.at(1))
;               {
;                   int j;
;                   if (flags == ATC_FROM_TERM && 0 < (j = termcode_star(@termcodes[i].code, @termcodes[i].len)))
;                   {
                        ;; Don't replace ESC[123;*X or ESC O*X with another
                        ;; when invoked from got_code_from_term().
;                       if (len == @termcodes[i].len - j
;                               && STRNCMP(code, @termcodes[i].code, len - 1) == 0
;                               && code.at(len - 1) == @termcodes[i].code.at(@termcodes[i].len - 1))
;                       {
                            ;; They are equal but for the ";*": don't add it.
;                           return;
;                       }
;                   }
;                   else
;                   {
                        ;; Replace old code.
;                       @termcodes[i].code = null;
;                       --@tc_len;
;                       break;
;                   }
;               }
;           }

            ;; Found alphabetical larger entry, move rest to insert new entry

;           for (int j = @tc_len; i < j; --j)
;               COPY_termcode(@termcodes[j], @termcodes[j - 1]);
;           break;
;       }

;       @termcodes[i].name.be(0, name.at(0));
;       @termcodes[i].name.be(1, name.at(1));
;       @termcodes[i].code = code;
;       @termcodes[i].len = len;

        ;; For xterm we recognize special codes like "ESC[42;*X" and "ESC O*X" that accept modifiers.
;       @termcodes[i].modlen = 0;
;       int j = termcode_star(code, len);
;       if (0 < j)
;           @termcodes[i].modlen = len - 1 - j;
;       @tc_len++;
    ))

;; Check termcode "code[len]" for ending in ;*X, <Esc>O*X or <M-O>*X.
;; The "X" can be any character.
;; Return 0 if not found, 2 for ;*X and 1 for O*X and <M-O>*X.

(defn- #_int termcode_star [#_Bytes code, #_int len]
    (§
        ;; Shortest is <M-O>*X.  With ; shortest is <CSI>1;*X.
;       if (3 <= len && code.at(len - 2) == (byte)'*')
;       {
;           if (5 <= len && code.at(len - 3) == (byte)';')
;               return 2;
;           if ((4 <= len && code.at(len - 3) == (byte)'O') || char_u(code.at(len - 3)) == 'O' + 0x80)
;               return 1;
;       }
;       return 0;
    ))

(defn- #_Bytes find_termcode [#_Bytes name]
    (§
;       for (int i = 0; i < @tc_len; i++)
;           if (@termcodes[i].name.at(0) == name.at(0) && @termcodes[i].name.at(1) == name.at(1))
;               return @termcodes[i].code;

;       return null;
    ))

(defn- #_Bytes get_termcode [#_int i]
    (§
;       if (i < @tc_len)
;           return @termcodes[i].name;

;       return null;
    ))

(defn- #_void del_termcode [#_Bytes name]
    (§
;       if (@termcodes == null)      ;; nothing there yet
;           return;

;       @need_gather = true;         ;; need to fill termleader[]

;       for (int i = 0; i < @tc_len; i++)
;           if (@termcodes[i].name.at(0) == name.at(0) && @termcodes[i].name.at(1) == name.at(1))
;           {
;               del_termcode_idx(i);
;               return;
;           }
        ;; Not found.  Give error message?
    ))

(defn- #_void del_termcode_idx [#_int idx]
    (§
;       @termcodes[idx].code = null;
;       --@tc_len;
;       for (int i = idx; i < @tc_len; i++)
;           COPY_termcode(@termcodes[i], @termcodes[i + 1]);
    ))

;; Called when detected that the terminal sends 8-bit codes.
;; Convert all 7-bit codes to their 8-bit equivalent.

(defn- #_void switch_to_8bit []
    (§
        ;; Only need to do something when not already using 8-bit codes.
;       if (!term_is_8bit(@T_NAME))
;       {
;           for (int i = 0; i < @tc_len; i++)
;           {
;               Bytes code = @termcodes[i].code;
;               byte esc = term_7to8bit(code);
;               if (esc != NUL)
;               {
;                   code.be(0, esc);
;                   BCOPY(code, 1, code, 2, STRLEN(code, 2) + 1);
;               }
;           }

;           @need_gather = true;             ;; need to fill termleader[]
;       }

;       @detected_8bit = true;
    ))

;; Checking for double clicks ourselves.
;; "orig_topline" is used to avoid detecting a double-click when the window contents scrolled
;; (e.g., when 'scrolloff' is non-zero).

(atom! long orig_topline)

;; Set orig_topline.  Used when jumping to another window, so that a double click still works.

(defn- #_void set_mouse_topline [#_window_C wp]
    (§
;       @orig_topline = wp.w_topline;
    ))

(atom! int held_button MOUSE_RELEASE)
(atom! int orig_num_clicks 1)
(atom! int orig_mouse_code)
(atom! int orig_mouse_col)
(atom! int orig_mouse_row)
(atom! timeval_C orig_mouse_time (timeval_C.))  ;; time of previous mouse click

;; Check if typebuf.tb_buf[] contains a terminal key code.
;; Check from typebuf.tb_buf[typebuf.tb_off] to typebuf.tb_buf[typebuf.tb_off + max_offset].
;; Return 0 for no match, -1 for partial match, > 0 for full match.
;; Return KEYLEN_REMOVED when a key code was deleted.
;; With a match, the match is removed, the replacement code is inserted in
;; typebuf.tb_buf[] and the number of characters in typebuf.tb_buf[] is returned.
;; When "buf" is not null, buf[bufsize] is used instead of typebuf.tb_buf[].
;; "buflen" is then the length of the string in buf[] and is updated for inserts and deletes.

(defn- #_int check_termcode [#_int max_offset, #_Bytes buf, #_int bufsize, #_int* buflen]
    (§
;       int retval = 0;

;       boolean cpo_koffset = (vim_strbyte(@p_cpo, CPO_KOFFSET) != null);

        ;; Speed up the checks for terminal codes by gathering all first bytes used in termleader[].
        ;; Often this is just a single <Esc>.

;       if (@need_gather)
;           gather_termleader();

;       int slen = 0;
;       int mouse_code = 0;
;       int wheel_code = 0;

        ;; Check at several positions in typebuf.tb_buf[], to catch something like "x<Up>"
        ;; that can be mapped.  Stop at max_offset, because characters after that cannot be
        ;; used for mapping, and with @r commands typebuf.tb_buf[] can become very long.
        ;; This is used often, KEEP IT FAST!

;       for (int offset = 0; offset < max_offset; offset++)
;       {
;           Bytes tp;
;           int len;

;           if (buf == null)
;           {
;               if (@typebuf.tb_len <= offset)
;                   break;
;               tp = @typebuf.tb_buf.plus(@typebuf.tb_off + offset);
;               len = @typebuf.tb_len - offset;      ;; length of the input
;           }
;           else
;           {
;               if (buflen[0] <= offset)
;                   break;
;               tp = buf.plus(offset);
;               len = buflen[0] - offset;
;           }

            ;; Don't check characters after KB_SPECIAL, those are already
            ;; translated terminal chars (avoid translating ~@^Hx).

;           if (tp.at(0) == KB_SPECIAL)
;           {
;               offset += 2;        ;; there are always 2 extra characters
;               continue;
;           }

            ;; Skip this position if the character does not appear as the first character in 'term_strings'.
            ;; This speeds up a lot, since most termcodes start with the same character (ESC or CSI).

;           Bytes q;
;           for (q = termleader; q.at(0) != NUL && q.at(0) != tp.at(0); q = q.plus(1))
            ;
;           if (q.at(0) == NUL)
;               continue;

            ;; Skip this position if "p_ek" is not set and *tp is an ESC and we are in Insert mode.

;           if (tp.at(0) == ESC && !@p_ek && (@State & INSERT) != 0)
;               continue;

;           Bytes key_name = new Bytes(2);
;           int[] modifiers = { 0 };      ;; no modifiers yet

;           int idx;
;           for (idx = 0; idx < @tc_len; idx++)
;           {
                ;; Ignore the entry if we are not at the start of typebuf.tb_buf[]
                ;; and there are not enough characters to make a match.
                ;; But only when the 'K' flag is in 'cpoptions'.

;               slen = @termcodes[idx].len;
;               if (cpo_koffset && offset != 0 && len < slen)
;                   continue;

;               if (STRNCMP(@termcodes[idx].code, tp, (len < slen) ? len : slen) == 0)
;               {
;                   if (len < slen)             ;; got a partial sequence
;                       return -1;              ;; need to get more chars

                    ;; When found a keypad key, check if there is another key that matches and use that one.
                    ;; This makes <Home> to be found instead of <kHome> when they produce the same key code.

;                   if (@termcodes[idx].name.at(0) == (byte)'K' && asc_isdigit(@termcodes[idx].name.at(1)))
;                   {
;                       for (int j = idx + 1; j < @tc_len; j++)
;                           if (@termcodes[j].len == slen
;                               && STRNCMP(@termcodes[idx].code, @termcodes[j].code, slen) == 0)
;                           {
;                               idx = j;
;                               break;
;                           }
;                   }

;                   key_name.be(0, @termcodes[idx].name.at(0));
;                   key_name.be(1, @termcodes[idx].name.at(1));
;                   break;
;               }

                ;; Check for code with modifier, like xterm uses:
                ;; <Esc>[123;*X (modslen == slen - 3), also <Esc>O*X and <M-O>*X (modslen == slen - 2).
                ;; When there is a modifier the * matches a number.
                ;; When there is no modifier the ;* or * is omitted.

;               if (0 < @termcodes[idx].modlen)
;               {
;                   int modslen = @termcodes[idx].modlen;
;                   if (cpo_koffset && offset != 0 && len < modslen)
;                       continue;

;                   if (STRNCMP(@termcodes[idx].code, tp, (len < modslen) ? len : modslen) == 0)
;                   {
;                       if (len <= modslen)     ;; got a partial sequence
;                           return -1;          ;; need to get more chars

;                       if (tp.at(modslen) == @termcodes[idx].code.at(slen - 1))
;                           slen = modslen + 1; ;; no modifiers
;                       else if (tp.at(modslen) != (byte)';' && modslen == slen - 3)
;                           continue;   ;; no match
;                       else
;                       {
                            ;; Skip over the digits, the final char must follow.
;                           int j;
;                           for (j = slen - 2; j < len && asc_isdigit(tp.at(j)); j++)
                            ;
;                           j++;
;                           if (len < j)        ;; got a partial sequence
;                               return -1;      ;; need to get more chars
;                           if (tp.at(j - 1) != @termcodes[idx].code.at(slen - 1))
;                               continue;       ;; no match

                            ;; Match!  Convert modifier bits.
;                           int n = libC.atoi(tp.plus(slen - 2)) - 1;
;                           if ((n & 1) != 0)
;                               modifiers[0] |= MOD_MASK_SHIFT;
;                           if ((n & 2) != 0)
;                               modifiers[0] |= MOD_MASK_ALT;
;                           if ((n & 4) != 0)
;                               modifiers[0] |= MOD_MASK_CTRL;
;                           if ((n & 8) != 0)
;                               modifiers[0] |= MOD_MASK_META;

;                           slen = j;
;                       }

;                       key_name.be(0, @termcodes[idx].name.at(0));
;                       key_name.be(1, @termcodes[idx].name.at(1));
;                       break;
;                   }
;               }
;           }

            ;; Mouse codes of DEC, pterm, and URXVT start with <ESC>[.
            ;; When detecting the start of these mouse codes they might
            ;; as well be another key code or terminal response.
;           if (key_name.at(0) == NUL)
;           {
                ;; Check for some responses from the terminal starting with "<Esc>[" or CSI:
                ;;
                ;; - Xterm version string: <Esc>[>{x};{vers};{y}c
                ;;   Also eat other possible responses to t_RV, rxvt returns "<Esc>[?1;2c".
                ;;   Also accept CSI instead of <Esc>[.
                ;;   mrxvt has been reported to have "+" in the version.
                ;;   Assume the escape sequence ends with a letter or one of "{|}~".
                ;;
                ;; - Cursor position report: <Esc>[{row};{col}R
                ;;   The final byte must be 'R'.
                ;;   It is used for checking the ambiguous-width character state.

;               Bytes p = (tp.at(0) == CSI) ? tp.plus(1) : tp.plus(2);
;               if ((@T_CRV.at(0) != NUL || @T_U7.at(0) != NUL)
;                           && ((tp.at(0) == ESC && tp.at(1) == (byte)'[' && 3 <= len) || (tp.at(0) == CSI && 2 <= len))
;                           && (asc_isdigit(p.at(0)) || p.at(0) == (byte)'>' || p.at(0) == (byte)'?'))
;               {
;                   int j = 0;
;                   int extra = 0;
;                   byte row_char = NUL;

;                   int i;
;                   for (i = 2 + ((tp.at(0) != CSI) ? 1 : 0); i < len && !('{' <= tp.at(i) && tp.at(i) <= '~') && !asc_isalpha(tp.at(i)); i++)
;                       if (tp.at(i) == (byte)';' && ++j == 1)
;                       {
;                           extra = i + 1;
;                           row_char = tp.at(i - 1);
;                       }
;                   if (i == len)
;                       return -1;

;                   int col = (0 < extra) ? libC.atoi(tp.plus(extra)) : 0;

                    ;; Eat it when it has 2 arguments and ends in 'R'.  Also when u7_status is not
                    ;; "sent", it may be from a previous Vim that just exited.  But not for <S-F3>,
                    ;; it sends something similar, check for row and column to make sense.
;                   if (j == 1 && tp.at(i) == (byte)'R')
;                   {
;                       if (row_char == '2' && 2 <= col)
;                       {
;                           @u7_status = U7_GOT;
;                           @did_cursorhold = true;

;                           Bytes aw = null;
;                           if (col == 2)
;                               aw = u8("single");
;                           else if (col == 3)
;                               aw = u8("double");
;                           if (aw != null && STRCMP(aw, @p_ambw) != 0)
;                           {
                                ;; Setting the option causes a screen redraw.
                                ;; Do that right away if possible, keeping any messages.
;                               set_option_value(u8("ambw"), 0L, aw, 0);
;                               redraw_asap(CLEAR);
;                           }
;                       }
;                       key_name.be(0, KS_EXTRA);
;                       key_name.be(1, KE_IGNORE);
;                       slen = i + 1;
;                   }

                    ;; Eat it when at least one digit and ending in 'c'.
;                   else if (@T_CRV.at(0) != NUL && 2 + ((tp.at(0) != CSI) ? 1 : 0) < i && tp.at(i) == (byte)'c')
;                   {
;                       @crv_status = CRV_GOT;
;                       @did_cursorhold = true;

                        ;; If this code starts with CSI, you can bet that the terminal uses 8-bit codes.
;                       if (tp.at(0) == CSI)
;                           switch_to_8bit();

                        ;; rxvt sends its version number: "20703" is 2.7.3.
                        ;; Ignore it for when the user has set 'term' to xterm, even though it's an rxvt.
;                       if (0 < extra)
;                           extra = libC.atoi(tp.plus(extra));
;                       if (20000 < extra)
;                           extra = 0;

;                       if (tp.at(1 + ((tp.at(0) != CSI) ? 1 : 0)) == '>' && j == 2)
;                       {
                            ;; Only set 'ttymouse' automatically if it was not set by the user already.
;                           if (!option_was_set(u8("ttym")))
;                           {
                                ;; if xterm version >= 95 use mouse dragging
;                               if (95 <= extra)
;                                   set_option_value(u8("ttym"), 0L, u8("xterm2"), 0);
;                           }

                            ;; if xterm version >= 141 try to get termcap codes
;                           if (141 <= extra)
;                           {
;                               @check_for_codes = true;
;                               @need_gather = true;
;                               req_codes_from_term();
;                           }
;                       }
;                       key_name.be(0, KS_EXTRA);
;                       key_name.be(1, KE_IGNORE);
;                       slen = i + 1;
;                   }
;               }

                ;; Check for '<Esc>P1+r<hex bytes><Esc>\'.
                ;; A "0" instead of the "1" means an invalid request.
;               else if (@check_for_codes && ((tp.at(0) == ESC && tp.at(1) == (byte)'P' && 2 <= len) || tp.at(0) == DCS))
;               {
;                   int i;

;                   int j = 1 + ((tp.at(0) != DCS) ? 1 : 0);
;                   for (i = j; i < len; i++)
;                       if ((tp.at(i) == ESC && tp.at(i + 1) == (byte)'\\' && i + 1 < len) || tp.at(i) == STERM)
;                       {
;                           if (3 <= i - j && tp.at(j + 1) == (byte)'+' && tp.at(j + 2) == (byte)'r')
;                               got_code_from_term(tp.plus(j), i);
;                           key_name.be(0, KS_EXTRA);
;                           key_name.be(1, KE_IGNORE);
;                           slen = i + 1 + (tp.at(i) == ESC ? 1 : 0);
;                           break;
;                       }

;                   if (i == len)
;                       return -1;          ;; not enough characters
;               }
;           }

;           if (key_name.at(0) == NUL)
;               continue;           ;; no match at this position, try next one

            ;; We only get here when we have a complete termcode match.

            ;; If it is a mouse click, get the coordinates.

;           if (key_name.at(0) == KS_MOUSE)
;           {
                ;; For xterm and MSDOS we get "<t_mouse>scr", where
                ;;  s == encoded button state:
                ;;         0x20 = left button down
                ;;         0x21 = middle button down
                ;;         0x22 = right button down
                ;;         0x23 = any button release
                ;;         0x60 = button 4 down (scroll wheel down)
                ;;         0x61 = button 5 down (scroll wheel up)
                ;;      add 0x04 for SHIFT
                ;;      add 0x08 for ALT
                ;;      add 0x10 for CTRL
                ;;      add 0x20 for mouse drag (0x40 is drag with left button)
                ;;  c == column + ' ' + 1 == column + 33
                ;;  r == row + ' ' + 1 == row + 33
                ;;
                ;; The coordinates are passed on through global variables.
                ;; Ugly, but this avoids trouble with mouse clicks at an
                ;; unexpected moment and allows for mapping them.

;               for ( ; ; )
;               {
;                   Bytes bytes = new Bytes(6);
;                   int n = get_bytes_from_buf(tp.plus(slen), bytes, 3);
;                   if (n == -1)    ;; not enough coordinates
;                       return -1;

;                   mouse_code = bytes.at(0);
;                   @mouse_col = bytes.at(1) - ' ' - 1;
;                   @mouse_row = bytes.at(2) - ' ' - 1;

;                   slen += n;

                    ;; If the following bytes is also a mouse code
                    ;; and it has the same code, dump this one and get the next.
                    ;; This makes dragging a whole lot faster.
;                   n = @termcodes[idx].len;
;                   if (STRNCMP(tp, tp.plus(slen), n) == 0
;                           && tp.at(slen + n) == mouse_code
;                           && tp.at(slen + n + 1) != NUL
;                           && tp.at(slen + n + 2) != NUL)
;                       slen += n;
;                   else
;                       break;
;               }

                ;; Handle mouse events.
                ;; Recognize the xterm mouse wheel, but not in the GUI, the Linux console
                ;; with GPM and the MS-DOS or Win32 console (multi-clicks use >= 0x60).

;               if (MOUSEWHEEL_LOW <= mouse_code)
;               {
                    ;; Keep the mouse_code before it's changed,
                    ;; so that we remember that it was a mouse wheel click.
;                   wheel_code = mouse_code;
;               }
;               else if (@held_button == MOUSE_RELEASE && (mouse_code == 0x23 || mouse_code == 0x24))
;               {
                    ;; Apparently used by rxvt scroll wheel.
;                   wheel_code = mouse_code - 0x23 + MOUSEWHEEL_LOW;
;               }
;               else if (1 < use_xterm_mouse())
;               {
;                   if ((mouse_code & MOUSE_DRAG_XTERM) != 0)
;                       mouse_code |= MOUSE_DRAG;
;               }

;               boolean is_click = false, is_drag = false;

                ;; Interpret the mouse code.
;               int current_button = (mouse_code & MOUSE_CLICK_MASK);
;               if (current_button == MOUSE_RELEASE && wheel_code == 0)
;               {
                    ;; If we get a mouse drag or release event when there is no mouse button
                    ;; held down (held_button == MOUSE_RELEASE), produce a K_IGNORE below.
                    ;; (can happen when you hold down two buttons and then let them go, or
                    ;; click in the menu bar, but not on a menu, and drag into the text).

;                   if ((mouse_code & MOUSE_DRAG) == MOUSE_DRAG)
;                       is_drag = true;
;                   current_button = @held_button;
;               }
;               else if (wheel_code == 0)
;               {
;                   timeval_C mouse_time = new timeval_C();     ;; time of current mouse click
;                   long timediff;                              ;; elapsed time in msec

                    ;; Compute the time elapsed since the previous mouse click.

;                   libC._gettimeofday(mouse_time);
;                   timediff = (mouse_time.tv_usec() - @orig_mouse_time.tv_usec()) / 1000;
;                   if (timediff < 0)
;                       @orig_mouse_time.tv_sec(@orig_mouse_time.tv_sec() - 1);
;                   timediff += (mouse_time.tv_sec() - @orig_mouse_time.tv_sec()) * 1000;
;                   COPY_timeval(@orig_mouse_time, mouse_time);
;                   if (mouse_code == @orig_mouse_code
;                           && timediff < @p_mouset
;                           && @orig_num_clicks != 4
;                           && @orig_mouse_col == @mouse_col
;                           && @orig_mouse_row == @mouse_row
;                           && (@orig_topline == @curwin.w_topline
                                ;; Double click in tab pages line also works when window contents changes.
;                               || (@mouse_row == 0 && 0 < @firstwin.w_winrow)))
;                       @orig_num_clicks++;
;                   else
;                       @orig_num_clicks = 1;
;                   @orig_mouse_col = @mouse_col;
;                   @orig_mouse_row = @mouse_row;
;                   @orig_topline = @curwin.w_topline;

;                   is_click = true;
;                   @orig_mouse_code = mouse_code;
;               }
;               if (!is_drag)
;                   @held_button = (mouse_code & MOUSE_CLICK_MASK);

                ;; Translate the actual mouse event into a pseudo mouse event.
                ;; First work out what modifiers are to be used.

;               if ((@orig_mouse_code & MOUSE_SHIFT) != 0)
;                   modifiers[0] |= MOD_MASK_SHIFT;
;               if ((@orig_mouse_code & MOUSE_CTRL) != 0)
;                   modifiers[0] |= MOD_MASK_CTRL;
;               if ((@orig_mouse_code & MOUSE_ALT) != 0)
;                   modifiers[0] |= MOD_MASK_ALT;
;               if (@orig_num_clicks == 2)
;                   modifiers[0] |= MOD_MASK_2CLICK;
;               else if (@orig_num_clicks == 3)
;                   modifiers[0] |= MOD_MASK_3CLICK;
;               else if (@orig_num_clicks == 4)
;                   modifiers[0] |= MOD_MASK_4CLICK;

                ;; Work out our pseudo mouse event.
;               key_name.be(0, KS_EXTRA);
;               if (wheel_code != 0)
;               {
;                   if ((wheel_code & MOUSE_CTRL) != 0)
;                       modifiers[0] |= MOD_MASK_CTRL;
;                   if ((wheel_code & MOUSE_ALT) != 0)
;                       modifiers[0] |= MOD_MASK_ALT;
;                   key_name.be(1, (wheel_code & 1) != 0 ? KE_MOUSEUP : KE_MOUSEDOWN);
;               }
;               else
;                   key_name.be(1, get_pseudo_mouse_code(current_button, is_click, is_drag));
;           }

            ;; Change <xHome> to <Home>, <xUp> to <Up>, etc.

;           int key = handle_x_keys(TERMCAP2KEY(key_name.at(0), key_name.at(1)));

;           Bytes string = new Bytes(MAX_KEY_CODE_LEN + 1);

            ;; Add any modifier codes to our string.

;           int new_slen = 0;           ;; length of what will replace the termcode
;           if (modifiers[0] != 0)
;           {
                ;; Some keys have the modifier included.
                ;; Need to handle that here to make mappings work.
;               key = simplify_key(key, modifiers);
;               if (modifiers[0] != 0)
;               {
;                   string.be(new_slen++, KB_SPECIAL);
;                   string.be(new_slen++, KS_MODIFIER);
;                   string.be(new_slen++, modifiers[0]);
;               }
;           }

            ;; Finally, add the special key code to our string.
;           key_name.be(0, KEY2TERMCAP0(key));
;           key_name.be(1, KEY2TERMCAP1(key));
;           if (key_name.at(0) == KS_KEY)
;           {
                ;; from ":set <M-b>=xx"
;               new_slen += utf_char2bytes(char_u(key_name.at(1)), string.plus(new_slen));
;           }
;           else if (new_slen == 0 && key_name.at(0) == KS_EXTRA && key_name.at(1) == KE_IGNORE)
;           {
                ;; Do not put K_IGNORE into the buffer, do return KEYLEN_REMOVED to indicate what happened.
;               retval = KEYLEN_REMOVED;
;           }
;           else
;           {
;               string.be(new_slen++, KB_SPECIAL);
;               string.be(new_slen++, key_name.at(0));
;               string.be(new_slen++, key_name.at(1));
;           }
;           string.be(new_slen, NUL);

;           int extra = new_slen - slen;
;           if (buf == null)
;           {
;               if (extra < 0)
                    ;; remove matched chars, taking care of noremap
;                   del_typebuf(-extra, offset);
;               else if (0 < extra)
                    ;; insert the extra space we need
;                   ins_typebuf(string.plus(slen), REMAP_YES, offset, false, false);

                ;; Careful: del_typebuf() and ins_typebuf() may have reallocated typebuf.tb_buf[]!

;               BCOPY(@typebuf.tb_buf, @typebuf.tb_off + offset, string, 0, new_slen);
;           }
;           else
;           {
;               if (extra < 0)
                    ;; remove matched characters
;                   BCOPY(buf, offset, buf, offset - extra, buflen[0] + offset + extra);
;               else if (0 < extra)
;               {
                    ;; Insert the extra space we need.  If there is insufficient space return -1.
;                   if (bufsize <= buflen[0] + extra + new_slen)
;                       return -1;
;                   BCOPY(buf, offset + extra, buf, offset, buflen[0] - offset);
;               }
;               BCOPY(buf, offset, string, 0, new_slen);
;               buflen[0] += extra + new_slen;
;           }

;           return (retval != 0) ? retval : len + extra + offset;
;       }

;       return 0;                       ;; no match found
    ))

;; Replace any terminal code strings in from[] with the equivalent internal vim representation.
;; This is used for the "from" and "to" part of a mapping, and the "to" part of a menu command.
;; Any strings like "<C-UP>" are also replaced, unless 'cpoptions' contains '<'.
;; KB_SPECIAL by itself is replaced by KB_SPECIAL KS_SPECIAL KE_FILLER.
;;
;; CTRL-V characters are removed.  When "from_part" is true, a trailing CTRL-V is included,
;; otherwise it is removed (for ":map xx ^V", maps xx to nothing).
;; When 'cpoptions' does not contain 'B', a backslash can be used instead of a CTRL-V.

(defn- #_Bytes replace_termcodes [#_Bytes from, #_boolean from_part, #_boolean do_lt, #_boolean special]
    ;; do_lt: also translate <lt>
    ;; special: always accept <key> notation
    (§
;       boolean do_backslash = (vim_strbyte(@p_cpo, CPO_BSLASH) == null);         ;; backslash is special
;       boolean do_special = (vim_strbyte(@p_cpo, CPO_SPECI) == null) || special; ;; recognize <> key codes
;       boolean do_key_code = (vim_strbyte(@p_cpo, CPO_KEYCODE) == null);         ;; recognize raw key codes

        ;; Allocate space for the translation.  Worst case a single character
        ;; is replaced by 6 bytes (shifted special key), plus a NUL at the end.

;       Bytes dest = new Bytes(STRLEN(from) * 6 + 1);

;       Bytes[] src = { from };
;       int dlen = 0;

        ;; Check for #n at start only: function key n.

;       if (from_part && src[0].at(0) == (byte)'#' && asc_isdigit(src[0].at(1)))  ;; function key
;       {
;           dest.be(dlen++, KB_SPECIAL);
;           dest.be(dlen++, (byte)'k');
;           if (src[0].at(1) == (byte)'0')
;               dest.be(dlen++, (byte)';');         ;; #0 is F10 is "k;"
;           else
;               dest.be(dlen++, src[0].at(1));      ;; #3 is F3 is "k3"
;           src[0] = src[0].plus(2);
;       }

        ;; Copy each byte from *from to dest[dlen].

;       while (src[0].at(0) != NUL)
;       {
            ;; If 'cpoptions' does not contain '<', check for special key codes,
            ;; like "<C-S-LeftMouse>".

;           if (do_special && (do_lt || STRNCMP(src[0], u8("<lt>"), 4) != 0))
;           {
;               int slen = trans_special(src, dest.plus(dlen), true);
;               if (slen != 0)
;               {
;                   dlen += slen;
;                   continue;
;               }
;           }

            ;; If 'cpoptions' does not contain 'k', see if it's an actual key-code.
            ;; Note that this is also checked after replacing the <> form.
            ;; Single character codes are NOT replaced (e.g. ^H or DEL), because
            ;; it could be a character in the file.

;           if (do_key_code)
;           {
;               int i = find_term_bykeys(src[0]);
;               if (0 <= i)
;               {
;                   dest.be(dlen++, KB_SPECIAL);
;                   dest.be(dlen++, @termcodes[i].name.at(0));
;                   dest.be(dlen++, @termcodes[i].name.at(1));
;                   src[0] = src[0].plus(@termcodes[i].len);
                    ;; If terminal code matched, continue after it.
;                   continue;
;               }
;           }

;           if (do_special)
;           {
;               Bytes p = null;
;               int n = 0;

                ;; Replace <Leader> by the value of "mapleader".
                ;; Replace <LocalLeader> by the value of "maplocalleader".
                ;; If "mapleader" or "maplocalleader" isn't set use a backslash.

;               if (STRNCASECMP(src[0], u8("<Leader>"), 8) == 0)
;               {
;                   p = null;
;                   n = 8;
;               }
;               else if (STRNCASECMP(src[0], u8("<LocalLeader>"), 13) == 0)
;               {
;                   p = null;
;                   n = 13;
;               }

;               if (n != 0)
;               {
                    ;; Allow up to 8 * 6 characters for "mapleader".
;                   if (p == null || p.at(0) == NUL || 8 * 6 < STRLEN(p))
;                       p = u8("\\");
;                   while (p.at(0) != NUL)
;                       dest.be(dlen++, (p = p.plus(1)).at(-1));
;                   src[0] = src[0].plus(n);
;                   continue;
;               }
;           }

            ;; Remove CTRL-V and ignore the next character.
            ;; For "from" side the CTRL-V at the end is included, for the "to" part it is removed.
            ;; If 'cpoptions' does not contain 'B', also accept a backslash.

;           byte key = src[0].at(0);
;           if (key == Ctrl_V || (do_backslash && key == '\\'))
;           {
;               src[0] = src[0].plus(1);                              ;; skip CTRL-V or backslash
;               if (src[0].at(0) == NUL)
;               {
;                   if (from_part)
;                       dest.be(dlen++, key);
;                   break;
;               }
;           }

            ;; skip multibyte char correctly
;           for (int n = us_ptr2len_cc(src[0]); 0 < n--; src[0] = src[0].plus(1))
;           {
                ;; If the character is KB_SPECIAL, replace it with KB_SPECIAL KS_SPECIAL KE_FILLER.
                ;; If compiled with the GUI replace CSI with K_CSI.

;               if (src[0].at(0) == KB_SPECIAL)
;               {
;                   dest.be(dlen++, KB_SPECIAL);
;                   dest.be(dlen++, KS_SPECIAL);
;                   dest.be(dlen++, KE_FILLER);
;               }
;               else
;                   dest.be(dlen++, src[0].at(0));
;           }
;       }
;       dest.be(dlen, NUL);

        ;; Copy the new string to allocated memory.

;       return STRDUP(dest);
    ))

;; Find a termcode with keys 'src' (must be NUL terminated).
;; Return the index in termcodes[], or -1 if not found.

(defn- #_int find_term_bykeys [#_Bytes src]
    (§
;       int slen = STRLEN(src);

;       for (int i = 0; i < @tc_len; i++)
;       {
;           if (slen == @termcodes[i].len && STRNCMP(@termcodes[i].code, src, slen) == 0)
;               return i;
;       }
;       return -1;
    ))

;; Gather the first characters in the terminal key codes into a string.
;; Used to speed up check_termcode().

(defn- #_void gather_termleader []
    (§
;       int len = 0;

;       if (@check_for_codes)
;           termleader.be(len++, DCS);    ;; the termcode response starts with DCS in 8-bit mode
;       termleader.be(len, NUL);

;       for (int i = 0; i < @tc_len; i++)
;           if (vim_strchr(termleader, @termcodes[i].code.at(0)) == null)
;           {
;               termleader.be(len++, @termcodes[i].code.at(0));
;               termleader.be(len, NUL);
;           }

;       @need_gather = false;
    ))

;; Show all termcodes (for ":set termcap").
;; This code looks a lot like showoptions(), but is different.

(defn- #_void show_termcodes []
    (§
;       if (@tc_len == 0)        ;; no terminal codes (must be GUI)
;           return;

;       final int INC3 = 27;    ;; try to make three columns
;       final int INC2 = 40;    ;; try to make two columns
;       final int GAP2 = 2;     ;; spaces between columns

;       int[] items = new int[@tc_len];

        ;; Highlight title.
;       msg_puts_title(u8("\n--- Terminal keys ---"));

        ;; do the loop two times:
        ;; 1. display the short items (non-strings and short strings)
        ;; 2. display the medium items (medium length strings)
        ;; 3. display the long items (remaining strings)

;       for (int run = 1; run <= 3 && !@got_int; run++)
;       {
            ;; collect the items in items[]

;           int n = 0;
;           for (int i = 0; i < @tc_len; i++)
;           {
;               int len = show_one_termcode(@termcodes[i].name, @termcodes[i].code, false);
;               if (len <= INC3 - GAP2 ? run == 1 : len <= INC2 - GAP2 ? run == 2 : run == 3)
;                   items[n++] = i;
;           }

            ;; display the items

;           int rows;
;           if (run <= 2)
;           {
;               int cols = ((int)@Columns + GAP2) / (run == 1 ? INC3 : INC2);
;               if (cols == 0)
;                   cols = 1;
;               rows = (n + cols - 1) / cols;
;           }
;           else    ;; run == 3
;               rows = n;

;           for (int row = 0; row < rows && !@got_int; row++)
;           {
;               msg_putchar('\n');                  ;; go to next line
;               if (@got_int)                        ;; 'q' typed in more
;                   break;

;               for (int i = row, col = 0; i < n; i += rows, col += (run == 2) ? INC2 : INC3)
;               {
;                   @msg_col = col;                  ;; make columns
;                   show_one_termcode(@termcodes[items[i]].name, @termcodes[items[i]].code, true);
;               }
;               out_flush();
;               ui_breakcheck();
;           }
;       }
    ))

;; Show one termcode entry.
;; Output goes into ioBuff[].

(defn- #_int show_one_termcode [#_Bytes name, #_Bytes code, #_boolean printit]
    (§
;       if ('~' < char_u(name.at(0)))
;       {
;           @ioBuff.be(0, (byte)' ');
;           @ioBuff.be(1, (byte)' ');
;           @ioBuff.be(2, (byte)' ');
;           @ioBuff.be(3, (byte)' ');
;       }
;       else
;       {
;           @ioBuff.be(0, (byte)'t');
;           @ioBuff.be(1, (byte)'_');
;           @ioBuff.be(2, name.at(0));
;           @ioBuff.be(3, name.at(1));
;       }
;       @ioBuff.be(4, (byte)' ');

;       Bytes p = get_special_key_name(TERMCAP2KEY(name.at(0), name.at(1)), 0);
;       if (p.at(1) != (byte)'t')
;           STRCPY(@ioBuff.plus(5), p);
;       else
;           @ioBuff.be(5, NUL);

;       int len = STRLEN(@ioBuff);
;       do
;       {
;           @ioBuff.be(len++, (byte)' ');
;       } while (len < 17);
;       @ioBuff.be(len, NUL);
;       len += (code != null) ? mb_string2cells(code, -1) : 4;

;       if (printit)
;       {
;           msg_puts(@ioBuff);
;           if (code != null)
;               msg_outtrans(code);
;           else
;               msg_puts(u8("NULL"));
;       }

;       return len;
    ))

;; For Xterm >= 140 compiled with OPT_TCAP_QUERY:
;; obtain the actually used termcap codes from the terminal itself.
;; We get them one by one to avoid a very long response string.

(atom! int xt_index_in)
(atom! int xt_index_out)

(defn- #_void req_codes_from_term []
    (§
;       @xt_index_in = 0;
;       @xt_index_out = 0;
;       req_more_codes_from_term();
    ))

(defn- #_void req_more_codes_from_term []
    (§
        ;; Don't do anything when going to exit.
;       if (@exiting)
;           return;

;       int old_idx = @xt_index_out;

        ;; Send up to 10 more requests out than we received.
        ;; Avoid sending too many, there can be a buffer overflow somewhere.
;       for ( ; @xt_index_out < @xt_index_in + 10 && key_names[@xt_index_out] != null; @xt_index_out++)
;       {
;           Bytes buf = new Bytes(10 + 1);

;           libC.sprintf(buf, u8("\033P+q%02x%02x\033\\"), key_names[@xt_index_out].at(0), key_names[@xt_index_out].at(1));
;           out_str_nf(buf);
;       }

        ;; Send the codes out right away.
;       if (@xt_index_out != old_idx)
;           out_flush();
    ))

;; Decode key code response from xterm: '<Esc>P1+r<name>=<string><Esc>\'.
;; A "0" instead of the "1" indicates a code that isn't supported.
;; Both <name> and <string> are encoded in hex.
;; "code" points to the "0" or "1".

(defn- #_void got_code_from_term [#_Bytes code, #_int len]
    (§
;       final int XT_LEN = 100;
;       Bytes str = new Bytes(XT_LEN);

        ;; A '1' means the code is supported, a '0' means it isn't.
        ;; When half the length is > XT_LEN we can't use it.
        ;; Our names are currently all 2 characters.
;       if (code.at(0) == (byte)'1' && code.at(7) == (byte)'=' && len / 2 < XT_LEN)
;       {
;           Bytes name = new Bytes(3);

            ;; Get the name from the response and find it in the table.
;           name.be(0, hexhex2nr(code.plus(3)));
;           name.be(1, hexhex2nr(code.plus(5)));
;           name.be(2, NUL);

;           int k;
;           for (k = 0; key_names[k] != null; k++)
;               if (STRCMP(key_names[k], name) == 0)
;               {
;                   @xt_index_in = k;
;                   break;
;               }

;           if (key_names[k] != null)
;           {
;               int j = 0;
;               for (int i = 8; ; i += 2)
;               {
;                   int x = hexhex2nr(code.plus(i));
;                   if (x < 0)
;                       break;
;                   str.be(j++, x);
;               }
;               str.be(j, NUL);

;               if (name.at(0) == (byte)'C' && name.at(1) == (byte)'o')
;               {
                    ;; Color count is not a key code.
;                   int i = libC.atoi(str);
;                   if (i != @t_colors)
;                   {
                        ;; Nr of colors changed, initialize highlighting and redraw everything.
                        ;; This causes a redraw, which usually clears the message.
                        ;; Try keeping the message if it might work.
;                       set_keep_msg_from_hist();
;                       set_color_count(i);
;                       init_highlight(true, false);
;                       redraw_asap(CLEAR);
;                   }
;               }
;               else
;               {
                    ;; First delete any existing entry with the same code.
;                   int i = find_term_bykeys(str);
;                   if (0 <= i)
;                       del_termcode_idx(i);
;                   add_termcode(name, str, ATC_FROM_TERM);
;               }
;           }
;       }

        ;; May request more codes now that we received one.
;       @xt_index_in++;
;       req_more_codes_from_term();
    ))

;; Check if there are any unanswered requests and deal with them.
;; This is called before starting an external program or getting direct keyboard input.
;; We don't want responses to be send to that program or handled as typed text.

(defn- #_void check_for_codes_from_term []
    (§
        ;; If no codes requested or all are answered, no need to wait.
;       if (@xt_index_out == 0 || @xt_index_out == @xt_index_in)
;           return;

        ;; vgetc() will check for and handle any response.
        ;; Keep calling vpeekc() until we don't get any responses.
;       @no_mapping++;
;       @allow_keys++;
;       for ( ; ; )
;       {
;           int c = vpeekc();
;           if (c == NUL)       ;; nothing available
;               break;

            ;; If a response is recognized it's replaced with K_IGNORE, must read it from the input stream.
            ;; If there is no K_IGNORE we can't do anything, break here
            ;; (there might be some responses further on, but we don't want to throw away any typed chars).

;           if (c != char_u(KB_SPECIAL) && c != K_IGNORE)
;               break;
;           c = vgetc();
;           if (c != K_IGNORE)
;           {
;               vungetc(c);
;               break;
;           }
;       }
;       --@no_mapping;
;       --@allow_keys;
    ))

;; Translate an internal mapping/abbreviation representation into the
;; corresponding external one recognized by :map/:abbrev commands;
;; respects the current B/k/< settings of 'cpoption'.
;;
;; This function is called when expanding mappings/abbreviations on the
;; command-line, and for building the "Ambiguous mapping..." error message.
;;
;; It uses a growarray to build the translation string since the latter
;; can be wider than the original description.  The caller has to free
;; the string afterwards.
;;
;; Returns null when there is a problem.

(defn- #_Bytes translate_mapping [#_Bytes s]
    (§
;       barray_C ba = new barray_C(40);

;       boolean cpo_bslash = (vim_strbyte(@p_cpo, CPO_BSLASH) != null);
;       boolean cpo_special = (vim_strbyte(@p_cpo, CPO_SPECI) != null);
;       boolean cpo_keycode = (vim_strbyte(@p_cpo, CPO_KEYCODE) == null);

;       for ( ; s.at(0) != NUL; s = s.plus(1))
;       {
;           int c = char_u(s.at(0));
;           if (c == char_u(KB_SPECIAL) && s.at(1) != NUL && s.at(2) != NUL)
;           {
;               int modifiers = 0;
;               if (s.at(1) == KS_MODIFIER)
;               {
;                   s = s.plus(1);
;                   modifiers = char_u((s = s.plus(1)).at(0));
;                   c = char_u((s = s.plus(1)).at(0));
;               }
;               if (cpo_special && cpo_keycode && c == char_u(KB_SPECIAL) && modifiers == 0)
;               {
                    ;; try to find special key in termcodes
;                   int i;
;                   for (i = 0; i < @tc_len; i++)
;                       if (@termcodes[i].name.at(0) == s.at(1) && @termcodes[i].name.at(1) == s.at(2))
;                           break;
;                   if (i < @tc_len)
;                   {
;                       ba_concat(ba, @termcodes[i].code);
;                       s = s.plus(2);
;                       continue;
;                   }
;               }
;               if (c == char_u(KB_SPECIAL) && s.at(1) != NUL && s.at(2) != NUL)
;               {
;                   if (cpo_special)
;                   {
;                       ba_clear(ba);
;                       return null;
;                   }
;                   c = toSpecial(s.at(1), s.at(2));
;                   if (c == K_ZERO)                ;; display <Nul> as ^@
;                       c = NUL;
;                   s = s.plus(2);
;               }
;               if (is_special(c) || modifiers != 0)    ;; special key
;               {
;                   if (cpo_special)
;                   {
;                       ba_clear(ba);
;                       return null;
;                   }
;                   ba_concat(ba, get_special_key_name(c, modifiers));
;                   continue;
;               }
;           }
;           if (c == ' ' || c == '\t' || c == Ctrl_J || c == Ctrl_V
;                   || (c == '<' && !cpo_special)
;                   || (c == '\\' && !cpo_bslash))
;               ba_append(ba, cpo_bslash ? Ctrl_V : (byte)'\\');
;           if (c != NUL)
;               ba_append(ba, (byte)c);
;       }

;       ba_append(ba, NUL);
;       return new Bytes(ba.ba_data);
    ))

;; ui.c: functions that handle the user interface.
;; 1. Keyboard input stuff, and a bit of windowing stuff.  These are called
;;    before the machine specific stuff (mch_*) so that we can call the GUI
;;    stuff instead if the GUI is running.
;; 2. Clipboard stuff.
;; 3. Input buffer stuff.

(defn- #_void ui_write [#_Bytes s, #_int len]
    (§
        ;; Don't output anything in silent mode ("ex -s") unless 'verbose' set.
;       if (!(@silent_mode && @p_verbose == 0))
;       {
;           mch_write(s, len);
;       }
    ))

;; ui_inchar(): low level input function.
;; Get characters from the keyboard.
;; Return the number of characters that are available.
;; If "wtime" == 0 do not wait for characters.
;; If "wtime" == -1 wait forever for characters.
;; If "wtime" > 0 wait "wtime" milliseconds for a character.
;;
;; "tb_change_cnt" is the value of typebuf.tb_change_cnt if "buf" points into it.
;; When typebuf.tb_change_cnt changes (e.g., when a message is received from a remote client)
;; "buf" can no longer be used.  "tb_change_cnt" is null otherwise.

(defn- #_int ui_inchar [#_Bytes buf, #_int maxlen, #_long wtime, #_int tb_change_cnt]
    ;; wtime: don't use "time", MIPS cannot handle it
    (§
        ;; If we are going to wait for some time or block...
;       if (wtime == -1 || 100L < wtime)
;       {
            ;; ... allow signals to kill us.
;           vim_handle_signal(SIGNAL_UNBLOCK);

            ;; ... there is no need for CTRL-C to interrupt something,
            ;; don't let it set got_int when it was mapped.
;           if (((@mapped_ctrl_c | @curbuf.b_mapped_ctrl_c) & get_real_state()) != 0)
;               @ctrl_c_interrupts = false;
;       }

;       int len = mch_inchar(buf, maxlen, wtime, tb_change_cnt);

;       if (wtime == -1 || 100L < wtime)
            ;; block SIGHUP et al.
;           vim_handle_signal(SIGNAL_BLOCK);

;       @ctrl_c_interrupts = true;

;       return len;
    ))

;; Delay for the given number of milliseconds.
;; If ignoreinput is false then we cancel the delay if a key is hit.

(defn- #_void ui_delay [#_long msec, #_boolean ignoreinput]
    (§
;       mch_delay(msec, ignoreinput);
    ))

;; If the machine has job control, use it to suspend the program,
;; otherwise fake it by starting a new shell.
;; When running the GUI iconify the window.

(defn- #_void ui_suspend []
    (§
;       mch_suspend();
    ))

;; Try to get the current Vim shell size.
;; Put the result in Rows and Columns.
;; Use the new sizes as defaults for 'columns' and 'lines'.
;; Return true when size could be determined, false otherwise.

(defn- #_boolean ui_get_shellsize []
    (§
;       boolean got = mch_get_shellsize();

;       check_shellsize();

        ;; adjust the default for 'lines' and 'columns'
;       if (got)
;       {
;           set_number_default(u8("lines"), @Rows);
;           set_number_default(u8("columns"), @Columns);
;       }

;       return got;
    ))

;; Set the size of the Vim shell according to Rows and Columns, if possible.
;; The gui_set_shellsize() or mch_set_shellsize() function will try to set the new size.
;; If this is not possible, it will adjust Rows and Columns.

(defn- #_void ui_set_shellsize [#_boolean _mustset]
    ;; mustset: set by the user
    (§
;       mch_set_shellsize();
    ))

;; Called when Rows and/or Columns changed.  Adjust scroll region and mouse region.

(defn- #_void ui_new_shellsize []
    (§
;       if (@full_screen && !@exiting)
;           mch_new_shellsize();
    ))

(defn- #_void ui_breakcheck []
    (§
;       mch_breakcheck();
    ))

;; Functions for copying and pasting text between applications.
;;
;; This is always included in a GUI version, but may also be included when
;; the clipboard and mouse is available to a terminal version such as xterm.
;; Note: there are some more functions in ops.c that handle selection stuff.
;;
;; Also note that the majority of functions here deal with the X 'primary'
;; (visible - for Visual mode use) selection, and only that.  There are no versions
;; of these for the 'clipboard' selection, as Visual mode has no use for them.

;; Selection stuff using Visual mode, for cutting and pasting text to other windows.

;; Call this to initialise the clipboard.  Pass it false if the clipboard code
;; is included, but the clipboard can not be used, or true if the clipboard can be used.
;; E.g. unix may call this with false, then call it again with true if the GUI starts.

(defn- #_void clip_init [#_boolean can_use]
    (§
;       for (clipboard_C cbd = @clip_star; ; )
;       {
;           cbd.available  = can_use;
;           cbd.owned      = false;
;           cbd.cbd_start.lnum = 0;
;           cbd.cbd_start.col  = 0;
;           cbd.cbd_end.lnum   = 0;
;           cbd.cbd_end.col    = 0;
;           cbd.state      = SELECT_CLEARED;

;           if (cbd == @clip_plus)
;               break;
;           cbd = @clip_plus;
;       }
    ))

;; Check whether the VIsual area has changed, and if so try to become the owner
;; of the selection, and free any old converted selection we may still have
;; lying around.  If the VIsual mode has ended, make a copy of what was
;; selected so we can still give it to others.  Will probably have to make sure
;; this is called whenever VIsual mode is ended.

(defn- #_void clip_update_selection [#_clipboard_C cbd]
    (§
        ;; If visual mode is only due to a redo command ("."), then ignore it.
;       if (!@redo_VIsual_busy && @VIsual_active && (@State & NORMAL) != 0)
;       {
;           pos_C start = §_pos_C();
;           pos_C end = §_pos_C();
;           if (ltpos(@VIsual, @curwin.w_cursor))
;           {
;               COPY_pos(start, @VIsual);
;               COPY_pos(end, @curwin.w_cursor);
;               end.col += us_ptr2len_cc(ml_get_cursor()) - 1;
;           }
;           else
;           {
;               COPY_pos(start, @curwin.w_cursor);
;               COPY_pos(end, @VIsual);
;           }

;           if (!eqpos(cbd.cbd_start, start) || !eqpos(cbd.cbd_end, end) || cbd.vmode != @VIsual_mode)
;           {
;               clip_clear_selection(cbd);
;               COPY_pos(cbd.cbd_start, start);
;               COPY_pos(cbd.cbd_end, end);
;               cbd.vmode = @VIsual_mode;
;               clip_free_selection(cbd);
;               clip_own_selection(cbd);
;               clip_gen_set_selection(cbd);
;           }
;       }
    ))

(defn- #_void clip_own_selection [#_clipboard_C cbd]
    (§
        ;; Also want to check somehow that we are reading from the keyboard rather than a mapping etc.

        ;; Only own the clipboard when we didn't own it yet.
;       if (!cbd.owned && cbd.available)
;           cbd.owned = (clip_gen_own_selection(cbd) == true);
    ))

(defn- #_void clip_lose_selection [#_clipboard_C cbd]
    (§
;       boolean visual_selection = false;

;       if (cbd == @clip_star || cbd == @clip_plus)
;           visual_selection = true;

;       clip_free_selection(cbd);
;       cbd.owned = false;
;       if (visual_selection)
;           clip_clear_selection(cbd);
;       clip_gen_lose_selection(cbd);
    ))

(defn- #_void clip_copy_selection [#_clipboard_C cbd]
    (§
;       if (@VIsual_active && (@State & NORMAL) != 0 && cbd.available)
;       {
;           clip_update_selection(cbd);
;           clip_free_selection(cbd);
;           clip_own_selection(cbd);
;           if (cbd.owned)
;               clip_get_selection(cbd);
;           clip_gen_set_selection(cbd);
;       }
    ))

;; Save and restore "clip_unnamed" before doing possibly many changes.
;; This prevents accessing the clipboard very often which might slow down Vim considerably.

(atom! int global_change_count)         ;; if set, inside a start_global_changes
(atom! boolean clipboard_needs_update)  ;; clipboard needs to be updated

;; Save "clip_unnamed" and reset it.

(defn- #_void start_global_changes []
    (§
;       if (1 < ++@global_change_count)
;           return;

;       @clip_unnamed_saved = @clip_unnamed;
;       @clipboard_needs_update = false;

;       if (@clip_did_set_selection)
;       {
;           @clip_unnamed = 0;
;           @clip_did_set_selection = false;
;       }
    ))

;; Restore "clip_unnamed" and set the selection when needed.

(defn- #_void end_global_changes []
    (§
;       if (0 < --@global_change_count)  ;; recursive
;           return;

;       if (!@clip_did_set_selection)
;       {
;           @clip_did_set_selection = true;
;           @clip_unnamed = @clip_unnamed_saved;
;           @clip_unnamed_saved = 0;
;           if (@clipboard_needs_update)
;           {
                ;; only store something in the clipboard,
                ;; if we have yanked anything to it
;               if ((@clip_unnamed & CLIP_UNNAMED) != 0)
;               {
;                   clip_own_selection(@clip_star);
;                   clip_gen_set_selection(@clip_star);
;               }
;               if ((@clip_unnamed & CLIP_UNNAMED_PLUS) != 0)
;               {
;                   clip_own_selection(@clip_plus);
;                   clip_gen_set_selection(@clip_plus);
;               }
;           }
;       }
    ))

;; Called when Visual mode is ended: update the selection.

(defn- #_void clip_auto_select []
    (§
;       if (clip_isautosel_star())
;           clip_copy_selection(@clip_star);
;       if (clip_isautosel_plus())
;           clip_copy_selection(@clip_plus);
    ))

;; Return true if automatic selection of Visual area is desired for the * register.

(defn- #_boolean clip_isautosel_star []
    (§
;       return @clip_autoselect_star;
    ))

;; Return true if automatic selection of Visual area is desired for the + register.

(defn- #_boolean clip_isautosel_plus []
    (§
;       return @clip_autoselect_plus;
    ))

;; Stuff for general mouse selection, without using Visual mode.

;; flags for clip_invert_area()
(final int CLIP_CLEAR      1)
(final int CLIP_SET        2)
(final int CLIP_TOGGLE     3)

;; Start, continue or end a modeless selection.
;; Used when editing the command-line and in the cmdline window.

(defn- #_void clip_modeless [#_int button, #_boolean is_click, #_boolean is_drag]
    (§
;       boolean repeat = ((@clip_star.mode == SELECT_MODE_CHAR || @clip_star.mode == SELECT_MODE_LINE)
;                                                   && (@mod_mask & MOD_MASK_2CLICK) != 0)
;                      || (@clip_star.mode == SELECT_MODE_WORD
;                                                   && (@mod_mask & MOD_MASK_3CLICK) != 0);
;       if (is_click && button == MOUSE_RIGHT)
;       {
            ;; Right mouse button: if there was no selection, start one;
            ;; otherwise extend the existing selection.
;           if (@clip_star.state == SELECT_CLEARED)
;               clip_start_selection(@mouse_col, @mouse_row, false);
;           clip_process_selection(button, @mouse_col, @mouse_row, repeat);
;       }
;       else if (is_click)
;           clip_start_selection(@mouse_col, @mouse_row, repeat);
;       else if (is_drag)
;       {
            ;; Don't try extending a selection if there isn't one.  Happens when
            ;; button-down is in the cmdline and them moving mouse upwards.
;           if (@clip_star.state != SELECT_CLEARED)
;               clip_process_selection(button, @mouse_col, @mouse_row, repeat);
;       }
;       else ;; release
;           clip_process_selection(MOUSE_RELEASE, @mouse_col, @mouse_row, false);
    ))

;; Compare two screen positions ala strcmp()

(defn- #_int clip_compare_pos [#_int row1, #_int col1, #_int row2, #_int col2]
    (§
;       if (row1 > row2) return 1;
;       if (row1 < row2) return -1;
;       if (col1 > col2) return 1;
;       if (col1 < col2) return -1;

;       return 0;
    ))

;; Start the selection

(defn- #_void clip_start_selection [#_int col, #_int row, #_boolean repeated_click]
    (§
;       clipboard_C cbd = @clip_star;

;       if (cbd.state == SELECT_DONE)
;           clip_clear_selection(cbd);

;       row = check_row(row);
;       col = check_col(col);
;       col = mb_fix_col(col, row);

;       cbd.cbd_start.lnum = row;
;       cbd.cbd_start.col = col;
;       COPY_pos(cbd.cbd_end, cbd.cbd_start);
;       cbd.origin_row = (int)cbd.cbd_start.lnum;
;       cbd.state = SELECT_IN_PROGRESS;

;       if (repeated_click)
;       {
;           if (SELECT_MODE_LINE < ++cbd.mode)
;               cbd.mode = SELECT_MODE_CHAR;
;       }
;       else
;           cbd.mode = SELECT_MODE_CHAR;

;       switch (cbd.mode)
;       {
;           case SELECT_MODE_CHAR:
;               cbd.origin_start_col = cbd.cbd_start.col;
;               cbd.word_end_col = clip_get_line_end((int)cbd.cbd_start.lnum);
;               break;

;           case SELECT_MODE_WORD:
;               clip_get_word_boundaries(cbd, (int)cbd.cbd_start.lnum, cbd.cbd_start.col);
;               cbd.origin_start_col = cbd.word_start_col;
;               cbd.origin_end_col   = cbd.word_end_col;

;               clip_invert_area((int)cbd.cbd_start.lnum, cbd.word_start_col,
;                                (int)cbd.cbd_end.lnum, cbd.word_end_col, CLIP_SET);
;               cbd.cbd_start.col = cbd.word_start_col;
;               cbd.cbd_end.col   = cbd.word_end_col;
;               break;

;           case SELECT_MODE_LINE:
;               clip_invert_area((int)cbd.cbd_start.lnum, 0,
;                                (int)cbd.cbd_start.lnum, (int)@Columns, CLIP_SET);
;               cbd.cbd_start.col = 0;
;               cbd.cbd_end.col   = (int)@Columns;
;               break;
;       }

;       COPY_pos(cbd.cbd_prev, cbd.cbd_start);
    ))

;; Continue processing the selection

(defn- #_void clip_process_selection [#_int button, #_int col, #_int row, #_boolean repeated_click]
    (§
;       clipboard_C cbd = @clip_star;

;       if (button == MOUSE_RELEASE)
;       {
            ;; Check to make sure we have something selected.
;           if (cbd.cbd_start.lnum == cbd.cbd_end.lnum && cbd.cbd_start.col == cbd.cbd_end.col)
;           {
;               cbd.state = SELECT_CLEARED;
;               return;
;           }

;           if (clip_isautosel_star() || (@clip_autoselectml))
;               clip_copy_modeless_selection(false);

;           cbd.state = SELECT_DONE;
;           return;
;       }

;       row = check_row(row);
;       col = check_col(col);
;       col = mb_fix_col(col, row);

;       if (col == cbd.cbd_prev.col && row == cbd.cbd_prev.lnum && !repeated_click)
;           return;

        ;; When extending the selection with the right mouse button, swap the
        ;; start and end if the position is before half the selection

;       if (cbd.state == SELECT_DONE && button == MOUSE_RIGHT)
;       {
            ;; If the click is before the start, or the click is inside the
            ;; selection and the start is the closest side, set the origin to the
            ;; end of the selection.

;           int diff;
;           if (clip_compare_pos(row, col, (int)cbd.cbd_start.lnum, cbd.cbd_start.col) < 0
;                   || (clip_compare_pos(row, col, (int)cbd.cbd_end.lnum, cbd.cbd_end.col) < 0
;                       && (((cbd.cbd_start.lnum == cbd.cbd_end.lnum
;                               && col - cbd.cbd_start.col < cbd.cbd_end.col - col))
;                           || (0 < (diff = ((int)cbd.cbd_end.lnum - row) - (row - (int)cbd.cbd_start.lnum))
;                                   || (diff == 0 && col < (cbd.cbd_start.col + cbd.cbd_end.col) / 2)))))
;           {
;               cbd.origin_row = (int)cbd.cbd_end.lnum;
;               cbd.origin_start_col = cbd.cbd_end.col - 1;
;               cbd.origin_end_col = cbd.cbd_end.col;
;           }
;           else
;           {
;               cbd.origin_row = (int)cbd.cbd_start.lnum;
;               cbd.origin_start_col = cbd.cbd_start.col;
;               cbd.origin_end_col = cbd.cbd_start.col;
;           }
;           if (cbd.mode == SELECT_MODE_WORD && !repeated_click)
;               cbd.mode = SELECT_MODE_CHAR;
;       }

        ;; set state, for when using the right mouse button
;       cbd.state = SELECT_IN_PROGRESS;

;       if (repeated_click && SELECT_MODE_LINE < ++cbd.mode)
;           cbd.mode = SELECT_MODE_CHAR;

;       switch (cbd.mode)
;       {
;           case SELECT_MODE_CHAR:
                ;; If we're on a different line, find where the line ends.
;               if (row != cbd.cbd_prev.lnum)
;                   cbd.word_end_col = clip_get_line_end(row);

                ;; See if we are before or after the origin of the selection.
;               if (0 <= clip_compare_pos(row, col, cbd.origin_row, cbd.origin_start_col))
;               {
;                   if (cbd.word_end_col <= col)
;                       clip_update_modeless_selection(cbd,
;                           cbd.origin_row, cbd.origin_start_col, row, (int)@Columns);
;                   else
;                   {
;                       int slen = 1;       ;; cursor shape width
;                       if (mb_lefthalve(row, col))
;                           slen = 2;
;                       clip_update_modeless_selection(cbd,
;                           cbd.origin_row, cbd.origin_start_col, row, col + slen);
;                   }
;               }
;               else
;               {
;                   int slen = 1;       ;; cursor shape width
;                   if (mb_lefthalve(cbd.origin_row, cbd.origin_start_col))
;                       slen = 2;
;                   if (cbd.word_end_col <= col)
;                       clip_update_modeless_selection(cbd,
;                           row, cbd.word_end_col, cbd.origin_row, cbd.origin_start_col + slen);
;                   else
;                       clip_update_modeless_selection(cbd,
;                           row, col, cbd.origin_row, cbd.origin_start_col + slen);
;               }
;               break;

;           case SELECT_MODE_WORD:
                ;; If we are still within the same word, do nothing.
;               if (row == cbd.cbd_prev.lnum
;                       && cbd.word_start_col <= col && col < cbd.word_end_col && !repeated_click)
;                   return;

                ;; Get new word boundaries.
;               clip_get_word_boundaries(cbd, row, col);

                ;; Handle being after the origin point of selection.
;               if (0 <= clip_compare_pos(row, col, cbd.origin_row, cbd.origin_start_col))
;                   clip_update_modeless_selection(cbd,
;                       cbd.origin_row, cbd.origin_start_col, row, cbd.word_end_col);
;               else
;                   clip_update_modeless_selection(cbd,
;                       row, cbd.word_start_col, cbd.origin_row, cbd.origin_end_col);
;               break;

;           case SELECT_MODE_LINE:
;               if (row == cbd.cbd_prev.lnum && !repeated_click)
;                   return;

;               if (0 <= clip_compare_pos(row, col, cbd.origin_row, cbd.origin_start_col))
;                   clip_update_modeless_selection(cbd, cbd.origin_row, 0, row, (int)@Columns);
;               else
;                   clip_update_modeless_selection(cbd, row, 0, cbd.origin_row, (int)@Columns);
;               break;
;       }

;       cbd.cbd_prev.lnum = row;
;       cbd.cbd_prev.col  = col;
    ))

;; Called from outside to clear selected region from the display

(defn- #_void clip_clear_selection [#_clipboard_C cbd]
    (§
;       if (cbd.state == SELECT_CLEARED)
;           return;

;       clip_invert_area((int)cbd.cbd_start.lnum, cbd.cbd_start.col, (int)cbd.cbd_end.lnum, cbd.cbd_end.col, CLIP_CLEAR);
;       cbd.state = SELECT_CLEARED;
    ))

;; Clear the selection if any lines from "row1" to "row2" are inside of it.

(defn- #_void clip_may_clear_selection [#_int row1, #_int row2]
    (§
;       if (@clip_star.state == SELECT_DONE && @clip_star.cbd_start.lnum <= row2 && row1 <= @clip_star.cbd_end.lnum)
;           clip_clear_selection(@clip_star);
    ))

;; Called before the screen is scrolled up or down.  Adjusts the line numbers
;; of the selection.  Call with big number when clearing the screen.

(defn- #_void clip_scroll_selection [#_int rows]
    ;; rows: negative for scroll down
    (§
;       if (@clip_star.state == SELECT_CLEARED)
;           return;

;       long lnum = @clip_star.cbd_start.lnum - rows;
;       if (lnum <= 0)
;           @clip_star.cbd_start.lnum = 0;
;       else if (@screenRows <= lnum)                ;; scrolled off of the screen
;           @clip_star.state = SELECT_CLEARED;
;       else
;           @clip_star.cbd_start.lnum = lnum;

;       lnum = @clip_star.cbd_end.lnum - rows;
;       if (lnum < 0)                               ;; scrolled off of the screen
;           @clip_star.state = SELECT_CLEARED;
;       else if (@screenRows <= lnum)
;           @clip_star.cbd_end.lnum = @screenRows - 1;
;       else
;           @clip_star.cbd_end.lnum = lnum;
    ))

;; Invert a region of the display between a starting and ending row and column
;; Values for "how":
;; CLIP_CLEAR:  undo inversion
;; CLIP_SET:    set inversion
;; CLIP_TOGGLE: set inversion if pos1 < pos2, undo inversion otherwise.
;; 0: invert (GUI only).

(defn- #_void clip_invert_area [#_int row1, #_int col1, #_int row2, #_int col2, #_int how]
    (§
;       boolean invert = false;

;       if (how == CLIP_SET)
;           invert = true;

        ;; Swap the from and to positions so the from is always before.
;       if (0 < clip_compare_pos(row1, col1, row2, col2))
;       {
;           int _row, _col;

;           _row = row1;
;           _col = col1;
;           row1 = row2;
;           col1 = col2;
;           row2 = _row;
;           col2 = _col;
;       }
;       else if (how == CLIP_TOGGLE)
;           invert = true;

        ;; If all on the same line, do it the easy way.
;       if (row1 == row2)
;       {
;           clip_invert_rectangle(row1, col1, 1, col2 - col1, invert);
;       }
;       else
;       {
            ;; Handle a piece of the first line.
;           if (0 < col1)
;           {
;               clip_invert_rectangle(row1, col1, 1, (int)@Columns - col1, invert);
;               row1++;
;           }

            ;; Handle a piece of the last line.
;           if (col2 < (int)@Columns - 1)
;           {
;               clip_invert_rectangle(row2, 0, 1, col2, invert);
;               row2--;
;           }

            ;; Handle the rectangle thats left.
;           if (row1 <= row2)
;               clip_invert_rectangle(row1, 0, row2 - row1 + 1, (int)@Columns, invert);
;       }
    ))

;; Invert or un-invert a rectangle of the screen.
;; "invert" is true if the result is inverted.

(defn- #_void clip_invert_rectangle [#_int row, #_int col, #_int height, #_int width, #_boolean invert]
    (§
;       screen_draw_rectangle(row, col, height, width, invert);
    ))

;; Copy the currently selected area into the '*' register so it will be available for pasting.
;; When "both" is true also copy to the '+' register.

(defn- #_void clip_copy_modeless_selection [#_boolean _both]
    (§
        ;; Can't use "screenLines" unless initialized.
;       if (@screenLines == null)
;           return;

;       int row1 = (int)@clip_star.cbd_start.lnum;
;       int col1 = @clip_star.cbd_start.col;
;       int row2 = (int)@clip_star.cbd_end.lnum;
;       int col2 = @clip_star.cbd_end.col;

        ;; Make sure row1 <= row2, and if row1 == row2 that col1 <= col2.

;       int row;
;       if (row2 < row1)
;       {
;           row = row1; row1 = row2; row2 = row;
;           row = col1; col1 = col2; col2 = row;
;       }
;       else if (row1 == row2 && col2 < col1)
;       {
;           row = col1; col1 = col2; col2 = row;
;       }
        ;; Correct starting point for being on right halve of double-wide char.
;       Bytes p = @screenLines.plus(@lineOffset[row1]);
;       if (p.at(col1) == 0)
;           --col1;

        ;; Create a temporary buffer for storing the text.
;       int len = (row2 - row1 + 1) * (int)@Columns + 1;
;       len *= MB_MAXBYTES;
;       Bytes buffer = new Bytes(len);

;       boolean add_newline_flag = false;

        ;; Process each row in the selection.
;       Bytes bufp;
;       for (bufp = buffer, row = row1; row <= row2; row++)
;       {
;           int start_col;
;           if (row == row1)
;               start_col = col1;
;           else
;               start_col = 0;

;           int end_col;
;           if (row == row2)
;               end_col = col2;
;           else
;               end_col = (int)@Columns;

;           int line_end_col = clip_get_line_end(row);

            ;; See if we need to nuke some trailing whitespace.
;           if ((int)@Columns <= end_col && (row < row2 || line_end_col < end_col))
;           {
                ;; Get rid of trailing whitespace.
;               end_col = line_end_col;
;               if (end_col < start_col)
;                   end_col = start_col;

                ;; If the last line extended to the end, add an extra newline.
;               if (row == row2)
;                   add_newline_flag = true;
;           }

            ;; If after the first row, we need to always add a newline.
;           if (row1 < row && !@lineWraps[row - 1])
;               (bufp = bufp.plus(1)).be(-1, NL);

;           if (row < @screenRows && end_col <= @screenColumns)
;           {
;               int off = @lineOffset[row];

;               for (int i = start_col; i < end_col; i++)
;               {
                    ;; The base character is either in screenLinesUC[] or screenLines[].
;                   if (@screenLinesUC[off + i] == 0)
;                       (bufp = bufp.plus(1)).be(-1, @screenLines.at(off + i));
;                   else
;                   {
;                       bufp = bufp.plus(utf_char2bytes(@screenLinesUC[off + i], bufp));
;                       for (int ci = 0; ci < @screen_mco; ci++)
;                       {
                            ;; Add a composing character.
;                           if (@screenLinesC[ci][off + i] == 0)
;                               break;
;                           bufp = bufp.plus(utf_char2bytes(@screenLinesC[ci][off + i], bufp));
;                       }
;                   }
                    ;; Skip right halve of double-wide character.
;                   if (@screenLines.at(off + i + 1) == 0)
;                       i++;
;               }
;           }
;       }

        ;; Add a newline at the end if the selection ended there.
;       if (add_newline_flag)
;           (bufp = bufp.plus(1)).be(-1, NL);

        ;; First cleanup any old selection and become the owner.
;       clip_free_selection(@clip_star);
;       clip_own_selection(@clip_star);

        ;; Yank the text into the '*' register.
;       clip_yank_selection(MCHAR, buffer, BDIFF(bufp, buffer), @clip_star);

        ;; Make the register contents available to the outside world.
;       clip_gen_set_selection(@clip_star);
    ))

;; Find the starting and ending positions of the word at the given row and column.
;; Only white-separated words are recognized here.

(defn- #_int __char_class [#_int c]
    (§
;       return (c <= ' ') ? ' ' : vim_iswordc(c, @curbuf) ? TRUE : FALSE;
    ))

(defn- #_void clip_get_word_boundaries [#_clipboard_C cbd, #_int row, #_int col]
    (§
;       if (@screenRows <= row || @screenColumns <= col || @screenLines == null)
;           return;

;       Bytes p = @screenLines.plus(@lineOffset[row]);
        ;; Correct for starting in the right halve of a double-wide char.
;       if (p.at(col) == 0)
;           --col;
;       int start_class = __char_class(p.at(col));

;       int temp_col = col;
;       for ( ; 0 < temp_col; temp_col--)
;           if (__char_class(p.at(temp_col - 1)) != start_class && p.at(temp_col - 1) != 0)
;               break;
;       cbd.word_start_col = temp_col;

;       temp_col = col;
;       for ( ; temp_col < @screenColumns; temp_col++)
;           if (__char_class(p.at(temp_col)) != start_class && p.at(temp_col) != 0)
;               break;
;       cbd.word_end_col = temp_col;
    ))

;; Find the column position for the last non-whitespace character on the given line.

(defn- #_int clip_get_line_end [#_int row]
    (§
;       if (@screenRows <= row || @screenLines == null)
;           return 0;

;       int i;
;       for (i = @screenColumns; 0 < i; i--)
;           if (@screenLines.at(@lineOffset[row] + i - 1) != (byte)' ')
;               break;
;       return i;
    ))

;; Update the currently selected region by adding and/or subtracting from the
;; beginning or end and inverting the changed area(s).

(defn- #_void clip_update_modeless_selection [#_clipboard_C cbd, #_int row1, #_int col1, #_int row2, #_int col2]
    (§
        ;; See if we changed at the beginning of the selection.
;       if (row1 != cbd.cbd_start.lnum || col1 != cbd.cbd_start.col)
;       {
;           clip_invert_area(row1, col1, (int)cbd.cbd_start.lnum, cbd.cbd_start.col, CLIP_TOGGLE);
;           cbd.cbd_start.lnum = row1;
;           cbd.cbd_start.col  = col1;
;       }

        ;; See if we changed at the end of the selection.
;       if (row2 != cbd.cbd_end.lnum || col2 != cbd.cbd_end.col)
;       {
;           clip_invert_area((int)cbd.cbd_end.lnum, cbd.cbd_end.col, row2, col2, CLIP_TOGGLE);
;           cbd.cbd_end.lnum = row2;
;           cbd.cbd_end.col  = col2;
;       }
    ))

(defn- #_boolean clip_gen_own_selection [#_clipboard_C _cbd]
    (§
;       return true;
    ))

(defn- #_void clip_gen_lose_selection [#_clipboard_C _cbd]
    (§
    ))

(defn- #_void clip_gen_set_selection [#_clipboard_C cbd]
    (§
;       if (!@clip_did_set_selection)
;       {
            ;; Updating postponed, so that accessing the system clipboard won't
            ;; hang Vim when accessing it many times (e.g. on a :g comand).
;           if ((cbd == @clip_plus && (@clip_unnamed_saved & CLIP_UNNAMED_PLUS) != 0)
;            || (cbd == @clip_star && (@clip_unnamed_saved & CLIP_UNNAMED) != 0))
;           {
;               @clipboard_needs_update = true;
;               return;
;           }
;       }
        ;; TODO
    ))

(defn- #_void clip_gen_request_selection [#_clipboard_C _cbd]
    (§
    ))

(defn- #_boolean clip_gen_owner_exists [#_clipboard_C _cbd]
    (§
;       return true;
    ))

;; Functions that handle the input buffer.
;; This is used for any GUI version, and the unix terminal version.
;;
;; For Unix, the input characters are buffered to be able to check for a CTRL-C.
;; This should be done with signals, but I don't know how to do that in a portable way
;; for a tty in RAW mode.
;;
;; For the client-server code in the console the received keys are put in the input buffer.

;; Internal typeahead buffer.
;; Includes extra space for long key code descriptions which would otherwise overflow.
;; The buffer is considered full when only this extra space (or part of it) remains.

(final int INBUFLEN 250)

(final Bytes    inbuf (Bytes. (+ INBUFLEN MAX_KEY_CODE_LEN)))
(atom! int      inbufcount)     ;; number of chars in inbuf[]

;; Remove everything from the input buffer.  Called when ^C is found.
(defn- #_void trash_input_buf []
    (§
;       @inbufcount = 0;
    ))

(defn- #_boolean is_input_buf_full []
    (§
;       return (INBUFLEN <= @inbufcount);
    ))

(defn- #_boolean is_input_buf_empty []
    (§
;       return (@inbufcount == 0);
    ))

;; Save current contents of the input buffer and make it empty.

(defn- #_void save_input_buf [#_tasave_C tp]
    (§
        ;; Add one to avoid a zero size.
;       tp.save_inputbuf = new Bytes(@inbufcount + 1);
;       BCOPY(tp.save_inputbuf, inbuf, @inbufcount);
;       tp.save_inputlen = @inbufcount;

;       trash_input_buf();
    ))

;; Restore prior contents of the input buffer saved by save_input_buf().

(defn- #_void restore_input_buf [#_tasave_C tp]
    (§
;       if (tp.save_inputbuf != null)
;       {
;           @inbufcount = tp.save_inputlen;
;           BCOPY(inbuf, tp.save_inputbuf, @inbufcount);

;           tp.save_inputbuf = null;
;           tp.save_inputlen = 0;
;       }
    ))

;; Read as much data from the input buffer as possible up to maxlen, and store it in buf.
;; Note: this function used to be Read() in unix.c

(defn- #_int read_from_input_buf [#_Bytes buf, #_int maxlen]
    (§
;       if (@inbufcount == 0)            ;; if the buffer is empty, fill it
;           fill_input_buf(true);
;       if (@inbufcount < maxlen)
;           maxlen = @inbufcount;
;       BCOPY(buf, inbuf, maxlen);
;       @inbufcount -= maxlen;
;       if (@inbufcount != 0)
;           BCOPY(inbuf, 0, inbuf, maxlen, @inbufcount);
;       return maxlen;
    ))

(atom! boolean did_read_something)
(atom! Bytes fib__rest)    ;; unconverted rest of previous read
(atom! int fib__restlen)

(defn- #_void fill_input_buf [#_boolean exit_on_error]
    (§
;       if (is_input_buf_full())
;           return;

        ;; Fill_input_buf() is only called when we really need a character.
        ;; If we can't get any, but there is some in the buffer, just return.
        ;; If we can't get any, and there isn't any in the buffer, we give up and exit Vim.

;       int unconverted;

;       if (@fib__rest != null)
;       {
            ;; Use remainder of previous call, starts with an invalid character
            ;; that may become valid when reading more.
;           if (@fib__restlen > INBUFLEN - @inbufcount)
;               unconverted = INBUFLEN - @inbufcount;
;           else
;               unconverted = @fib__restlen;
;           BCOPY(inbuf, @inbufcount, @fib__rest, 0, unconverted);
;           if (unconverted == @fib__restlen)
;           {
;               @fib__rest = null;
;           }
;           else
;           {
;               @fib__restlen -= unconverted;
;               BCOPY(@fib__rest, 0, @fib__rest, unconverted, @fib__restlen);
;           }
;           @inbufcount += unconverted;
;       }
;       else
;           unconverted = 0;

;       int len = 0;

;       for (int round = 0; round < 100; round++)
;       {
;           len = (int)libC.read(@read_cmd_fd, inbuf.plus(@inbufcount), INBUFLEN - @inbufcount);

;           if (0 < len || @got_int)
;               break;

            ;; If reading stdin results in an error, continue reading stderr.
            ;; This helps when using "foo | xargs vim".

;           if (!@did_read_something && libc.isatty(@read_cmd_fd) == 0 && @read_cmd_fd == 0)
;           {
;               int m = @cur_tmode;

                ;; We probably set the wrong file descriptor to raw mode.
                ;; Switch back to cooked mode, use another descriptor
                ;; and set the mode to what it was.
;               settmode(TMODE_COOK);
                ;; Use stderr for stdin, also works for shell commands.
;               libc.close(0);
;               libc.dup(2);
;               settmode(m);
;           }
;           if (!exit_on_error)
;               return;
;       }
;       if (len <= 0 && !@got_int)
;           read_error_exit();
;       if (0 < len)
;           @did_read_something = true;
;       if (@got_int)
;       {
            ;; Interrupted, pretend a CTRL-C was typed.
;           inbuf.be(0, 3);
;           @inbufcount = 1;
;       }
;       else
;       {
            ;; May perform conversion on the input characters.
            ;; Include the unconverted rest of the previous call.
            ;; If there is an incomplete char at the end it is kept for the next
            ;; time, reading more bytes should make conversion possible.
            ;; Don't do this in the unlikely event that the input buffer is too
            ;; small ("fib__rest" still contains more bytes).

;           while (0 < len--)
;           {
                ;; if a CTRL-C was typed, remove it from the buffer and set got_int

;               if (inbuf.at(@inbufcount) == 3 && @ctrl_c_interrupts)
;               {
                    ;; remove everything typed before the CTRL-C
;                   BCOPY(inbuf, 0, inbuf, @inbufcount, len + 1);
;                   @inbufcount = 0;
;                   @got_int = true;
;               }
;               @inbufcount++;
;           }
;       }
    ))

;; Exit because of an input read error.

(defn- #_void read_error_exit []
    (§
;       if (@silent_mode)    ;; Normal way to exit for "ex -s"
;           getout(0);

;       STRCPY(@ioBuff, u8("Vim: Error reading input, exiting...\n"));
;       preserve_exit();
    ))

;; May update the shape of the cursor.

(defn- #_void ui_cursor_shape []
    (§
;       term_cursor_shape();

;       conceal_check_cursor_line();
    ))

;; Check bounds for column number

(defn- #_int check_col [#_int col]
    (§
;       if (col < 0)
;           return 0;
;       if (col >= @screenColumns)
;           return @screenColumns - 1;

;       return col;
    ))

;; Check bounds for row number

(defn- #_int check_row [#_int row]
    (§
;       if (row < 0)
;           return 0;
;       if (row >= @screenRows)
;           return @screenRows - 1;

;       return row;
    ))

(atom! int on_status_line)      ;; #lines below bottom of window
(atom! int on_sep_line)         ;; on separator right of window

(atom! int jm__prev_row -1)
(atom! int jm__prev_col -1)

(atom! window_C jm__dragwin)    ;; window being dragged
(atom! boolean jm__did_drag)    ;; drag was noticed

;; Move the cursor to the specified row and column on the screen.
;; Change current window if necessary.  Returns an integer with the
;; CURSOR_MOVED bit set if the cursor has moved or unset otherwise.
;;
;; If flags has MOUSE_FOCUS, then the current window will not be changed, and
;; if the mouse is outside the window then the text will scroll, or if the
;; mouse was previously on a status line, then the status line may be dragged.
;;
;; If flags has MOUSE_MAY_VIS, then VIsual mode will be started before the
;; cursor is moved unless the cursor was on a status line.
;; This function returns one of IN_UNKNOWN, IN_BUFFER, IN_STATUS_LINE or
;; IN_SEP_LINE depending on where the cursor was clicked.
;;
;; If flags has MOUSE_MAY_STOP_VIS, then Visual mode will be stopped, unless
;; the mouse is on the status line of the same window.
;;
;; If flags has MOUSE_DID_MOVE, nothing is done if the mouse didn't move since
;; the last call.
;;
;; If flags has MOUSE_SETPOS, nothing is done, only the current position is
;; remembered.

(defn- #_int jump_to_mouse [#_int flags, #_boolean* inclusive, #_int which_button]
    ;; inclusive: used for inclusive operator, can be null
    ;; which_button: MOUSE_LEFT, MOUSE_RIGHT, MOUSE_MIDDLE
    (§
;       int count;

;       int[] row = { @mouse_row };
;       int[] col = { @mouse_col };

;       @mouse_past_bottom = false;
;       @mouse_past_eol = false;

;       if ((flags & MOUSE_RELEASED) != 0)
;       {
            ;; On button release we may change window focus if positioned
            ;; on a status line and no dragging happened.
;           if (@jm__dragwin != null && !@jm__did_drag)
;               flags &= ~(MOUSE_FOCUS | MOUSE_DID_MOVE);
;           @jm__dragwin = null;
;           @jm__did_drag = false;
;       }

;       if ((flags & MOUSE_DID_MOVE) != 0 && @jm__prev_row == @mouse_row && @jm__prev_col == @mouse_col)
;       {
            ;; Before moving the cursor for a left click which is NOT in a status line,
            ;; stop Visual mode.
;           if (@on_status_line != 0)
;               return IN_STATUS_LINE;
;           if (@on_sep_line != 0)
;               return IN_SEP_LINE;
;           if ((flags & MOUSE_MAY_STOP_VIS) != 0)
;           {
;               end_visual_mode();
;               redraw_curbuf_later(INVERTED);      ;; delete the inversion
;           }
            ;; Continue a modeless selection in another window.
;           if (@cmdwin_type != 0 && row[0] < @curwin.w_winrow)
;               return IN_OTHER_WIN;

;           return IN_BUFFER;
;       }

;       @jm__prev_row = @mouse_row;
;       @jm__prev_col = @mouse_col;

;       if ((flags & MOUSE_SETPOS) != 0)
;       {
            ;; Before moving the cursor for a left click which is NOT in a status line,
            ;; stop Visual mode.
;           if (@on_status_line != 0)
;               return IN_STATUS_LINE;
;           if (@on_sep_line != 0)
;               return IN_SEP_LINE;
;           if ((flags & MOUSE_MAY_STOP_VIS) != 0)
;           {
;               end_visual_mode();
;               redraw_curbuf_later(INVERTED);      ;; delete the inversion
;           }
            ;; Continue a modeless selection in another window.
;           if (@cmdwin_type != 0 && row[0] < @curwin.w_winrow)
;               return IN_OTHER_WIN;

;           return IN_BUFFER;
;       }

;       window_C old_curwin = @curwin;
;       pos_C old_cursor = §_pos_C();
;       COPY_pos(old_cursor, @curwin.w_cursor);

;       if ((flags & MOUSE_FOCUS) == 0)
;       {
;           if (row[0] < 0 || col[0] < 0)                 ;; check if it makes sense
;               return IN_UNKNOWN;

            ;; find the window where the row is in
;           window_C wp = mouse_find_win(row, col);
;           @jm__dragwin = null;

            ;; winpos and height may change in win_enter()!

;           if (wp.w_height <= row[0])                 ;; in (or below) status line
;           {
;               @on_status_line = row[0] - wp.w_height + 1;
;               @jm__dragwin = wp;
;           }
;           else
;               @on_status_line = 0;
;           if (wp.w_width <= col[0])                  ;; in separator line
;           {
;               @on_sep_line = col[0] - wp.w_width + 1;
;               @jm__dragwin = wp;
;           }
;           else
;               @on_sep_line = 0;

            ;; The rightmost character of the status line might be a vertical
            ;; separator character if there is no connecting window to the right.
;           if (@on_status_line != 0 && @on_sep_line != 0)
;           {
;               if (stl_connected(wp))
;                   @on_sep_line = 0;
;               else
;                   @on_status_line = 0;
;           }

            ;; Before jumping to another buffer, or moving the cursor for a left click,
            ;; stop Visual mode.
;           if (@VIsual_active
;                   && (wp.w_buffer != @curwin.w_buffer
;                       || (@on_status_line == 0 && @on_sep_line == 0 && (flags & MOUSE_MAY_STOP_VIS) != 0)))
;           {
;               end_visual_mode();
;               redraw_curbuf_later(INVERTED);      ;; delete the inversion
;           }
;           if (@cmdwin_type != 0 && wp != @curwin)
;           {
                ;; A click outside the command-line window: use modeless selection if possible.
                ;; Allow dragging the status lines.
;               @on_sep_line = 0;
;               if (@on_status_line != 0)
;                   return IN_STATUS_LINE;

;               return IN_OTHER_WIN;
;           }
            ;; Only change window focus when not clicking on or dragging the
            ;; status line.  Do change focus when releasing the mouse button
            ;; (MOUSE_FOCUS was set above if we dragged first).
;           if (@jm__dragwin == null || (flags & MOUSE_RELEASED) != 0)
;               win_enter(wp, true);                ;; can make wp invalid!
            ;; set topline, to be able to check for double click ourselves
;           if (@curwin != old_curwin)
;               set_mouse_topline(@curwin);
;           if (@on_status_line != 0)                    ;; in (or below) status line
;           {
                ;; Don't use start_arrow() if we're in the same window.
;               if (@curwin == old_curwin)
;                   return IN_STATUS_LINE;
;               else
;                   return IN_STATUS_LINE | CURSOR_MOVED;
;           }
;           if (@on_sep_line != 0)                       ;; in (or below) status line
;           {
                ;; Don't use start_arrow() if we're in the same window.
;               if (@curwin == old_curwin)
;                   return IN_SEP_LINE;
;               else
;                   return IN_SEP_LINE | CURSOR_MOVED;
;           }

;           @curwin.w_cursor.lnum = @curwin.w_topline;
;       }
;       else if (@on_status_line != 0 && which_button == MOUSE_LEFT)
;       {
;           if (@jm__dragwin != null)
;           {
                ;; Drag the status line.
;               count = row[0] - @jm__dragwin.w_winrow - @jm__dragwin.w_height + 1 - @on_status_line;
;               win_drag_status_line(@jm__dragwin, count);
;               @jm__did_drag |= (count != 0);
;           }
;           return IN_STATUS_LINE;                  ;; Cursor didn't move
;       }
;       else if (@on_sep_line != 0 && which_button == MOUSE_LEFT)
;       {
;           if (@jm__dragwin != null)
;           {
                ;; Drag the separator column.
;               count = col[0] - @jm__dragwin.w_wincol - @jm__dragwin.w_width + 1 - @on_sep_line;
;               win_drag_vsep_line(@jm__dragwin, count);
;               @jm__did_drag |= (count != 0);
;           }
;           return IN_SEP_LINE;                     ;; Cursor didn't move
;       }
;       else ;; keep_window_focus must be true
;       {
            ;; before moving the cursor for a left click, stop Visual mode
;           if ((flags & MOUSE_MAY_STOP_VIS) != 0)
;           {
;               end_visual_mode();
;               redraw_curbuf_later(INVERTED);      ;; delete the inversion
;           }

            ;; Continue a modeless selection in another window.
;           if (@cmdwin_type != 0 && row[0] < @curwin.w_winrow)
;               return IN_OTHER_WIN;

;           row[0] -= @curwin.w_winrow;
;           col[0] -= @curwin.w_wincol;

            ;; When clicking beyond the end of the window, scroll the screen.
            ;; Scroll by however many rows outside the window we are.

;           if (row[0] < 0)
;           {
;               count = 0;
;               for (boolean first = true; 1 < @curwin.w_topline; )
;               {
;                   count += plines(@curwin.w_topline - 1);
;                   if (!first && -row[0] < count)
;                       break;
;                   first = false;
;                   --@curwin.w_topline;
;               }
;               @curwin.w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE|VALID_BOTLINE_AP);
;               redraw_later(VALID);
;               row[0] = 0;
;           }
;           else if (@curwin.w_height <= row[0])
;           {
;               count = 0;
;               for (boolean first = true; @curwin.w_topline < @curbuf.b_ml.ml_line_count; )
;               {
;                   count += plines(@curwin.w_topline);
;                   if (!first && row[0] - @curwin.w_height + 1 < count)
;                       break;
;                   first = false;
;                   @curwin.w_topline++;
;               }
;               redraw_later(VALID);
;               @curwin.w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE|VALID_BOTLINE_AP);
;               row[0] = @curwin.w_height - 1;
;           }
;           else if (row[0] == 0)
;           {
                ;; When dragging the mouse, while the text has been scrolled up as
                ;; far as it goes, moving the mouse in the top line should scroll
                ;; the text down (done later when recomputing w_topline).
;               if (0 < @mouse_dragging
;                       && @curwin.w_cursor.lnum == @curwin.w_buffer.b_ml.ml_line_count
;                       && @curwin.w_cursor.lnum == @curwin.w_topline)
;                   @curwin.w_valid &= ~(VALID_TOPLINE);
;           }
;       }

        ;; compute the position in the buffer line from the posn on the screen
;       boolean b;
;       { long[] __ = { @curwin.w_cursor.lnum }; b = mouse_comp_pos(@curwin, row, col, __); @curwin.w_cursor.lnum = __[0]; }
;       if (b)
;           @mouse_past_bottom = true;

        ;; Start Visual mode before coladvance(), for when 'sel' != "old".
;       if ((flags & MOUSE_MAY_VIS) != 0 && !@VIsual_active)
;       {
;           check_visual_highlight();
;           COPY_pos(@VIsual, old_cursor);
;           @VIsual_active = true;
;           @VIsual_reselect = true;
            ;; if 'selectmode' contains "mouse", start Select mode
;           may_start_select('o');
;           setmouse();
;           if (@p_smd && @msg_silent == 0)
;               @redraw_cmdline = true;          ;; show visual mode later
;       }

;       @curwin.w_curswant = col[0];
;       @curwin.w_set_curswant = false;          ;; May still have been true
;       if (coladvance(col[0]) == false)           ;; Mouse click beyond end of line
;       {
;           if (inclusive != null)
;               inclusive[0] = true;
;           @mouse_past_eol = true;
;       }
;       else if (inclusive != null)
;           inclusive[0] = false;

;       count = IN_BUFFER;
;       if (@curwin != old_curwin || @curwin.w_cursor.lnum != old_cursor.lnum
;               || @curwin.w_cursor.col != old_cursor.col)
;           count |= CURSOR_MOVED;              ;; Cursor has moved

;       return count;
    ))

;; Compute the position in the buffer line from the posn on the screen in window "win".
;; Returns true if the position is below the last line.

(defn- #_boolean mouse_comp_pos [#_window_C win, #_int* rowp, #_int* colp, #_long* lnump]
    (§
;       boolean retval = false;

;       int col = colp[0];
;       int row = rowp[0];

;       if (win.w_onebuf_opt.@wo_rl)
;           col = win.w_width - 1 - col;

;       long lnum = win.w_topline;

;       while (0 < row)
;       {
;           int count = plines_win(win, lnum, true);
;           if (row < count)
;               break;          ;; position is in this buffer line
;           if (lnum == win.w_buffer.b_ml.ml_line_count)
;           {
;               retval = true;
;               break;              ;; past end of file
;           }
;           row -= count;
;           lnum++;
;       }

;       if (!retval)
;       {
            ;; Compute the column without wrapping.
;           int off = win_col_off(win) - win_col_off2(win);
;           if (col < off)
;               col = off;
;           col += row * (win.w_width - off);
            ;; add skip column (for long wrapping line)
;           col += win.w_skipcol;
;       }

;       if (!win.w_onebuf_opt.@wo_wrap)
;           col += win.w_leftcol;

        ;; skip line number and fold column in front of the line
;       col -= win_col_off(win);
;       if (col < 0)
;       {
;           col = 0;
;       }

;       colp[0] = col;
;       rowp[0] = row;
;       lnump[0] = lnum;
;       return retval;
    ))

;; Find the window at screen position "*rowp" and "*colp".  The positions are
;; updated to become relative to the top-left of the window.

(defn- #_window_C mouse_find_win [#_int* rowp, #_int* colp]
    (§
;       frame_C fp = @topframe;
;       rowp[0] -= @firstwin.w_winrow;
;       for ( ; ; )
;       {
;           if (fp.fr_layout == FR_LEAF)
;               break;
;           if (fp.fr_layout == FR_ROW)
;           {
;               for (fp = fp.fr_child; fp.fr_next != null; fp = fp.fr_next)
;               {
;                   if (colp[0] < fp.fr_width)
;                       break;
;                   colp[0] -= fp.fr_width;
;               }
;           }
;           else    ;; fr_layout == FR_COL
;           {
;               for (fp = fp.fr_child; fp.fr_next != null; fp = fp.fr_next)
;               {
;                   if (rowp[0] < fp.fr_height)
;                       break;
;                   rowp[0] -= fp.fr_height;
;               }
;           }
;       }
;       return fp.fr_win;
    ))

;; screen.c: code for displaying on the screen
;;
;; Output to the screen (console, terminal emulator or GUI window) is minimized
;; by remembering what is already on the screen, and only updating the parts
;; that changed.
;;
;; screenLines[off]  Contains a copy of the whole screen, as it is currently
;;                   displayed (excluding text written by external commands).
;; screenAttrs[off]  Contains the associated attributes.
;; lineOffset[row]   Contains the offset into screenLines*[] and screenAttrs[]
;;                   for each line.
;; lineWraps[row]    Flag for each line whether it wraps to the next line.
;;
;; For double-byte characters, two consecutive bytes in screenLines[] can form one character
;; which occupies two display cells.  For UTF-8 a multi-byte character is converted to Unicode
;; and stored in screenLinesUC[].  screenLines[] contains the first byte only.  For an ASCII
;; character without composing chars screenLinesUC[] will be 0 and screenLinesC[][] is not used.
;; When the character occupies two display cells the next byte in screenLines[] is 0.
;; screenLinesC[][] contain up to 'maxcombine' composing characters
;; (drawn on top of the first character).  There is 0 after the last one used.
;;
;; The screen_*() functions write to the screen and handle updating screenLines[].
;;
;; update_screen() is the function that updates all windows and status lines.
;; It is called form the main loop when must_redraw is non-zero.  It may be
;; called from other places when an immediate screen update is needed.
;;
;; The part of the buffer that is displayed in a window is set with:
;; - w_topline (first buffer line in window)
;; - w_topfill (filler lines above the first line)
;; - w_leftcol (leftmost window cell in window),
;; - w_skipcol (skipped window cells of first line)
;;
;; Commands that only move the cursor around in a window, do not need to take
;; action to update the display.  The main loop will check if w_topline is
;; valid and update it (scroll the window) when needed.
;;
;; Commands that scroll a window change w_topline and must call
;; check_cursor() to move the cursor into the visible part of the window, and
;; call redraw_later(VALID) to have the window displayed by update_screen() later.
;;
;; Commands that change text in the buffer must call changed_bytes() or
;; changed_lines() to mark the area that changed and will require updating
;; later.  The main loop will call update_screen(), which will update each
;; window that shows the changed buffer.  This assumes text above the change
;; can remain displayed as it is.  Text after the change may need updating for
;; scrolling, folding and syntax highlighting.
;;
;; Commands that change how a window is displayed (e.g., setting 'list') or
;; invalidate the contents of a window in another way (e.g., change fold
;; settings), must call redraw_later(NOT_VALID) to have the whole window
;; redisplayed by update_screen() later.
;;
;; Commands that change how a buffer is displayed (e.g., setting 'tabstop')
;; must call redraw_curbuf_later(NOT_VALID) to have all the windows for the
;; buffer redisplayed by update_screen() later.
;;
;; Commands that change highlighting and possibly cause a scroll too must call
;; redraw_later(SOME_VALID) to update the whole window but still use scrolling
;; to avoid redrawing everything.  But the length of displayed lines must not
;; change, use NOT_VALID then.
;;
;; Commands that move the window position must call redraw_later(NOT_VALID).
;; TODO: should minimize redrawing by scrolling when possible.
;;
;; Commands that change everything (e.g., resizing the screen) must call
;; redraw_all_later(NOT_VALID) or redraw_all_later(CLEAR).
;;
;; Things that are handled indirectly:
;; - When messages scroll the screen up, msg_scrolled will be set and
;;   update_screen() called to redraw.

(final byte MB_FILLER_CHAR \<)     ;; character used when a double-width character doesn't fit.

;; The attributes that are actually active for writing to the screen.

(atom! int screen_attr)

;; Positioning the cursor is reduced by remembering the last position.
;; Mostly used by windgoto() and screen_char().

;; last known cursor position
(atom! int screen_cur_row)
(atom! int screen_cur_col)

(atom! match_C search_hl    (§_match_C))   ;; used for 'hlsearch' highlight matching

;; Buffer for one screen line (characters and attributes).

(atom! Bytes current_ScreenLine)

(final int SEARCH_HL_PRIORITY 0)

;; Ugly global: overrule attribute used by screen_char().
(atom! int screen_char_attr)

;; Redraw the current window later, with update_screen(type).
;; Set must_redraw only if not already set to a higher value.
;; e.g. if must_redraw is CLEAR, type NOT_VALID will do nothing.

(defn- #_void redraw_later [#_int type]
    (§
;       redraw_win_later(@curwin, type);
    ))

(defn- #_void redraw_win_later [#_window_C wp, #_int type]
    (§
;       if (wp.w_redr_type < type)
;       {
;           wp.w_redr_type = type;
;           if (NOT_VALID <= type)
;               wp.w_lines_valid = 0;
;           if (@must_redraw < type) ;; must_redraw is the maximum of all windows
;               @must_redraw = type;
;       }
    ))

;; Force a complete redraw later.  Also resets the highlighting.
;; To be used after executing a shell command that messes up the screen.

(defn- #_void redraw_later_clear []
    (§
;       redraw_all_later(CLEAR);
        ;; Use attributes that is very unlikely to appear in text.
;       @screen_attr = HL_BOLD | HL_UNDERLINE | HL_INVERSE;
    ))

;; Mark all windows to be redrawn later.

(defn- #_void redraw_all_later [#_int type]
    (§
;       for (window_C wp = @firstwin; wp != null; wp = wp.w_next)
;           redraw_win_later(wp, type);
    ))

;; Mark all windows that are editing the current buffer to be updated later.

(defn- #_void redraw_curbuf_later [#_int type]
    (§
;       redraw_buf_later(@curbuf, type);
    ))

(defn- #_void redraw_buf_later [#_buffer_C buf, #_int type]
    (§
;       for (window_C wp = @firstwin; wp != null; wp = wp.w_next)
;           if (wp.w_buffer == buf)
;               redraw_win_later(wp, type);
    ))

;; Redraw as soon as possible.  When the command line is not scrolled
;; redraw right away and restore what was on the command line.
;; Return a code indicating what happened.

(defn- #_int redraw_asap [#_int type]
    (§
;       int ret = 0;

;       redraw_later(type);
;       if (@msg_scrolled != 0 || (@State != NORMAL && @State != NORMAL_BUSY))
;           return ret;

        ;; Allocate space to save the text displayed in the command line area.
;       int rows = (int)@Rows - @cmdline_row;
;       Bytes slis = new Bytes(rows * (int)@Columns);
;       int[] sats = new int[rows * (int)@Columns];

;       int[] sluc = new int[rows * (int)@Columns];
;       int[][] smco = new int[MAX_MCO][];
;       for (int i = 0; i < @p_mco; i++)
;           smco[i] = new int[rows * (int)@Columns];

        ;; Save the text displayed in the command line area.
;       for (int r = 0; r < rows; r++)
;       {
;           int off = @lineOffset[@cmdline_row + r];

;           BCOPY(slis, r * (int)@Columns, @screenLines, off, (int)@Columns);
;           ACOPY(sats, r * (int)@Columns, @screenAttrs, off, (int)@Columns);
;           ACOPY(sluc, r * (int)@Columns, @screenLinesUC, off, (int)@Columns);
;           for (int i = 0; i < @p_mco; i++)
;               ACOPY(smco[i], r * (int)@Columns, @screenLinesC[i], off, (int)@Columns);
;       }

;       update_screen(0);
;       ret = 3;

;       if (@must_redraw == 0)
;       {
;           int off = BDIFF(@current_ScreenLine, @screenLines);

            ;; Restore the text displayed in the command line area.
;           for (int r = 0; r < rows; r++)
;           {
;               BCOPY(@current_ScreenLine, 0, slis, r * (int)@Columns, (int)@Columns);
;               ACOPY(@screenAttrs, off, sats, r * (int)@Columns, (int)@Columns);
;               ACOPY(@screenLinesUC, off, sluc, r * (int)@Columns, (int)@Columns);
;               for (int i = 0; i < @p_mco; i++)
;                   ACOPY(@screenLinesC[i], off, smco[i], r * (int)@Columns, (int)@Columns);
;               screen_line(@cmdline_row + r, 0, (int)@Columns, (int)@Columns, false);
;           }
;           ret = 4;
;       }

;       setcursor();

;       return ret;
    ))

;; Changed something in the current window, at buffer line "lnum", that
;; requires that line and possibly other lines to be redrawn.
;; Used when entering/leaving Insert mode with the cursor on a folded line.
;; Used to remove the "$" from a change command.
;; Note that when also inserting/deleting lines w_redraw_top and w_redraw_bot
;; may become invalid and the whole window will have to be redrawn.

(defn- #_void redrawWinline [#_long lnum]
    (§
;       if (@curwin.w_redraw_top == 0 || @curwin.w_redraw_top > lnum)
;           @curwin.w_redraw_top = lnum;
;       if (@curwin.w_redraw_bot == 0 || @curwin.w_redraw_bot < lnum)
;           @curwin.w_redraw_bot = lnum;

;       redraw_later(VALID);
    ))

;; update all windows that are editing the current buffer

(defn- #_void update_curbuf [#_int type]
    (§
;       redraw_curbuf_later(type);
;       update_screen(type);
    ))

;; update_screen()
;;
;; Based on the current value of curwin.w_topline, transfer a screenfull
;; of stuff from Filemem to screenLines[], and update curwin.w_botline.

(defn- #_void update_screen [#_int type]
    (§
        ;; Don't do anything if the screen structures are (not yet) valid.
;       if (!screen_valid(true))
;           return;

;       if (@must_redraw != 0)
;       {
;           if (type < @must_redraw)             ;; use maximal type
;               type = @must_redraw;

            ;; must_redraw is reset here, so that when we run into some weird
            ;; reason to redraw while busy redrawing (e.g., asynchronous
            ;; scrolling), or update_topline() in win_update() will cause a
            ;; scroll, the screen will be redrawn later or in win_update().
;           @must_redraw = 0;
;       }

        ;; Need to update w_lines[].
;       if (@curwin.w_lines_valid == 0 && type < NOT_VALID)
;           type = NOT_VALID;

        ;; Postpone the redrawing when it's not needed and when being called recursively.
;       if (!redrawing() || @updating_screen)
;       {
;           redraw_later(type);                 ;; remember type for next time
;           @must_redraw = type;
;           if (INVERTED_ALL < type)
;               @curwin.w_lines_valid = 0;       ;; don't use w_lines[].wl_size now
;           return;
;       }

;       @updating_screen = true;
        ;; let syntax code know we're in a next round of display updating
;       if (++@display_tick < 0)
;           @display_tick = 0;

        ;; if the screen was scrolled up when displaying a message, scroll it down

;       if (@msg_scrolled != 0)
;       {
;           @clear_cmdline = true;
;           if (@Rows - 5 < @msg_scrolled)        ;; clearing is faster
;               type = CLEAR;
;           else if (type != CLEAR)
;           {
;               check_for_delay(false);
;               if (screen_ins_lines(0, 0, @msg_scrolled, (int)@Rows, null) == false)
;                   type = CLEAR;
;               for (window_C wp = @firstwin; wp != null; wp = wp.w_next)
;               {
;                   if (wp.w_winrow < @msg_scrolled)
;                   {
;                       if (@msg_scrolled < wp.w_winrow + wp.w_height
;                               && wp.w_redr_type < REDRAW_TOP
;                               && 0 < wp.w_lines_valid
;                               && wp.w_topline == wp.w_lines[0].wl_lnum)
;                       {
;                           wp.w_upd_rows = @msg_scrolled - wp.w_winrow;
;                           wp.w_redr_type = REDRAW_TOP;
;                       }
;                       else
;                       {
;                           wp.w_redr_type = NOT_VALID;
;                           if (wp.w_winrow + wp.w_height + wp.w_status_height <= @msg_scrolled)
;                               wp.w_redr_status = true;
;                       }
;                   }
;               }
;               @redraw_cmdline = true;
;               @redraw_tabline = true;
;           }
;           @msg_scrolled = 0;
;           @need_wait_return = false;
;       }

        ;; reset cmdline_row now (may have been changed temporarily)
;       compute_cmdrow();

        ;; Check for changed highlighting.
;       if (@need_highlight_changed)
;           highlight_changed();

;       if (type == CLEAR)              ;; first clear screen
;       {
;           screenclear();              ;; will reset clear_cmdline
;           type = NOT_VALID;
;       }

;       if (@clear_cmdline)              ;; going to clear cmdline (done below)
;           check_for_delay(false);

        ;; Force redraw when width of 'number' or 'relativenumber' column changes.
;       if (@curwin.w_redr_type < NOT_VALID
;              && @curwin.w_nrwidth != ((@curwin.w_onebuf_opt.@wo_nu || @curwin.w_onebuf_opt.@wo_rnu) ? number_width(@curwin) : 0))
;           @curwin.w_redr_type = NOT_VALID;

        ;; Only start redrawing if there is really something to do.

;       if (type == INVERTED)
;           update_curswant();
;       if (@curwin.w_redr_type < type
;               && !((type == VALID
;                       && @curwin.w_lines[0].wl_valid
;                       && @curwin.w_topline == @curwin.w_lines[0].wl_lnum)
;                   || (type == INVERTED
;                       && @VIsual_active
;                       && @curwin.w_old_cursor_lnum == @curwin.w_cursor.lnum
;                       && @curwin.w_old_visual_mode == @VIsual_mode
;                       && (@curwin.w_valid & VALID_VIRTCOL) != 0
;                       && @curwin.w_old_curswant == @curwin.w_curswant)
;                   ))
;           @curwin.w_redr_type = type;

        ;; Redraw the tab pages line if needed.
;       if (@redraw_tabline || NOT_VALID <= type)
;           draw_tabline();

        ;; Go from top to bottom through the windows, redrawing the ones that need it.

;       boolean did_one = false;
;       @search_hl.rmm.regprog = null;

;       for (window_C wp = @firstwin; wp != null; wp = wp.w_next)
;       {
;           if (wp.w_redr_type != 0)
;           {
;               cursor_off();
;               if (!did_one)
;               {
;                   did_one = true;
;                   start_search_hl();
                    ;; When Visual area changed, may have to update selection.
;                   if (@clip_star.available && clip_isautosel_star())
;                       clip_update_selection(@clip_star);
;                   if (@clip_plus.available && clip_isautosel_plus())
;                       clip_update_selection(@clip_plus);
;               }
;               win_update(wp);
;           }

            ;; redraw status line after the window to minimize cursor movement
;           if (wp.w_redr_status)
;           {
;               cursor_off();
;               win_redr_status(wp);
;           }
;       }
;       end_search_hl();

        ;; Reset b_mod_set flags.  Going through all windows is probably faster
        ;; than going through all buffers (there could be many buffers).
;       for (window_C wp = @firstwin; wp != null; wp = wp.w_next)
;           wp.w_buffer.b_mod_set = false;

;       @updating_screen = false;

        ;; Clear or redraw the command line.
        ;; Done last, because scrolling may mess up the command line.
;       if (@clear_cmdline || @redraw_cmdline)
;           showmode();
    ))

;; Return true if the cursor line in window "wp" may be concealed, according
;; to the 'concealcursor' option.

(defn- #_boolean conceal_cursor_line [#_window_C wp]
    (§
;       if (wp.w_onebuf_opt.@wo_cocu.at(0) == NUL)
;           return false;

;       int c;
;       if ((get_real_state() & VISUAL) != 0)
;           c = 'v';
;       else if ((@State & INSERT) != 0)
;           c = 'i';
;       else if ((@State & NORMAL) != 0)
;           c = 'n';
;       else if ((@State & CMDLINE) != 0)
;           c = 'c';
;       else
;           return false;

;       return (vim_strchr(wp.w_onebuf_opt.@wo_cocu, c) != null);
    ))

;; Check if the cursor line needs to be redrawn because of 'concealcursor'.

(defn- #_void conceal_check_cursor_line []
    (§
;       if (0 < @curwin.w_onebuf_opt.@wo_cole && conceal_cursor_line(@curwin))
;       {
;           @need_cursor_line_redraw = true;
            ;; Need to recompute cursor column, e.g., when starting Visual mode without concealing.
;           curs_columns(true);
;       }
    ))

(defn- #_void update_single_line [#_window_C wp, #_long lnum]
    (§
;       if (wp.w_topline <= lnum && lnum < wp.w_botline)
;       {
;           int row = 0;
;           for (int j = 0; j < wp.w_lines_valid; j++)
;           {
;               if (lnum == wp.w_lines[j].wl_lnum)
;               {
;                   screen_start(); ;; not sure of screen cursor
;                   init_search_hl(wp);
;                   start_search_hl();
;                   prepare_search_hl(wp, lnum);
;                   win_line(wp, lnum, row, row + wp.w_lines[j].wl_size, false);
;                   end_search_hl();
;                   break;
;               }
;               row += wp.w_lines[j].wl_size;
;           }
;       }

;       @need_cursor_line_redraw = false;
    ))

(atom! boolean _2_recursive)    ;; being called recursively

;; Update a single window.
;;
;; This may cause the windows below it also to be redrawn (when clearing the
;; screen or scrolling lines).
;;
;; How the window is redrawn depends on wp.w_redr_type.  Each type also
;; implies the one below it.
;; NOT_VALID    redraw the whole window
;; SOME_VALID   redraw the whole window but do scroll when possible
;; REDRAW_TOP   redraw the top w_upd_rows window lines, otherwise like VALID
;; INVERTED     redraw the changed part of the Visual area
;; INVERTED_ALL redraw the whole Visual area
;; VALID        1. scroll up/down to adjust for a changed w_topline
;;              2. update lines at the top when scrolled down
;;              3. redraw changed text:
;;                 - if wp.w_buffer.b_mod_set set, update lines between
;;                   b_mod_top and b_mod_bot.
;;                 - if wp.w_redraw_top non-zero, redraw lines between
;;                   wp.w_redraw_top and wp.w_redr_bot.
;;                 - continue redrawing when syntax status is invalid.
;;              4. if scrolled up, update lines at the bottom.
;; This results in three areas that may need updating:
;; top: from first row to top_end (when scrolled down)
;; mid: from mid_start to mid_end (update inversion or changed text)
;; bot: from bot_start to last row (when scrolled up)

(defn- #_void win_update [#_window_C wp]
    (§
;       buffer_C buf = wp.w_buffer;

;       int top_end = 0;                    ;; Below last row of the top area that needs
                                            ;; updating.  0 when no top area updating.
;       int mid_start = 999;                ;; First row of the mid area that needs
                                            ;; updating.  999 when no mid area updating.
;       int mid_end = 0;                    ;; Below last row of the mid area that needs
                                            ;; updating.  0 when no mid area updating.
;       int bot_start = 999;                ;; First row of the bot area that needs
                                            ;; updating.  999 when no bot area updating.
;       boolean scrolled_down = false;      ;; true when scrolled down when
                                            ;; w_topline got smaller a bit
;       boolean top_to_mod = false;         ;; redraw above mod_top

;       boolean eof = false;                ;; if true, we hit the end of the file
;       boolean didline = false;            ;; if true, we finished the last line

;       long old_botline = wp.w_botline;

        ;; remember what happened to the previous line,
        ;; to know if check_visual_highlight() can be used

;       final int
;           DID_NONE = 1,                   ;; didn't update a line
;           DID_LINE = 2,                   ;; updated a normal line
;           DID_FOLD = 3;                   ;; updated a folded line
;       int did_update = DID_NONE;

;       long syntax_last_parsed = 0;        ;; last parsed text line
;       long mod_top = 0;
;       long mod_bot = 0;

;       int type = wp.w_redr_type;

;       if (type == NOT_VALID)
;       {
;           wp.w_redr_status = true;
;           wp.w_lines_valid = 0;
;       }

        ;; Window is zero-height: nothing to draw.
;       if (wp.w_height == 0)
;       {
;           wp.w_redr_type = 0;
;           return;
;       }

        ;; Window is zero-width: Only need to draw the separator.
;       if (wp.w_width == 0)
;       {
            ;; draw the vertical separator right of this window
;           draw_vsep_win(wp, 0);
;           wp.w_redr_type = 0;
;           return;
;       }

;       init_search_hl(wp);

        ;; Force redraw when width of 'number' or 'relativenumber' column changes.
;       int i = (wp.w_onebuf_opt.@wo_nu || wp.w_onebuf_opt.@wo_rnu) ? number_width(wp) : 0;
;       if (wp.w_nrwidth != i)
;       {
;           type = NOT_VALID;
;           wp.w_nrwidth = i;
;       }
;       else if (buf.b_mod_set && buf.b_mod_xlines != 0 && wp.w_redraw_top != 0)
;       {
            ;; When there are both inserted/deleted lines and specific lines to be
            ;; redrawn, w_redraw_top and w_redraw_bot may be invalid, just redraw
            ;; everything (only happens when redrawing is off for while).

;           type = NOT_VALID;
;       }
;       else
;       {
            ;; Set mod_top to the first line that needs displaying because of changes.
            ;; Set mod_bot to the first line after the changes.

;           mod_top = wp.w_redraw_top;
;           if (wp.w_redraw_bot != 0)
;               mod_bot = wp.w_redraw_bot + 1;
;           else
;               mod_bot = 0;
;           wp.w_redraw_top = 0;    ;; reset for next time
;           wp.w_redraw_bot = 0;
;           if (buf.b_mod_set)
;           {
;               if (mod_top == 0 || buf.b_mod_top < mod_top)
;                   mod_top = buf.b_mod_top;
;               if (mod_bot == 0 || mod_bot < buf.b_mod_bot)
;                   mod_bot = buf.b_mod_bot;

                ;; When 'hlsearch' is on and using a multi-line search pattern,
                ;; a change in one line may make the Search highlighting in a previous line invalid.
                ;; Simple solution: redraw all visible lines above the change.
                ;; Same for a match pattern.

;               if (@search_hl.rmm.regprog != null && re_multiline(@search_hl.rmm.regprog))
;                   top_to_mod = true;
;               else
;               {
;                   for (matchitem_C mi = wp.w_match_head; mi != null; mi = mi.next)
;                       if (mi.mi_match.regprog != null && re_multiline(mi.mi_match.regprog))
;                       {
;                           top_to_mod = true;
;                           break;
;                       }
;               }
;           }

            ;; When a change starts above w_topline and the end is below w_topline,
            ;; start redrawing at w_topline.
            ;; If the end of the change is above w_topline: do like no change was made,
            ;; but redraw the first line to find changes in syntax.
;           if (mod_top != 0 && mod_top < wp.w_topline)
;           {
;               if (mod_bot > wp.w_topline)
;                   mod_top = wp.w_topline;
;           }

            ;; When line numbers are displayed, need to redraw all lines below
            ;; inserted/deleted lines.
;           if (mod_top != 0 && buf.b_mod_xlines != 0 && wp.w_onebuf_opt.@wo_nu)
;               mod_bot = MAXLNUM;
;       }

        ;; When only displaying the lines at the top, set top_end.
        ;; Used when window has scrolled down for msg_scrolled.

;       if (type == REDRAW_TOP)
;       {
;           int j = 0;
;           for (i = 0; i < wp.w_lines_valid; i++)
;           {
;               j += wp.w_lines[i].wl_size;
;               if (wp.w_upd_rows <= j)
;               {
;                   top_end = j;
;                   break;
;               }
;           }
;           if (top_end == 0)
                ;; not found (cannot happen?): redraw everything
;               type = NOT_VALID;
;           else
                ;; top area defined, the rest is VALID
;               type = VALID;
;       }

        ;; Trick: we want to avoid clearing the screen twice.  screenclear() will set
        ;; "screen_cleared" to true.  The special value MAYBE (which is still non-zero
        ;; and thus not false) will indicate that screenclear() was not called.
;       if (@screen_cleared != FALSE)
;           @screen_cleared = MAYBE;

        ;; If there are no changes on the screen that require a complete redraw,
        ;; handle three cases:
        ;; 1: we are off the top of the screen by a few lines: scroll down
        ;; 2: wp.w_topline is below wp.w_lines[0].wl_lnum: may scroll up
        ;; 3: wp.w_topline is wp.w_lines[0].wl_lnum: find first entry in w_lines[] that needs updating.

;       if ((type == VALID || type == SOME_VALID || type == INVERTED || type == INVERTED_ALL))
;       {
;           if (mod_top != 0 && wp.w_topline == mod_top)
;           {
                ;; w_topline is the first changed line, the scrolling will be done further down.
;           }
;           else if (wp.w_lines[0].wl_valid && (wp.w_topline < wp.w_lines[0].wl_lnum))
;           {
                ;; New topline is above old topline: may scroll down.
;               int j = (int)(wp.w_lines[0].wl_lnum - wp.w_topline);

;               if (j < wp.w_height - 2)        ;; not too far off
;               {
;                   i = plines_m_win(wp, wp.w_topline, wp.w_lines[0].wl_lnum - 1);

;                   if (i < wp.w_height - 2)    ;; less than a screen off
;                   {
                        ;; Try to insert the correct number of lines.
                        ;; If not the last window, delete the lines at the bottom.
                        ;; win_ins_lines may fail when the terminal can't do it.

;                       if (0 < i)
;                           check_for_delay(false);
;                       if (win_ins_lines(wp, 0, i, false, wp == @firstwin) == true)
;                       {
;                           if (wp.w_lines_valid != 0)
;                           {
                                ;; Need to update rows that are new,
                                ;; stop at the first one that scrolled down.
;                               top_end = i;
;                               scrolled_down = true;

                                ;; Move the entries that were scrolled,
                                ;; disable the entries for the lines to be redrawn.
;                               if ((wp.w_lines_valid += j) > wp.w_height)
;                                   wp.w_lines_valid = wp.w_height;
;                               int idx;
;                               for (idx = wp.w_lines_valid; 0 <= idx - j; --idx)
;                                   COPY_wline(wp.w_lines[idx], wp.w_lines[idx - j]);
;                               while (0 <= idx)
;                                   wp.w_lines[idx--].wl_valid = false;
;                           }
;                       }
;                       else
;                           mid_start = 0;          ;; redraw all lines
;                   }
;                   else
;                       mid_start = 0;              ;; redraw all lines
;               }
;               else
;                   mid_start = 0;                  ;; redraw all lines
;           }
;           else
;           {
                ;; New topline is at or below old topline: May scroll up.
                ;; When topline didn't change, find first entry in w_lines[] that needs updating.

                ;; try to find wp.w_topline in wp.w_lines[].wl_lnum
;               int j = -1;
;               int row = 0;
;               for (i = 0; i < wp.w_lines_valid; i++)
;               {
;                   if (wp.w_lines[i].wl_valid && wp.w_lines[i].wl_lnum == wp.w_topline)
;                   {
;                       j = i;
;                       break;
;                   }
;                   row += wp.w_lines[i].wl_size;
;               }
;               if (j == -1)
;               {
                    ;; if wp.w_topline is not in wp.w_lines[].wl_lnum redraw all lines
;                   mid_start = 0;
;               }
;               else
;               {
                    ;; Try to delete the correct number of lines.
                    ;; wp.w_topline is at wp.w_lines[i].wl_lnum.

;                   if (0 < row)
;                   {
;                       check_for_delay(false);
;                       if (win_del_lines(wp, 0, row, false, wp == @firstwin) == true)
;                           bot_start = wp.w_height - row;
;                       else
;                           mid_start = 0;          ;; redraw all lines
;                   }
;                   if ((row == 0 || bot_start < 999) && wp.w_lines_valid != 0)
;                   {
                        ;; Skip the lines (below the deleted lines) that are still valid and
                        ;; don't need redrawing.  Copy their info upwards, to compensate for the
                        ;; deleted lines.  Set bot_start to the first row that needs redrawing.

;                       bot_start = 0;
;                       int idx = 0;                ;; current index in w_lines[]
;                       for ( ; ; )
;                       {
;                           COPY_wline(wp.w_lines[idx], wp.w_lines[j]);
                            ;; stop at line that didn't fit,
                            ;; unless it is still valid (no lines deleted)
;                           if (0 < row && wp.w_height < bot_start + row + wp.w_lines[j].wl_size)
;                           {
;                               wp.w_lines_valid = idx + 1;
;                               break;
;                           }
;                           bot_start += wp.w_lines[idx++].wl_size;

                            ;; stop at the last valid entry in w_lines[].wl_size
;                           if (wp.w_lines_valid <= ++j)
;                           {
;                               wp.w_lines_valid = idx;
;                               break;
;                           }
;                       }
;                   }
;               }
;           }

            ;; When starting redraw in the first line, redraw all lines.
            ;; When there is only one window it's probably faster to clear the screen first.
;           if (mid_start == 0)
;           {
;               mid_end = wp.w_height;
;               if (@lastwin == @firstwin)
;               {
                    ;; Clear the screen when it was not done by win_del_lines() or
                    ;; win_ins_lines() above, "screen_cleared" is false or MAYBE then.
;                   if (@screen_cleared != TRUE)
;                       screenclear();
                    ;; The screen was cleared, redraw the tab pages line.
;                   if (@redraw_tabline)
;                       draw_tabline();
;               }
;           }

            ;; When win_del_lines() or win_ins_lines() caused the screen to be
            ;; cleared (only happens for the first window) or when screenclear()
            ;; was called directly above, "must_redraw" will have been set to
            ;; NOT_VALID, need to reset it here to avoid redrawing twice.
;           if (@screen_cleared == TRUE)
;               @must_redraw = 0;
;       }
;       else
;       {
            ;; Not VALID or INVERTED: redraw all lines.
;           mid_start = 0;
;           mid_end = wp.w_height;
;       }

;       if (type == SOME_VALID)
;       {
            ;; SOME_VALID: redraw all lines.
;           mid_start = 0;
;           mid_end = wp.w_height;
;           type = NOT_VALID;
;       }

        ;; check if we are updating or removing the inverted part
;       if ((@VIsual_active && buf == @curwin.w_buffer)
;           || (wp.w_old_cursor_lnum != 0 && type != NOT_VALID))
;       {
;           long from, to;

;           if (@VIsual_active)
;           {
;               if (@VIsual_active && (@VIsual_mode != wp.w_old_visual_mode || type == INVERTED_ALL))
;               {
                    ;; If the type of Visual selection changed, redraw the whole selection.
                    ;; Also when the ownership of the X selection is gained or lost.

;                   if (@curwin.w_cursor.lnum < @VIsual.lnum)
;                   {
;                       from = @curwin.w_cursor.lnum;
;                       to = @VIsual.lnum;
;                   }
;                   else
;                   {
;                       from = @VIsual.lnum;
;                       to = @curwin.w_cursor.lnum;
;                   }
                    ;; redraw more when the cursor moved as well
;                   if (wp.w_old_cursor_lnum < from)
;                       from = wp.w_old_cursor_lnum;
;                   if (to < wp.w_old_cursor_lnum)
;                       to = wp.w_old_cursor_lnum;
;                   if (wp.w_old_visual_lnum < from)
;                       from = wp.w_old_visual_lnum;
;                   if (to < wp.w_old_visual_lnum)
;                       to = wp.w_old_visual_lnum;
;               }
;               else
;               {
                    ;; Find the line numbers that need to be updated: The lines
                    ;; between the old cursor position and the current cursor
                    ;; position.  Also check if the Visual position changed.

;                   if (@curwin.w_cursor.lnum < wp.w_old_cursor_lnum)
;                   {
;                       from = @curwin.w_cursor.lnum;
;                       to = wp.w_old_cursor_lnum;
;                   }
;                   else
;                   {
;                       from = wp.w_old_cursor_lnum;
;                       to = @curwin.w_cursor.lnum;
;                       if (from == 0)              ;; Visual mode just started
;                           from = to;
;                   }

;                   if (@VIsual.lnum != wp.w_old_visual_lnum || @VIsual.col != wp.w_old_visual_col)
;                   {
;                       if (wp.w_old_visual_lnum < from && wp.w_old_visual_lnum != 0)
;                           from = wp.w_old_visual_lnum;
;                       if (to < wp.w_old_visual_lnum)
;                           to = wp.w_old_visual_lnum;
;                       if (@VIsual.lnum < from)
;                           from = @VIsual.lnum;
;                       if (to < @VIsual.lnum)
;                           to = @VIsual.lnum;
;                   }
;               }

                ;; If in block mode and changed column or curwin.w_curswant: update all lines.
                ;; First compute the actual start and end column.

;               if (@VIsual_mode == Ctrl_V)
;               {
;                   int[] fromc = new int[1];
;                   int[] toc = new int[1];
;                   int save_ve_flags = @ve_flags;

;                   if (@curwin.w_onebuf_opt.@wo_lbr)
;                       @ve_flags = VE_ALL;
;                   getvcols(wp, @VIsual, @curwin.w_cursor, fromc, toc);
;                   @ve_flags = save_ve_flags;
;                   toc[0]++;
;                   if (@curwin.w_curswant == MAXCOL)
;                       toc[0] = MAXCOL;

;                   if (fromc[0] != wp.w_old_cursor_fcol || toc[0] != wp.w_old_cursor_lcol)
;                   {
;                       if (@VIsual.lnum < from)
;                           from = @VIsual.lnum;
;                       if (to < @VIsual.lnum)
;                           to = @VIsual.lnum;
;                   }
;                   wp.w_old_cursor_fcol = fromc[0];
;                   wp.w_old_cursor_lcol = toc[0];
;               }
;           }
;           else
;           {
                ;; Use the line numbers of the old Visual area.
;               if (wp.w_old_cursor_lnum < wp.w_old_visual_lnum)
;               {
;                   from = wp.w_old_cursor_lnum;
;                   to = wp.w_old_visual_lnum;
;               }
;               else
;               {
;                   from = wp.w_old_visual_lnum;
;                   to = wp.w_old_cursor_lnum;
;               }
;           }

            ;; There is no need to update lines above the top of the window.

;           if (from < wp.w_topline)
;               from = wp.w_topline;

            ;; If we know the value of w_botline,
            ;; use it to restrict the update to the lines that are visible in the window.

;           if ((wp.w_valid & VALID_BOTLINE) != 0)
;           {
;               if (from >= wp.w_botline)
;                   from = wp.w_botline - 1;
;               if (to >= wp.w_botline)
;                   to = wp.w_botline - 1;
;           }

            ;; Find the minimal part to be updated.
            ;; Watch out for scrolling that made entries in w_lines[] invalid.
            ;; E.g., CTRL-U makes the first half of w_lines[] invalid and sets top_end;
            ;; need to redraw from top_end to the "to" line.
            ;; A middle mouse click with a Visual selection may change the text above
            ;; the Visual area and reset wl_valid, do count these for mid_end (in srow).

;           if (0 < mid_start)
;           {
;               long lnum = wp.w_topline;       ;; current buffer lnum to display
;               int idx = 0;                    ;; current index in w_lines[]
;               int srow = 0;                   ;; starting row of the current line
;               if (scrolled_down)
;                   mid_start = top_end;
;               else
;                   mid_start = 0;
;               while (lnum < from && idx < wp.w_lines_valid)   ;; find start
;               {
;                   if (wp.w_lines[idx].wl_valid)
;                       mid_start += wp.w_lines[idx].wl_size;
;                   else if (!scrolled_down)
;                       srow += wp.w_lines[idx].wl_size;
;                   idx++;
;                   lnum++;
;               }
;               srow += mid_start;
;               mid_end = wp.w_height;
;               for ( ; idx < wp.w_lines_valid; idx++)          ;; find end
;               {
;                   if (wp.w_lines[idx].wl_valid && to + 1 <= wp.w_lines[idx].wl_lnum)
;                   {
                        ;; Only update until first row of this line.
;                       mid_end = srow;
;                       break;
;                   }
;                   srow += wp.w_lines[idx].wl_size;
;               }
;           }
;       }

;       if (@VIsual_active && buf == @curwin.w_buffer)
;       {
;           wp.w_old_visual_mode = @VIsual_mode;
;           wp.w_old_cursor_lnum = @curwin.w_cursor.lnum;
;           wp.w_old_visual_lnum = @VIsual.lnum;
;           wp.w_old_visual_col = @VIsual.col;
;           wp.w_old_curswant = @curwin.w_curswant;
;       }
;       else
;       {
;           wp.w_old_visual_mode = 0;
;           wp.w_old_cursor_lnum = 0;
;           wp.w_old_visual_lnum = 0;
;           wp.w_old_visual_col = 0;
;       }

        ;; reset got_int, otherwise regexp won't work
;       boolean save_got_int = @got_int;
;       @got_int = false;

        ;; Update all the window rows.

;       int idx = 0;                    ;; first entry in w_lines[].wl_size
;       int row = 0;                    ;; current window row to display
;       int srow = 0;                   ;; starting row of the current line
;       long lnum = wp.w_topline;       ;; first line shown in window
;       for ( ; ; )
;       {
            ;; stop updating when reached the end of the window
            ;; (check for _past_ the end of the window is at the end of the loop)
;           if (row == wp.w_height)
;           {
;               didline = true;
;               break;
;           }

            ;; stop updating when hit the end of the file
;           if (buf.b_ml.ml_line_count < lnum)
;           {
;               eof = true;
;               break;
;           }

            ;; Remember the starting row of the line that is going to be dealt with.
            ;; It is used further down when the line doesn't fit.
;           srow = row;

            ;; Update a line when it is in an area that needs updating,
            ;; when it has changes or w_lines[idx] is invalid.
            ;; bot_start may be halfway a wrapped line after using win_del_lines(),
            ;; check if the current line includes it.
            ;; When syntax folding is being used, the saved syntax states will
            ;; already have been updated, we can't see where the syntax state is
            ;; the same again, just update until the end of the window.

;           if (row < top_end
;                   || (mid_start <= row && row < mid_end)
;                   || top_to_mod
;                   || wp.w_lines_valid <= idx
;                   || (bot_start < row + wp.w_lines[idx].wl_size)
;                   || (mod_top != 0
;                       && (lnum == mod_top
;                           || (mod_top <= lnum
;                               && (lnum < mod_bot
;                                   || did_update == DID_FOLD
                                    ;; match in fixed position might need redraw
                                    ;; if lines were inserted or deleted
;                                   || (wp.w_match_head != null && buf.b_mod_xlines != 0)
;                                   )))))
;           {
;               if (lnum == mod_top)
;                   top_to_mod = false;

                ;; When at start of changed lines:
                ;; may scroll following lines up or down to minimize redrawing.
                ;; Don't do this when the change continues until the end.
                ;; Don't scroll when dollar_vcol >= 0, keep the "$".

;               if (lnum == mod_top
;                       && mod_bot != MAXLNUM
;                       && !(0 <= @dollar_vcol && mod_bot == mod_top + 1))
;               {
;                   int old_rows = 0;
;                   int new_rows = 0;
;                   int xtra_rows;
;                   long l;

                    ;; Count the old number of window rows, using w_lines[], which should
                    ;; still contain the sizes for the lines as they are currently displayed.

;                   for (i = idx; i < wp.w_lines_valid; i++)
;                   {
                        ;; Only valid lines have a meaningful wl_lnum.
                        ;; Invalid lines are part of the changed area.
;                       if (wp.w_lines[i].wl_valid && wp.w_lines[i].wl_lnum == mod_bot)
;                           break;
;                       old_rows += wp.w_lines[i].wl_size;
;                   }

;                   if (wp.w_lines_valid <= i)
;                   {
                        ;; We can't find a valid line below the changed lines,
                        ;; need to redraw until the end of the window.
                        ;; Inserting/deleting lines has no use.
;                       bot_start = 0;
;                   }
;                   else
;                   {
                        ;; Able to count old number of rows:
                        ;; count new window rows, and may insert/delete lines.
;                       int j = idx;
;                       for (l = lnum; l < mod_bot; l++)
;                       {
;                           new_rows += plines_win(wp, l, true);
;                           j++;
;                           if (wp.w_height - row - 2 < new_rows)
;                           {
                                ;; it's getting too much, must redraw the rest
;                               new_rows = 9999;
;                               break;
;                           }
;                       }
;                       xtra_rows = new_rows - old_rows;
;                       if (xtra_rows < 0)
;                       {
                            ;; May scroll text up.
                            ;; If there is not enough remaining text or scrolling fails,
                            ;; must redraw the rest.
                            ;; If scrolling works,
                            ;; must redraw the text below the scrolled text.
;                           if (wp.w_height - 2 <= row - xtra_rows)
;                               mod_bot = MAXLNUM;
;                           else
;                           {
;                               check_for_delay(false);
;                               if (win_del_lines(wp, row, -xtra_rows, false, false) == false)
;                                   mod_bot = MAXLNUM;
;                               else
;                                   bot_start = wp.w_height + xtra_rows;
;                           }
;                       }
;                       else if (0 < xtra_rows)
;                       {
                            ;; May scroll text down.
                            ;; If there is not enough remaining text of scrolling fails,
                            ;; must redraw the rest.
;                           if (wp.w_height - 2 <= row + xtra_rows)
;                               mod_bot = MAXLNUM;
;                           else
;                           {
;                               check_for_delay(false);
;                               if (win_ins_lines(wp, row + old_rows, xtra_rows, false, false) == false)
;                                   mod_bot = MAXLNUM;
;                               else if (row + old_rows < top_end)
                                    ;; Scrolled the part at the top that requires updating down.
;                                   top_end += xtra_rows;
;                           }
;                       }

                        ;; When not updating the rest, may need to move w_lines[] entries.
;                       if (mod_bot != MAXLNUM && i != j)
;                       {
;                           if (j < i)
;                           {
;                               int x = row + new_rows;

                                ;; move entries in w_lines[] upwards
;                               for ( ; ; )
;                               {
                                    ;; stop at last valid entry in w_lines[]
;                                   if (wp.w_lines_valid <= i)
;                                   {
;                                       wp.w_lines_valid = j;
;                                       break;
;                                   }
;                                   COPY_wline(wp.w_lines[j], wp.w_lines[i]);
                                    ;; stop at a line that won't fit
;                                   if (wp.w_height < x + wp.w_lines[j].wl_size)
;                                   {
;                                       wp.w_lines_valid = j + 1;
;                                       break;
;                                   }
;                                   x += wp.w_lines[j++].wl_size;
;                                   i++;
;                               }
;                               if (x < bot_start)
;                                   bot_start = x;
;                           }
;                           else ;; j > i
;                           {
                                ;; move entries in w_lines[] downwards
;                               j -= i;
;                               wp.w_lines_valid += j;
;                               if (wp.w_lines_valid > wp.w_height)
;                                   wp.w_lines_valid = wp.w_height;
;                               for (i = wp.w_lines_valid; idx <= i - j; --i)
;                                   COPY_wline(wp.w_lines[i], wp.w_lines[i - j]);

                                ;; The w_lines[] entries for inserted lines are now invalid,
                                ;; but wl_size may be used above.
                                ;; Reset to zero.
;                               while (idx <= i)
;                               {
;                                   wp.w_lines[i].wl_size = 0;
;                                   wp.w_lines[i--].wl_valid = false;
;                               }
;                           }
;                       }
;                   }
;               }

;               if (idx < wp.w_lines_valid
;                       && wp.w_lines[idx].wl_valid
;                       && wp.w_lines[idx].wl_lnum == lnum
;                       && wp.w_topline < lnum
;                       && (@dy_flags & DY_LASTLINE) == 0
;                       && wp.w_height < srow + wp.w_lines[idx].wl_size)
;               {
                    ;; This line is not going to fit.
                    ;; Don't draw anything here, will draw "@  " lines below.
;                   row = wp.w_height + 1;
;               }
;               else
;               {
;                   prepare_search_hl(wp, lnum);

                    ;; Display one line.

;                   row = win_line(wp, lnum, srow, wp.w_height, mod_top == 0);

;                   did_update = DID_LINE;
;                   syntax_last_parsed = lnum;
;               }

;               wp.w_lines[idx].wl_lnum = lnum;
;               wp.w_lines[idx].wl_valid = true;
;               if (wp.w_height < row)              ;; past end of screen
;               {
                    ;; we may need the size of that too long line later on
;                   if (@dollar_vcol == -1)
;                       wp.w_lines[idx].wl_size = plines_win(wp, lnum, true);
;                   idx++;
;                   break;
;               }
;               if (@dollar_vcol == -1)
;                   wp.w_lines[idx].wl_size = row - srow;
;               idx++;
;               lnum++;
;           }
;           else
;           {
                ;; This line does not need updating, advance to the next one.
;               row += wp.w_lines[idx++].wl_size;
;               if (wp.w_height < row)              ;; past end of screen
;                   break;
;               lnum++;
;               did_update = DID_NONE;
;           }

;           if (buf.b_ml.ml_line_count < lnum)
;           {
;               eof = true;
;               break;
;           }
;       }

        ;; End of loop over all window lines.

;       if (wp.w_lines_valid < idx)
;           wp.w_lines_valid = idx;

        ;; If we didn't hit the end of the file, and we didn't finish the last
        ;; line we were working on, then the line didn't fit.

;       wp.w_empty_rows = 0;
;       if (!eof && !didline)
;       {
;           if (lnum == wp.w_topline)
;           {
                ;; Single line that does not fit!
                ;; Don't overwrite it, it can be edited.

;               wp.w_botline = lnum + 1;
;           }
;           else if ((@dy_flags & DY_LASTLINE) != 0)     ;; 'display' has "lastline"
;           {
                ;; Last line isn't finished: Display "@@@" at the end.

;               screen_fill(wp.w_winrow + wp.w_height - 1, wp.w_winrow + wp.w_height,
;                           wp.w_wincol + wp.w_width - 3, wp.w_wincol + wp.w_width,
;                           '@', '@', hl_attr(HLF_AT));
;               set_empty_rows(wp, srow);
;               wp.w_botline = lnum;
;           }
;           else
;           {
;               win_draw_end(wp, '@', ' ', srow, wp.w_height, HLF_AT);
;               wp.w_botline = lnum;
;           }
;       }
;       else
;       {
;           draw_vsep_win(wp, row);
;           if (eof)                                ;; we hit the end of the file
;           {
;               wp.w_botline = buf.b_ml.ml_line_count + 1;
;           }
;           else if (@dollar_vcol == -1)
;               wp.w_botline = lnum;

            ;; Make sure the rest of the screen is blank,
            ;; put '~'s on rows that aren't part of the file.
;           win_draw_end(wp, '~', ' ', row, wp.w_height, HLF_AT);
;       }

        ;; Reset the type of redrawing required, the window has been updated.
;       wp.w_redr_type = 0;

;       if (@dollar_vcol == -1)
;       {
            ;; There is a trick with w_botline.  If we invalidate it on each
            ;; change that might modify it, this will cause a lot of expensive
            ;; calls to plines() in update_topline() each time.  Therefore the
            ;; value of w_botline is often approximated, and this value is used to
            ;; compute the value of w_topline.  If the value of w_botline was
            ;; wrong, check that the value of w_topline is correct (cursor is on
            ;; the visible part of the text).  If it's not, we need to redraw
            ;; again.  Mostly this just means scrolling up a few lines, so it
            ;; doesn't look too bad.  Only do this for the current window (where
            ;; changes are relevant).

;           wp.w_valid |= VALID_BOTLINE;
;           if (wp == @curwin && wp.w_botline != old_botline && !@_2_recursive)
;           {
;               @_2_recursive = true;
;               @curwin.w_valid &= ~VALID_TOPLINE;
;               update_topline();   ;; may invalidate w_botline again
;               if (@must_redraw != 0)
;               {
                    ;; Don't update for changes in buffer again.
;                   boolean b = @curbuf.b_mod_set;
;                   @curbuf.b_mod_set = false;
;                   win_update(@curwin);
;                   @must_redraw = 0;
;                   @curbuf.b_mod_set = b;
;               }
;               @_2_recursive = false;
;           }
;       }

        ;; restore got_int, unless CTRL-C was hit while redrawing
;       if (!@got_int)
;           @got_int = save_got_int;
    ))

;; Clear the rest of the window and mark the unused lines with "c1".
;; Use "c2" as the filler character.

(defn- #_void win_draw_end [#_window_C wp, #_int c1, #_int c2, #_int row, #_int endrow, #_int hl]
    (§
;       int n = 0;

;       if (wp.w_onebuf_opt.@wo_rl)
;       {
            ;; No check for cmdline window: should never be right-left.
;           screen_fill(wp.w_winrow + row, wp.w_winrow + endrow,
;                       wp.w_wincol, wp.w_wincol + wp.w_width - 1 - n,
;                       c2, c2, hl_attr(hl));
;           screen_fill(wp.w_winrow + row, wp.w_winrow + endrow,
;                       wp.w_wincol + wp.w_width - 1 - n, wp.w_wincol + wp.w_width - n,
;                       c1, c2, hl_attr(hl));
;       }
;       else
;       {
;           if (@cmdwin_type != 0 && wp == @curwin)
;           {
                ;; draw the cmdline character in the leftmost column
;               n = 1;
;               if (n > wp.w_width)
;                   n = wp.w_width;
;               screen_fill(wp.w_winrow + row, wp.w_winrow + endrow,
;                           wp.w_wincol, wp.w_wincol + n,
;                           @cmdwin_type, ' ', hl_attr(HLF_AT));
;           }
;           screen_fill(wp.w_winrow + row, wp.w_winrow + endrow,
;                       wp.w_wincol + n, wp.w_wincol + wp.w_width,
;                       c1, c2, hl_attr(hl));
;       }

;       set_empty_rows(wp, row);
    ))

;; Advance **color_cols and return true when there are columns to draw.

(defn- #_boolean advance_color_col [#_int vcol, #_int* color_cols, #_int* cci]
    (§
;       while (0 <= color_cols[cci[0]] && color_cols[cci[0]] < vcol)
;           cci[0]++;

;       return (0 <= color_cols[cci[0]]);
    ))

;; used for p_extra when displaying lcs_eol at end-of-line
(final Bytes at_end_str (u8 ""))

;; Display line "lnum" of window 'wp' on the screen.
;; Start at row "startrow", stop when "endrow" is reached.
;; wp.w_virtcol needs to be valid.
;;
;; Return the number of last row the line occupies.

(defn- #_int win_line [#_window_C wp, #_long lnum, #_int startrow, #_int endrow, #_boolean _nochange]
    ;; nochange: not updating for changed text
    (§
;       int c = 0;
;       int vcol = 0;                          ;; virtual column (for tabs)
;       int vcol_sbr = -1;                     ;; virtual column after showbreak
;       int vcol_prev = -1;                    ;; "vcol" of previous character

;       Bytes extra = new Bytes(18);            ;; "%ld" and 'fdc' must fit in here
;       int n_extra = 0;                        ;; number of extra chars
;       Bytes p_extra = null;                  ;; string of extra chars, plus NUL
;       Bytes p_extra_free = null;             ;; "p_extra" needs to be freed
;       int c_extra = NUL;                      ;; extra chars, all the same
;       int extra_attr = 0;                     ;; attributes when n_extra != 0

;       int lcs_eol_one = @lcs_eol;              ;; lcs_eol until it's been used
;       int lcs_prec_todo = @lcs_prec;           ;; lcs_prec until it's been used

;       int saved_n_extra = 0;  ;; saved "extra" items for when draw_state becomes WL_LINE (again)
;       Bytes saved_p_extra = null;
;       int saved_c_extra = 0;
;       int saved_char_attr = 0;

;       int n_attr = 0;                         ;; chars with special attr
;       int saved_attr2 = 0;                    ;; char_attr saved for n_attr
;       int n_attr3 = 0;                        ;; chars with overruling special attr
;       int saved_attr3 = 0;                    ;; char_attr saved for n_attr3

;       int n_skip = 0;                         ;; nr of chars to skip for 'nowrap'

;       int fromcol_prev = -2;                  ;; start of inverting after cursor
;       boolean noinvcur = false;               ;; don't invert the cursor
;       pos_C top, bot;
;       boolean lnum_in_visual_area = false;

;       int char_attr = 0;                      ;; attributes for next character
;       boolean attr_pri = false;               ;; char_attr has priority
;       boolean area_highlighting = false;      ;; Visual or incsearch highlighting in this line
;       int attr = 0;                           ;; attributes for area highlighting
;       int area_attr = 0;                      ;; attributes desired by highlighting
;       int search_attr = 0;                    ;; attributes desired by 'hlsearch'
;       int vcol_save_attr = 0;                 ;; saved attr for 'cursorcolumn'
;       int syntax_attr = 0;                    ;; attributes desired by syntax
;       int eol_hl_off = 0;                     ;; 1 if highlighted char after EOL
;       int multi_attr = 0;                     ;; attributes desired by multibyte
;       int mb_l = 1;                           ;; multi-byte byte length
;       int mb_c = 0;                           ;; decoded multi-byte character
;       boolean mb_utf8 = false;                ;; screen char is UTF-8 char
;       int[] u8cc = new int[MAX_MCO];          ;; composing UTF-8 chars
;       int trailcol = MAXCOL;                  ;; start of trailing spaces
;       boolean need_showbreak = false;

;       int line_attr = 0;                      ;; attribute for the whole line
;       int did_line_attr = 0;

        ;; draw_state: items that are drawn in sequence:
;       final int
;           WL_START = 0,                       ;; nothing done yet
;           WL_CMDLINE = WL_START + 1,          ;; cmdline window column
;           WL_NR = WL_CMDLINE + 1,             ;; line number
;           WL_BRI = WL_NR + 1,                 ;; 'breakindent'
;           WL_SBR = WL_BRI + 1,                ;; 'showbreak' or 'diff'
;           WL_LINE = WL_SBR + 1;               ;; text in the line

;       int draw_state = WL_START;              ;; what to draw next

;       int syntax_flags = 0;
;       int[] syntax_seqnr = { 0 };
;       int prev_syntax_id = 0;
;       int conceal_attr = hl_attr(HLF_CONCEAL);
;       boolean is_concealing = false;
;       int boguscols = 0;                      ;; nonexistent columns added to force wrapping
;       int vcol_off = 0;                       ;; offset for concealed characters
;       boolean did_wcol = false;
;       int old_boguscols = 0;

;       if (endrow < startrow)                  ;; past the end already!
;           return startrow;

;       int row = startrow;                     ;; row in the window, excl w_winrow
;       int screen_row = row + wp.w_winrow;     ;; row on the screen, incl w_winrow

        ;; To speed up the loop below, set extra_check when there is linebreak,
        ;; trailing white space and/or syntax processing to be done.

;       boolean extra_check = wp.w_onebuf_opt.@wo_lbr;  ;; has syntax or linebreak

        ;; Check for columns to display for 'colorcolumn'.
;       int[] color_cols = wp.w_p_cc_cols, cci = { 0 };         ;; pointer to according columns array
;       boolean draw_color_col = false;                         ;; highlight colorcolumn
;       if (color_cols != null)
;           draw_color_col = advance_color_col(vcol - vcol_off, color_cols, cci);

        ;; handle visual active in this window

;       int[] fromcol = { -10 }, tocol = { MAXCOL };            ;; start/end of inverting
;       if (@VIsual_active && wp.w_buffer == @curwin.w_buffer)
;       {
;           if (ltoreq(@curwin.w_cursor, @VIsual))                ;; Visual is after curwin.w_cursor
;           {
;               top = @curwin.w_cursor;
;               bot = @VIsual;
;           }
;           else                                                ;; Visual is before curwin.w_cursor
;           {
;               top = @VIsual;
;               bot = @curwin.w_cursor;
;           }

;           lnum_in_visual_area = (top.lnum <= lnum && lnum <= bot.lnum);

;           if (@VIsual_mode == Ctrl_V)                          ;; block mode
;           {
;               if (lnum_in_visual_area)
;               {
;                   fromcol[0] = wp.w_old_cursor_fcol;
;                   tocol[0] = wp.w_old_cursor_lcol;
;               }
;           }
;           else                                        ;; non-block mode
;           {
;               if (top.lnum < lnum && lnum <= bot.lnum)
;                   fromcol[0] = 0;
;               else if (lnum == top.lnum)
;               {
;                   if (@VIsual_mode == 'V')             ;; linewise
;                       fromcol[0] = 0;
;                   else
;                   {
;                       getvvcol(wp, top, fromcol, null, null);
;                       if (gchar_pos(top) == NUL)
;                           tocol[0] = fromcol[0] + 1;
;                   }
;               }
;               if (@VIsual_mode != 'V' && lnum == bot.lnum)
;               {
;                   if (@p_sel.at(0) == (byte)'e' && bot.col == 0 && bot.coladd == 0)
;                   {
;                       fromcol[0] = -10;
;                       tocol[0] = MAXCOL;
;                   }
;                   else if (bot.col == MAXCOL)
;                       tocol[0] = MAXCOL;
;                   else
;                   {
;                       pos_C pos = §_pos_C();
;                       COPY_pos(pos, bot);
;                       if (@p_sel.at(0) == (byte)'e')
;                           getvvcol(wp, pos, tocol, null, null);
;                       else
;                       {
;                           getvvcol(wp, pos, null, null, tocol);
;                           tocol[0]++;
;                       }
;                   }
;               }
;           }

            ;; Check if the character under the cursor should not be inverted.
;           if (!@highlight_match && lnum == @curwin.w_cursor.lnum && wp == @curwin)
;               noinvcur = true;

            ;; if inverting in this line set area_highlighting
;           if (0 <= fromcol[0])
;           {
;               area_highlighting = true;
;               attr = hl_attr(HLF_V);
;           }
;       }

        ;; handle 'incsearch' and ":s///c" highlighting

;       else if (@highlight_match
;               && wp == @curwin
;               && @curwin.w_cursor.lnum <= lnum
;               && lnum <= @curwin.w_cursor.lnum + @search_match_lines)
;       {
;           if (lnum == @curwin.w_cursor.lnum)
;               getvcol(@curwin, @curwin.w_cursor, fromcol, null, null);
;           else
;               fromcol[0] = 0;
;           if (lnum == @curwin.w_cursor.lnum + @search_match_lines)
;           {
;               pos_C pos = §_pos_C();
;               pos.lnum = lnum;
;               pos.col = @search_match_endcol;

;               getvcol(@curwin, pos, tocol, null, null);
;           }
;           else
;               tocol[0] = MAXCOL;
            ;; do at least one character; happens when past end of line
;           if (fromcol[0] == tocol[0])
;               tocol[0] = fromcol[0] + 1;
;           area_highlighting = true;
;           attr = hl_attr(HLF_I);
;       }

;       if (line_attr != 0)
;           area_highlighting = true;

;       Bytes line = ml_get_buf(wp.w_buffer, lnum, false); ;; current line
;       Bytes ptr = line;                                  ;; current position in "line"

        ;; find start of trailing whitespace
;       if (wp.w_onebuf_opt.@wo_list && @lcs_trail != NUL)
;       {
;           trailcol = STRLEN(ptr);
;           while (0 < trailcol && vim_iswhite(ptr.at(trailcol - 1)))
;               --trailcol;
;           trailcol += BDIFF(ptr, line);
;           extra_check = true;
;       }

        ;; 'nowrap' or 'wrap' and a single line that doesn't fit:
        ;; advance to the first character to be displayed.

;       int v;
;       if (wp.w_onebuf_opt.@wo_wrap)
;           v = wp.w_skipcol;
;       else
;           v = wp.w_leftcol;
;       if (0 < v)
;       {
;           Bytes prev_ptr = ptr;
;           while (vcol < v && ptr.at(0) != NUL)
;           {
;               c = win_lbr_chartabsize(wp, line, ptr, vcol, null);
;               vcol += c;
;               prev_ptr = ptr;
;               ptr = ptr.plus(us_ptr2len_cc(ptr));
;           }

            ;; When:
            ;; - 'cuc' is set, or
            ;; - 'colorcolumn' is set, or
            ;; - 'virtualedit' is set, or
            ;; - the visual mode is active,
            ;; the end of the line may be before the start of the displayed part.

;           if (vcol < v && (wp.w_onebuf_opt.@wo_cuc || draw_color_col || virtual_active()
;                               || (@VIsual_active && wp.w_buffer == @curwin.w_buffer)))
;           {
;               vcol = v;
;           }

            ;; Handle a character that's not completely on the screen:
            ;; put 'ptr' at that character, but skip the first few screen characters.
;           if (v < vcol)
;           {
;               vcol -= c;
;               ptr = prev_ptr;
;               n_skip = v - vcol;
;           }

            ;; Adjust for when the inverted text is before the screen,
            ;; and when the start of the inverted text is before the screen.

;           if (tocol[0] <= vcol)
;               fromcol[0] = 0;
;           else if (0 <= fromcol[0] && fromcol[0] < vcol)
;               fromcol[0] = vcol;

            ;; When w_skipcol is non-zero, first line needs 'showbreak'.
;           if (wp.w_onebuf_opt.@wo_wrap)
;               need_showbreak = true;
;       }

        ;; Correct highlighting for cursor that can't be disabled.
        ;; Avoids having to check this for each character.

;       if (0 <= fromcol[0])
;       {
;           if (noinvcur)
;           {
;               if (fromcol[0] == wp.w_virtcol)
;               {
                    ;; highlighting starts at cursor, let it start just after the cursor
;                   fromcol_prev = fromcol[0];
;                   fromcol[0] = -1;
;               }
;               else if (fromcol[0] < wp.w_virtcol)
                    ;; restart highlighting after the cursor
;                   fromcol_prev = wp.w_virtcol;
;           }
;           if (tocol[0] <= fromcol[0])
;               fromcol[0] = -1;
;       }

        ;; Handle highlighting the last used search pattern and matches.
        ;; Do this for both search_hl and the match list.

;       matchitem_C mi = wp.w_match_head;   ;; points to the match list
;       boolean shl_flag = false;           ;; whether search_hl has been processed
;       while (mi != null || !shl_flag)
;       {
;           match_C shl;                    ;; points to search_hl or a match
;           if (!shl_flag)
;           {
;               shl = @search_hl;
;               shl_flag = true;
;           }
;           else
;               shl = mi.mi_hl;
;           shl.startcol = MAXCOL;
;           shl.endcol = MAXCOL;
;           shl.attr_cur = 0;
;           v = BDIFF(ptr, line);
;           if (mi != null)
;               mi.mi_pos.cur = 0;
;           next_search_hl(wp, shl, lnum, v, mi);

            ;; Need to get the line again, a multi-line regexp may have made it invalid.
;           line = ml_get_buf(wp.w_buffer, lnum, false);
;           ptr = line.plus(v);

;           if (shl.lnum != 0 && shl.lnum <= lnum)
;           {
;               if (shl.lnum == lnum)
;                   shl.startcol = shl.rmm.startpos[0].col;
;               else
;                   shl.startcol = 0;
;               if (lnum == shl.lnum + shl.rmm.endpos[0].lnum - shl.rmm.startpos[0].lnum)
;                   shl.endcol = shl.rmm.endpos[0].col;
;               else
;                   shl.endcol = MAXCOL;
                ;; Highlight one character for an empty match.
;               if (shl.startcol == shl.endcol)
;               {
;                   if (line.at(shl.endcol) != NUL)
;                       shl.endcol += us_ptr2len_cc(line.plus(shl.endcol));
;                   else
;                       shl.endcol++;
;               }
;               if ((long)shl.startcol < v) ;; match at leftcol
;               {
;                   shl.attr_cur = shl.attr;
;                   search_attr = shl.attr;
;               }
;               area_highlighting = true;
;           }
;           if (shl != @search_hl && mi != null)
;               mi = mi.next;
;       }

        ;; Cursor line highlighting for 'cursorline' in the current window.
        ;; Not when Visual mode is active, because it's not clear what is selected then.
;       if (wp.w_onebuf_opt.@wo_cul && lnum == wp.w_cursor.lnum && !(wp == @curwin && @VIsual_active))
;       {
;           line_attr = hl_attr(HLF_CUL);
;           area_highlighting = true;
;       }

;       int col = 0;                                        ;; visual column on screen
;       int off = BDIFF(@current_ScreenLine, @screenLines);  ;; offset in screenLines/screenAttrs
;       if (wp.w_onebuf_opt.@wo_rl)
;       {
            ;; Rightleft window: process the text in the normal direction,
            ;; but put it in current_ScreenLine[] from right to left.
            ;; Start at the rightmost column of the window.
;           col = wp.w_width - 1;
;           off += col;
;       }

        ;; Repeat for the whole displayed line.

;       for ( ; ; )
;       {
            ;; Skip this quickly when working on the text.
;           if (draw_state != WL_LINE)
;           {
;               if (draw_state == WL_CMDLINE - 1 && n_extra == 0)
;               {
;                   draw_state = WL_CMDLINE;
;                   if (@cmdwin_type != 0 && wp == @curwin)
;                   {
                        ;; Draw the cmdline character.
;                       n_extra = 1;
;                       c_extra = @cmdwin_type;
;                       char_attr = hl_attr(HLF_AT);
;                   }
;               }

;               if (draw_state == WL_NR - 1 && n_extra == 0)
;               {
;                   draw_state = WL_NR;
                    ;; Display the absolute or relative line number.
                    ;; After the first fill with blanks when the 'n' flag isn't in 'cpo'.
;                   if ((wp.w_onebuf_opt.@wo_nu || wp.w_onebuf_opt.@wo_rnu)
;                           && (row == startrow || vim_strbyte(@p_cpo, CPO_NUMCOL) == null))
;                   {
                        ;; Draw the line number (empty space after wrapping).
;                       if (row == startrow)
;                       {
;                           long num;
;                           Bytes fmt = u8("%*ld ");

;                           if (wp.w_onebuf_opt.@wo_nu && !wp.w_onebuf_opt.@wo_rnu)
                                ;; 'number' + 'norelativenumber'
;                               num = lnum;
;                           else
;                           {
                                ;; 'relativenumber', don't use negative numbers
;                               num = Math.abs(get_cursor_rel_lnum(wp, lnum));
;                               if (num == 0 && wp.w_onebuf_opt.@wo_nu && wp.w_onebuf_opt.@wo_rnu)
;                               {
                                    ;; 'number' + 'relativenumber'
;                                   num = lnum;
;                                   fmt = u8("%-*ld ");
;                               }
;                           }

;                           libC.sprintf(extra, fmt, number_width(wp), num);
;                           if (0 < wp.w_skipcol)
;                               for (p_extra = extra; p_extra.at(0) == (byte)' '; p_extra = p_extra.plus(1))
;                                   p_extra.be(0, (byte)'-');
;                           if (wp.w_onebuf_opt.@wo_rl)             ;; reverse line numbers
;                               rl_mirror(extra);
;                           p_extra = extra;
;                           c_extra = NUL;
;                       }
;                       else
;                           c_extra = ' ';
;                       n_extra = number_width(wp) + 1;
;                       char_attr = hl_attr(HLF_N);
                        ;; When 'cursorline' is set, highlight the line number of the current line differently.
                        ;; TODO: Can we use CursorLine instead of CursorLineNr when CursorLineNr isn't set?
;                       if ((wp.w_onebuf_opt.@wo_cul || wp.w_onebuf_opt.@wo_rnu) && lnum == wp.w_cursor.lnum)
;                           char_attr = hl_attr(HLF_CLN);
;                   }
;               }

;               if (wp.w_p_brisbr && draw_state == WL_BRI - 1 && n_extra == 0 && @p_sbr.at(0) != NUL)
                    ;; draw indent after showbreak value
;                   draw_state = WL_BRI;
;               else if (wp.w_p_brisbr && draw_state == WL_SBR && n_extra == 0)
                    ;; After the showbreak, draw the breakindent.
;                   draw_state = WL_BRI - 1;

                ;; draw 'breakindent': indent wrapped text accordingly
;               if (draw_state == WL_BRI - 1 && n_extra == 0)
;               {
;                   draw_state = WL_BRI;
;                   if (wp.w_onebuf_opt.@wo_bri && n_extra == 0 && row != startrow)
;                   {
;                       char_attr = 0; ;; was: hl_attr(HLF_AT);
;                       p_extra = null;
;                       c_extra = ' ';
;                       n_extra = get_breakindent_win(wp, ml_get_buf(wp.w_buffer, lnum, false));
                        ;; Correct end of highlighted area for 'breakindent',
                        ;; required when 'linebreak' is also set.
;                       if (tocol[0] == vcol)
;                           tocol[0] += n_extra;
;                   }
;               }

;               if (draw_state == WL_SBR - 1 && n_extra == 0)
;               {
;                   draw_state = WL_SBR;
;                   if (@p_sbr.at(0) != NUL && need_showbreak)
;                   {
                        ;; Draw 'showbreak' at the start of each broken line.
;                       p_extra = @p_sbr;
;                       c_extra = NUL;
;                       n_extra = STRLEN(@p_sbr);
;                       char_attr = hl_attr(HLF_AT);
;                       need_showbreak = false;
;                       vcol_sbr = vcol + us_charlen(@p_sbr);
                        ;; Correct end of highlighted area for 'showbreak',
                        ;; required when 'linebreak' is also set.
;                       if (tocol[0] == vcol)
;                           tocol[0] += n_extra;
                        ;; combine 'showbreak' with 'cursorline'
;                       if (wp.w_onebuf_opt.@wo_cul && lnum == wp.w_cursor.lnum)
;                           char_attr = hl_combine_attr(char_attr, hl_attr(HLF_CUL));
;                   }
;               }

;               if (draw_state == WL_LINE - 1 && n_extra == 0)
;               {
;                   draw_state = WL_LINE;
;                   if (saved_n_extra != 0)
;                   {
                        ;; Continue item from end of wrapped line.
;                       n_extra = saved_n_extra;
;                       c_extra = saved_c_extra;
;                       p_extra = saved_p_extra;
;                       char_attr = saved_char_attr;
;                   }
;                   else
;                       char_attr = 0;
;               }
;           }

            ;; When still displaying '$' of change command, stop at cursor.
;           if (0 <= @dollar_vcol && wp == @curwin && lnum == wp.w_cursor.lnum && wp.w_virtcol <= vcol)
;           {
;               screen_line(screen_row, wp.w_wincol, col, -wp.w_width, wp.w_onebuf_opt.@wo_rl);
                ;; Pretend we have finished updating the window,
                ;; except when 'cursorcolumn' is set.
;               if (wp.w_onebuf_opt.@wo_cuc)
;                   row = wp.w_cline_row + wp.w_cline_height;
;               else
;                   row = wp.w_height;
;               break;
;           }

;           if (draw_state == WL_LINE && area_highlighting)
;           {
                ;; handle Visual or match highlighting in this line
;               if (vcol == fromcol[0]
;                       || (vcol + 1 == fromcol[0] && n_extra == 0
;                           && 1 < us_ptr2cells(ptr))
;                       || (vcol_prev == fromcol_prev
;                           && vcol_prev < vcol             ;; not at margin
;                           && vcol < tocol[0]))
;                   area_attr = attr;                       ;; start highlighting
;               else if (area_attr != 0
;                       && (vcol == tocol[0] || (noinvcur && vcol == wp.w_virtcol)))
;                   area_attr = 0;                          ;; stop highlighting

;               if (n_extra == 0)
;               {
                    ;; Check for start/end of search pattern match.
                    ;; After end, check for start/end of next match.
                    ;; When another match, have to check for start again.
                    ;; Watch out for matching an empty string!
                    ;; Do this for 'search_hl' and the match list (ordered by priority).

;                   v = BDIFF(ptr, line);
;                   mi = wp.w_match_head;
;                   shl_flag = false;
;                   while (mi != null || !shl_flag)
;                   {
;                       match_C shl;        ;; points to search_hl or a match
;                       if (!shl_flag && ((mi != null && SEARCH_HL_PRIORITY < mi.priority) || mi == null))
;                       {
;                           shl = @search_hl;
;                           shl_flag = true;
;                       }
;                       else
;                           shl = mi.mi_hl;
;                       if (mi != null)
;                           mi.mi_pos.cur = 0;
                        ;; marks that position match search is in progress
;                       boolean pos_inprogress = true;
;                       while (shl.rmm.regprog != null || (mi != null && pos_inprogress))
;                       {
;                           if (shl.startcol != MAXCOL && shl.startcol <= v && v < shl.endcol)
;                           {
;                               int tmp_col = v + us_ptr2len_cc(ptr);

;                               if (shl.endcol < tmp_col)
;                                   shl.endcol = tmp_col;
;                               shl.attr_cur = shl.attr;
;                           }
;                           else if (v == shl.endcol)
;                           {
;                               shl.attr_cur = 0;
;                               next_search_hl(wp, shl, lnum, v, mi);
;                               pos_inprogress = (mi != null && mi.mi_pos.cur != 0);

                                ;; Need to get the line again, a multi-line regexp may have made it invalid.
;                               line = ml_get_buf(wp.w_buffer, lnum, false);
;                               ptr = line.plus(v);

;                               if (shl.lnum == lnum)
;                               {
;                                   shl.startcol = shl.rmm.startpos[0].col;
;                                   if (shl.rmm.endpos[0].lnum == 0)
;                                       shl.endcol = shl.rmm.endpos[0].col;
;                                   else
;                                       shl.endcol = MAXCOL;

;                                   if (shl.startcol == shl.endcol)
;                                   {
                                        ;; highlight empty match, try again after it
;                                       shl.endcol += us_ptr2len_cc(line.plus(shl.endcol));
;                                   }

                                    ;; Loop to check if the match starts at the current position.
;                                   continue;
;                               }
;                           }
;                           break;
;                       }
;                       if (shl != @search_hl && mi != null)
;                           mi = mi.next;
;                   }

                    ;; Use attributes from match with highest priority
                    ;; among 'search_hl' and the match list.
;                   search_attr = @search_hl.attr_cur;
;                   mi = wp.w_match_head;
;                   shl_flag = false;
;                   while (mi != null || !shl_flag)
;                   {
;                       match_C shl;        ;; points to search_hl or a match
;                       if (!shl_flag && ((mi != null && SEARCH_HL_PRIORITY < mi.priority) || mi == null))
;                       {
;                           shl = @search_hl;
;                           shl_flag = true;
;                       }
;                       else
;                           shl = mi.mi_hl;
;                       if (shl.attr_cur != 0)
;                           search_attr = shl.attr_cur;
;                       if (shl != @search_hl && mi != null)
;                           mi = mi.next;
;                   }
;               }

                ;; Decide which of the highlight attributes to use.
;               attr_pri = true;

;               if (area_attr != 0)
;                   char_attr = hl_combine_attr(line_attr, area_attr);
;               else if (search_attr != 0)
;                   char_attr = hl_combine_attr(line_attr, search_attr);
                    ;; Use line_attr when not in the Visual or 'incsearch' area
                    ;; (area_attr may be 0 when "noinvcur" is set).
;               else if (line_attr != 0 && ((fromcol[0] == -10 && tocol[0] == MAXCOL)
;                                       || vcol < fromcol[0] || vcol_prev < fromcol_prev || tocol[0] <= vcol))
;                   char_attr = line_attr;
;               else
;               {
;                   attr_pri = false;
;                   char_attr = 0;
;               }
;           }

            ;; Get the next character to put on the screen.

            ;; The "p_extra" points to the extra stuff that is inserted to represent
            ;; special characters (non-printable stuff) and other things.
            ;; When all characters are the same, c_extra is used.
            ;; "p_extra" must end in a NUL to avoid us_ptr2len_cc() reads past "p_extra[n_extra]".
            ;; For the '$' of the 'list' option, n_extra == 1, p_extra == "".

;           if (0 < n_extra)
;           {
;               if (c_extra != NUL)
;               {
;                   c = c_extra;
;                   mb_c = c;       ;; doesn't handle non-utf-8 multi-byte!
;                   if (1 < utf_char2len(c))
;                   {
;                       mb_utf8 = true;
;                       u8cc[0] = 0;
;                       c = 0xc0;
;                   }
;                   else
;                       mb_utf8 = false;
;               }
;               else
;               {
;                   c = p_extra.at(0);

;                   mb_c = c;

                    ;; If the UTF-8 character is more than one byte, decode it into "mb_c".
;                   mb_l = us_ptr2len_cc(p_extra);
;                   mb_utf8 = false;
;                   if (n_extra < mb_l)
;                       mb_l = 1;
;                   else if (1 < mb_l)
;                   {
;                       mb_c = us_ptr2char_cc(p_extra, u8cc);
;                       mb_utf8 = true;
;                       c = 0xc0;
;                   }

;                   if (mb_l == 0)  ;; at the NUL at end-of-line
;                       mb_l = 1;

                    ;; If a double-width char doesn't fit display a '>' in the last column.
;                   if ((wp.w_onebuf_opt.@wo_rl ? (col <= 0) : (wp.w_width - 1 <= col)) && utf_char2cells(mb_c) == 2)
;                   {
;                       c = '>';
;                       mb_c = c;
;                       mb_l = 1;
;                       mb_utf8 = false;
;                       multi_attr = hl_attr(HLF_AT);
                        ;; put the pointer back to output the double-width
                        ;; character at the start of the next line
;                       n_extra++;
;                       p_extra = p_extra.minus(1);
;                   }
;                   else
;                   {
;                       n_extra -= mb_l - 1;
;                       p_extra = p_extra.plus(mb_l - 1);
;                   }

;                   p_extra = p_extra.plus(1);
;               }
;               --n_extra;
;           }
;           else
;           {
;               if (p_extra_free != null)
;                   p_extra_free = null;

                ;; Get a character from the line itself.

;               c = ptr.at(0);

;               mb_c = c;

                ;; If the UTF-8 character is more than one byte, decode it into "mb_c".
;               mb_l = us_ptr2len_cc(ptr);
;               mb_utf8 = false;
;               if (1 < mb_l)
;               {
;                   mb_c = us_ptr2char_cc(ptr, u8cc);
                    ;; Overlong encoded ASCII or ASCII with composing char
                    ;; is displayed normally, except a NUL.
;                   if (mb_c < 0x80)
;                       c = mb_c;
;                   mb_utf8 = true;

                    ;; At start of the line we can have a composing char.
                    ;; Draw it as a space with a composing char.
;                   if (utf_iscomposing(mb_c))
;                   {
;                       for (int i = @screen_mco - 1; 0 < i; --i)
;                           u8cc[i] = u8cc[i - 1];
;                       u8cc[0] = mb_c;
;                       mb_c = ' ';
;                   }
;               }

;               if ((mb_l == 1 && 0x80 <= c)
;                       || (1 <= mb_l && mb_c == 0)
;                       || (1 < mb_l && !vim_isprintc(mb_c)))
;               {
                    ;; Illegal UTF-8 byte: display as <xx>.
                    ;; Non-BMP character : display as ? or fullwidth ?.

;                   {
;                       transchar_hex(extra, mb_c);
;                       if (wp.w_onebuf_opt.@wo_rl)             ;; reverse
;                           rl_mirror(extra);
;                   }

;                   p_extra = extra;
;                   c = p_extra.at(0);
;                   { Bytes[] __ = { p_extra }; mb_c = us_ptr2char_adv(__, true); p_extra = __[0]; }
;                   mb_utf8 = (0x80 <= c);
;                   n_extra = STRLEN(p_extra);
;                   c_extra = NUL;
;                   if (area_attr == 0 && search_attr == 0)
;                   {
;                       n_attr = n_extra + 1;
;                       extra_attr = hl_attr(HLF_8);
;                       saved_attr2 = char_attr;    ;; save current attr
;                   }
;               }
;               else if (mb_l == 0)                 ;; at the NUL at end-of-line
;                   mb_l = 1;

                ;; If a double-width char doesn't fit, display a '>' in the last column;
                ;; the character is displayed at the start of the next line.
;               if ((wp.w_onebuf_opt.@wo_rl ? (col <= 0) : (wp.w_width - 1 <= col)) && utf_char2cells(mb_c) == 2)
;               {
;                   c = '>';
;                   mb_c = c;
;                   mb_utf8 = false;
;                   mb_l = 1;
;                   multi_attr = hl_attr(HLF_AT);
                    ;; Put pointer back so that the character will be
                    ;; displayed at the start of the next line.
;                   ptr = ptr.minus(1);
;               }
;               else if (ptr.at(0) != NUL)
;                   ptr = ptr.plus(mb_l - 1);

                ;; If a double-width char doesn't fit at the left side, display a '<'
                ;; in the first column.  Don't do this for unprintable characters.
;               if (0 < n_skip && 1 < mb_l && n_extra == 0)
;               {
;                   n_extra = 1;
;                   c_extra = MB_FILLER_CHAR;
;                   c = ' ';
;                   if (area_attr == 0 && search_attr == 0)
;                   {
;                       n_attr = n_extra + 1;
;                       extra_attr = hl_attr(HLF_AT);
;                       saved_attr2 = char_attr;    ;; save current attr
;                   }
;                   mb_c = c;
;                   mb_utf8 = false;
;                   mb_l = 1;
;               }

;               ptr = ptr.plus(1);

                ;; 'list' : change char 0xa0 to lcs_nbsp.
;               if (wp.w_onebuf_opt.@wo_list && (c == 0xa0 || (mb_utf8 && mb_c == 0xa0)) && @lcs_nbsp != NUL)
;               {
;                   c = @lcs_nbsp;
;                   if (area_attr == 0 && search_attr == 0)
;                   {
;                       n_attr = 1;
;                       extra_attr = hl_attr(HLF_8);
;                       saved_attr2 = char_attr;    ;; save current attr
;                   }
;                   mb_c = c;
;                   if (1 < utf_char2len(c))
;                   {
;                       mb_utf8 = true;
;                       u8cc[0] = 0;
;                       c = 0xc0;
;                   }
;                   else
;                       mb_utf8 = false;
;               }

;               if (extra_check)
;               {
                    ;; Get syntax attribute, unless still at the start of the line
                    ;; (double-wide char that doesn't fit).
;                   v = BDIFF(ptr, line);

                    ;; Found last space before word: check for line break.

;                   if (wp.w_onebuf_opt.@wo_lbr && @breakat_flags[char_u((byte)c)] && !@breakat_flags[char_u(ptr.at(0))])
;                   {
;                       int mb_off = us_head_off(line, ptr.minus(1));
;                       Bytes p = ptr.minus(mb_off + 1);

                        ;; TODO: is passing 'p' for start of the line OK?
;                       n_extra = win_lbr_chartabsize(wp, line, p, vcol, null) - 1;
;                       if (c == TAB && wp.w_width < n_extra + col)
;                           n_extra = (int)wp.w_buffer.@b_p_ts - vcol % (int)wp.w_buffer.@b_p_ts - 1;

;                       c_extra = (0 < mb_off) ? MB_FILLER_CHAR : ' ';
;                       if (vim_iswhite(c))
;                       {
;                           if (c == TAB)       ;; See "Tab alignment" below.
;                           {
;                               n_extra += vcol_off;
;                               vcol -= vcol_off;
;                               vcol_off = 0;
;                               col -= boguscols;
;                               old_boguscols = boguscols;
;                               boguscols = 0;
;                           }
;                           if (!wp.w_onebuf_opt.@wo_list)
;                               c = ' ';
;                       }
;                   }

;                   if (trailcol != MAXCOL && BLT(line.plus(trailcol), ptr) && c == ' ')
;                   {
;                       c = @lcs_trail;
;                       if (!attr_pri)
;                       {
;                           n_attr = 1;
;                           extra_attr = hl_attr(HLF_8);
;                           saved_attr2 = char_attr;    ;; save current attr
;                       }
;                       mb_c = c;
;                       if (1 < utf_char2len(c))
;                       {
;                           mb_utf8 = true;
;                           u8cc[0] = 0;
;                           c = 0xc0;
;                       }
;                       else
;                           mb_utf8 = false;
;                   }
;               }

                ;; Handling of non-printable characters.

;               if ((chartab[c & 0xff] & CT_PRINT_CHAR) == 0)
;               {
                    ;; When getting a character from the file, we may have to turn it
                    ;; into something else on the way to putting it into "screenLines".

;                   if (c == TAB && (!wp.w_onebuf_opt.@wo_list || lcs_tab1[0] != NUL))
;                   {
;                       int tab_len = 0;
;                       int vcol_adjusted = vcol; ;; removed showbreak length
                        ;; Only adjust the "tab_len" when at the first column
                        ;; after the showbreak value was drawn.
;                       if (@p_sbr.at(0) != NUL && vcol == vcol_sbr && wp.w_onebuf_opt.@wo_wrap)
;                           vcol_adjusted = vcol - us_charlen(@p_sbr);
                        ;; tab amount depends on current column
;                       tab_len = (int)wp.w_buffer.@b_p_ts - vcol_adjusted % (int)wp.w_buffer.@b_p_ts - 1;

;                       if (!wp.w_onebuf_opt.@wo_lbr || !wp.w_onebuf_opt.@wo_list)
                            ;; tab amount depends on current column
;                           n_extra = tab_len;
;                       else
;                       {
;                           int len = n_extra;
;                           int saved_nextra = n_extra;

;                           if (0 < vcol_off)
                                ;; there are characters to conceal
;                               tab_len += vcol_off;
                            ;; boguscols before FIX_FOR_BOGUSCOLS macro from above
;                           if (wp.w_onebuf_opt.@wo_list
;                                       && lcs_tab1[0] != NUL && 0 < old_boguscols && tab_len < n_extra)
;                               tab_len += n_extra - tab_len;

                            ;; if n_extra > 0, it gives the number of chars, to use for a tab,
                            ;; else we need to calculate the width for a tab
;                           len = tab_len * utf_char2len(lcs_tab2[0]);
;                           if (0 < n_extra)
;                               len += n_extra - tab_len;
;                           c = lcs_tab1[0];
;                           Bytes p = new Bytes(len + 1);
;                           BFILL(p, 0, (byte)' ', len);
;                           p.be(len, NUL);
;                           p_extra_free = p;
;                           for (int i = 0; i < tab_len; i++)
;                           {
;                               utf_char2bytes(lcs_tab2[0], p);
;                               p = p.plus(utf_char2len(lcs_tab2[0]));
;                               n_extra += utf_char2len(lcs_tab2[0]) - (0 < saved_nextra ? 1 : 0);
;                           }
;                           p_extra = p_extra_free;
                            ;; n_extra will be increased by FIX_FOX_BOGUSCOLS
                            ;; macro below, so need to adjust for that here
;                           if (0 < vcol_off)
;                               n_extra -= vcol_off;
;                       }

;                       {
;                           int vc_saved = vcol_off;

                            ;; Tab alignment should be identical regardless of
                            ;; 'conceallevel' value.  So tab compensates of all
                            ;; previous concealed characters, and thus resets
                            ;; vcol_off and boguscols accumulated so far in the
                            ;; line.  Note that the tab can be longer than
                            ;; 'tabstop' when there are concealed characters.
;                           {
;                               n_extra += vcol_off;
;                               vcol -= vcol_off;
;                               vcol_off = 0;
;                               col -= boguscols;
;                               old_boguscols = boguscols;
;                               boguscols = 0;
;                           }

                            ;; Make sure, the highlighting for the tab char will be
                            ;; correctly set further below (effectively reverts the
                            ;; FIX_FOR_BOGUSCOLS macro
;                           if (n_extra == tab_len + vc_saved && wp.w_onebuf_opt.@wo_list && lcs_tab1[0] != NUL)
;                               tab_len += vc_saved;
;                       }

;                       mb_utf8 = false;                    ;; don't draw as UTF-8
;                       if (wp.w_onebuf_opt.@wo_list)
;                       {
;                           c = lcs_tab1[0];
;                           if (wp.w_onebuf_opt.@wo_lbr)
;                               c_extra = NUL;              ;; using "p_extra" from above
;                           else
;                               c_extra = lcs_tab2[0];
;                           n_attr = tab_len + 1;
;                           extra_attr = hl_attr(HLF_8);
;                           saved_attr2 = char_attr;        ;; save current attr
;                           mb_c = c;
;                           if (1 < utf_char2len(c))
;                           {
;                               mb_utf8 = true;
;                               u8cc[0] = 0;
;                               c = 0xc0;
;                           }
;                       }
;                       else
;                       {
;                           c_extra = ' ';
;                           c = ' ';
;                       }
;                   }
;                   else if (c == NUL
;                           && ((wp.w_onebuf_opt.@wo_list && 0 < @lcs_eol)
;                               || ((0 <= fromcol[0] || 0 <= fromcol_prev)
;                                   && vcol < tocol[0]
;                                   && @VIsual_mode != Ctrl_V
;                                   && (wp.w_onebuf_opt.@wo_rl ? (0 <= col) : (col < wp.w_width))
;                                   && !(noinvcur
;                                       && lnum == wp.w_cursor.lnum
;                                       && vcol == wp.w_virtcol)))
;                           && 0 <= lcs_eol_one)
;                   {
                        ;; Display a '$' after the line or highlight an extra character
                        ;; if the line break is included.

                        ;; For a diff line the highlighting continues after the "$".
;                       if (line_attr == 0)
;                       {
                            ;; In virtualedit, visual selections may extend beyond end of line.
;                           if (area_highlighting && virtual_active() && tocol[0] != MAXCOL && vcol < tocol[0])
;                               n_extra = 0;
;                           else
;                           {
;                               p_extra = at_end_str;
;                               n_extra = 1;
;                               c_extra = NUL;
;                           }
;                       }
;                       if (wp.w_onebuf_opt.@wo_list)
;                           c = @lcs_eol;
;                       else
;                           c = ' ';
;                       lcs_eol_one = -1;
;                       ptr = ptr.minus(1);                 ;; put it back at the NUL
;                       if (!attr_pri)
;                       {
;                           extra_attr = hl_attr(HLF_AT);
;                           n_attr = 1;
;                       }
;                       mb_c = c;
;                       if (1 < utf_char2len(c))
;                       {
;                           mb_utf8 = true;
;                           u8cc[0] = 0;
;                           c = 0xc0;
;                       }
;                       else
;                           mb_utf8 = false;                ;; don't draw as UTF-8
;                   }
;                   else if (c != NUL)
;                   {
;                       p_extra = transchar(c);
;                       if (n_extra == 0)
;                           n_extra = mb_byte2cells((byte)c) - 1;
;                       if ((@dy_flags & DY_UHEX) != 0 && wp.w_onebuf_opt.@wo_rl)
;                           rl_mirror(p_extra);             ;; reverse "<12>"
;                       c_extra = NUL;
;                       if (wp.w_onebuf_opt.@wo_lbr)
;                       {
;                           Bytes p;

;                           c = p_extra.at(0);
;                           p = new Bytes(n_extra + 1);
;                           BFILL(p, 0, (byte)' ', n_extra);
;                           STRNCPY(p, p_extra.plus(1), STRLEN(p_extra) - 1);
;                           p.be(n_extra, NUL);
;                           p_extra_free = p_extra = p;
;                       }
;                       else
;                       {
;                           n_extra = mb_byte2cells((byte)c) - 1;
;                           c = (p_extra = p_extra.plus(1)).at(-1);
;                       }
;                       if (!attr_pri)
;                       {
;                           n_attr = n_extra + 1;
;                           extra_attr = hl_attr(HLF_8);
;                           saved_attr2 = char_attr;        ;; save current attr
;                       }
;                       mb_utf8 = false;                    ;; don't draw as UTF-8
;                   }
;                   else if (@VIsual_active
;                            && (@VIsual_mode == Ctrl_V || @VIsual_mode == 'v')
;                            && virtual_active()
;                            && tocol[0] != MAXCOL
;                            && vcol < tocol[0]
;                            && (wp.w_onebuf_opt.@wo_rl ? (0 <= col) : (col < wp.w_width)))
;                   {
;                       c = ' ';
;                       ptr = ptr.minus(1);                             ;; put it back at the NUL
;                   }
;                   else if ((line_attr != 0)
;                       && (wp.w_onebuf_opt.@wo_rl ? (0 <= col) : (col - boguscols < wp.w_width)))
;                   {
                        ;; Highlight until the right side of the window.
;                       c = ' ';
;                       ptr = ptr.minus(1);                             ;; put it back at the NUL

                        ;; Remember we do the char for line highlighting.
;                       did_line_attr++;

                        ;; don't do search HL for the rest of the line
;                       if (line_attr != 0 && char_attr == search_attr && 0 < col)
;                           char_attr = line_attr;
;                   }
;               }

;               if (0 < wp.w_onebuf_opt.@wo_cole
;                   && (wp != @curwin || lnum != wp.w_cursor.lnum || conceal_cursor_line(wp))
;                   && (syntax_flags & HL_CONCEAL) != 0
;                   && !(lnum_in_visual_area && vim_strchr(wp.w_onebuf_opt.@wo_cocu, 'v') == null))
;               {
;                   char_attr = conceal_attr;
;                   if (prev_syntax_id != syntax_seqnr[0]
;                           && (syn_get_sub_char() != NUL || wp.w_onebuf_opt.@wo_cole == 1)
;                           && wp.w_onebuf_opt.@wo_cole != 3)
;                   {
                        ;; First time at this concealed item: display one character.
;                       if (syn_get_sub_char() != NUL)
;                           c = syn_get_sub_char();
;                       else if (@lcs_conceal != NUL)
;                           c = @lcs_conceal;
;                       else
;                           c = ' ';

;                       prev_syntax_id = syntax_seqnr[0];

;                       if (0 < n_extra)
;                           vcol_off += n_extra;
;                       vcol += n_extra;
;                       if (wp.w_onebuf_opt.@wo_wrap && 0 < n_extra)
;                       {
;                           if (wp.w_onebuf_opt.@wo_rl)
;                           {
;                               col -= n_extra;
;                               boguscols -= n_extra;
;                           }
;                           else
;                           {
;                               boguscols += n_extra;
;                               col += n_extra;
;                           }
;                       }
;                       n_extra = 0;
;                       n_attr = 0;
;                   }
;                   else if (n_skip == 0)
;                   {
;                       is_concealing = true;
;                       n_skip = 1;
;                   }
;                   mb_c = c;
;                   if (1 < utf_char2len(c))
;                   {
;                       mb_utf8 = true;
;                       u8cc[0] = 0;
;                       c = 0xc0;
;                   }
;                   else
;                       mb_utf8 = false;    ;; don't draw as UTF-8
;               }
;               else
;               {
;                   prev_syntax_id = 0;
;                   is_concealing = false;
;               }
;           }

            ;; In the cursor line and we may be concealing characters:
            ;; correct the cursor column when we reach its position.
;           if (!did_wcol && draw_state == WL_LINE
;                   && wp == @curwin && lnum == wp.w_cursor.lnum
;                   && conceal_cursor_line(wp)
;                   && wp.w_virtcol <= vcol + n_skip)
;           {
;               wp.w_wcol = col - boguscols;
;               wp.w_wrow = row;
;               did_wcol = true;
;           }

            ;; Don't override visual selection highlighting.
;           if (0 < n_attr
;                   && draw_state == WL_LINE
;                   && !attr_pri)
;               char_attr = extra_attr;

            ;; Handle the case where we are in column 0 but not on the first
            ;; character of the line and the user wants us to show us a
            ;; special character (via 'listchars' option "precedes:<char>".

;           if (lcs_prec_todo != NUL
;                   && wp.w_onebuf_opt.@wo_list
;                   && (wp.w_onebuf_opt.@wo_wrap ? 0 < wp.w_skipcol : 0 < wp.w_leftcol)
;                   && WL_NR < draw_state
;                   && c != NUL)
;           {
;               c = @lcs_prec;
;               lcs_prec_todo = NUL;
;               if (1 < utf_char2cells(mb_c))
;               {
                    ;; Double-width character being overwritten by the "precedes"
                    ;; character, need to fill up half the character.
;                   c_extra = MB_FILLER_CHAR;
;                   n_extra = 1;
;                   n_attr = 2;
;                   extra_attr = hl_attr(HLF_AT);
;               }
;               mb_c = c;
;               if (1 < utf_char2len(c))
;               {
;                   mb_utf8 = true;
;                   u8cc[0] = 0;
;                   c = 0xc0;
;               }
;               else
;                   mb_utf8 = false;                ;; don't draw as UTF-8
;               if (!attr_pri)
;               {
;                   saved_attr3 = char_attr;        ;; save current attr
;                   char_attr = hl_attr(HLF_AT);    ;; later copied to char_attr
;                   n_attr3 = 1;
;               }
;           }

            ;; At end of the text line or just after the last character.

;           if (c == NUL || did_line_attr == 1)
;           {
;               long prevcol = BDIFF(ptr, line) - ((c == NUL) ? 1 : 0);

                ;; we're not really at that column when skipping some text
;               if (prevcol < (long)(wp.w_onebuf_opt.@wo_wrap ? wp.w_skipcol : wp.w_leftcol))
;                   prevcol++;

                ;; Invert at least one char, used for Visual and empty line or highlight
                ;; match at end of line.  If it's beyond the last char on the screen,
                ;; just overwrite that one (tricky!)
                ;; Not needed when a '$' was displayed for 'list'.

;               boolean prevcol_hl_flag = false;                ;; whether prevcol equals startcol of
                                                                ;; search_hl or one of the matches
;               if (prevcol == (long)@search_hl.startcol)
;                   prevcol_hl_flag = true;
;               else
;               {
;                   for (mi = wp.w_match_head; mi != null; mi = mi.next)
;                       if (prevcol == (long)mi.mi_hl.startcol)
;                       {
;                           prevcol_hl_flag = true;
;                           break;
;                       }
;               }
;               if (@lcs_eol == lcs_eol_one
;                       && ((area_attr != 0 && vcol == fromcol[0]
;                           && (@VIsual_mode != Ctrl_V || lnum == @VIsual.lnum || lnum == @curwin.w_cursor.lnum)
;                           && c == NUL)
                                ;; highlight 'hlsearch' match at end of line
;                               || (prevcol_hl_flag == true && did_line_attr <= 1)))
;               {
;                   int n = 0;

;                   if (wp.w_onebuf_opt.@wo_rl)
;                   {
;                       if (col < 0)
;                           n = 1;
;                   }
;                   else
;                   {
;                       if (wp.w_width <= col)
;                           n = -1;
;                   }
;                   if (n != 0)
;                   {
                        ;; At the window boundary, highlight the last character
                        ;; instead (better than nothing).
;                       off += n;
;                       col += n;
;                   }
;                   else
;                   {
                        ;; Add a blank character to highlight.
;                       @screenLines.be(off, (byte)' ');
;                       @screenLinesUC[off] = 0;
;                   }
;                   if (area_attr == 0)
;                   {
                        ;; Use attributes from match with highest priority
                        ;; among 'search_hl' and the match list.
;                       char_attr = @search_hl.attr;
;                       mi = wp.w_match_head;
;                       shl_flag = false;
;                       while (mi != null || !shl_flag)
;                       {
;                           match_C shl;        ;; points to search_hl or a match
;                           if (!shl_flag && ((mi != null && SEARCH_HL_PRIORITY < mi.priority) || mi == null))
;                           {
;                               shl = @search_hl;
;                               shl_flag = true;
;                           }
;                           else
;                               shl = mi.mi_hl;
;                           if (BDIFF(ptr, line) - 1 == shl.startcol)
;                               char_attr = shl.attr;
;                           if (shl != @search_hl && mi != null)
;                               mi = mi.next;
;                       }
;                   }
;                   @screenAttrs[off] = char_attr;
;                   if (wp.w_onebuf_opt.@wo_rl)
;                   {
;                       --col;
;                       --off;
;                   }
;                   else
;                   {
;                       col++;
;                       off++;
;                   }
;                   vcol++;
;                   eol_hl_off = 1;
;               }
;           }

            ;; At end of the text line.

;           if (c == NUL)
;           {
;               if (0 < eol_hl_off
;                   && vcol - eol_hl_off == wp.w_virtcol
;                   && lnum == wp.w_cursor.lnum)
;               {
                    ;; highlight last char after line
;                   --col;
;                   --off;
;                   --vcol;
;               }

                ;; Highlight 'cursorcolumn' & 'colorcolumn' past end of the line.
;               if (wp.w_onebuf_opt.@wo_wrap)
;                   v = wp.w_skipcol;
;               else
;                   v = wp.w_leftcol;

                ;; check if line ends before left margin
;               if (vcol < v + col - win_col_off(wp))
;                   vcol = v + col - win_col_off(wp);
                ;; Get rid of the boguscols now,
                ;; we want to draw until the right edge for 'cursorcolumn'.
;               col -= boguscols;
;               boguscols = 0;

;               if (draw_color_col)
;                   draw_color_col = advance_color_col(vcol - vcol_off, color_cols, cci);

;               if (((wp.w_onebuf_opt.@wo_cuc
;                         && vcol - vcol_off - eol_hl_off <= wp.w_virtcol
;                         && wp.w_virtcol < wp.w_width * (row - startrow + 1) + v
;                         && lnum != wp.w_cursor.lnum)
;                       || draw_color_col)
;                       && !wp.w_onebuf_opt.@wo_rl)
;               {
;                   int rightmost_vcol = 0;

;                   if (wp.w_onebuf_opt.@wo_cuc)
;                       rightmost_vcol = wp.w_virtcol;
;                   if (draw_color_col)
                        ;; determine rightmost colorcolumn to possibly draw
;                       for (int i = 0; 0 <= color_cols[cci[0] + i]; i++)
;                           if (rightmost_vcol < color_cols[cci[0] + i])
;                               rightmost_vcol = color_cols[cci[0] + i];

;                   while (col < wp.w_width)
;                   {
;                       @screenLines.be(off, (byte)' ');
;                       @screenLinesUC[off] = 0;
;                       col++;
;                       if (draw_color_col)
;                           draw_color_col = advance_color_col(vcol - vcol_off, color_cols, cci);

;                       if (wp.w_onebuf_opt.@wo_cuc && vcol - vcol_off == wp.w_virtcol)
;                           @screenAttrs[off++] = hl_attr(HLF_CUC);
;                       else if (draw_color_col && vcol - vcol_off == color_cols[cci[0]])
;                           @screenAttrs[off++] = hl_attr(HLF_MC);
;                       else
;                           @screenAttrs[off++] = 0;

;                       if (rightmost_vcol <= vcol - vcol_off)
;                           break;

;                       vcol++;
;                   }
;               }

;               screen_line(screen_row, wp.w_wincol, col, wp.w_width, wp.w_onebuf_opt.@wo_rl);
;               row++;

                ;; Update w_cline_height and w_cline_folded if the cursor line was
                ;; updated (saves a call to plines() later).

;               if (wp == @curwin && lnum == @curwin.w_cursor.lnum)
;               {
;                   @curwin.w_cline_row = startrow;
;                   @curwin.w_cline_height = row - startrow;
;                   @curwin.w_valid |= (VALID_CHEIGHT|VALID_CROW);
;               }

;               break;
;           }

            ;; line continues beyond line end
;           if (@lcs_ext != NUL
;                   && !wp.w_onebuf_opt.@wo_wrap
;                   && (wp.w_onebuf_opt.@wo_rl ? col == 0 : col == wp.w_width - 1)
;                   && (ptr.at(0) != NUL
;                       || (wp.w_onebuf_opt.@wo_list && 0 < lcs_eol_one)
;                       || (n_extra != 0 && (c_extra != NUL || p_extra.at(0) != NUL))))
;           {
;               c = @lcs_ext;
;               char_attr = hl_attr(HLF_AT);
;               mb_c = c;
;               if (1 < utf_char2len(c))
;               {
;                   mb_utf8 = true;
;                   u8cc[0] = 0;
;                   c = 0xc0;
;               }
;               else
;                   mb_utf8 = false;
;           }

            ;; advance to the next 'colorcolumn'
;           if (draw_color_col)
;               draw_color_col = advance_color_col(vcol - vcol_off, color_cols, cci);

            ;; Highlight the cursor column if 'cursorcolumn' is set.
            ;; But don't highlight the cursor position itself.
            ;; Also highlight the 'colorcolumn' if it is different than 'cursorcolumn'.
;           vcol_save_attr = -1;
;           if (draw_state == WL_LINE && !lnum_in_visual_area)
;           {
;               if (wp.w_onebuf_opt.@wo_cuc && vcol - vcol_off == wp.w_virtcol && lnum != wp.w_cursor.lnum)
;               {
;                   vcol_save_attr = char_attr;
;                   char_attr = hl_combine_attr(char_attr, hl_attr(HLF_CUC));
;               }
;               else if (draw_color_col && vcol - vcol_off == color_cols[cci[0]])
;               {
;                   vcol_save_attr = char_attr;
;                   char_attr = hl_combine_attr(char_attr, hl_attr(HLF_MC));
;               }
;           }

            ;; Store character to be displayed.
            ;; Skip characters that are left of the screen for 'nowrap'.

;           vcol_prev = vcol;
;           if (draw_state < WL_LINE || n_skip <= 0)
;           {
                ;; Store the character.

;               if (wp.w_onebuf_opt.@wo_rl && 1 < utf_char2cells(mb_c))
;               {
                    ;; A double-wide character is: put first halve in left cell.
;                   --off;
;                   --col;
;               }
;               @screenLines.be(off, c);
;               if (mb_utf8)
;               {
;                   @screenLinesUC[off] = mb_c;
;                   if ((c & 0xff) == 0)
;                       @screenLines.be(off, 0x80);    ;; avoid storing zero
;                   for (int i = 0; i < @screen_mco; i++)
;                   {
;                       @screenLinesC[i][off] = u8cc[i];
;                       if (u8cc[i] == 0)
;                           break;
;                   }
;               }
;               else
;                   @screenLinesUC[off] = 0;
;               if (multi_attr != 0)
;               {
;                   @screenAttrs[off] = multi_attr;
;                   multi_attr = 0;
;               }
;               else
;                   @screenAttrs[off] = char_attr;

;               if (1 < utf_char2cells(mb_c))
;               {
                    ;; Need to fill two screen columns.
;                   off++;
;                   col++;
                    ;; UTF-8: Put a 0 in the second screen char.
;                   @screenLines.be(off, NUL);
;                   vcol++;
                    ;; When "tocol" is halfway a character, set it to the end
                    ;; of the character, otherwise highlighting won't stop.
;                   if (tocol[0] == vcol)
;                       tocol[0]++;
;                   if (wp.w_onebuf_opt.@wo_rl)
;                   {
                        ;; now it's time to backup one cell
;                       --off;
;                       --col;
;                   }
;               }
;               if (wp.w_onebuf_opt.@wo_rl)
;               {
;                   --off;
;                   --col;
;               }
;               else
;               {
;                   off++;
;                   col++;
;               }
;           }
;           else if (0 < wp.w_onebuf_opt.@wo_cole && is_concealing)
;           {
;               --n_skip;
;               vcol_off++;
;               if (0 < n_extra)
;                   vcol_off += n_extra;
;               if (wp.w_onebuf_opt.@wo_wrap)
;               {
                    ;; Special voodoo required if 'wrap' is on.
                    ;;
                    ;; Advance the column indicator to force the line drawing to wrap early.
                    ;; This will make the line take up the same screen space when parts are concealed,
                    ;; so that cursor line computations aren't messed up.
                    ;;
                    ;; To avoid the fictitious advance of 'col' causing trailing junk to be written
                    ;; out of the screen line we are building, 'boguscols' keeps track of the number
                    ;; of bad columns we have advanced.

;                   if (0 < n_extra)
;                   {
;                       vcol += n_extra;
;                       if (wp.w_onebuf_opt.@wo_rl)
;                       {
;                           col -= n_extra;
;                           boguscols -= n_extra;
;                       }
;                       else
;                       {
;                           col += n_extra;
;                           boguscols += n_extra;
;                       }
;                       n_extra = 0;
;                       n_attr = 0;
;                   }

;                   if (1 < utf_char2cells(mb_c))
;                   {
                        ;; Need to fill two screen columns.
;                       if (wp.w_onebuf_opt.@wo_rl)
;                       {
;                           --boguscols;
;                           --col;
;                       }
;                       else
;                       {
;                           boguscols++;
;                           col++;
;                       }
;                   }

;                   if (wp.w_onebuf_opt.@wo_rl)
;                   {
;                       --boguscols;
;                       --col;
;                   }
;                   else
;                   {
;                       boguscols++;
;                       col++;
;                   }
;               }
;               else
;               {
;                   if (0 < n_extra)
;                   {
;                       vcol += n_extra;
;                       n_extra = 0;
;                       n_attr = 0;
;                   }
;               }
;           }
;           else
;               --n_skip;

            ;; Only advance the "vcol" when after the 'number' or 'relativenumber' column.
;           if (WL_NR < draw_state)
;               vcol++;

;           if (0 <= vcol_save_attr)
;               char_attr = vcol_save_attr;

            ;; restore attributes after "predeces" in 'listchars'
;           if (WL_NR < draw_state && 0 < n_attr3 && --n_attr3 == 0)
;               char_attr = saved_attr3;

            ;; restore attributes after last 'listchars' or 'number' char
;           if (0 < n_attr && draw_state == WL_LINE && --n_attr == 0)
;               char_attr = saved_attr2;

            ;; At end of screen line and there is more to come:
            ;; display the line so far.
            ;; If there is no more to display it is caught above.

;           if ((wp.w_onebuf_opt.@wo_rl ? (col < 0) : (wp.w_width <= col))
;                   && (ptr.at(0) != NUL
;                       || (wp.w_onebuf_opt.@wo_list && @lcs_eol != NUL && BNE(p_extra, at_end_str))
;                       || (n_extra != 0 && (c_extra != NUL || p_extra.at(0) != NUL))))
;           {
;               screen_line(screen_row, wp.w_wincol, col - boguscols, wp.w_width, wp.w_onebuf_opt.@wo_rl);
;               boguscols = 0;
;               row++;
;               screen_row++;

                ;; When not wrapping and finished diff lines, or when displayed
                ;; '$' and highlighting until last column, break here.
;               if ((!wp.w_onebuf_opt.@wo_wrap) || lcs_eol_one == -1)
;                   break;

                ;; When the window is too narrow draw all "@" lines.
;               if (draw_state != WL_LINE)
;               {
;                   win_draw_end(wp, '@', ' ', row, wp.w_height, HLF_AT);
;                   draw_vsep_win(wp, row);
;                   row = endrow;
;               }

                ;; When line got too long for screen break here.
;               if (row == endrow)
;               {
;                   row++;
;                   break;
;               }

;               if (@screen_cur_row == screen_row - 1 && wp.w_width == (int)@Columns)
;               {
                    ;; Remember that the line wraps, used for modeless copy.
;                   @lineWraps[screen_row - 1] = true;

                    ;; Special trick to make copy/paste of wrapped lines work with xterm/screen:
                    ;; write an extra character beyond the end of the line.
                    ;; This will work with all terminal types (regardless of the xn,am settings).
                    ;; Only do this on a fast tty.
                    ;; Only do this if the cursor is on the current line
                    ;; (something has been written in it).
                    ;; Don't do this for the GUI.
                    ;; Don't do this for double-width characters.
                    ;; Don't do this for a window not at the right screen border.

;                   if (@p_tf
;                            && !(utf_off2cells(@lineOffset[screen_row],
;                                        @lineOffset[screen_row] + @screenColumns) == 2
;                                    || utf_off2cells(@lineOffset[screen_row - 1] + ((int)@Columns - 2),
;                                        @lineOffset[screen_row] + @screenColumns) == 2))
;                   {
;                       int eoff = @lineOffset[screen_row - 1] + ((int)@Columns - 1);

                        ;; First make sure we are at the end of the screen line,
                        ;; then output the same character again to let the terminal know about the wrap.
                        ;; If the terminal doesn't auto-wrap, we overwrite the character.
;                       if (@screen_cur_col != wp.w_width)
;                           screen_char(eoff, screen_row - 1, ((int)@Columns - 1));

                        ;; When there is a multi-byte character,
                        ;; just output a space to keep it simple.
;                       if (1 < us_byte2len(@screenLines.at(eoff), false))
;                           out_char((byte)' ');
;                       else
;                           out_char(@screenLines.at(eoff));
                        ;; force a redraw of the first char on the next line
;                       @screenAttrs[@lineOffset[screen_row]] = -1;
;                       screen_start();     ;; don't know where cursor is now
;                   }
;               }

;               col = 0;
;               off = BDIFF(@current_ScreenLine, @screenLines);
;               if (wp.w_onebuf_opt.@wo_rl)
;               {
;                   col = wp.w_width - 1;   ;; col is not used if breaking!
;                   off += col;
;               }

                ;; reset the drawing state for the start of a wrapped line
;               draw_state = WL_START;
;               saved_n_extra = n_extra;
;               saved_p_extra = p_extra;
;               saved_c_extra = c_extra;
;               saved_char_attr = char_attr;
;               n_extra = 0;
;               lcs_prec_todo = @lcs_prec;
;                   need_showbreak = true;
;           }
;       }

;       return row;
    ))

;; Return if the composing characters at "off_from" and "off_to" differ.
;; Only to be used when screenLinesUC[off_from] != 0.

(defn- #_boolean comp_char_differs [#_int off_from, #_int off_to]
    (§
;       for (int i = 0; i < @screen_mco; i++)
;       {
;           if (@screenLinesC[i][off_from] != @screenLinesC[i][off_to])
;               return true;
;           if (@screenLinesC[i][off_from] == 0)
;               break;
;       }
;       return false;
    ))

;; Check whether the given character needs redrawing:
;; - the (first byte of the) character is different
;; - the attributes are different
;; - the character is multi-byte and the next byte is different
;; - the character is two cells wide and the second cell differs.

(defn- #_boolean char_needs_redraw [#_int from, #_int to, #_int cols]
    (§
;       return (0 < cols
;           && ((@screenLines.at(from) != @screenLines.at(to) || @screenAttrs[from] != @screenAttrs[to])
;               || (@screenLinesUC[from] != @screenLinesUC[to]
;                   || (@screenLinesUC[from] != 0 && comp_char_differs(from, to))
;                   || (1 < utf_off2cells(from, from + cols)
;                       && @screenLines.at(from + 1) != @screenLines.at(to + 1)))));
    ))

;; Move one "cooked" screen line to the screen, but only the characters that
;; have actually changed.  Handle insert/delete character.
;; "coloff" gives the first column on the screen for this line.
;; "endcol" gives the columns where valid characters are.
;; "clear_width" is the width of the window.  It's > 0 if the rest of the line
;; needs to be cleared, negative otherwise.
;; "rlflag" is true in a rightleft window:
;;    When true and "clear_width" > 0, clear columns 0 to "endcol"
;;    When false and "clear_width" > 0, clear columns "endcol" to "clear_width"

(defn- #_void screen_line [#_int row, #_int coloff, #_int endcol, #_int clear_width, #_boolean rlflag]
    (§
;       int col = 0;
;       boolean force = false;              ;; force update rest of the line
;       boolean clear_next = false;

        ;; Check for illegal row and col, just in case.
;       if (@Rows <= row)
;           row = (int)@Rows - 1;
;       if (@Columns < endcol)
;           endcol = (int)@Columns;

;       clip_may_clear_selection(row, row);

;       int off_from = BDIFF(@current_ScreenLine, @screenLines);
;       int off_to = @lineOffset[row] + coloff;
;       int max_off_from = off_from + @screenColumns;
;       int max_off_to = @lineOffset[row] + @screenColumns;

;       if (rlflag)
;       {
            ;; Clear rest first, because it's left of the text.
;           if (0 < clear_width)
;           {
;               while (col <= endcol && @screenLines.at(off_to) == (byte)' '
;                                    && @screenAttrs[off_to] == 0
;                                    && @screenLinesUC[off_to] == 0)
;               {
;                   off_to++;
;                   col++;
;               }
;               if (col <= endcol)
;                   screen_fill(row, row + 1, col + coloff, endcol + coloff + 1, ' ', ' ', 0);
;           }
;           col = endcol + 1;
;           off_to = @lineOffset[row] + col + coloff;
;           off_from += col;
;           endcol = (0 < clear_width) ? clear_width : -clear_width;
;       }

;       boolean redraw_next = char_needs_redraw(off_from, off_to, endcol - col);

;       while (col < endcol)
;       {
;           int char_cells;             ;; 1: normal char; 2: occupies two display cells
;           if (col + 1 < endcol)
;               char_cells = utf_off2cells(off_from, max_off_from);
;           else
;               char_cells = 1;

            ;; bool: does character need redraw?
;           boolean redraw_this = redraw_next;
            ;; redraw_this for next character
;           redraw_next = force || char_needs_redraw(off_from + char_cells, off_to + char_cells, endcol - col - char_cells);

;           if (redraw_this)
;           {
                ;; When writing a single-width character over a double-width
                ;; character and at the end of the redrawn text, need to clear out
                ;; the right halve of the old character.
                ;; Also required when writing the right halve of a double-width
                ;; char over the left halve of an existing one.
;               if (col + char_cells == endcol
;                       && ((char_cells == 1
;                               && 1 < utf_off2cells(off_to, max_off_to))
;                           || (char_cells == 2
;                               && utf_off2cells(off_to, max_off_to) == 1
;                               && 1 < utf_off2cells(off_to + 1, max_off_to))))
;                   clear_next = true;

;               @screenLines.be(off_to, @screenLines.at(off_from));
;               @screenLinesUC[off_to] = @screenLinesUC[off_from];
;               if (@screenLinesUC[off_from] != 0)
;               {
;                   for (int i = 0; i < @screen_mco; i++)
;                       @screenLinesC[i][off_to] = @screenLinesC[i][off_from];
;               }
;               if (char_cells == 2)
;                   @screenLines.be(off_to + 1, @screenLines.at(off_from + 1));

                ;; The bold trick makes a single column of pixels appear in the
                ;; next character.  When a bold character is removed, the next
                ;; character should be redrawn too.  This happens for our own GUI
                ;; and for some xterms.
;               if (@term_is_xterm)
;               {
;                   int hl = @screenAttrs[off_to];
;                   if (HL_ALL < hl)
;                       hl = syn_attr2attr(hl);
;                   if ((hl & HL_BOLD) != 0)
;                       redraw_next = true;
;               }
;               @screenAttrs[off_to] = @screenAttrs[off_from];
                ;; For simplicity, set the attributes of second half
                ;; of a double-wide character equal to the first half.
;               if (char_cells == 2)
;                   @screenAttrs[off_to + 1] = @screenAttrs[off_from];

;               screen_char(off_to, row, col + coloff);
;           }

;           off_to += char_cells;
;           off_from += char_cells;
;           col += char_cells;
;       }

;       if (clear_next)
;       {
            ;; Clear the second half of a double-wide character of which
            ;; the left half was overwritten with a single-wide character.
;           @screenLines.be(off_to, (byte)' ');
;           @screenLinesUC[off_to] = 0;
;           screen_char(off_to, row, col + coloff);
;       }

;       if (0 < clear_width && !rlflag)
;       {
            ;; blank out the rest of the line
;           while (col < clear_width && @screenLines.at(off_to) == (byte)' '
;                                    && @screenAttrs[off_to] == 0
;                                    && @screenLinesUC[off_to] == 0)
;           {
;               off_to++;
;               col++;
;           }
;           if (col < clear_width)
;           {
;               screen_fill(row, row + 1, col + coloff, clear_width + coloff, ' ', ' ', 0);
;               off_to += clear_width - col;
;               col = clear_width;
;           }
;       }

;       if (0 < clear_width)
;       {
            ;; For a window that's left of another, draw the separator char.
;           if (col + coloff < (int)@Columns)
;           {
;               int[] hl = new int[1];
;               int c = fillchar_vsep(hl);
;               if (@screenLines.at(off_to) != c
;                       || @screenLinesUC[off_to] != (0x80 <= c ? c : 0)
;                       || @screenAttrs[off_to] != hl[0])
;               {
;                   @screenLines.be(off_to, c);
;                   @screenAttrs[off_to] = hl[0];
;                   if (0x80 <= c)
;                   {
;                       @screenLinesUC[off_to] = c;
;                       @screenLinesC[0][off_to] = 0;
;                   }
;                   else
;                       @screenLinesUC[off_to] = 0;
;                   screen_char(off_to, row, col + coloff);
;               }
;           }
;           else
;               @lineWraps[row] = false;
;       }
    ))

;; Mirror text "str" for right-left displaying.
;; Only works for single-byte characters (e.g., numbers).

(defn- #_void rl_mirror [#_Bytes str]
    (§
;       for (Bytes p1 = str, p2 = str.plus(STRLEN(str) - 1); BLT(p1, p2); p1 = p1.plus(1), p2 = p2.minus(1))
;       {
;           byte b = p1.at(0);
;           p1.be(0, p2.at(0));
;           p2.be(0, b);
;       }
    ))

;; mark all status lines for redraw

(defn- #_void status_redraw_all []
    (§
;       for (window_C wp = @firstwin; wp != null; wp = wp.w_next)
;           if (wp.w_status_height != 0)
;           {
;               wp.w_redr_status = true;
;               redraw_later(VALID);
;           }
    ))

;; mark all status lines of the current buffer for redraw

(defn- #_void status_redraw_curbuf []
    (§
;       for (window_C wp = @firstwin; wp != null; wp = wp.w_next)
;           if (wp.w_status_height != 0 && wp.w_buffer == @curbuf)
;           {
;               wp.w_redr_status = true;
;               redraw_later(VALID);
;           }
    ))

;; Redraw all status lines that need to be redrawn.

(defn- #_void redraw_statuslines []
    (§
;       for (window_C wp = @firstwin; wp != null; wp = wp.w_next)
;           if (wp.w_redr_status)
;               win_redr_status(wp);
;       if (@redraw_tabline)
;           draw_tabline();
    ))

;; Draw the verticap separator right of window "wp" starting with line "row".

(defn- #_void draw_vsep_win [#_window_C wp, #_int row]
    (§
;       if (wp.w_vsep_width != 0)
;       {
            ;; draw the vertical separator right of this window
;           int[] hl = new int[1];
;           int c = fillchar_vsep(hl);
;           screen_fill(wp.w_winrow + row, wp.w_winrow + wp.w_height,
;                       wp.w_wincol + wp.w_width, wp.w_wincol + wp.w_width + 1,
;                       c, ' ', hl[0]);
;       }
    ))

(atom! boolean _3_busy)

;; Redraw the status line of window wp.
;;
;; If inversion is possible we use it.  Else '=' characters are used.

(defn- #_void win_redr_status [#_window_C wp]
    (§
        ;; It's possible to get here recursively when 'statusline' (indirectly)
        ;; invokes ":redrawstatus".  Simply ignore the call then.
;       if (@_3_busy)
;           return;
;       @_3_busy = true;

;       wp.w_redr_status = false;
;       if (wp.w_status_height == 0)
;       {
            ;; no status line, can only be last window
;           @redraw_cmdline = true;
;       }
;       else if (!redrawing())
;       {
            ;; Don't redraw right now, do it later.
;           wp.w_redr_status = true;
;       }
;       else
;       {
;           int[] attr = new int[1];
;           int fillchar = fillchar_status(attr, wp == @curwin);

;           get_trans_bufname(wp.w_buffer);
;           Bytes p = @nameBuff;
;           int len = STRLEN(p);

;           if (bufIsChanged(wp.w_buffer) || wp.w_buffer.@b_p_ro)
;               p.be(len++, (byte)' ');
;           if (bufIsChanged(wp.w_buffer))
;           {
;               STRCPY(p.plus(len), u8("[+]"));
;               len += 3;
;           }
;           if (wp.w_buffer.@b_p_ro)
;           {
;               STRCPY(p.plus(len), u8("[RO]"));
;               len += 4;
;           }

;           int this_ru_col = @ru_col - ((int)@Columns - wp.w_width);
;           if (this_ru_col < (wp.w_width + 1) / 2)
;               this_ru_col = (wp.w_width + 1) / 2;
;           if (this_ru_col <= 1)
;           {
;               p = u8("<");                    ;; No room for file name!
;               len = 1;
;           }
;           else
;           {
                ;; Count total number of display cells.
;               len = us_string2cells(p, -1);

                ;; Find first character that will fit.
                ;; Going from start to end is much faster for DBCS.
;               int i;
;               for (i = 0; p.at(i) != NUL && this_ru_col - 1 <= len; i += us_ptr2len_cc(p.plus(i)))
;                   len -= us_ptr2cells(p.plus(i));
;               if (0 < i)
;               {
;                   p = p.plus(i - 1);
;                   p.be(0, (byte)'<');
;                   len++;
;               }
;           }

;           int row = wp.w_winrow + wp.w_height;
;           screen_puts(p, row, wp.w_wincol, attr[0]);
;           screen_fill(row, row + 1, len + wp.w_wincol, this_ru_col + wp.w_wincol, fillchar, fillchar, attr[0]);

;           win_redr_ruler(wp, true);
;       }

        ;; May need to draw the character below the vertical separator.

;       if (wp.w_vsep_width != 0 && wp.w_status_height != 0 && redrawing())
;       {
;           int fillchar;
;           int[] attr = new int[1];
;           if (stl_connected(wp))
;               fillchar = fillchar_status(attr, wp == @curwin);
;           else
;               fillchar = fillchar_vsep(attr);
;           screen_putchar(fillchar, wp.w_winrow + wp.w_height, wp.w_wincol + wp.w_width, attr[0]);
;       }
;       @_3_busy = false;
    ))

;; Return true if the status line of window "wp" is connected to the status
;; line of the window right of it.  If not, then it's a vertical separator.
;; Only call if (wp.w_vsep_width != 0).

(defn- #_boolean stl_connected [#_window_C wp]
    (§
;       for (frame_C fr = wp.w_frame; fr.fr_parent != null; fr = fr.fr_parent)
;       {
;           if (fr.fr_parent.fr_layout == FR_COL)
;           {
;               if (fr.fr_next != null)
;                   break;
;           }
;           else
;           {
;               if (fr.fr_next != null)
;                   return true;
;           }
;       }
;       return false;
    ))

(atom! boolean _3_entered)

;; Redraw the tab pages line from 'tabline'.

(defn- #_void win_redr_custom []
    (§
        ;; There is a tiny chance that this gets called recursively:
        ;; when redrawing a status line triggers redrawing the ruler or tabline.
        ;; Avoid trouble by not allowing recursion.
;       if (@_3_entered)
;           return;
;       @_3_entered = true;

;       stl_hlrec_C[] hltab = ARRAY_stl_hlrec(STL_MAX_ITEM);
;       stl_hlrec_C[] tabtab = ARRAY_stl_hlrec(STL_MAX_ITEM);

;       int col = 0;

        ;; Use 'tabline'.  Always at the first line of the screen.
;       Bytes stl = @p_tal;
;       int row = 0;
;       int fillchar = ' ';
;       int[] attr = new int[1];
;           attr[0] = hl_attr(HLF_TPF);
;       int maxwidth = (int)@Columns;
;       boolean use_sandbox = was_set_insecurely(u8("tabline"), 0);

;       if (0 < maxwidth)
;       {
            ;; Temporarily reset 'cursorbind',
            ;; we don't want a side effect from moving the cursor away and back.
;           window_C ewp = @curwin;
;           boolean p_crb_save = ewp.w_onebuf_opt.@wo_crb;
;           ewp.w_onebuf_opt.@wo_crb = false;

;           Bytes buf = new Bytes(MAXPATHL);
            ;; Make a copy, because the statusline may include a function call that
            ;; might change the option value and free the memory.
;           stl = STRDUP(stl);
;           int width = build_stl_str_hl(ewp, buf, buf.size(), stl, use_sandbox, fillchar, maxwidth, hltab, tabtab);
;           ewp.w_onebuf_opt.@wo_crb = p_crb_save;

            ;; Make all characters printable.
;           vim_strncpy(buf, transstr(buf), buf.size() - 1);

            ;; fill up with "fillchar"
;           int len = STRLEN(buf);
;           while (width < maxwidth && len < buf.size() - 1)
;           {
;               len += utf_char2bytes(fillchar, buf.plus(len));
;               width++;
;           }
;           buf.be(len, NUL);

            ;; Draw each snippet with the specified highlighting.

;           int curattr = attr[0];
;           Bytes p = buf;
;           for (int n = 0; hltab[n].start != null; n++)
;           {
;               len = BDIFF(hltab[n].start, p);
;               screen_puts_len(p, len, row, col, curattr);
;               col += mb_string2cells(p, len);
;               p = hltab[n].start;

;               if (hltab[n].userhl == 0)
;                   curattr = attr[0];
;               else if (hltab[n].userhl < 0)
;                   curattr = syn_id2attr(-hltab[n].userhl);
;               else
;                   curattr = @highlight_user[hltab[n].userhl - 1];
;           }
;           screen_puts(p, row, col, curattr);

            ;; Fill the tabPageIdxs[] array for clicking in the tab pagesline.
;           col = 0;
;           len = 0;
;           p = buf;
;           fillchar = 0;
;           for (int n = 0; tabtab[n].start != null; n++)
;           {
;               len += mb_string2cells(p, BDIFF(tabtab[n].start, p));
;               while (col < len)
;                   @tabPageIdxs[col++] = (short)fillchar;
;               p = tabtab[n].start;
;               fillchar = tabtab[n].userhl;
;           }
;           while (col < (int)@Columns)
;               @tabPageIdxs[col++] = (short)fillchar;
;       }

;       @_3_entered = false;
    ))

;; Output a single character directly to the screen and update "screenLines".

(defn- #_void screen_putchar [#_int c, #_int row, #_int col, #_int attr]
    (§
;       Bytes buf = new Bytes(MB_MAXBYTES + 1);

;       buf.be(utf_char2bytes(c, buf), NUL);
;       screen_puts(buf, row, col, attr);
    ))

;; Get a single character directly from "screenLines" into "bytes[]".
;; Also return its attribute in "*attrp".

(defn- #_void screen_getbytes [#_int row, #_int col, #_Bytes bytes, #_int* attrp]
    (§
        ;; safety check
;       if (@screenLines != null && row < @screenRows && col < @screenColumns)
;       {
;           int off = @lineOffset[row] + col;

;           attrp[0] = @screenAttrs[off];
;           bytes.be(0, @screenLines.at(off));
;           bytes.be(1, NUL);

;           if (@screenLinesUC[off] != 0)
;               bytes.be(utfc_char2bytes(off, bytes), NUL);
;       }
    ))

;; Return true if composing characters for screen posn "off"
;; differs from composing characters in "u8cc".
;; Only to be used when screenLinesUC[off] != 0.

(defn- #_boolean screen_comp_differs [#_int off, #_int* u8cc]
    (§
;       for (int i = 0; i < @screen_mco; i++)
;       {
;           if (@screenLinesC[i][off] != u8cc[i])
;               return true;
;           if (u8cc[i] == 0)
;               break;
;       }
;       return false;
    ))

;; Put string '*text' on the screen at position 'row' and 'col', with
;; attributes 'attr', and update screenLines[] and screenAttrs[].
;; Note: only outputs within one row, message is truncated at screen boundary!
;; Note: if screenLines[], row and/or col is invalid, nothing is done.

(defn- #_void screen_puts [#_Bytes text, #_int row, #_int col, #_int attr]
    (§
;       screen_puts_len(text, -1, row, col, attr);
    ))

;; Like screen_puts(), but output "text[len]".  When "len" is -1 output up to a NUL.

(defn- #_void screen_puts_len [#_Bytes text, #_int textlen, #_int row, #_int col, #_int attr]
    (§
;       boolean clear_next_cell = false;
;       boolean force_redraw_next = false;

;       if (@screenLines == null || @screenRows <= row)       ;; safety check
;           return;

;       int off = @lineOffset[row] + col;

        ;; When drawing over the right halve of a double-wide char clear out the left halve.
        ;; Only needed in a terminal.
;       if (0 < col && col < @screenColumns && mb_fix_col(col, row) != col)
;       {
;           @screenLines.be(off - 1, (byte)' ');
;           @screenAttrs[off - 1] = 0;
;           @screenLinesUC[off - 1] = 0;
;           @screenLinesC[0][off - 1] = 0;
            ;; redraw the previous cell, make it empty
;           screen_char(off - 1, row, col - 1);
            ;; force the cell at "col" to be redrawn
;           force_redraw_next = true;
;       }

;       Bytes ptr = text;
;       int len = textlen;
;       int[] u8cc = new int[MAX_MCO];

;       int max_off = @lineOffset[row] + @screenColumns;
;       while (col < @screenColumns && (len < 0 || BDIFF(ptr, text) < len) && ptr.at(0) != NUL)
;       {
;           byte c = ptr.at(0);

;           int mbyte_blen;
            ;; check if this is the first byte of a multibyte
;           if (0 < len)
;               mbyte_blen = us_ptr2len_cc_len(ptr, BDIFF(text.plus(len), ptr));
;           else
;               mbyte_blen = us_ptr2len_cc(ptr);

;           int u8c;
;           if (0 <= len)
;               u8c = us_ptr2char_cc_len(ptr, u8cc, BDIFF(text.plus(len), ptr));
;           else
;               u8c = us_ptr2char_cc(ptr, u8cc);

;           int mbyte_cells = utf_char2cells(u8c);

;           if (@screenColumns < col + mbyte_cells)
;           {
                ;; Only 1 cell left, but character requires 2 cells:
                ;; display a '>' in the last column to avoid wrapping.
;               c = '>';
;               mbyte_cells = 1;
;           }

;           boolean force_redraw_this = force_redraw_next;
;           force_redraw_next = false;

;           boolean need_redraw = (@screenLines.at(off) != c)
;                   || (mbyte_cells == 2 && @screenLines.at(off + 1) != 0)
;                   || (@screenLinesUC[off] != ((char_u(c) < 0x80 && u8cc[0] == 0) ? 0 : u8c)
;                           || (@screenLinesUC[off] != 0 && screen_comp_differs(off, u8cc)))
;                   || (@screenAttrs[off] != attr)
;                   || (@exmode_active != 0);

;           if (need_redraw || force_redraw_this)
;           {
                ;; The bold trick makes a single row of pixels appear in the next character.
                ;; When a bold character is removed, the next character should be redrawn too.
                ;; This happens for our own GUI and for some xterms.
;               if (need_redraw && @screenLines.at(off) != (byte)' ' && @term_is_xterm)
;               {
;                   int n = @screenAttrs[off];

;                   if (HL_ALL < n)
;                       n = syn_attr2attr(n);
;                   if ((n & HL_BOLD) != 0)
;                       force_redraw_next = true;
;               }
                ;; When at the end of the text and overwriting a two-cell character with
                ;; a one-cell character, need to clear the next cell.  Also when overwriting
                ;; the left halve of a two-cell char with the right halve of a two-cell char.
                ;; Do this only once (utf_off2cells() may return 2 on the right halve).
;               if (clear_next_cell)
;                   clear_next_cell = false;
;               else if ((len < 0 ? ptr.at(mbyte_blen) == NUL : BLE(text.plus(len), ptr.plus(mbyte_blen)))
;                       && ((mbyte_cells == 1 && 1 < utf_off2cells(off, max_off))
;                           || (mbyte_cells == 2
;                               && utf_off2cells(off, max_off) == 1
;                               && 1 < utf_off2cells(off + 1, max_off))))
;                   clear_next_cell = true;

;               @screenLines.be(off, c);
;               @screenAttrs[off] = attr;

;               if (char_u(c) < 0x80 && u8cc[0] == 0)
;                   @screenLinesUC[off] = 0;
;               else
;               {
;                   @screenLinesUC[off] = u8c;
;                   for (int i = 0; i < @screen_mco; i++)
;                   {
;                       @screenLinesC[i][off] = u8cc[i];
;                       if (u8cc[i] == 0)
;                           break;
;                   }
;               }
;               if (mbyte_cells == 2)
;               {
;                   @screenLines.be(off + 1, NUL);
;                   @screenAttrs[off + 1] = attr;
;               }
;               screen_char(off, row, col);
;           }

;           off += mbyte_cells;
;           col += mbyte_cells;
;           ptr = ptr.plus(mbyte_blen);
;           if (clear_next_cell)
;           {
                ;; This only happens at the end, display one space next.
;               ptr = u8(" ");
;               len = -1;
;           }
;       }

        ;; If we detected the next character needs to be redrawn,
        ;; but the text doesn't extend up to there, update the character here.
;       if (force_redraw_next && col < @screenColumns)
;           screen_char(off, row, col);
    ))

;; Prepare for 'hlsearch' highlighting.

(defn- #_void start_search_hl []
    (§
;       if (@p_hls && !@no_hlsearch)
;       {
;           last_pat_prog(@search_hl.rmm);
;           @search_hl.attr = hl_attr(HLF_L);
            ;; Set the time limit to 'redrawtime'.
;           profile_setlimit(@p_rdt, @search_hl.tm);
;       }
    ))

;; Clean up for 'hlsearch' highlighting.

(defn- #_void end_search_hl []
    (§
;       if (@search_hl.rmm.regprog != null)
;           @search_hl.rmm.regprog = null;
    ))

;; Init for calling prepare_search_hl().

(defn- #_void init_search_hl [#_window_C wp]
    (§
        ;; Setup for match and 'hlsearch' highlighting.  Disable any previous match.
;       for (matchitem_C mi = wp.w_match_head; mi != null; mi = mi.next)
;       {
;           COPY_regmmatch(mi.mi_hl.rmm, mi.mi_match);
;           mi.mi_hl.attr = (mi.hlg_id != 0) ? syn_id2attr(mi.hlg_id) : 0;
;           mi.mi_hl.buf = wp.w_buffer;
;           mi.mi_hl.lnum = 0;
;           mi.mi_hl.first_lnum = 0;
            ;; Set the time limit to 'redrawtime'.
;           profile_setlimit(@p_rdt, mi.mi_hl.tm);
;       }
;       @search_hl.buf = wp.w_buffer;
;       @search_hl.lnum = 0;
;       @search_hl.first_lnum = 0;
        ;; time limit is set at the toplevel, for all windows
    ))

;; Advance to the match in window "wp" line "lnum" or past it.

(defn- #_void prepare_search_hl [#_window_C wp, #_long lnum]
    (§
        ;; When using a multi-line pattern, start searching at the top
        ;; of the window or just after a closed fold.
        ;; Do this both for search_hl and the match list.

;       matchitem_C mi = wp.w_match_head;
;       boolean shl_flag = false;               ;; whether search_hl has been processed
;       while (mi != null || !shl_flag)
;       {
;           match_C shl;                        ;; points to search_hl or a match
;           if (!shl_flag)
;           {
;               shl = @search_hl;
;               shl_flag = true;
;           }
;           else
;               shl = mi.mi_hl;
;           if (shl.rmm.regprog != null && shl.lnum == 0 && re_multiline(shl.rmm.regprog))
;           {
;               if (shl.first_lnum == 0)
;                   shl.first_lnum = wp.w_topline;
;               if (mi != null)
;                   mi.mi_pos.cur = 0;
;               boolean pos_inprogress = true;  ;; marks that position match search is in progress
;               int n = 0;
;               while (shl.first_lnum < lnum && (shl.rmm.regprog != null || (mi != null && pos_inprogress)))
;               {
;                   next_search_hl(wp, shl, shl.first_lnum, n, mi);
;                   pos_inprogress = (mi != null && mi.mi_pos.cur != 0);
;                   if (shl.lnum != 0)
;                   {
;                       shl.first_lnum = shl.lnum + shl.rmm.endpos[0].lnum - shl.rmm.startpos[0].lnum;
;                       n = shl.rmm.endpos[0].col;
;                   }
;                   else
;                   {
;                       shl.first_lnum++;
;                       n = 0;
;                   }
;               }
;           }
;           if (shl != @search_hl && mi != null)
;               mi = mi.next;
;       }
    ))

;; Search for a next 'hlsearch' or match.
;; Uses shl.buf.
;; Sets shl.lnum and shl.rmm contents.
;; Note: Assumes a previous match is always before "lnum", unless shl.lnum is zero.
;; Careful: Any pointers for buffer lines will become invalid.

(defn- #_void next_search_hl [#_window_C win, #_match_C shl, #_long lnum, #_int mincol, #_matchitem_C mi]
    ;; shl: points to search_hl or a match
    ;; mincol: minimal column for a match
    ;; mi: to retrieve match positions if any
    (§
;       if (shl.lnum != 0)
;       {
            ;; Check for three situations:
            ;; 1. If the "lnum" is below a previous match, start a new search.
            ;; 2. If the previous match includes "mincol", use it.
            ;; 3. Continue after the previous match.

;           long l = shl.lnum + shl.rmm.endpos[0].lnum - shl.rmm.startpos[0].lnum;
;           if (l < lnum)
;               shl.lnum = 0;
;           else if (lnum < l || mincol < shl.rmm.endpos[0].col)
;               return;
;       }

        ;; Repeat searching for a match until one is found that includes "mincol"
        ;; or none is found in this line.

;       @called_emsg = false;
;       for ( ; ; )
;       {
            ;; Stop searching after passing the time limit.
;           if (profile_passed_limit(shl.tm))
;           {
;               shl.lnum = 0;   ;; no match found in time
;               break;
;           }
            ;; Three situations:
            ;; 1. No useful previous match: search from start of line.
            ;; 2. Not Vi compatible or empty match: continue at next character.
            ;;    Break the loop if this is beyond the end of the line.
            ;; 3. Vi compatible searching: continue at end of previous match.

;           int matchcol;
;           if (shl.lnum == 0)
;               matchcol = 0;
;           else if (vim_strbyte(@p_cpo, CPO_SEARCH) == null
;                   || (shl.rmm.endpos[0].lnum == 0 && shl.rmm.endpos[0].col <= shl.rmm.startpos[0].col))
;           {
;               matchcol = shl.rmm.startpos[0].col;
;               Bytes ml = ml_get_buf(shl.buf, lnum, false).plus(matchcol);
;               if (ml.at(0) == NUL)
;               {
;                   matchcol++;
;                   shl.lnum = 0;
;                   break;
;               }
;               matchcol += us_ptr2len_cc(ml);
;           }
;           else
;               matchcol = shl.rmm.endpos[0].col;

;           long nmatched;

;           shl.lnum = lnum;
;           if (shl.rmm.regprog != null)
;           {
                ;; Remember whether shl.rmm is using a copy of the regprog in mi.mi_match.
;               boolean regprog_is_copy = (shl != @search_hl && mi != null
;                                       && shl == mi.mi_hl
;                                       && mi.mi_match.regprog == mi.mi_hl.rmm.regprog);

;               nmatched = vim_regexec_multi(shl.rmm, win, shl.buf, lnum, matchcol, shl.tm);
                ;; Copy the regprog, in case it got freed and recompiled.
;               if (regprog_is_copy)
;                   mi.mi_match.regprog = mi.mi_hl.rmm.regprog;

;               if (@called_emsg || @got_int)
;               {
                    ;; Error while handling regexp: stop using this regexp.
;                   if (shl == @search_hl)
;                   {
;                       @no_hlsearch = true;
;                   }
;                   shl.rmm.regprog = null;
;                   shl.lnum = 0;
;                   @got_int = false;    ;; avoid the "Type :quit to exit Vim" message
;                   break;
;               }
;           }
;           else if (mi != null)
;               nmatched = next_search_hl_pos(shl, lnum, mi.mi_pos, matchcol) ? 1 : 0;
;           else
;               nmatched = 0;
;           if (nmatched == 0)
;           {
;               shl.lnum = 0;           ;; no match found
;               break;
;           }
;           if (0 < shl.rmm.startpos[0].lnum
;                   || mincol <= shl.rmm.startpos[0].col
;                   || 1 < nmatched
;                   || mincol < shl.rmm.endpos[0].col)
;           {
;               shl.lnum += shl.rmm.startpos[0].lnum;
;               break;                  ;; useful match found
;           }
;       }
    ))

(defn- #_boolean next_search_hl_pos [#_match_C shl, #_long lnum, #_posmatch_C posmatch, #_int mincol]
    ;; shl: points to a match
    ;; posmatch: match positions
    ;; mincol: minimal column for a match
    (§
;       int bot = -1;

;       llpos_C tmp = §_llpos_C();

;       shl.lnum = 0;
;       for (int i = posmatch.cur; i < MAXPOSMATCH; i++)
;       {
;           if (posmatch.pm_pos[i].lnum == 0)
;               break;
;           if (posmatch.pm_pos[i].col < mincol)
;               continue;
;           if (posmatch.pm_pos[i].lnum == lnum)
;           {
;               if (shl.lnum == lnum)
;               {
                    ;; partially sort positions by column numbers on the same line
;                   if (posmatch.pm_pos[i].col < posmatch.pm_pos[bot].col)
;                   {
;                       COPY_llpos(tmp, posmatch.pm_pos[i]);
;                       COPY_llpos(posmatch.pm_pos[i], posmatch.pm_pos[bot]);
;                       COPY_llpos(posmatch.pm_pos[bot], tmp);
;                   }
;               }
;               else
;               {
;                   bot = i;
;                   shl.lnum = lnum;
;               }
;           }
;       }
;       posmatch.cur = 0;

;       if (shl.lnum == lnum)
;       {
;           int start = (posmatch.pm_pos[bot].col == 0) ? 0 : posmatch.pm_pos[bot].col - 1;
;           int end = (posmatch.pm_pos[bot].col == 0) ? MAXCOL : start + posmatch.pm_pos[bot].len;

;           shl.rmm.startpos[0].lnum = 0;
;           shl.rmm.startpos[0].col = start;
;           shl.rmm.endpos[0].lnum = 0;
;           shl.rmm.endpos[0].col = end;
;           posmatch.cur = bot + 1;

;           return true;
;       }

;       return false;
    ))

(defn- #_void screen_start_highlight [#_int attr]
    (§
;       attrentry_C aep = null;

;       @screen_attr = attr;
;       if (@full_screen)
;       {
;           if (HL_ALL < attr)                                  ;; special HL attr.
;           {
;               if (1 < @t_colors)
;                   aep = syn_cterm_attr2entry(attr);
;               else
;                   aep = syn_term_attr2entry(attr);
;               if (aep == null)                                ;; did ":syntax clear"
;                   attr = 0;
;               else
;                   attr = aep.ae_attr;
;           }
;           if ((attr & HL_BOLD) != 0 && @T_MD != null)          ;; bold
;               out_str(@T_MD);
;           else if (aep != null && 1 < @t_colors && aep.ae_fg_color != 0 && @cterm_normal_fg_bold != 0)
                ;; If the Normal FG color has BOLD attribute
                ;; and the new HL has a FG color defined, clear BOLD.
;               out_str(@T_ME);
;           if ((attr & HL_STANDOUT) != 0 && @T_SO != null)      ;; standout
;               out_str(@T_SO);
;           if ((attr & (HL_UNDERLINE | HL_UNDERCURL)) != 0 && @T_US != null) ;; underline or undercurl
;               out_str(@T_US);
;           if ((attr & HL_ITALIC) != 0 && @T_CZH != null)       ;; italic
;               out_str(@T_CZH);
;           if ((attr & HL_INVERSE) != 0 && @T_MR != null)       ;; inverse (reverse)
;               out_str(@T_MR);

            ;; Output the color or start string after bold etc.,
            ;; in case the bold etc. override the color setting.

;           if (aep != null)
;           {
;               if (1 < @t_colors)
;               {
;                   if (aep.ae_fg_color != 0)
;                       term_fg_color(aep.ae_fg_color - 1);
;                   if (aep.ae_bg_color != 0)
;                       term_bg_color(aep.ae_bg_color - 1);
;               }
;               else
;               {
;                   if (aep.ae_esc_start != null)
;                       out_str(aep.ae_esc_start);
;               }
;           }
;       }
    ))

(defn- #_void screen_stop_highlight []
    (§
;       boolean do_ME = false;                          ;; output T_ME code

;       if (@screen_attr != 0)
;       {
;           if (HL_ALL < @screen_attr)                   ;; special HL attr.
;           {
;               attrentry_C aep;

;               if (1 < @t_colors)
;               {
                    ;; Assume that t_me restores the original colors!

;                   aep = syn_cterm_attr2entry(@screen_attr);
;                   if (aep != null && (aep.ae_fg_color != 0 || aep.ae_bg_color != 0))
;                       do_ME = true;
;               }
;               else
;               {
;                   aep = syn_term_attr2entry(@screen_attr);
;                   if (aep != null && aep.ae_esc_stop != null)
;                   {
;                       if (STRCMP(aep.ae_esc_stop, @T_ME) == 0)
;                           do_ME = true;
;                       else
;                           out_str(aep.ae_esc_stop);
;                   }
;               }
;               if (aep == null)                        ;; did ":syntax clear"
;                   @screen_attr = 0;
;               else
;                   @screen_attr = aep.ae_attr;
;           }

            ;; Often all ending-codes are equal to T_ME.
            ;; Avoid outputting the same sequence several times.

;           if ((@screen_attr & HL_STANDOUT) != 0)
;           {
;               if (STRCMP(@T_SE, @T_ME) == 0)
;                   do_ME = true;
;               else
;                   out_str(@T_SE);
;           }
;           if ((@screen_attr & (HL_UNDERLINE | HL_UNDERCURL)) != 0)
;           {
;               if (STRCMP(@T_UE, @T_ME) == 0)
;                   do_ME = true;
;               else
;                   out_str(@T_UE);
;           }
;           if ((@screen_attr & HL_ITALIC) != 0)
;           {
;               if (STRCMP(@T_CZR, @T_ME) == 0)
;                   do_ME = true;
;               else
;                   out_str(@T_CZR);
;           }
;           if (do_ME || (@screen_attr & (HL_BOLD | HL_INVERSE)) != 0)
;               out_str(@T_ME);

;           if (1 < @t_colors)
;           {
                ;; set Normal cterm colors
;               if (@cterm_normal_fg_color != 0)
;                   term_fg_color(@cterm_normal_fg_color - 1);
;               if (@cterm_normal_bg_color != 0)
;                   term_bg_color(@cterm_normal_bg_color - 1);
;               if (@cterm_normal_fg_bold != 0)
;                   out_str(@T_MD);
;           }
;       }
;       @screen_attr = 0;
    ))

;; Reset the colors for a cterm.  Used when leaving Vim.
;; The machine specific code may override this again.

(defn- #_void reset_cterm_colors []
    (§
;       if (1 < @t_colors)
;       {
            ;; set Normal cterm colors
;           if (0 < @cterm_normal_fg_color || 0 < @cterm_normal_bg_color)
;           {
;               out_str(@T_OP);
;               @screen_attr = -1;
;           }
;           if (@cterm_normal_fg_bold != 0)
;           {
;               out_str(@T_ME);
;               @screen_attr = -1;
;           }
;       }
    ))

;; Put character screenLines["off"] on the screen at position "row" and "col",
;; using the attributes from screenAttrs["off"].

(defn- #_void screen_char [#_int off, #_int row, #_int col]
    (§
        ;; Check for illegal values, just in case (could happen just after resizing).
;       if (@screenRows <= row || @screenColumns <= col)
;           return;

        ;; Outputting a character in the last cell on the screen may scroll the
        ;; screen up.  Only do it when the "xn" termcap property is set, otherwise
        ;; mark the character invalid (update it when scrolled up).
;       if (@T_XN.at(0) == NUL
;               && row == @screenRows - 1 && col == @screenColumns - 1
                ;; account for first command-line character in rightleft mode
;               && !@cmdmsg_rl)
;       {
;           @screenAttrs[off] = -1;
;           return;
;       }

        ;; Stop highlighting first, so it's easier to move the cursor.

;       int attr;
;       if (@screen_char_attr != 0)
;           attr = @screen_char_attr;
;       else
;           attr = @screenAttrs[off];
;       if (@screen_attr != attr)
;           screen_stop_highlight();

;       windgoto(row, col);

;       if (@screen_attr != attr)
;           screen_start_highlight(attr);

;       if (@screenLinesUC[off] != 0)
;       {
;           Bytes buf = new Bytes(MB_MAXBYTES + 1);

            ;; Convert UTF-8 character to bytes and write it.
;           buf.be(utfc_char2bytes(off, buf), NUL);

;           out_str(buf);
;           if (1 < utf_char2cells(@screenLinesUC[off]))
;               @screen_cur_col++;
;       }
;       else
;       {
;           out_flush_check();
;           out_char(@screenLines.at(off));
;       }

;       @screen_cur_col++;
    ))

;; Draw a rectangle of the screen, inverted when "invert" is true.
;; This uses the contents of screenLines[] and doesn't change it.

(defn- #_void screen_draw_rectangle [#_int row, #_int col, #_int height, #_int width, #_boolean invert]
    (§
        ;; Can't use "screenLines" unless initialized.
;       if (@screenLines == null)
;           return;

;       if (invert)
;           @screen_char_attr = HL_INVERSE;
;       for (int r = row; r < row + height; r++)
;       {
;           int off = @lineOffset[r];
;           int max_off = off + @screenColumns;
;           for (int c = col; c < col + width; c++)
;           {
;               screen_char(off + c, r, c);
;               if (1 < utf_off2cells(off + c, max_off))
;                   c++;
;           }
;       }
;       @screen_char_attr = 0;
    ))

;; Redraw the characters for a vertically split window.

(defn- #_void redraw_block [#_int row, #_int end, #_window_C wp]
    (§
;       clip_may_clear_selection(row, end - 1);

;       int col;
;       int width;

;       if (wp == null)
;       {
;           col = 0;
;           width = (int)@Columns;
;       }
;       else
;       {
;           col = wp.w_wincol;
;           width = wp.w_width;
;       }

;       screen_draw_rectangle(row, col, end - row, width, false);
    ))

;; Fill the screen from 'start_row' to 'end_row', from 'start_col' to 'end_col'
;; with character 'c1' in first column followed by 'c2' in the other columns.
;; Use attributes 'attr'.

(defn- #_void screen_fill [#_int start_row, #_int end_row, #_int start_col, #_int end_col, #_int c1, #_int c2, #_int attr]
    (§
;       boolean force_next = false;

;       if (@screenRows < end_row)               ;; safety check
;           end_row = @screenRows;
;       if (@screenColumns < end_col)            ;; safety check
;           end_col = @screenColumns;
;       if (@screenLines == null
;               || end_row <= start_row
;               || end_col <= start_col)        ;; nothing to do
;           return;

        ;; it's a "normal" terminal when not in a GUI or cterm
;       boolean norm_term = (@t_colors <= 1);

;       for (int row = start_row; row < end_row; row++)
;       {
            ;; When drawing over the right halve of a double-wide char clear out the left halve.
            ;; When drawing over the left halve of a double wide-char clear out the right halve.
            ;; Only needed in a terminal.
;           if (0 < start_col && mb_fix_col(start_col, row) != start_col)
;               screen_puts_len(u8(" "), 1, row, start_col - 1, 0);
;           if (end_col < @screenColumns && mb_fix_col(end_col, row) != end_col)
;               screen_puts_len(u8(" "), 1, row, end_col, 0);

            ;; Try to use delete-line termcap code, when no attributes or in a
            ;; "normal" terminal, where a bold/italic space is just a space.

;           boolean did_delete = false;
;           if (c2 == ' '
;                   && end_col == (int)@Columns
;                   && can_clear(@T_CE)
;                   && (attr == 0
;                       || (norm_term
;                           && attr <= HL_ALL
;                           && ((attr & ~(HL_BOLD | HL_ITALIC)) == 0))))
;           {
                ;; check if we really need to clear something

;               int col = start_col;
;               if (c1 != ' ')                      ;; don't clear first char
;                   col++;

;               int off = @lineOffset[row] + col;
;               int end_off = @lineOffset[row] + end_col;

                ;; skip blanks (used often, keep it fast!)
;               while (off < end_off && @screenLines.at(off) == (byte)' '
;                                    && @screenAttrs[off] == 0
;                                    && @screenLinesUC[off] == 0)
;                   off++;
;               if (off < end_off)                  ;; something to be cleared
;               {
;                   col = off - @lineOffset[row];
;                   screen_stop_highlight();
;                   term_windgoto(row, col);        ;; clear rest of this screen line
;                   out_str(@T_CE);
;                   screen_start();                 ;; don't know where cursor is now
;                   col = end_col - col;
;                   while (0 < col--)                   ;; clear chars in "screenLines"
;                   {
;                       @screenLines.be(off, (byte)' ');
;                       @screenLinesUC[off] = 0;
;                       @screenAttrs[off] = 0;
;                       off++;
;                   }
;               }
;               did_delete = true;                  ;; the chars are cleared now
;           }

;           int off = @lineOffset[row] + start_col;
;           int c = c1;
;           for (int col = start_col; col < end_col; col++)
;           {
;               if (@screenLines.at(off) != c
;                       || @screenLinesUC[off] != (0x80 <= c ? c : 0)
;                       || @screenAttrs[off] != attr
;                       || force_next)
;               {
                    ;; The bold trick may make a single row of pixels appear in
                    ;; the next character.  When a bold character is removed, the
                    ;; next character should be redrawn too.  This happens for our
                    ;; own GUI and for some xterms.
;                   if (@term_is_xterm)
;                   {
;                       if (@screenLines.at(off) != (byte)' '
;                               && (HL_ALL < @screenAttrs[off] || (@screenAttrs[off] & HL_BOLD) != 0))
;                           force_next = true;
;                       else
;                           force_next = false;
;                   }
;                   @screenLines.be(off, c);
;                   if (0x80 <= c)
;                   {
;                       @screenLinesUC[off] = c;
;                       @screenLinesC[0][off] = 0;
;                   }
;                   else
;                       @screenLinesUC[off] = 0;
;                   @screenAttrs[off] = attr;
;                   if (!did_delete || c != ' ')
;                       screen_char(off, row, col);
;               }
;               off++;
;               if (col == start_col)
;               {
;                   if (did_delete)
;                       break;
;                   c = c2;
;               }
;           }
;           if (end_col == (int)@Columns)
;               @lineWraps[row] = false;
;           if (row == (int)@Rows - 1)                ;; overwritten the command line
;           {
;               @redraw_cmdline = true;
;               if (c1 == ' ' && c2 == ' ')
;                   @clear_cmdline = false;      ;; command line has been cleared
;               if (start_col == 0)
;                   @mode_displayed = false;     ;; mode cleared or overwritten
;           }
;       }
    ))

;; Check if there should be a delay.
;; Used before clearing or redrawing the screen or the command line.

(defn- #_void check_for_delay [#_boolean check_msg_scroll]
    (§
;       if ((@emsg_on_display || (check_msg_scroll && @msg_scroll)) && !@did_wait_return && @emsg_silent == 0)
;       {
;           out_flush();
;           ui_delay(1000L, true);
;           @emsg_on_display = false;
;           if (check_msg_scroll)
;               @msg_scroll = false;
;       }
    ))

;; screen_valid -  allocate screen buffers if size changed
;;   If "doclear" is true: clear screen if it has been resized.
;;      Returns true if there is a valid screen to write to.
;;      Returns false when starting up and screen not initialized yet.

(defn- #_boolean screen_valid [#_boolean doclear]
    (§
;       screenalloc(doclear);           ;; allocate screen buffers if size changed

;       return (@screenLines != null);
    ))

(atom! boolean _4_entered)  ;; avoid recursiveness

;; Resize the shell to Rows and Columns.
;; Allocate screenLines[] and associated items.
;;
;; There may be some time between setting Rows and Columns and (re)allocating
;; screenLines[].  This happens when starting up and when (manually) changing
;; the shell size.  Always use screenRows and screenColumns to access items
;; in screenLines[].  Use Rows and Columns for positioning text etc. where the
;; final size of the shell is needed.

(defn- #_void screenalloc [#_boolean doclear]
    (§
;       int[][] smco = new int[MAX_MCO][];

;       int retry_count = 0;

;       retry:
;       for ( ; ; )
;       {
            ;; Allocation of the screen buffers is done only when the size changes and
            ;; when Rows and Columns have been set and we have started doing full screen stuff.

;           if ((@screenLines != null
;                       && (int)@Rows == @screenRows
;                       && (int)@Columns == @screenColumns
;                       && @screenLinesUC != null
;                       && @p_mco == @screen_mco)
;                   || (int)@Rows == 0
;                   || (int)@Columns == 0
;                   || (!@full_screen && @screenLines == null))
;               return;

            ;; It's possible that we produce an out-of-memory message below, which
            ;; will cause this function to be called again.  To break the loop, just return here.

;           if (@_4_entered)
;               return;
;           @_4_entered = true;

            ;; Note that the window sizes are updated before reallocating the arrays,
            ;; thus we must not redraw here!

;           @redrawingDisabled++;

;           win_new_shellsize();    ;; fit the windows in the new sized shell

;           comp_col();             ;; recompute columns for shown command and ruler

            ;; We're changing the size of the screen.
            ;; - Allocate new arrays for "screenLines" and "screenAttrs".
            ;; - Move lines from the old arrays into the new arrays, clear extra
            ;;   lines (unless the screen is going to be cleared).
            ;; - Free the old arrays.
            ;;
            ;; If anything fails, make "screenLines" null, so we don't do anything!
            ;; Continuing with the old "screenLines" may result in a crash, because the size is wrong.

;           for (tabpage_C tp = @first_tabpage; tp != null; tp = null)
;               for (window_C wp = (tp == @curtab) ? @firstwin : tp.tp_firstwin; wp != null; wp = wp.w_next)
;                   win_free_lines(wp);
;           if (@aucmd_win != null)
;               win_free_lines(@aucmd_win);

;           Bytes slis = new Bytes((int)(@Rows + 1) * (int)@Columns);
;           for (int i = 0; i < MAX_MCO; i++)
;               smco[i] = null;
;           int[] sluc = new int[(int)(@Rows + 1) * (int)@Columns];
;           for (int i = 0; i < @p_mco; i++)
;               smco[i] = new int[(int)(@Rows + 1) * (int)@Columns];

;           int[] sats = new int[(int)(@Rows + 1) * (int)@Columns];
;           int[] lofs = new int[(int)@Rows];
;           boolean[] lwrs = new boolean[(int)@Rows];
;           short[] tpis = new short[(int)@Columns];

;           for (tabpage_C tp = @first_tabpage; tp != null; tp = null)
;               for (window_C wp = (tp == @curtab) ? @firstwin : tp.tp_firstwin; wp != null; wp = wp.w_next)
;                   win_alloc_lines(wp);
;           if (@aucmd_win != null && @aucmd_win.w_lines == null)
;               win_alloc_lines(@aucmd_win);

;           for (int r = 0; r < @Rows; r++)
;           {
;               lofs[r] = r * (int)@Columns;
;               lwrs[r] = false;

                ;; If the screen is not going to be cleared, copy as much as
                ;; possible from the old screen to the new one and clear the rest
                ;; (used when resizing the window at the "--more--" prompt or
                ;; when executing an external command, for the GUI).

;               if (!doclear)
;               {
;                   BFILL(slis, lofs[r], (byte)' ', (int)@Columns);
;                   AFILL(sluc, lofs[r], 0, (int)@Columns);
;                   for (int i = 0; i < @p_mco; i++)
;                       AFILL(smco[i], lofs[r], 0, (int)@Columns);
;                   AFILL(sats, lofs[r], 0, (int)@Columns);

;                   int r0 = r + (@screenRows - (int)@Rows);
;                   if (0 <= r0 && @screenLines != null)
;                   {
;                       int off = @lineOffset[r0], len = (@screenColumns < (int)@Columns) ? @screenColumns : (int)@Columns;

                        ;; When switching to utf-8 don't copy characters, they
                        ;; may be invalid now.  Also when "p_mco" changes.
;                       if (@screenLinesUC != null && @p_mco == @screen_mco)
;                       {
;                           BCOPY(slis, lofs[r], @screenLines, off, len);
;                           ACOPY(sluc, lofs[r], @screenLinesUC, off, len);
;                           for (int i = 0; i < @p_mco; i++)
;                               ACOPY(smco[i], lofs[r], @screenLinesC[i], off, len);
;                       }
;                       ACOPY(sats, lofs[r], @screenAttrs, off, len);
;                   }
;               }
;           }

            ;; Use the last line of the screen for the current line.
;           @current_ScreenLine = slis.plus((int)@Rows * (int)@Columns);

;           @screenLines = slis;
;           @screenLinesUC = sluc;
;           for (int i = 0; i < @p_mco; i++)
;               @screenLinesC[i] = smco[i];
;           @screen_mco = (int)@p_mco;
;           @screenAttrs = sats;
;           @lineOffset = lofs;
;           @lineWraps = lwrs;
;           @tabPageIdxs = tpis;

            ;; It's important that screenRows and screenColumns reflect the actual
            ;; size of screenLines[].  Set them before calling anything.
;           @screenRows = (int)@Rows;
;           @screenColumns = (int)@Columns;

;           @must_redraw = CLEAR;        ;; need to clear the screen later
;           if (doclear)
;               screenclear2();

;           @_4_entered = false;
;           --@redrawingDisabled;

            ;; Do not apply autocommands more than 3 times to avoid an endless loop
            ;; in case applying autocommands always changes Rows or Columns.

;           if (@starting == 0 && ++retry_count <= 3)
;           {
                ;; In rare cases, autocommands may have altered Rows or Columns,
                ;; jump back to check if we need to allocate the screen again.
;               continue retry;
;           }

;           break;
;       }
    ))

(defn- #_void screenclear []
    (§
;       check_for_delay(false);
;       screenalloc(false);             ;; allocate screen buffers if size changed
;       screenclear2();                 ;; clear the screen
    ))

(defn- #_void screenclear2 []
    (§
;       if (@starting == NO_SCREEN || @screenLines == null)
;           return;

;       @screen_attr = -1;               ;; force setting the Normal colors
;       screen_stop_highlight();        ;; don't want highlighting here

        ;; disable selection without redrawing it
;       clip_scroll_selection(9999);

        ;; blank out "screenLines"
;       for (int i = 0; i < @Rows; i++)
;       {
;           lineclear(@lineOffset[i], (int)@Columns);
;           @lineWraps[i] = false;
;       }

;       if (can_clear(@T_CL))
;       {
;           out_str(@T_CL);              ;; clear the display
;           @clear_cmdline = false;
;           @mode_displayed = false;
;       }
;       else
;       {
            ;; can't clear the screen, mark all chars with invalid attributes
;           for (int i = 0; i < @Rows; i++)
;               lineinvalid(@lineOffset[i], (int)@Columns);
;           @clear_cmdline = true;
;       }

;       @screen_cleared = TRUE;          ;; can use contents of "screenLines" now

;       win_rest_invalid(@firstwin);
;       @redraw_cmdline = true;
;       @redraw_tabline = true;
;       if (@must_redraw == CLEAR)       ;; no need to clear again
;           @must_redraw = NOT_VALID;
;       compute_cmdrow();
;       @msg_row = @cmdline_row;          ;; put cursor on last line for messages
;       @msg_col = 0;
;       screen_start();                 ;; don't know where cursor is now
;       @msg_scrolled = 0;               ;; can't scroll back
;       @msg_didany = false;
;       @msg_didout = false;
    ))

;; Clear one line in "screenLines".

(defn- #_void lineclear [#_int off, #_int width]
    (§
;       BFILL(@screenLines, off, (byte)' ', width);
;       AFILL(@screenLinesUC, off, 0, width);
;       AFILL(@screenAttrs, off, 0, width);
    ))

;; Mark one line in "screenLines" invalid by setting the attributes to an invalid value.

(defn- #_void lineinvalid [#_int off, #_int width]
    (§
;       AFILL(@screenAttrs, off, -1, width);
    ))

;; Copy part of a Screenline for vertically split window "wp".

(defn- #_void linecopy [#_int to, #_int from, #_window_C wp]
    (§
;       int off_to = @lineOffset[to] + wp.w_wincol;
;       int off_from = @lineOffset[from] + wp.w_wincol;

;       BCOPY(@screenLines, off_to, @screenLines, off_from, wp.w_width);
;       ACOPY(@screenLinesUC, off_to, @screenLinesUC, off_from, wp.w_width);
;       for (int i = 0; i < @p_mco; i++)
;           ACOPY(@screenLinesC[i], off_to, @screenLinesC[i], off_from, wp.w_width);
;       ACOPY(@screenAttrs, off_to, @screenAttrs, off_from, wp.w_width);
    ))

;; Return true if clearing with term string "p" would work.
;; It can't work when the string is empty or it won't set the right background.

(defn- #_boolean can_clear [#_Bytes p]
    (§
;       return (p.at(0) != NUL && (@t_colors <= 1 || @cterm_normal_bg_color == 0 || @T_UT.at(0) != NUL));
    ))

;; Reset cursor position.  Use whenever cursor was moved because of outputting
;; something directly to the screen (shell commands) or a terminal control code.

(defn- #_void screen_start []
    (§
;       @screen_cur_row = @screen_cur_col = 9999;
    ))

;; Move the cursor to position "row","col" in the screen.
;; This tries to find the most efficient way to move, minimizing the number of
;; characters sent to the terminal.

(defn- #_void windgoto [#_int row, #_int col]
    (§
;       final int
;           GOTO_COST = 7,      ;; assume a term_windgoto() takes about 7 chars
;           HIGHL_COST = 5;     ;; assume unhighlight takes 5 chars

;       final int
;           PLAN_LE = 1,
;           PLAN_CR = 2,
;           PLAN_NL = 3,
;           PLAN_WRITE = 4;

        ;; Can't use "screenLines" unless initialized.
;       if (@screenLines == null)
;           return;

;       if (col != @screen_cur_col || row != @screen_cur_row)
;       {
;           int cost;

            ;; Check for valid position.
;           if (row < 0)    ;; window without text lines?
;               row = 0;
;           if (@screenRows <= row)
;               row = @screenRows - 1;
;           if (@screenColumns <= col)
;               col = @screenColumns - 1;

            ;; check if no cursor movement is allowed in highlight mode
;           int noinvcurs;
;           if (@screen_attr != 0 && @T_MS.at(0) == NUL)
;               noinvcurs = HIGHL_COST;
;           else
;               noinvcurs = 0;
;           int goto_cost = GOTO_COST + noinvcurs;

            ;; Plan how to do the positioning:
            ;;
            ;; 1. Use CR to move it to column 0, same row.
            ;; 2. Use T_LE to move it a few columns to the left.
            ;; 3. Use NL to move a few lines down, column 0.
            ;; 4. Move a few columns to the right with T_ND or by writing chars.
            ;;
            ;; Don't do this if the cursor went beyond the last column,
            ;; the cursor position is unknown then (some terminals wrap, some don't).
            ;;
            ;; First check if the highlighting attributes allow us to write
            ;; characters to move the cursor to the right.

;           if (@screen_cur_row <= row && @screen_cur_col < (int)@Columns)
;           {
;               int plan;
;               int wouldbe_col;

                ;; If the cursor is in the same row, bigger col, we can use CR or T_LE.

;               Bytes bs = null;
;               int attr = @screen_attr;
;               if (row == @screen_cur_row && col < @screen_cur_col)
;               {
                    ;; "le" is preferred over "bc", because "bc" is obsolete
;                   if (@T_LE.at(0) != NUL)
;                       bs = @T_LE;              ;; "cursor left"
;                   else
;                       bs = @T_BC;              ;; "backspace character (old)
;                   if (bs.at(0) != NUL)
;                       cost = (@screen_cur_col - col) * STRLEN(bs);
;                   else
;                       cost = 999;
;                   if (col + 1 < cost)             ;; using CR is less characters
;                   {
;                       plan = PLAN_CR;
;                       wouldbe_col = 0;
;                       cost = 1;                   ;; CR is just one character
;                   }
;                   else
;                   {
;                       plan = PLAN_LE;
;                       wouldbe_col = col;
;                   }
;                   if (noinvcurs != 0)             ;; will stop highlighting
;                   {
;                       cost += noinvcurs;
;                       attr = 0;
;                   }
;               }

                ;; If the cursor is above where we want to be, we can use CR LF.

;               else if (@screen_cur_row < row)
;               {
;                   plan = PLAN_NL;
;                   wouldbe_col = 0;
;                   cost = (row - @screen_cur_row) * 2;  ;; CR LF
;                   if (noinvcurs != 0)                 ;; will stop highlighting
;                   {
;                       cost += noinvcurs;
;                       attr = 0;
;                   }
;               }

                ;; If the cursor is in the same row, smaller col, just use write.

;               else
;               {
;                   plan = PLAN_WRITE;
;                   wouldbe_col = @screen_cur_col;
;                   cost = 0;
;               }

                ;; Check if any characters that need to be written have the
                ;; correct attributes.  Also avoid UTF-8 characters.

;               int i = col - wouldbe_col;
;               if (0 < i)
;                   cost += i;
;               if (cost < goto_cost && 0 < i)
;               {
                    ;; Check if the attributes are correct without additionally
                    ;; stopping highlighting.

;                   int ai = @lineOffset[row] + wouldbe_col;
;                   while (i != 0 && @screenAttrs[ai++] == attr)
;                       --i;
;                   if (i != 0)
;                   {
                        ;; Try if it works when highlighting is stopped here.

;                       if (@screenAttrs[--ai] == 0)
;                       {
;                           cost += noinvcurs;
;                           while (i != 0 && @screenAttrs[ai++] == 0)
;                               --i;
;                       }
;                       if (i != 0)
;                           cost = 999;     ;; different attributes, don't do it
;                   }

                    ;; Don't use an UTF-8 char for positioning, it's slow.
;                   for (i = wouldbe_col; i < col; i++)
;                       if (@screenLinesUC[@lineOffset[row] + i] != 0)
;                       {
;                           cost = 999;
;                           break;
;                       }
;               }

                ;; We can do it without term_windgoto()!

;               if (cost < goto_cost)
;               {
;                   if (plan == PLAN_LE)
;                   {
;                       if (noinvcurs != 0)
;                           screen_stop_highlight();
;                       while (col < @screen_cur_col)
;                       {
;                           out_str(bs);
;                           --@screen_cur_col;
;                       }
;                   }
;                   else if (plan == PLAN_CR)
;                   {
;                       if (noinvcurs != 0)
;                           screen_stop_highlight();
;                       out_char((byte)'\r');
;                       @screen_cur_col = 0;
;                   }
;                   else if (plan == PLAN_NL)
;                   {
;                       if (noinvcurs != 0)
;                           screen_stop_highlight();
;                       while (@screen_cur_row < row)
;                       {
;                           out_char((byte)'\n');
;                           @screen_cur_row++;
;                       }
;                       @screen_cur_col = 0;
;                   }

;                   i = col - @screen_cur_col;
;                   if (0 < i)
;                   {
                        ;; Use cursor-right if it's one character only.
                        ;; Avoids removing a line of pixels from the last bold char,
                        ;; when using the bold trick in the GUI.

;                       if (@T_ND.at(0) != NUL && @T_ND.at(1) == NUL)
;                       {
;                           while (0 < i--)
;                               out_char(@T_ND.at(0));
;                       }
;                       else
;                       {
;                           int off = @lineOffset[row] + @screen_cur_col;

;                           while (0 < i--)
;                           {
;                               if (@screenAttrs[off] != @screen_attr)
;                                   screen_stop_highlight();
;                               out_flush_check();
;                               out_char(@screenLines.at(off));
;                               off++;
;                           }
;                       }
;                   }
;               }
;           }
;           else
;               cost = 999;

;           if (goto_cost <= cost)
;           {
;               if (noinvcurs != 0)
;                   screen_stop_highlight();
;               if (row == @screen_cur_row && (@screen_cur_col < col) && @T_CRI.at(0) != NUL)
;                   term_cursor_right(col - @screen_cur_col);
;               else
;                   term_windgoto(row, col);
;           }
;           @screen_cur_row = row;
;           @screen_cur_col = col;
;       }
    ))

;; Set cursor to its position in the current window.

(defn- #_void setcursor []
    (§
;       if (redrawing())
;       {
;           validate_cursor();

            ;; With 'rightleft' set and the cursor on a double-wide character,
            ;; position it on the leftmost column.
;           int wcol = @curwin.w_onebuf_opt.@wo_rl
;               ? (@curwin.w_width - @curwin.w_wcol
;                   - ((us_ptr2cells(ml_get_cursor()) == 2 && vim_isprintc(gchar_cursor())) ? 2 : 1))
;               : @curwin.w_wcol;

;           windgoto(@curwin.w_winrow + @curwin.w_wrow, @curwin.w_wincol + wcol);
;       }
    ))

;; insert 'line_count' lines at 'row' in window 'wp'
;; if 'invalid' is true the wp.w_lines[].wl_lnum is invalidated.
;; if 'mayclear' is true the screen will be cleared if it is faster than scrolling.
;; Returns false if the lines are not inserted, true for success.

(defn- #_boolean win_ins_lines [#_window_C wp, #_int row, #_int line_count, #_boolean invalid, #_boolean mayclear]
    (§
;       if (invalid)
;           wp.w_lines_valid = 0;

;       if (wp.w_height < 5)
;           return false;

;       if (line_count > wp.w_height - row)
;           line_count = wp.w_height - row;

;       maybean maybe = win_do_lines(wp, row, line_count, mayclear, false);
;       if (maybe != MAYBE)
;           return (maybe != FALSE);

        ;; If there is a next window or a status line, we first try to delete the
        ;; lines at the bottom to avoid messing what is after the window.
        ;; If this fails and there are following windows, don't do anything to avoid
        ;; messing up those windows, better just redraw.

;       boolean did_delete = false;
;       if (wp.w_next != null || wp.w_status_height != 0)
;       {
;           if (screen_del_lines(0, wp.w_winrow + wp.w_height - line_count,
;                                       line_count, (int)@Rows, false, null) == true)
;               did_delete = true;
;           else if (wp.w_next != null)
;               return false;
;       }

        ;; if no lines deleted, blank the lines that will end up below the window

;       if (!did_delete)
;       {
;           wp.w_redr_status = true;
;           @redraw_cmdline = true;
;           int nextrow = wp.w_winrow + wp.w_height + wp.w_status_height;
;           int lastrow = nextrow + line_count;
;           if (@Rows < lastrow)
;               lastrow = (int)@Rows;
;           screen_fill(nextrow - line_count, lastrow - line_count,
;                       wp.w_wincol, wp.w_wincol + wp.w_width,
;                       ' ', ' ', 0);
;       }

;       if (screen_ins_lines(0, wp.w_winrow + row, line_count, (int)@Rows, null) == false)
;       {
            ;; deletion will have messed up other windows
;           if (did_delete)
;           {
;               wp.w_redr_status = true;
;               win_rest_invalid(wp.w_next);
;           }
;           return false;
;       }

;       return true;
    ))

;; delete "line_count" window lines at "row" in window "wp"
;; If "invalid" is true curwin.w_lines[] is invalidated.
;; If "mayclear" is true the screen will be cleared if it is faster than scrolling
;; Return true for success, false if the lines are not deleted.

(defn- #_boolean win_del_lines [#_window_C wp, #_int row, #_int line_count, #_boolean invalid, #_boolean mayclear]
    (§
;       if (invalid)
;           wp.w_lines_valid = 0;

;       if (line_count > wp.w_height - row)
;           line_count = wp.w_height - row;

;       maybean maybe = win_do_lines(wp, row, line_count, mayclear, true);
;       if (maybe != MAYBE)
;           return (maybe != FALSE);

;       if (screen_del_lines(0, wp.w_winrow + row, line_count, (int)@Rows, false, null) == false)
;           return false;

        ;; If there are windows or status lines below, try to put them at the
        ;; correct place.  If we can't do that, they have to be redrawn.

;       if (wp.w_next != null || wp.w_status_height != 0 || @cmdline_row < @Rows - 1)
;       {
;           if (screen_ins_lines(0, wp.w_winrow + wp.w_height - line_count,
;                                            line_count, (int)@Rows, null) == false)
;           {
;               wp.w_redr_status = true;
;               win_rest_invalid(wp.w_next);
;           }
;       }
        ;; If this is the last window and there is no status line, redraw the command line later.
;       else
;           @redraw_cmdline = true;

;       return true;
    ))

;; Common code for win_ins_lines() and win_del_lines().
;; Returns true or false when the work has been done.
;; Returns MAYBE when not finished yet.

(defn- #_maybean win_do_lines [#_window_C wp, #_int row, #_int line_count, #_boolean mayclear, #_boolean del]
    (§
;       if (!redrawing() || line_count <= 0)
;           return FALSE;

        ;; only a few lines left: redraw is faster
;       if (mayclear && @Rows - line_count < 5 && wp.w_width == (int)@Columns)
;       {
;           screenclear();      ;; will set wp.w_lines_valid to 0
;           return FALSE;
;       }

        ;; Delete all remaining lines

;       if (wp.w_height <= row + line_count)
;       {
;           screen_fill(wp.w_winrow + row, wp.w_winrow + wp.w_height,
;                       wp.w_wincol, wp.w_wincol + wp.w_width,
;                       ' ', ' ', 0);
;           return TRUE;
;       }

        ;; when scrolling, the message on the command line should be cleared,
        ;; otherwise it will stay there forever.

;       @clear_cmdline = true;

        ;; If the terminal can set a scroll region, use that.
        ;; Always do this in a vertically split window.  This will redraw from
        ;; screenLines[] when t_CV isn't defined.  That's faster than using win_line().
        ;; Don't use a scroll region when we are going to redraw the text, writing
        ;; a character in the lower right corner of the scroll region causes a
        ;; scroll-up in the DJGPP version.

;       if (@scroll_region || wp.w_width != (int)@Columns)
;       {
;           if (@scroll_region && (wp.w_width == (int)@Columns || @T_CSV.at(0) != NUL))
;               scroll_region_set(wp, row);

;           boolean r;
;           if (del)
;               r = screen_del_lines(wp.w_winrow + row, 0, line_count, wp.w_height - row, false, wp);
;           else
;               r = screen_ins_lines(wp.w_winrow + row, 0, line_count, wp.w_height - row, wp);

;           if (@scroll_region && (wp.w_width == (int)@Columns || @T_CSV.at(0) != NUL))
;               scroll_region_reset();

;           return r ? TRUE : FALSE;
;       }

;       if (wp.w_next != null && @p_tf) ;; don't delete/insert on fast terminal
;           return FALSE;

;       return MAYBE;
    ))

;; window 'wp' and everything after it is messed up, mark it for redraw

(defn- #_void win_rest_invalid [#_window_C wp]
    (§
;       while (wp != null)
;       {
;           redraw_win_later(wp, NOT_VALID);
;           wp.w_redr_status = true;
;           wp = wp.w_next;
;       }
;       @redraw_cmdline = true;
    ))

;; The rest of the routines in this file perform screen manipulations.
;; The given operation is performed physically on the screen.
;; The corresponding change is also made to the internal screen image.
;; In this way, the editor anticipates the effect of editing changes
;; on the appearance of the screen.
;; That way, when we call screenupdate a complete redraw isn't usually necessary.
;; Another advantage is that we can keep adding code to anticipate screen changes,
;; and in the meantime, everything still works.

;; types for inserting or deleting lines

(final int USE_T_CAL   1)
(final int USE_T_CDL   2)
(final int USE_T_AL    3)
(final int USE_T_CE    4)
(final int USE_T_DL    5)
(final int USE_T_SR    6)
(final int USE_NL      7)
(final int USE_T_CD    8)
(final int USE_REDRAW  9)

;; insert lines on the screen and update screenLines[]
;; 'end' is the line after the scrolled part.  Normally it is Rows.
;; When scrolling region used 'off' is the offset from the top for the region.
;; 'row' and 'end' are relative to the start of the region.
;;
;; return false for failure, true for success.

(defn- #_boolean screen_ins_lines [#_int off, #_int row, #_int line_count, #_int end, #_window_C wp]
    ;; wp: null or window to use width from
    (§
;       boolean can_ce = can_clear(@T_CE);

        ;; FAIL if
        ;; - there is no valid screen
        ;; - the screen has to be redrawn completely
        ;; - the line count is less than one
        ;; - the line count is more than 'ttyscroll'

;       if (!screen_valid(true) || line_count <= 0 || @p_ttyscroll < line_count)
;           return false;

        ;; There are seven ways to insert lines:
        ;;
        ;; 0. When in a vertically split window and t_CV isn't set, redraw the characters from screenLines[].
        ;; 1. Use T_CD (clear to end of display) if it exists and the result of the insert is just empty lines.
        ;; 2. Use T_CAL (insert multiple lines) if it exists and T_AL is not present or line_count > 1.
        ;;    It looks better if we do all the inserts at once.
        ;; 3. Use T_CDL (delete multiple lines) if it exists and the result of the
        ;;    insert is just empty lines and T_CE is not present or line_count > 1.
        ;; 4. Use T_AL (insert line) if it exists.
        ;; 5. Use T_CE (erase line) if it exists and the result of the insert is just empty lines.
        ;; 6. Use T_DL (delete line) if it exists and the result of the insert is just empty lines.
        ;; 7. Use T_SR (scroll reverse) if it exists and inserting at row 0
        ;;    and the 'da' flag is not set or we have clear line capability.
        ;; 8. Redraw the characters from screenLines[].
        ;;
        ;; Careful: In a hpterm scroll reverse doesn't work as expected, it moves
        ;; the scrollbar for the window.  It does have insert line, use that if it exists.

;       boolean result_empty = (end <= row + line_count);

;       int type;
;       if (wp != null && wp.w_width != (int)@Columns && @T_CSV.at(0) == NUL)
;           type = USE_REDRAW;
;       else if (can_clear(@T_CD) && result_empty)
;           type = USE_T_CD;
;       else if (@T_CAL.at(0) != NUL && (1 < line_count || @T_AL.at(0) == NUL))
;           type = USE_T_CAL;
;       else if (@T_CDL.at(0) != NUL && result_empty && (1 < line_count || !can_ce))
;           type = USE_T_CDL;
;       else if (@T_AL.at(0) != NUL)
;           type = USE_T_AL;
;       else if (can_ce && result_empty)
;           type = USE_T_CE;
;       else if (@T_DL.at(0) != NUL && result_empty)
;           type = USE_T_DL;
;       else if (@T_SR.at(0) != NUL && row == 0 && (@T_DA.at(0) == NUL || can_ce))
;           type = USE_T_SR;
;       else
;           return false;

        ;; For clearing the lines screen_del_lines() is used.  This will also take
        ;; care of t_db if necessary.

;       if (type == USE_T_CD || type == USE_T_CDL || type == USE_T_CE || type == USE_T_DL)
;           return screen_del_lines(off, row, line_count, end, false, wp);

        ;; If text is retained below the screen, first clear or delete as many
        ;; lines at the bottom of the window as are about to be inserted so that
        ;; the deleted lines won't later surface during a screen_del_lines.

;       if (@T_DB.at(0) != NUL)
;           screen_del_lines(off, end - line_count, line_count, end, false, wp);

        ;; Remove a modeless selection when inserting lines halfway the screen
        ;; or not the full width of the screen.
;       if (0 < off + row || (wp != null && wp.w_width != (int)@Columns))
;           clip_clear_selection(@clip_star);
;       else
;           clip_scroll_selection(-line_count);

;       int cursor_row;
;       if (@T_CCS.at(0) != NUL)      ;; cursor relative to region
;           cursor_row = row;
;       else
;           cursor_row = row + off;

        ;; Shift lineOffset[] line_count down to reflect the inserted lines.
        ;; Clear the inserted lines in screenLines[].

;       row += off;
;       end += off;
;       for (int i = 0; i < line_count; i++)
;       {
;           if (wp != null && wp.w_width != (int)@Columns)
;           {
                ;; need to copy part of a line
;               int j = end - 1 - i;
;               while (row <= (j -= line_count))
;                   linecopy(j + line_count, j, wp);
;               j += line_count;
;               if (can_clear(u8(" ")))
;                   lineclear(@lineOffset[j] + wp.w_wincol, wp.w_width);
;               else
;                   lineinvalid(@lineOffset[j] + wp.w_wincol, wp.w_width);
;               @lineWraps[j] = false;
;           }
;           else
;           {
;               int j = end - 1 - i;
;               int temp = @lineOffset[j];
;               while (row <= (j -= line_count))
;               {
;                   @lineOffset[j + line_count] = @lineOffset[j];
;                   @lineWraps[j + line_count] = @lineWraps[j];
;               }
;               @lineOffset[j + line_count] = temp;
;               @lineWraps[j + line_count] = false;
;               if (can_clear(u8(" ")))
;                   lineclear(temp, (int)@Columns);
;               else
;                   lineinvalid(temp, (int)@Columns);
;           }
;       }

;       screen_stop_highlight();
;       windgoto(cursor_row, 0);

        ;; redraw the characters
;       if (type == USE_REDRAW)
;           redraw_block(row, end, wp);
;       else if (type == USE_T_CAL)
;       {
;           term_append_lines(line_count);
;           screen_start();         ;; don't know where cursor is now
;       }
;       else
;       {
;           for (int i = 0; i < line_count; i++)
;           {
;               if (type == USE_T_AL)
;               {
;                   if (i != 0 && cursor_row != 0)
;                       windgoto(cursor_row, 0);
;                   out_str(@T_AL);
;               }
;               else ;; type == USE_T_SR
;                   out_str(@T_SR);
;               screen_start();         ;; don't know where cursor is now
;           }
;       }

        ;; With scroll-reverse and 'da' flag set we need to clear the lines that
        ;; have been scrolled down into the region.

;       if (type == USE_T_SR && @T_DA.at(0) != NUL)
;       {
;           for (int i = 0; i < line_count; i++)
;           {
;               windgoto(off + i, 0);
;               out_str(@T_CE);
;               screen_start();         ;; don't know where cursor is now
;           }
;       }

;       return true;
    ))

;; delete lines on the screen and update screenLines[]
;; 'end' is the line after the scrolled part.  Normally it is Rows.
;; When scrolling region used 'off' is the offset from the top for the region.
;; 'row' and 'end' are relative to the start of the region.
;;
;; Return true for success, false if the lines are not deleted.

(defn- #_boolean screen_del_lines [#_int off, #_int row, #_int line_count, #_int end, #_boolean force, #_window_C wp]
    ;; force: even when line_count > p_ttyscroll
    ;; wp: null or window to use width from
    (§
        ;; FAIL if
        ;; - there is no valid screen
        ;; - the screen has to be redrawn completely
        ;; - the line count is less than one
        ;; - the line count is more than 'ttyscroll'

;       if (!screen_valid(true) || line_count <= 0 || (!force && @p_ttyscroll < line_count))
;           return false;

        ;; Check if the rest of the current region will become empty.

;       boolean result_empty = (end <= row + line_count);

        ;; We can delete lines only when 'db' flag not set or when 'ce' option available.

;       boolean can_delete = (@T_DB.at(0) == NUL || can_clear(@T_CE));

;       int type;

        ;; There are six ways to delete lines:
        ;;
        ;; 0. When in a vertically split window and t_CV isn't set, redraw the characters from screenLines[].
        ;; 1. Use T_CD if it exists and the result is empty.
        ;; 2. Use newlines if row == 0 and count == 1 or T_CDL does not exist.
        ;; 3. Use T_CDL (delete multiple lines) if it exists and line_count > 1 or none of the other ways work.
        ;; 4. Use T_CE (erase line) if the result is empty.
        ;; 5. Use T_DL (delete line) if it exists.
        ;; 6. Redraw the characters from screenLines[].

;       if (wp != null && wp.w_width != (int)@Columns && @T_CSV.at(0) == NUL)
;           type = USE_REDRAW;
;       else if (can_clear(@T_CD) && result_empty)
;           type = USE_T_CD;
;       else if (row == 0 && (line_count == 1 || @T_CDL.at(0) == NUL))
;           type = USE_NL;
;       else if (@T_CDL.at(0) != NUL && 1 < line_count && can_delete)
;           type = USE_T_CDL;
;       else if (can_clear(@T_CE) && result_empty && (wp == null || wp.w_width == (int)@Columns))
;           type = USE_T_CE;
;       else if (@T_DL.at(0) != NUL && can_delete)
;           type = USE_T_DL;
;       else if (@T_CDL.at(0) != NUL && can_delete)
;           type = USE_T_CDL;
;       else
;           return false;

        ;; Remove a modeless selection when deleting lines halfway the screen
        ;; or not the full width of the screen.
;       if (0 < off + row || (wp != null && wp.w_width != (int)@Columns))
;           clip_clear_selection(@clip_star);
;       else
;           clip_scroll_selection(line_count);

;       int cursor_row;
;       int cursor_end;
;       if (@T_CCS.at(0) != NUL)      ;; cursor relative to region
;       {
;           cursor_row = row;
;           cursor_end = end;
;       }
;       else
;       {
;           cursor_row = row + off;
;           cursor_end = end + off;
;       }

        ;; Now shift lineOffset[] line_count up to reflect the deleted lines.
        ;; Clear the inserted lines in screenLines[].

;       row += off;
;       end += off;
;       for (int i = 0; i < line_count; i++)
;       {
;           if (wp != null && wp.w_width != (int)@Columns)
;           {
                ;; need to copy part of a line
;               int j = row + i;
;               while ((j += line_count) <= end - 1)
;                   linecopy(j - line_count, j, wp);
;               j -= line_count;
;               if (can_clear(u8(" ")))
;                   lineclear(@lineOffset[j] + wp.w_wincol, wp.w_width);
;               else
;                   lineinvalid(@lineOffset[j] + wp.w_wincol, wp.w_width);
;               @lineWraps[j] = false;
;           }
;           else
;           {
                ;; whole width, moving the line pointers is faster
;               int j = row + i;
;               int temp = @lineOffset[j];
;               while ((j += line_count) <= end - 1)
;               {
;                   @lineOffset[j - line_count] = @lineOffset[j];
;                   @lineWraps[j - line_count] = @lineWraps[j];
;               }
;               @lineOffset[j - line_count] = temp;
;               @lineWraps[j - line_count] = false;
;               if (can_clear(u8(" ")))
;                   lineclear(temp, (int)@Columns);
;               else
;                   lineinvalid(temp, (int)@Columns);
;           }
;       }

;       screen_stop_highlight();

        ;; redraw the characters
;       if (type == USE_REDRAW)
;           redraw_block(row, end, wp);
;       else if (type == USE_T_CD)          ;; delete the lines
;       {
;           windgoto(cursor_row, 0);
;           out_str(@T_CD);
;           screen_start();                 ;; don't know where cursor is now
;       }
;       else if (type == USE_T_CDL)
;       {
;           windgoto(cursor_row, 0);
;           term_delete_lines(line_count);
;           screen_start();                 ;; don't know where cursor is now
;       }

        ;; Deleting lines at top of the screen or scroll region: Just scroll
        ;; the whole screen (scroll region) up by outputting newlines on the last line.

;       else if (type == USE_NL)
;       {
;           windgoto(cursor_end - 1, 0);
;           for (int i = line_count; 0 <= --i; )
;               out_char((byte)'\n');             ;; cursor will remain on same line
;       }
;       else
;       {
;           for (int i = line_count; 0 <= --i; )
;           {
;               if (type == USE_T_DL)
;               {
;                   windgoto(cursor_row, 0);
;                   out_str(@T_DL);          ;; delete a line
;               }
;               else ;; type == USE_T_CE
;               {
;                   windgoto(cursor_row + i, 0);
;                   out_str(@T_CE);          ;; erase a line
;               }
;               screen_start();             ;; don't know where cursor is now
;           }
;       }

        ;; If the 'db' flag is set, we need to clear the lines that have been
        ;; scrolled up at the bottom of the region.

;       if (@T_DB.at(0) != NUL && (type == USE_T_DL || type == USE_T_CDL))
;       {
;           for (int i = line_count; 0 < i; --i)
;           {
;               windgoto(cursor_end - i, 0);
;               out_str(@T_CE);              ;; erase a line
;               screen_start();             ;; don't know where cursor is now
;           }
;       }

;       return true;
    ))

;; show the current mode and ruler
;;
;; If clear_cmdline is true, clear the rest of the cmdline.
;; If clear_cmdline is false there may be a message there that needs to be
;; cleared only if a mode is shown.
;; Return the length of the message (0 if no message).

(defn- #_int showmode []
    (§
;       int length = 0;

;       boolean do_mode = ((@p_smd && @msg_silent == 0) && ((@State & INSERT) != 0 || @restart_edit != 0 || @VIsual_active));
;       if (do_mode || @Recording)
;       {
            ;; Don't show mode right now, when not redrawing or inside a mapping.
            ;; Call char_avail() only when we are going to show something, because
            ;; it takes a bit of time.

;           if (!redrawing() || (char_avail() && !@keyTyped) || @msg_silent != 0)
;           {
;               @redraw_cmdline = true;              ;; show mode later
;               return 0;
;           }

;           boolean nwr_save = @need_wait_return;

            ;; wait a bit before overwriting an important message
;           check_for_delay(false);

            ;; if the cmdline is more than one line high, erase top lines
;           boolean need_clear = @clear_cmdline;
;           if (@clear_cmdline && @cmdline_row < @Rows - 1)
;               msg_clr_cmdline();                  ;; will reset clear_cmdline

            ;; Position on the last line in the window, column 0.
;           msg_pos_mode();
;           cursor_off();
;           int attr = hl_attr(HLF_CM);                 ;; Highlight mode
;           if (do_mode)
;           {
;               msg_puts_attr(u8("--"), attr);

;               if ((@State & VREPLACE_FLAG) != 0)
;                   msg_puts_attr(u8(" VREPLACE"), attr);
;               else if ((@State & REPLACE_FLAG) != 0)
;                   msg_puts_attr(u8(" REPLACE"), attr);
;               else if ((@State & INSERT) != 0)
;               {
;                   if (@p_ri)
;                       msg_puts_attr(u8(" REVERSE"), attr);
;                   msg_puts_attr(u8(" INSERT"), attr);
;               }
;               else if (@restart_edit == 'I')
;                   msg_puts_attr(u8(" (insert)"), attr);
;               else if (@restart_edit == 'R')
;                   msg_puts_attr(u8(" (replace)"), attr);
;               else if (@restart_edit == 'V')
;                   msg_puts_attr(u8(" (vreplace)"), attr);

;               if ((@State & INSERT) != 0 && @p_paste)
;                   msg_puts_attr(u8(" (paste)"), attr);

;               if (@VIsual_active)
;               {
;                   Bytes p;

                    ;; Don't concatenate separate words to avoid translation problems.
;                   switch ((@VIsual_select ? 4 : 0) + ((@VIsual_mode == Ctrl_V) ? 2 : 0) + ((@VIsual_mode == 'V') ? 1 : 0))
;                   {
;                       case 0: p = u8(" VISUAL"); break;
;                       case 1: p = u8(" VISUAL LINE"); break;
;                       case 2: p = u8(" VISUAL BLOCK"); break;
;                       case 4: p = u8(" SELECT"); break;
;                       case 5: p = u8(" SELECT LINE"); break;
;                       default: p = u8(" SELECT BLOCK"); break;
;                   }
;                   msg_puts_attr(p, attr);
;               }
;               msg_puts_attr(u8(" --"), attr);

;               need_clear = true;
;           }
;           if (@Recording)
;           {
;               msg_puts_attr(u8("recording"), attr);
;               need_clear = true;
;           }

;           @mode_displayed = true;
;           if (need_clear || @clear_cmdline)
;               msg_clr_eos();
;           @msg_didout = false;             ;; overwrite this message
;           length = @msg_col;
;           @msg_col = 0;
;           @need_wait_return = nwr_save;    ;; never ask for hit-return for this
;       }
;       else if (@clear_cmdline && @msg_silent == 0)
            ;; Clear the whole command line.  Will reset "clear_cmdline".
;           msg_clr_cmdline();

        ;; In Visual mode the size of the selected area must be redrawn.
;       if (@VIsual_active)
;           clear_showcmd();

        ;; If the last window has no status line,
        ;; the ruler is after the mode message and must be redrawn.
;       if (redrawing() && @lastwin.w_status_height == 0)
;           win_redr_ruler(@lastwin, true);
;       @redraw_cmdline = false;
;       @clear_cmdline = false;

;       return length;
    ))

;; Position for a mode message.

(defn- #_void msg_pos_mode []
    (§
;       @msg_col = 0;
;       @msg_row = (int)@Rows - 1;
    ))

;; Delete mode message.  Used when ESC is typed which is expected to end
;; Insert mode (but Insert mode didn't end yet!).
;; Caller should check "mode_displayed".

(defn- #_void unshowmode [#_boolean force]
    (§
        ;; Don't delete it right now, when not redrawing or inside a mapping.

;       if (!redrawing() || (!force && char_avail() && !@keyTyped))
;           @redraw_cmdline = true;          ;; delete mode later
;       else
;       {
;           msg_pos_mode();
;           if (@Recording)
;               msg_puts_attr(u8("recording"), hl_attr(HLF_CM));
;           msg_clr_eos();
;       }
    ))

;; Draw the tab pages line at the top of the Vim window.

(defn- #_void draw_tabline []
    (§
;       int tabcount = 0;
;       int col = 0;
;       int attr_sel = hl_attr(HLF_TPS);
;       int attr_nosel = hl_attr(HLF_TP);
;       int attr_fill = hl_attr(HLF_TPF);
;       boolean use_sep_chars = (@t_colors < 8);

;       @redraw_tabline = false;

;       if (tabline_height() < 1)
;           return;

        ;; Init tabPageIdxs[] to zero: Clicking outside of tabs has no effect.
;       for (int scol = 0; scol < (int)@Columns; scol++)
;           @tabPageIdxs[scol] = 0;

        ;; Use the 'tabline' option if it's set.
;       if (@p_tal.at(0) != NUL)
;       {
;           boolean save_called_emsg = @called_emsg;

            ;; Check for an error.
            ;; If there is one we would loop in redrawing the screen.
            ;; Avoid that by making 'tabline' empty.
;           @called_emsg = false;
;           win_redr_custom();
;           if (@called_emsg)
;               set_string_option_direct(u8("tabline"), -1, u8(""), OPT_FREE);
;           @called_emsg |= save_called_emsg;
;       }
;       else
;       {
;           for (tabpage_C tp = @first_tabpage; tp != null; tp = null)
;               tabcount++;

;           int tabwidth = ((int)@Columns - 1 + tabcount / 2) / tabcount;
;           if (tabwidth < 6)
;               tabwidth = 6;

;           int attr = attr_nosel;
;           tabcount = 0;
;           int scol = 0;
;           for (tabpage_C tp = @first_tabpage; tp != null && col < (int)@Columns - 4; tp = null)
;           {
;               scol = col;

;               if (tp.tp_topframe == @topframe)
;                   attr = attr_sel;
;               if (use_sep_chars && 0 < col)
;                   screen_putchar('|', 0, col++, attr);

;               if (tp.tp_topframe != @topframe)
;                   attr = attr_nosel;

;               screen_putchar(' ', 0, col++, attr);

;               window_C cwp, wp;
;               if (tp == @curtab)
;               {
;                   cwp = @curwin;
;                   wp = @firstwin;
;               }
;               else
;               {
;                   cwp = tp.tp_curwin;
;                   wp = tp.tp_firstwin;
;               }

;               boolean modified = false;
;               int wincount;
;               for (wincount = 0; wp != null; wp = wp.w_next, ++wincount)
;                   if (bufIsChanged(wp.w_buffer))
;                       modified = true;
;               if (modified || 1 < wincount)
;               {
;                   if (1 < wincount)
;                   {
;                       vim_snprintf(@nameBuff, MAXPATHL, u8("%d"), wincount);
;                       int len = STRLEN(@nameBuff);
;                       if ((int)@Columns - 3 <= col + len)
;                           break;
;                       screen_puts_len(@nameBuff, len, 0, col, hl_combine_attr(attr, hl_attr(HLF_T)));
;                       col += len;
;                   }
;                   if (modified)
;                       screen_puts_len(u8("+"), 1, 0, col++, attr);
;                   screen_putchar(' ', 0, col++, attr);
;               }

;               int room = scol - col + tabwidth - 1;
;               if (0 < room)
;               {
                    ;; Get buffer name in nameBuff[].
;                   get_trans_bufname(cwp.w_buffer);
;                   shorten_dir(@nameBuff);
;                   int len = mb_string2cells(@nameBuff, -1);
;                   Bytes p = @nameBuff;

;                   while (room < len)
;                   {
;                       len -= mb_ptr2cells(p);
;                       p = p.plus(us_ptr2len_cc(p));
;                   }

;                   if (len > (int)@Columns - col - 1)
;                       len = (int)@Columns - col - 1;

;                   screen_puts_len(p, STRLEN(p), 0, col, attr);
;                   col += len;
;               }
;               screen_putchar(' ', 0, col++, attr);

                ;; Store the tab page number in tabPageIdxs[],
                ;; so that jump_to_mouse() knows where each one is.
;               tabcount++;
;               while (scol < col)
;                   @tabPageIdxs[scol++] = (short)tabcount;
;           }

;           int c;
;           if (use_sep_chars)
;               c = '_';
;           else
;               c = ' ';
;           screen_fill(0, 1, col, (int)@Columns, c, c, attr_fill);

            ;; Put an "X" for closing the current tab if there are several.
;           if (null != null)
;           {
;               screen_putchar('X', 0, (int)@Columns - 1, attr_nosel);
;               @tabPageIdxs[(int)@Columns - 1] = -999;
;           }
;       }

        ;; Reset the flag here again, in case evaluating 'tabline' causes it to be set.
;       @redraw_tabline = false;
    ))

;; Get buffer name for "buf" into nameBuff[].
;; Takes care of special buffer names and translates special characters.

(defn- #_void get_trans_bufname [#_buffer_C buf]
    (§
;       vim_strncpy(@nameBuff, buf_spname(buf, false), MAXPATHL - 1);
;       trans_characters(@nameBuff, MAXPATHL);
    ))

;; Get the character to use in a status line.  Get its attributes in "*attr".

(defn- #_int fillchar_status [#_int* attr, #_boolean is_curwin]
    (§
;       int fill;
;       if (is_curwin)
;       {
;           attr[0] = hl_attr(HLF_S);
;           fill = @fill_stl;
;       }
;       else
;       {
;           attr[0] = hl_attr(HLF_SNC);
;           fill = @fill_stlnc;
;       }

        ;; Use fill when there is highlighting, and highlighting of current window differs,
        ;; or the fillchars differ, or this is not the current window.
;       if (attr[0] != 0 && ((hl_attr(HLF_S) != hl_attr(HLF_SNC) || !is_curwin || @firstwin == @lastwin) || @fill_stl != @fill_stlnc))
;           return fill;
;       if (is_curwin)
;           return '^';

;       return '=';
    ))

;; Get the character to use in a separator between vertically split windows.
;; Get its attributes in "*attr".

(defn- #_int fillchar_vsep [#_int* attr]
    (§
;       attr[0] = hl_attr(HLF_C);
;       if (attr[0] == 0 && @fill_vert == ' ')
;           return '|';
;       else
;           return @fill_vert;
    ))

;; Return true if redrawing should currently be done.

(defn- #_boolean redrawing []
    (§
;       return (@redrawingDisabled == 0 && !(@p_lz && char_avail() && !@keyTyped && !@do_redraw));
    ))

;; Return true if printing messages should currently be done.

(defn- #_boolean messaging []
    (§
;       return !(@p_lz && char_avail() && !@keyTyped);
    ))

;; Show current status info in ruler and various other places.
;; If always is false, only show ruler if position has changed.

(defn- #_void showruler [#_boolean always]
    (§
;       if (!always && !redrawing())
;           return;

;       win_redr_ruler(@curwin, always);

        ;; Redraw the tab pages line if needed.
;       if (@redraw_tabline)
;           draw_tabline();
    ))

(defn- #_void win_redr_ruler [#_window_C wp, #_boolean always]
    (§
        ;; If 'ruler' off or redrawing disabled, don't do anything.
;       if (!@p_ru)
;           return;

        ;; Check if cursor.lnum is valid, since win_redr_ruler() may be called
        ;; after deleting lines, before cursor.lnum is corrected.

;       if (wp.w_buffer.b_ml.ml_line_count < wp.w_cursor.lnum)
;           return;

        ;; Check if not in Insert mode and the line is empty (will show "0-1").

;       boolean empty_line = false;
;       if ((@State & INSERT) == 0 && ml_get_buf(wp.w_buffer, wp.w_cursor.lnum, false).at(0) == NUL)
;           empty_line = true;

        ;; Only draw the ruler when something changed.

;       validate_virtcol_win(wp);
;       if (@redraw_cmdline
;               || always
;               || wp.w_cursor.lnum != wp.w_ru_cursor.lnum
;               || wp.w_cursor.col != wp.w_ru_cursor.col
;               || wp.w_virtcol != wp.w_ru_virtcol
;               || wp.w_cursor.coladd != wp.w_ru_cursor.coladd
;               || wp.w_topline != wp.w_ru_topline
;               || wp.w_buffer.b_ml.ml_line_count != wp.w_ru_line_count
;               || empty_line != wp.w_ru_empty)
;       {
;           cursor_off();

;           int row, fillchar, off, width;
;           int[] attr = new int[1];
;           if (wp.w_status_height != 0)
;           {
;               row = wp.w_winrow + wp.w_height;
;               fillchar = fillchar_status(attr, wp == @curwin);
;               off = wp.w_wincol;
;               width = wp.w_width;
;           }
;           else
;           {
;               row = (int)@Rows - 1;
;               fillchar = ' ';
;               attr[0] = 0;
;               off = 0;
;               width = (int)@Columns;
;           }

            ;; In list mode virtcol needs to be recomputed.
;           int[] virtcol = { wp.w_virtcol };
;           if (wp.w_onebuf_opt.@wo_list && lcs_tab1[0] == NUL)
;           {
;               wp.w_onebuf_opt.@wo_list = false;
;               getvvcol(wp, wp.w_cursor, null, virtcol, null);
;               wp.w_onebuf_opt.@wo_list = true;
;           }

;           final int RULER_BUF_LEN = 70;
;           Bytes buffer = new Bytes(RULER_BUF_LEN);

            ;; Some sprintfs return the length, some return a pointer.
            ;; To avoid portability problems we use STRLEN() here.

;           vim_snprintf(buffer, RULER_BUF_LEN, u8("%ld,"),
;                   ((wp.w_buffer.b_ml.ml_flags & ML_EMPTY) != 0) ? 0L : wp.w_cursor.lnum);
;           int len = STRLEN(buffer);
;           col_print(buffer.plus(len), RULER_BUF_LEN - len, (empty_line) ? 0 : wp.w_cursor.col + 1, virtcol[0] + 1);

            ;; Add a "50%" if there is room for it.
            ;; On the last line, don't print in the last column
            ;; (scrolls the screen up on some terminals).

;           int ii = STRLEN(buffer);
;           get_rel_pos(wp, buffer.plus(ii + 1), RULER_BUF_LEN - ii - 1);
;           int oo = ii + mb_string2cells(buffer.plus(ii + 1), -1);
;           if (wp.w_status_height == 0)    ;; can't use last char of screen
;               oo++;
;           int this_ru_col = @ru_col - ((int)@Columns - width);
;           if (this_ru_col < 0)
;               this_ru_col = 0;
            ;; Never use more than half the window/screen width,
            ;; leave the other half for the filename.
;           if (this_ru_col < (width + 1) / 2)
;               this_ru_col = (width + 1) / 2;
;           if (this_ru_col + oo < width)
;           {
                ;; need at least 3 chars left for get_rel_pos() + NUL
;               while (this_ru_col + oo < width && ii + 4 < RULER_BUF_LEN)
;               {
;                   ii += utf_char2bytes(fillchar, buffer.plus(ii));
;                   oo++;
;               }
;               get_rel_pos(wp, buffer.plus(ii), RULER_BUF_LEN - ii);
;           }

            ;; Truncate at window boundary.
;           int ooo = 0;
;           for (int i = 0; buffer.at(i) != NUL; i += us_ptr2len_cc(buffer.plus(i)))
;           {
;               ooo += us_ptr2cells(buffer.plus(i));
;               if (width < this_ru_col + ooo)
;               {
;                   buffer.be(i, NUL);
;                   break;
;               }
;           }

;           screen_puts(buffer, row, this_ru_col + off, attr[0]);
;           boolean iii = @redraw_cmdline;
;           screen_fill(row, row + 1,
;                       this_ru_col + off + STRLEN(buffer), off + width,
;                       fillchar, fillchar, attr[0]);
            ;; don't redraw the cmdline because of showing the ruler
;           @redraw_cmdline = iii;
;           COPY_pos(wp.w_ru_cursor, wp.w_cursor);
;           wp.w_ru_virtcol = wp.w_virtcol;
;           wp.w_ru_empty = empty_line;
;           wp.w_ru_topline = wp.w_topline;
;           wp.w_ru_line_count = wp.w_buffer.b_ml.ml_line_count;
;       }
    ))

;; Return the width of the 'number' and 'relativenumber' column.
;; Caller may need to check if 'number' or 'relativenumber' is set.
;; Otherwise it depends on 'numberwidth' and the line count.

(defn- #_int number_width [#_window_C wp]
    (§
;       long lnum;
;       if (wp.w_onebuf_opt.@wo_rnu && !wp.w_onebuf_opt.@wo_nu)
            ;; cursor line shows "0"
;           lnum = wp.w_height;
;       else
            ;; cursor line shows absolute line number
;           lnum = wp.w_buffer.b_ml.ml_line_count;

;       if (lnum == wp.w_nrwidth_line_count && wp.w_nuw_cached == wp.w_onebuf_opt.@wo_nuw)
;           return wp.w_nrwidth_width;

;       wp.w_nrwidth_line_count = lnum;

;       int n = 0;
;       do
;       {
;           lnum /= 10;
;           n++;
;       } while (0 < lnum);

        ;; 'numberwidth' gives the minimal width plus one
;       if (n < wp.w_onebuf_opt.@wo_nuw - 1)
;           n = (int)wp.w_onebuf_opt.@wo_nuw - 1;

;       wp.w_nrwidth_width = n;
;       wp.w_nuw_cached = wp.w_onebuf_opt.@wo_nuw;
;       return n;
    ))

;; Return the current cursor column.  This is the actual position on the screen.
;; First column is 0.

(defn- #_int screen_screencol []
    (§
;       return @screen_cur_col;
    ))

;; Return the current cursor row.  This is the actual position on the screen.
;; First row is 0.

(defn- #_int screen_screenrow []
    (§
;       return @screen_cur_row;
    ))

;;; ============================================================================================== VimW

;; window.c ---------------------------------------------------------------------------------------

(final int URL_SLASH       1)               ;; path_is_url() has found "://"
(final int URL_BACKSLASH   2)               ;; path_is_url() has found ":\\"

(final window_C NOWIN (§_window_C))         ;; non-existing window

(final Bytes m_onlyone (u8 "Already only one window"))

;; all CTRL-W window commands are handled here, called from normal_cmd().

(defn- #_void do_window [#_int nchar, #_long Prenum, #_int xchar]
    ;; xchar: extra char from ":wincmd gx" or NUL
    (§
;       Bytes cbuf = new Bytes(40);

;       long Prenum1 = (Prenum == 0) ? 1 : Prenum;

;       switch (nchar)
;       {
            ;; split current window in two parts, horizontally
;           case 'S':
;           case Ctrl_S:
;           case 's':
;               if (@cmdwin_type != 0)
;               {
;                   emsg(e_cmdwin);
;                   break;
;               }
;               reset_VIsual_and_resel();
;               win_split((int)Prenum, 0);
;               break;

            ;; split current window in two parts, vertically
;           case Ctrl_V:
;           case 'v':
;               if (@cmdwin_type != 0)
;               {
;                   emsg(e_cmdwin);
;                   break;
;               }
;               reset_VIsual_and_resel();
;               win_split((int)Prenum, WSP_VERT);
;               break;

            ;; split current window and edit alternate file
;           case Ctrl_HAT:
;           case '^':
;               if (@cmdwin_type != 0)
;               {
;                   emsg(e_cmdwin);
;                   break;
;               }
;               reset_VIsual_and_resel();
;               cmd_with_count(u8("split #"), cbuf, cbuf.size(), Prenum);
;               do_cmdline_cmd(cbuf);
;               break;

            ;; open new window
;           case Ctrl_N:
;           case 'n':
;               if (@cmdwin_type != 0)
;               {
;                   emsg(e_cmdwin);
;                   break;
;               }
;               reset_VIsual_and_resel();
;               if (Prenum != 0)
                    ;; window height
;                   vim_snprintf(cbuf, cbuf.size() - 5, u8("%ld"), Prenum);
;               else
;                   cbuf.be(0, NUL);
;               STRCAT(cbuf, u8("new"));
;               do_cmdline_cmd(cbuf);
;               break;

            ;; quit current window
;           case Ctrl_Q:
;           case 'q':
;               reset_VIsual_and_resel();
;               cmd_with_count(u8("quit"), cbuf, cbuf.size(), Prenum);
;               do_cmdline_cmd(cbuf);
;               break;

            ;; close current window
;           case Ctrl_C:
;           case 'c':
;               reset_VIsual_and_resel();
;               cmd_with_count(u8("close"), cbuf, cbuf.size(), Prenum);
;               do_cmdline_cmd(cbuf);
;               break;

            ;; close all but current window
;           case Ctrl_O:
;           case 'o':
;               if (@cmdwin_type != 0)
;               {
;                   emsg(e_cmdwin);
;                   break;
;               }
;               reset_VIsual_and_resel();
;               cmd_with_count(u8("only"), cbuf, cbuf.size(), Prenum);
;               do_cmdline_cmd(cbuf);
;               break;

            ;; cursor to next window with wrap around
;           case Ctrl_W:
;           case 'w':
            ;; cursor to previous window with wrap around
;           case 'W':
;               if (@cmdwin_type != 0)
;               {
;                   emsg(e_cmdwin);
;                   break;
;               }
;               if (@firstwin == @lastwin && Prenum != 1) ;; just one window
;                   beep_flush();
;               else
;               {
;                   window_C wp;
;                   if (Prenum != 0)                    ;; go to specified window
;                   {
;                       for (wp = @firstwin; 0 < --Prenum; )
;                       {
;                           if (wp.w_next == null)
;                               break;
;                           else
;                               wp = wp.w_next;
;                       }
;                   }
;                   else
;                   {
;                       if (nchar == 'W')           ;; go to previous window
;                       {
;                           wp = @curwin.w_prev;
;                           if (wp == null)
;                               wp = @lastwin;       ;; wrap around
;                       }
;                       else                        ;; go to next window
;                       {
;                           wp = @curwin.w_next;
;                           if (wp == null)
;                               wp = @firstwin;      ;; wrap around
;                       }
;                   }
;                   win_goto(wp);
;               }
;               break;

            ;; cursor to window below
;           case 'j':
;           case K_DOWN:
;           case Ctrl_J:
;               if (@cmdwin_type != 0)
;               {
;                   emsg(e_cmdwin);
;                   break;
;               }
;               win_goto_ver(false, Prenum1);
;               break;

            ;; cursor to window above
;           case 'k':
;           case K_UP:
;           case Ctrl_K:
;               if (@cmdwin_type != 0)
;               {
;                   emsg(e_cmdwin);
;                   break;
;               }
;               win_goto_ver(true, Prenum1);
;               break;

            ;; cursor to left window
;           case 'h':
;           case K_LEFT:
;           case Ctrl_H:
;           case K_BS:
;               if (@cmdwin_type != 0)
;               {
;                   emsg(e_cmdwin);
;                   break;
;               }
;               win_goto_hor(true, Prenum1);
;               break;

            ;; cursor to right window
;           case 'l':
;           case K_RIGHT:
;           case Ctrl_L:
;               if (@cmdwin_type != 0)
;               {
;                   emsg(e_cmdwin);
;                   break;
;               }
;               win_goto_hor(false, Prenum1);
;               break;

            ;; cursor to top-left window
;           case 't':
;           case Ctrl_T:
;               win_goto(@firstwin);
;               break;

            ;; cursor to bottom-right window
;           case 'b':
;           case Ctrl_B:
;               win_goto(@lastwin);
;               break;

            ;; cursor to last accessed (previous) window
;           case 'p':
;           case Ctrl_P:
;               if (@prevwin == null)
;                   beep_flush();
;               else
;                   win_goto(@prevwin);
;               break;

            ;; exchange current and next window
;           case 'x':
;           case Ctrl_X:
;               if (@cmdwin_type != 0)
;               {
;                   emsg(e_cmdwin);
;                   break;
;               }
;               win_exchange(Prenum);
;               break;

            ;; rotate windows downwards
;           case Ctrl_R:
;           case 'r':
;               if (@cmdwin_type != 0)
;               {
;                   emsg(e_cmdwin);
;                   break;
;               }
;               reset_VIsual_and_resel();
;               win_rotate(false, (int)Prenum1);
;               break;

            ;; rotate windows upwards
;           case 'R':
;               if (@cmdwin_type != 0)
;               {
;                   emsg(e_cmdwin);
;                   break;
;               }
;               reset_VIsual_and_resel();
;               win_rotate(true, (int)Prenum1);
;               break;

            ;; move window to the very top/bottom/left/right
;           case 'K':
;           case 'J':
;           case 'H':
;           case 'L':
;               if (@cmdwin_type != 0)
;               {
;                   emsg(e_cmdwin);
;                   break;
;               }
;               win_totop((int)Prenum,
;                       ((nchar == 'H' || nchar == 'L') ? WSP_VERT : 0)
;                     | ((nchar == 'H' || nchar == 'K') ? WSP_TOP : WSP_BOT));
;               break;

            ;; make all windows the same height
;           case '=':
;               win_equal(null, false, 'b');
;               break;

            ;; increase current window height
;           case '+':
;               win_setheight(@curwin.w_height + (int)Prenum1);
;               break;

            ;; decrease current window height
;           case '-':
;               win_setheight(@curwin.w_height - (int)Prenum1);
;               break;

            ;; set current window height
;           case Ctrl__:
;           case '_':
;               win_setheight(Prenum != 0 ? (int)Prenum : 9999);
;               break;

            ;; increase current window width
;           case '>':
;               win_setwidth(@curwin.w_width + (int)Prenum1);
;               break;

            ;; decrease current window width
;           case '<':
;               win_setwidth(@curwin.w_width - (int)Prenum1);
;               break;

            ;; set current window width
;           case '|':
;               win_setwidth(Prenum != 0 ? (int)Prenum : 9999);
;               break;

            ;; jump to tag and split window if tag exists (in preview window)
;           case ']':
;           case Ctrl_RSB:
;               if (@cmdwin_type != 0)
;               {
;                   emsg(e_cmdwin);
;                   break;
;               }
                ;; keep Visual mode, can select words to use as a tag
;               if (Prenum != 0)
;                   @postponed_split = (int)Prenum;
;               else
;                   @postponed_split = -1;

                ;; Execute the command right here,
                ;; required when "wincmd ]" was used in a function.
;               do_nv_ident(Ctrl_RSB, NUL);
;               break;

;           case K_KENTER:
;           case CAR:
;               break;

            ;; CTRL-W g extended commands.
;           case 'g':
;           case Ctrl_G:
;               if (@cmdwin_type != 0)
;               {
;                   emsg(e_cmdwin);
;                   break;
;               }
;               @no_mapping++;
;               @allow_keys++;       ;; no mapping for xchar, but allow key codes
;               if (xchar == NUL)
;                   xchar = plain_vgetc();
;               --@no_mapping;
;               --@allow_keys;
;               add_to_showcmd(xchar);
;               switch (xchar)
;               {
;                   case ']':
;                   case Ctrl_RSB:
                        ;; keep Visual mode, can select words to use as a tag
;                       if (Prenum != 0)
;                           @postponed_split = (int)Prenum;
;                       else
;                           @postponed_split = -1;

                        ;; Execute the command right here,
                        ;; required when "wincmd g}" was used in a function.
;                       do_nv_ident('g', xchar);
;                       break;

;                   default:
;                       beep_flush();
;                       break;
;               }
;               break;

;           default:
;               beep_flush();
;               break;
;       }
    ))

;; Figure out the address type for ":wnncmd".

(defn- #_void get_wincmd_addr_type [#_Bytes arg, #_exarg_C eap]
    (§
;       switch (arg.at(0))
;       {
;           case 'S':
;           case Ctrl_S:
;           case 's':
;           case Ctrl_N:
;           case 'n':
;           case 'j':
;           case Ctrl_J:
;           case 'k':
;           case Ctrl_K:
;           case 'T':
;           case Ctrl_R:
;           case 'r':
;           case 'R':
;           case 'K':
;           case 'J':
;           case '+':
;           case '-':
;           case Ctrl__:
;           case '_':
;           case '|':
;           case ']':
;           case Ctrl_RSB:
;           case 'g':
;           case Ctrl_G:
;           case Ctrl_V:
;           case 'v':
;           case 'h':
;           case Ctrl_H:
;           case 'l':
;           case Ctrl_L:
;           case 'H':
;           case 'L':
;           case '>':
;           case '<':
                ;; window size or any count
;               eap.addr_type = ADDR_LINES;
;               break;

;           case Ctrl_HAT:
;           case '^':
                ;; buffer number
;               eap.addr_type = ADDR_BUFFERS;
;               break;

;           case Ctrl_Q:
;           case 'q':
;           case Ctrl_C:
;           case 'c':
;           case Ctrl_O:
;           case 'o':
;           case Ctrl_W:
;           case 'w':
;           case 'W':
;           case 'x':
;           case Ctrl_X:
                ;; window number
;               eap.addr_type = ADDR_WINDOWS;
;               break;

;           case 't':
;           case Ctrl_T:
;           case 'b':
;           case Ctrl_B:
;           case 'p':
;           case Ctrl_P:
;           case '=':
;           case CAR:
                ;; no count
;               eap.addr_type = 0;
;               break;
;       }
    ))

(defn- #_void cmd_with_count [#_Bytes cmd, #_Bytes bufp, #_int bufsize, #_long Prenum]
    (§
;       int len = STRLEN(cmd);

;       STRCPY(bufp, cmd);
;       if (0 < Prenum)
;           vim_snprintf(bufp.plus(len), bufsize - len, u8("%ld"), Prenum);
    ))

;; split the current window, implements CTRL-W s and :split
;;
;; "size" is the height or width for the new window, 0 to use half of current height or width.
;;
;; "flags":
;; WSP_ROOM: require enough room for new window
;; WSP_VERT: vertical split.
;; WSP_TOP:  open window at the top-left of the shell (help window).
;; WSP_BOT:  open window at the bottom-right of the shell (quickfix window).
;;
;; return false for failure, true otherwise

(defn- #_boolean win_split [#_int size, #_int flags]
    (§
        ;; Add flags from ":vertical", ":topleft" and ":botright".
;       flags |= @cmdmod.split;
;       if ((flags & WSP_TOP) != 0 && (flags & WSP_BOT) != 0)
;       {
;           emsg(u8("E442: Can't split topleft and botright at the same time"));
;           return false;
;       }

;       return win_split_ins(size, flags, null, 0);
    ))

;; When "new_wp" is null: split the current window in two.
;; When "new_wp" is not null: insert this window at the far top/left/right/bottom.
;; return false for failure, true otherwise

(defn- #_boolean win_split_ins [#_int size, #_int flags, #_window_C new_wp, #_int dir]
    (§
;       window_C wp = new_wp;
;       int new_size = size;
;       boolean do_equal = false;
;       int oldwin_height = 0;

;       window_C oldwin;
;       if ((flags & WSP_TOP) != 0)
;           oldwin = @firstwin;
;       else if ((flags & WSP_BOT) != 0)
;           oldwin = @lastwin;
;       else
;           oldwin = @curwin;

;       int need_status = 0;
        ;; add a status line when p_ls == 1 and splitting the first window
;       if (@lastwin == @firstwin && @p_ls == 1 && oldwin.w_status_height == 0)
;       {
;           if (oldwin.w_height <= @p_wmh && new_wp == null)
;           {
;               emsg(e_noroom);
;               return false;
;           }
;           need_status = STATUS_HEIGHT;
;       }

;       byte layout;
;       if ((flags & WSP_VERT) != 0)
;       {
;           layout = FR_ROW;

            ;; Check if we are able to split the current window and compute its width.

            ;; Current window requires at least 1 space.
;           int wmw1 = (@p_wmw == 0) ? 1 : (int)@p_wmw;
;           int needed = wmw1 + 1;
;           if ((flags & WSP_ROOM) != 0)
;               needed += @p_wiw - wmw1;
;           int minwidth;
;           int available;
;           if ((flags & (WSP_BOT | WSP_TOP)) != 0)
;           {
;               minwidth = frame_minwidth(@topframe, NOWIN);
;               available = @topframe.fr_width;
;               needed += minwidth;
;           }
;           else if (@p_ea)
;           {
;               minwidth = frame_minwidth(oldwin.w_frame, NOWIN);
;               frame_C prevfrp = oldwin.w_frame;
;               for (frame_C frp = oldwin.w_frame.fr_parent; frp != null; frp = frp.fr_parent)
;               {
;                   if (frp.fr_layout == FR_ROW)
;                       for (frame_C frp2 = frp.fr_child; frp2 != null; frp2 = frp2.fr_next)
;                           if (frp2 != prevfrp)
;                               minwidth += frame_minwidth(frp2, NOWIN);
;                   prevfrp = frp;
;               }
;               available = @topframe.fr_width;
;               needed += minwidth;
;           }
;           else
;           {
;               minwidth = frame_minwidth(oldwin.w_frame, NOWIN);
;               available = oldwin.w_frame.fr_width;
;               needed += minwidth;
;           }
;           if (available < needed && new_wp == null)
;           {
;               emsg(e_noroom);
;               return false;
;           }
;           if (new_size == 0)
;               new_size = oldwin.w_width / 2;
;           if (new_size > available - minwidth - 1)
;               new_size = available - minwidth - 1;
;           if (new_size < wmw1)
;               new_size = wmw1;

            ;; if it doesn't fit in the current window, need win_equal()
;           if (oldwin.w_width - new_size - 1 < @p_wmw)
;               do_equal = true;

            ;; We don't like to take lines for the new window from a 'winfixwidth' window.
            ;; Take them from a window to the left or right instead, if possible.
;           if (oldwin.w_onebuf_opt.@wo_wfw)
;               win_setwidth_win(oldwin.w_width + new_size, oldwin);

            ;; Only make all windows the same width if one of them (except oldwin)
            ;; is wider than one of the split windows.
;           if (!do_equal && @p_ea && size == 0 && @p_ead.at(0) != (byte)'v' && oldwin.w_frame.fr_parent != null)
;           {
;               frame_C frp = oldwin.w_frame.fr_parent.fr_child;
;               while (frp != null)
;               {
;                   if (frp.fr_win != oldwin && frp.fr_win != null
;                           && (new_size < frp.fr_win.w_width
;                               || oldwin.w_width - new_size - 1 < frp.fr_win.w_width))
;                   {
;                       do_equal = true;
;                       break;
;                   }
;                   frp = frp.fr_next;
;               }
;           }
;       }
;       else
;       {
;           layout = FR_COL;

            ;; Check if we are able to split the current window and compute its height.

            ;; Current window requires at least 1 space.
;           int wmh1 = (@p_wmh == 0) ? 1 : (int)@p_wmh;
;           int needed = wmh1 + STATUS_HEIGHT;
;           if ((flags & WSP_ROOM) != 0)
;               needed += @p_wh - wmh1;
;           int minheight;
;           int available;
;           if ((flags & (WSP_BOT | WSP_TOP)) != 0)
;           {
;               minheight = frame_minheight(@topframe, NOWIN) + need_status;
;               available = @topframe.fr_height;
;               needed += minheight;
;           }
;           else if (@p_ea)
;           {
;               minheight = frame_minheight(oldwin.w_frame, NOWIN) + need_status;
;               frame_C prevfrp = oldwin.w_frame;
;               for (frame_C frp = oldwin.w_frame.fr_parent; frp != null; frp = frp.fr_parent)
;               {
;                   if (frp.fr_layout == FR_COL)
;                       for (frame_C frp2 = frp.fr_child; frp2 != null; frp2 = frp2.fr_next)
;                           if (frp2 != prevfrp)
;                               minheight += frame_minheight(frp2, NOWIN);
;                   prevfrp = frp;
;               }
;               available = @topframe.fr_height;
;               needed += minheight;
;           }
;           else
;           {
;               minheight = frame_minheight(oldwin.w_frame, NOWIN) + need_status;
;               available = oldwin.w_frame.fr_height;
;               needed += minheight;
;           }
;           if (available < needed && new_wp == null)
;           {
;               emsg(e_noroom);
;               return false;
;           }
;           oldwin_height = oldwin.w_height;
;           if (need_status != 0)
;           {
;               oldwin.w_status_height = STATUS_HEIGHT;
;               oldwin_height -= STATUS_HEIGHT;
;           }
;           if (new_size == 0)
;               new_size = oldwin_height / 2;
;           if (new_size > available - minheight - STATUS_HEIGHT)
;               new_size = available - minheight - STATUS_HEIGHT;
;           if (new_size < wmh1)
;               new_size = wmh1;

            ;; if it doesn't fit in the current window, need win_equal()
;           if (oldwin_height - new_size - STATUS_HEIGHT < @p_wmh)
;               do_equal = true;

            ;; We don't like to take lines for the new window from a 'winfixheight' window.
            ;; Take them from a window above or below instead, if possible.
;           if (oldwin.w_onebuf_opt.@wo_wfh)
;           {
;               win_setheight_win(oldwin.w_height + new_size + STATUS_HEIGHT, oldwin);
;               oldwin_height = oldwin.w_height;
;               if (need_status != 0)
;                   oldwin_height -= STATUS_HEIGHT;
;           }

            ;; Only make all windows the same height if one of them (except oldwin)
            ;; is higher than one of the split windows.
;           if (!do_equal && @p_ea && size == 0 && @p_ead.at(0) != (byte)'h' && oldwin.w_frame.fr_parent != null)
;           {
;               frame_C frp = oldwin.w_frame.fr_parent.fr_child;
;               while (frp != null)
;               {
;                   if (frp.fr_win != oldwin && frp.fr_win != null
;                           && (new_size < frp.fr_win.w_height
;                               || oldwin_height - new_size - STATUS_HEIGHT < frp.fr_win.w_height))
;                   {
;                       do_equal = true;
;                       break;
;                   }
;                   frp = frp.fr_next;
;               }
;           }
;       }

        ;; allocate new window structure and link it in the window list

;       if ((flags & WSP_TOP) == 0
;               && ((flags & WSP_BOT) != 0
;                   || (flags & WSP_BELOW) != 0
;                   || ((flags & WSP_ABOVE) == 0
;                       && ((flags & WSP_VERT) != 0 ? @p_spr : @p_sb))))
;       {
            ;; new window below/right of current one
;           if (new_wp == null)
;               wp = newWindow(oldwin, false);
;           else
;               win_append(oldwin, wp);
;       }
;       else
;       {
;           if (new_wp == null)
;               wp = newWindow(oldwin.w_prev, false);
;           else
;               win_append(oldwin.w_prev, wp);
;       }

;       if (new_wp == null)
;       {
;           if (wp == null)
;               return false;

;           wp.w_frame = newFrame(wp);

            ;; make the contents of the new window the same as the current one
;           win_init(wp, @curwin, flags);
;       }

        ;; Reorganise the tree of frames to insert the new window.

;       frame_C curfrp;
;       boolean before;
;       if ((flags & (WSP_TOP | WSP_BOT)) != 0)
;       {
;           if ((@topframe.fr_layout == FR_COL && (flags & WSP_VERT) == 0)
;               || (@topframe.fr_layout == FR_ROW && (flags & WSP_VERT) != 0))
;           {
;               curfrp = @topframe.fr_child;
;               if ((flags & WSP_BOT) != 0)
;                   while (curfrp.fr_next != null)
;                       curfrp = curfrp.fr_next;
;           }
;           else
;               curfrp = @topframe;
;           before = ((flags & WSP_TOP) != 0);
;       }
;       else
;       {
;           curfrp = oldwin.w_frame;
;           if ((flags & WSP_BELOW) != 0)
;               before = false;
;           else if ((flags & WSP_ABOVE) != 0)
;               before = true;
;           else if ((flags & WSP_VERT) != 0)
;               before = !@p_spr;
;           else
;               before = !@p_sb;
;       }
;       if (curfrp.fr_parent == null || curfrp.fr_parent.fr_layout != layout)
;       {
            ;; Need to create a new frame in the tree to make a branch.
;           frame_C frp = §_frame_C();
;           COPY_frame(frp, curfrp);
;           curfrp.fr_layout = layout;
;           frp.fr_parent = curfrp;
;           frp.fr_next = null;
;           frp.fr_prev = null;
;           curfrp.fr_child = frp;
;           curfrp.fr_win = null;
;           curfrp = frp;
;           if (frp.fr_win != null)
;               oldwin.w_frame = frp;
;           else
;               for (frp = frp.fr_child; frp != null; frp = frp.fr_next)
;                   frp.fr_parent = curfrp;
;       }

;       frame_C frp;
;       if (new_wp == null)
;           frp = wp.w_frame;
;       else
;           frp = new_wp.w_frame;
;       frp.fr_parent = curfrp.fr_parent;

        ;; Insert the new frame at the right place in the frame list.
;       if (before)
;           frame_insert(curfrp, frp);
;       else
;           frame_append(curfrp, frp);

        ;; Set w_fraction now so that the cursor keeps the same relative vertical position.
;       if (0 < oldwin.w_height)
;           set_fraction(oldwin);
;       wp.w_fraction = oldwin.w_fraction;

;       if ((flags & WSP_VERT) != 0)
;       {
;           wp.w_onebuf_opt.@wo_scr = @curwin.w_onebuf_opt.@wo_scr;

;           if (need_status != 0)
;           {
;               win_new_height(oldwin, oldwin.w_height - 1);
;               oldwin.w_status_height = need_status;
;           }
;           if ((flags & (WSP_TOP | WSP_BOT)) != 0)
;           {
                ;; set height and row of new window to full height
;               wp.w_winrow = tabline_height();
;               win_new_height(wp, curfrp.fr_height - (0 < @p_ls ? 1 : 0));
;               wp.w_status_height = (0 < @p_ls) ? 1 : 0;
;           }
;           else
;           {
                ;; height and row of new window is same as current window
;               wp.w_winrow = oldwin.w_winrow;
;               win_new_height(wp, oldwin.w_height);
;               wp.w_status_height = oldwin.w_status_height;
;           }
;           frp.fr_height = curfrp.fr_height;

            ;; "new_size" of the current window goes to the new window,
            ;; use one column for the vertical separator
;           win_new_width(wp, new_size);
;           if (before)
;               wp.w_vsep_width = 1;
;           else
;           {
;               wp.w_vsep_width = oldwin.w_vsep_width;
;               oldwin.w_vsep_width = 1;
;           }
;           if ((flags & (WSP_TOP | WSP_BOT)) != 0)
;           {
;               if ((flags & WSP_BOT) != 0)
;                   frame_add_vsep(curfrp);
                ;; Set width of neighbor frame.
;               frame_new_width(curfrp, curfrp.fr_width - (new_size + ((flags & WSP_TOP) != 0 ? 1 : 0)), (flags & WSP_TOP) != 0, false);
;           }
;           else
;               win_new_width(oldwin, oldwin.w_width - (new_size + 1));
;           if (before)     ;; new window left of current one
;           {
;               wp.w_wincol = oldwin.w_wincol;
;               oldwin.w_wincol += new_size + 1;
;           }
;           else            ;; new window right of current one
;               wp.w_wincol = oldwin.w_wincol + oldwin.w_width + 1;
;           frame_fix_width(oldwin);
;           frame_fix_width(wp);
;       }
;       else
;       {
            ;; width and column of new window is same as current window
;           if ((flags & (WSP_TOP | WSP_BOT)) != 0)
;           {
;               wp.w_wincol = 0;
;               win_new_width(wp, (int)@Columns);
;               wp.w_vsep_width = 0;
;           }
;           else
;           {
;               wp.w_wincol = oldwin.w_wincol;
;               win_new_width(wp, oldwin.w_width);
;               wp.w_vsep_width = oldwin.w_vsep_width;
;           }
;           frp.fr_width = curfrp.fr_width;

            ;; "new_size" of the current window goes to the new window,
            ;; use one row for the status line
;           win_new_height(wp, new_size);
;           if ((flags & (WSP_TOP | WSP_BOT)) != 0)
;               frame_new_height(curfrp, curfrp.fr_height - (new_size + STATUS_HEIGHT), (flags & WSP_TOP) != 0, false);
;           else
;               win_new_height(oldwin, oldwin_height - (new_size + STATUS_HEIGHT));
;           if (before)     ;; new window above current one
;           {
;               wp.w_winrow = oldwin.w_winrow;
;               wp.w_status_height = STATUS_HEIGHT;
;               oldwin.w_winrow += wp.w_height + STATUS_HEIGHT;
;           }
;           else            ;; new window below current one
;           {
;               wp.w_winrow = oldwin.w_winrow + oldwin.w_height + STATUS_HEIGHT;
;               wp.w_status_height = oldwin.w_status_height;
;               oldwin.w_status_height = STATUS_HEIGHT;
;           }
;           if ((flags & WSP_BOT) != 0)
;               frame_add_statusline(curfrp);
;           frame_fix_height(wp);
;           frame_fix_height(oldwin);
;       }

;       if ((flags & (WSP_TOP | WSP_BOT)) != 0)
;           win_comp_pos();

        ;; Both windows need redrawing

;       redraw_win_later(wp, NOT_VALID);
;       wp.w_redr_status = true;
;       redraw_win_later(oldwin, NOT_VALID);
;       oldwin.w_redr_status = true;

;       if (need_status != 0)
;       {
;           @msg_row = (int)@Rows - 1;
;           @msg_col = @sc_col;
;           msg_clr_eos_force();    ;; old command/ruler may still be there
;           comp_col();
;           @msg_row = (int)@Rows - 1;
;           @msg_col = 0;            ;; put position back at start of line
;       }

        ;; equalize the window sizes.

;       if (do_equal || dir != 0)
;           win_equal(wp, true, (flags & WSP_VERT) != 0 ? (dir == 'v' ? 'b' : 'h') : (dir == 'h' ? 'b' : 'v'));

        ;; Don't change the window height/width to 'winheight' / 'winwidth' if a size was given.
;       int i;
;       if ((flags & WSP_VERT) != 0)
;       {
;           i = (int)@p_wiw;
;           if (size != 0)
;               @p_wiw = size;
;       }
;       else
;       {
;           i = (int)@p_wh;
;           if (size != 0)
;               @p_wh = size;
;       }

        ;; Keep same changelist position in new window.
;       wp.w_changelistidx = oldwin.w_changelistidx;

        ;; make the new window the current window

;       win_enter(wp, false);
;       if ((flags & WSP_VERT) != 0)
;           @p_wiw = i;
;       else
;           @p_wh = i;

;       return true;
    ))

;; Initialize window "newp" from window "oldp".
;; Used when splitting a window and when creating a new tab page.
;; The windows will both edit the same buffer.
;; WSP_NEWLOC may be specified in flags to prevent the location list from being copied.

(defn- #_void win_init [#_window_C newp, #_window_C oldp, #_int _flags]
    (§
;       newp.w_buffer = oldp.w_buffer;
;       oldp.w_buffer.b_nwindows++;
;       COPY_pos(newp.w_cursor, oldp.w_cursor);
;       newp.w_valid = 0;
;       newp.w_curswant = oldp.w_curswant;
;       newp.w_set_curswant = oldp.w_set_curswant;
;       newp.w_topline = oldp.w_topline;
;       newp.w_leftcol = oldp.w_leftcol;
;       COPY_pos(newp.w_pcmark, oldp.w_pcmark);
;       COPY_pos(newp.w_prev_pcmark, oldp.w_prev_pcmark);
;       newp.w_alt_fnum = oldp.w_alt_fnum;
;       newp.w_wrow = oldp.w_wrow;
;       newp.w_fraction = oldp.w_fraction;
;       newp.w_prev_fraction_row = oldp.w_prev_fraction_row;
;       copy_jumplist(oldp, newp);

;       win_init_some(newp, oldp);

;       check_colorcolumn(newp);
    ))

;; Initialize window "newp" from window "old".
;; Only the essential things are copied.

(defn- #_void win_init_some [#_window_C newp, #_window_C oldp]
    (§
        ;; copy options from existing window
;       win_copy_options(oldp, newp);
    ))

;; Check if "win" is a pointer to an existing window.

(defn- #_boolean win_valid [#_window_C win]
    (§
;       if (win == null)
;           return false;

;       for (window_C wp = @firstwin; wp != null; wp = wp.w_next)
;           if (wp == win)
;               return true;

;       return false;
    ))

;; Return the number of windows.

(defn- #_int win_count []
    (§
;       int count = 0;

;       for (window_C wp = @firstwin; wp != null; wp = wp.w_next)
;           count++;

;       return count;
    ))

;; Make "count" windows on the screen.
;; Return actual number of windows on the screen.
;; Must be called when there is just one window, filling the whole screen
;; (excluding the command line).

(defn- #_int make_windows [#_int count, #_boolean vertical]
    ;; vertical: split windows vertically if true
    (§
;       int maxcount;
;       if (vertical)
;       {
            ;; Each windows needs at least 'winminwidth' lines and a separator column.
;           maxcount = (@curwin.w_width + @curwin.w_vsep_width - (int)(@p_wiw - @p_wmw)) / ((int)@p_wmw + 1);
;       }
;       else
;       {
            ;; Each window needs at least 'winminheight' lines and a status line.
;           maxcount = (@curwin.w_height + @curwin.w_status_height - (int)(@p_wh - @p_wmh)) / ((int)@p_wmh + STATUS_HEIGHT);
;       }

;       if (maxcount < 2)
;           maxcount = 2;
;       if (maxcount < count)
;           count = maxcount;

        ;; add status line now, otherwise first window will be too big

;       if (1 < count)
;           last_status(true);

;       int todo;
        ;; todo is number of windows left to create
;       for (todo = count - 1; 0 < todo; --todo)
;           if (vertical)
;           {
;               if (win_split(@curwin.w_width - (@curwin.w_width - todo) / (todo + 1) - 1, WSP_VERT | WSP_ABOVE) == false)
;                   break;
;           }
;           else
;           {
;               if (win_split(@curwin.w_height - (@curwin.w_height - todo * STATUS_HEIGHT) / (todo + 1) - STATUS_HEIGHT, WSP_ABOVE) == false)
;                   break;
;           }

        ;; return actual number of windows
;       return (count - todo);
    ))

;; Exchange current and next window

(defn- #_void win_exchange [#_long Prenum]
    (§
;       if (@lastwin == @firstwin)        ;; just one window
;       {
;           beep_flush();
;           return;
;       }

;       frame_C frp;

        ;; find window to exchange with

;       if (Prenum != 0)
;       {
;           frp = @curwin.w_frame.fr_parent.fr_child;
;           while (frp != null && 0 < --Prenum)
;               frp = frp.fr_next;
;       }
;       else if (@curwin.w_frame.fr_next != null)    ;; Swap with next.
;           frp = @curwin.w_frame.fr_next;
;       else    ;; Swap last window in row/col with previous.
;           frp = @curwin.w_frame.fr_prev;

        ;; We can only exchange a window with another window, not with a frame containing windows.
;       if (frp == null || frp.fr_win == null || frp.fr_win == @curwin)
;           return;

;       window_C wp = frp.fr_win;

        ;; 1. remove curwin from the list.  Remember after which window it was in wp2
        ;; 2. insert curwin before wp in the list
        ;; if wp != wp2
        ;;    3. remove wp from the list
        ;;    4. insert wp after wp2
        ;; 5. exchange the status line height and vsep width.

;       window_C wp2 = @curwin.w_prev;
;       frame_C frp2 = @curwin.w_frame.fr_prev;
;       if (wp.w_prev != @curwin)
;       {
;           win_remove(@curwin, null);
;           frame_remove(@curwin.w_frame);
;           win_append(wp.w_prev, @curwin);
;           frame_insert(frp, @curwin.w_frame);
;       }
;       if (wp != wp2)
;       {
;           win_remove(wp, null);
;           frame_remove(wp.w_frame);
;           win_append(wp2, wp);
;           if (frp2 == null)
;               frame_insert(wp.w_frame.fr_parent.fr_child, wp.w_frame);
;           else
;               frame_append(frp2, wp.w_frame);
;       }

;       int temp = @curwin.w_status_height;
;       @curwin.w_status_height = wp.w_status_height;
;       wp.w_status_height = temp;
;       temp = @curwin.w_vsep_width;
;       @curwin.w_vsep_width = wp.w_vsep_width;
;       wp.w_vsep_width = temp;

        ;; If the windows are not in the same frame, exchange the sizes to avoid
        ;; messing up the window layout.  Otherwise fix the frame sizes.
;       if (@curwin.w_frame.fr_parent != wp.w_frame.fr_parent)
;       {
;           temp = @curwin.w_height;
;           @curwin.w_height = wp.w_height;
;           wp.w_height = temp;
;           temp = @curwin.w_width;
;           @curwin.w_width = wp.w_width;
;           wp.w_width = temp;
;       }
;       else
;       {
;           frame_fix_height(@curwin);
;           frame_fix_height(wp);
;           frame_fix_width(@curwin);
;           frame_fix_width(wp);
;       }

;       win_comp_pos();                 ;; recompute window positions

;       win_enter(wp, true);
;       redraw_later(CLEAR);
    ))

;; rotate windows: if upwards true the second window becomes the first one
;;                 if upwards false the first window becomes the second one

(defn- #_void win_rotate [#_boolean upwards, #_int count]
    (§
;       if (@firstwin == @lastwin)            ;; nothing to do
;       {
;           beep_flush();
;           return;
;       }

;       frame_C frp;
        ;; Check if all frames in this row/col have one window.
;       for (frp = @curwin.w_frame.fr_parent.fr_child; frp != null; frp = frp.fr_next)
;           if (frp.fr_win == null)
;           {
;               emsg(u8("E443: Cannot rotate when another window is split"));
;               return;
;           }

;       while (0 < count--)
;       {
;           window_C wp1, wp2;

;           if (upwards)            ;; first window becomes last window
;           {
                ;; remove first window/frame from the list
;               frp = @curwin.w_frame.fr_parent.fr_child;
;               wp1 = frp.fr_win;
;               win_remove(wp1, null);
;               frame_remove(frp);

                ;; find last frame and append removed window/frame after it
;               for ( ; frp.fr_next != null; frp = frp.fr_next)
                ;
;               win_append(frp.fr_win, wp1);
;               frame_append(frp, wp1.w_frame);

;               wp2 = frp.fr_win;   ;; previously last window
;           }
;           else                    ;; last window becomes first window
;           {
                ;; find last window/frame in the list and remove it
;               for (frp = @curwin.w_frame; frp.fr_next != null; frp = frp.fr_next)
                ;
;               wp1 = frp.fr_win;
;               wp2 = wp1.w_prev;   ;; will become last window
;               win_remove(wp1, null);
;               frame_remove(frp);

                ;; append the removed window/frame before the first in the list
;               win_append(frp.fr_parent.fr_child.fr_win.w_prev, wp1);
;               frame_insert(frp.fr_parent.fr_child, frp);
;           }

            ;; exchange status height and vsep width of old and new last window
;           int n = wp2.w_status_height;
;           wp2.w_status_height = wp1.w_status_height;
;           wp1.w_status_height = n;
;           frame_fix_height(wp1);
;           frame_fix_height(wp2);

;           n = wp2.w_vsep_width;
;           wp2.w_vsep_width = wp1.w_vsep_width;
;           wp1.w_vsep_width = n;
;           frame_fix_width(wp1);
;           frame_fix_width(wp2);

            ;; recompute w_winrow and w_wincol for all windows
;           win_comp_pos();
;       }

;       redraw_later(CLEAR);
    ))

;; Move the current window to the very top/bottom/left/right of the screen.

(defn- #_void win_totop [#_int size, #_int flags]
    (§
;       int height = @curwin.w_height;

;       if (@lastwin == @firstwin)
;       {
;           beep_flush();
;           return;
;       }

        ;; Remove the window and frame from the tree of frames.
;       int[] dir = new int[1];
;       winframe_remove(@curwin, dir, null);
;       win_remove(@curwin, null);
;       last_status(false);             ;; may need to remove last status line
;       win_comp_pos();                 ;; recompute window positions

        ;; Split a window on the desired side and put the window there.
;       win_split_ins(size, flags, @curwin, dir[0]);
;       if ((flags & WSP_VERT) == 0)
;       {
;           win_setheight(height);
;           if (@p_ea)
;               win_equal(@curwin, true, 'v');
;       }
    ))

;; Move window "win1" to below/right of "win2" and make "win1" the current
;; window.  Only works within the same frame!

(defn- #_void win_move_after [#_window_C win1, #_window_C win2]
    (§
        ;; check if the arguments are reasonable
;       if (win1 == win2)
;           return;

        ;; check if there is something to do
;       if (win2.w_next != win1)
;       {
            ;; may need move the status line/vertical separator of the last window
;           if (win1 == @lastwin)
;           {
;               int height = win1.w_prev.w_status_height;
;               win1.w_prev.w_status_height = win1.w_status_height;
;               win1.w_status_height = height;
;               if (win1.w_prev.w_vsep_width == 1)
;               {
                    ;; Remove the vertical separator from the last-but-one window,
                    ;; add it to the last window.  Adjust the frame widths.
;                   win1.w_prev.w_vsep_width = 0;
;                   win1.w_prev.w_frame.fr_width -= 1;
;                   win1.w_vsep_width = 1;
;                   win1.w_frame.fr_width += 1;
;               }
;           }
;           else if (win2 == @lastwin)
;           {
;               int height = win1.w_status_height;
;               win1.w_status_height = win2.w_status_height;
;               win2.w_status_height = height;
;               if (win1.w_vsep_width == 1)
;               {
                    ;; Remove the vertical separator from win1, add it to the last
                    ;; window, win2.  Adjust the frame widths.
;                   win2.w_vsep_width = 1;
;                   win2.w_frame.fr_width += 1;
;                   win1.w_vsep_width = 0;
;                   win1.w_frame.fr_width -= 1;
;               }
;           }
;           win_remove(win1, null);
;           frame_remove(win1.w_frame);
;           win_append(win2, win1);
;           frame_append(win2.w_frame, win1.w_frame);

;           win_comp_pos();             ;; recompute w_winrow for all windows
;           redraw_later(NOT_VALID);
;       }
;       win_enter(win1, false);
    ))

;; Make all windows the same height.
;; 'next_curwin' will soon be the current window, make sure it has enough rows.

(defn- #_void win_equal [#_window_C next_curwin, #_boolean current, #_int dir]
    ;; next_curwin: pointer to current window to be or null
    ;; current: do only frame with current window
    ;; dir: 'v' for vertically, 'h' for horizontally, 'b' for both, 0 for using "p_ead"
    (§
;       if (dir == 0)
;           dir = @p_ead.at(0);
;       win_equal_rec((next_curwin == null) ? @curwin : next_curwin, current,
;                         @topframe, dir, 0, tabline_height(), (int)@Columns, @topframe.fr_height);
    ))

;; Set a frame to a new position and height, spreading the available room
;; equally over contained frames.
;; The window "next_curwin" (if not null) should at least get the size from
;; 'winheight' and 'winwidth' if possible.

(defn- #_void win_equal_rec [#_window_C next_curwin, #_boolean current, #_frame_C topfr, #_int dir, #_int col, #_int row, #_int width, #_int height]
    ;; next_curwin: pointer to current window to be or null
    ;; current: do only frame with current window
    ;; topfr: frame to set size off
    ;; dir: 'v', 'h' or 'b', see win_equal()
    ;; col: horizontal position for frame
    ;; row: vertical position for frame
    ;; width: new width of frame
    ;; height: new height of frame
    (§
;       int extra_sep = 0;
;       int wincount, totwincount = 0;
;       int next_curwin_size = 0;
;       int room = 0;
;       boolean has_next_curwin = false;

;       if (topfr.fr_layout == FR_LEAF)
;       {
            ;; Set the width/height of this frame.
            ;; Redraw when size or position changes
;           if (topfr.fr_height != height || topfr.fr_win.w_winrow != row
;              || topfr.fr_width != width || topfr.fr_win.w_wincol != col)
;           {
;               topfr.fr_win.w_winrow = row;
;               frame_new_height(topfr, height, false, false);
;               topfr.fr_win.w_wincol = col;
;               frame_new_width(topfr, width, false, false);
;               redraw_all_later(CLEAR);
;           }
;       }
;       else if (topfr.fr_layout == FR_ROW)
;       {
;           topfr.fr_width = width;
;           topfr.fr_height = height;

;           if (dir != 'v')                 ;; equalize frame widths
;           {
                ;; Compute the maximum number of windows horizontally in this frame.
;               int n = frame_minwidth(topfr, NOWIN);
                ;; add one for the rightmost window, it doesn't have a separator
;               if (col + width == (int)@Columns)
;                   extra_sep = 1;
;               else
;                   extra_sep = 0;
;               totwincount = (n + extra_sep) / ((int)@p_wmw + 1);
;               has_next_curwin = frame_has_win(topfr, next_curwin);

                ;; Compute width for "next_curwin" window and room available for other windows.
                ;; "m" is the minimal width when counting "p_wiw" for "next_curwin".

;               int m = frame_minwidth(topfr, next_curwin);
;               room = width - m;
;               if (room < 0)
;               {
;                   next_curwin_size = (int)@p_wiw + room;
;                   room = 0;
;               }
;               else
;               {
;                   next_curwin_size = -1;
;                   for (frame_C fr = topfr.fr_child; fr != null; fr = fr.fr_next)
;                   {
                        ;; If 'winfixwidth' set keep the window width if possible.
                        ;; Watch out for this window being the next_curwin.
;                       if (frame_fixed_width(fr))
;                       {
;                           n = frame_minwidth(fr, NOWIN);
;                           int new_size = fr.fr_width;
;                           if (frame_has_win(fr, next_curwin))
;                           {
;                               room += @p_wiw - @p_wmw;
;                               next_curwin_size = 0;
;                               if (new_size < @p_wiw)
;                                   new_size = (int)@p_wiw;
;                           }
;                           else
                                ;; These windows don't use up room.
;                               totwincount -= (n + (fr.fr_next == null ? extra_sep : 0)) / (@p_wmw + 1);
;                           room -= new_size - n;
;                           if (room < 0)
;                           {
;                               new_size += room;
;                               room = 0;
;                           }
;                           fr.fr_newwidth = new_size;
;                       }
;                   }
;                   if (next_curwin_size == -1)
;                   {
;                       if (!has_next_curwin)
;                           next_curwin_size = 0;
;                       else if (1 < totwincount && @p_wiw < (room + (totwincount - 2)) / (totwincount - 1))
;                       {
                            ;; Can make all windows wider than 'winwidth', spread the room equally.
;                           next_curwin_size = (room + (int)@p_wiw
;                                            + (totwincount - 1) * (int)@p_wmw
;                                            + (totwincount - 1)) / totwincount;
;                           room -= next_curwin_size - @p_wiw;
;                       }
;                       else
;                           next_curwin_size = (int)@p_wiw;
;                   }
;               }

;               if (has_next_curwin)
;                   --totwincount;          ;; don't count curwin
;           }

;           for (frame_C fr = topfr.fr_child; fr != null; fr = fr.fr_next)
;           {
;               wincount = 1;
;               int new_size;
;               if (fr.fr_next == null)
                    ;; last frame gets all that remains (avoid roundoff error)
;                   new_size = width;
;               else if (dir == 'v')
;                   new_size = fr.fr_width;
;               else if (frame_fixed_width(fr))
;               {
;                   new_size = fr.fr_newwidth;
;                   wincount = 0;       ;; doesn't count as a sizeable window
;               }
;               else
;               {
                    ;; Compute the maximum number of windows horiz. in "fr".
;                   int n = frame_minwidth(fr, NOWIN);
;                   wincount = (n + (fr.fr_next == null ? extra_sep : 0)) / ((int)@p_wmw + 1);
;                   int m = frame_minwidth(fr, next_curwin);
;                   boolean hnc;
;                   if (has_next_curwin)
;                       hnc = frame_has_win(fr, next_curwin);
;                   else
;                       hnc = false;
;                   if (hnc)            ;; don't count next_curwin
;                       --wincount;
;                   if (totwincount == 0)
;                       new_size = room;
;                   else
;                       new_size = (wincount * room + (totwincount >>> 1)) / totwincount;
;                   if (hnc)            ;; add next_curwin size
;                   {
;                       next_curwin_size -= @p_wiw - (m - n);
;                       new_size += next_curwin_size;
;                       room -= new_size - next_curwin_size;
;                   }
;                   else
;                       room -= new_size;
;                   new_size += n;
;               }

                ;; Skip frame that is full width when splitting or closing a window,
                ;; unless equalizing all frames.
;               if (!current || dir != 'v'
;                       || topfr.fr_parent != null || new_size != fr.fr_width || frame_has_win(fr, next_curwin))
;                   win_equal_rec(next_curwin, current, fr, dir, col, row, new_size, height);
;               col += new_size;
;               width -= new_size;
;               totwincount -= wincount;
;           }
;       }
;       else ;; topfr.fr_layout == FR_COL
;       {
;           topfr.fr_width = width;
;           topfr.fr_height = height;

;           if (dir != 'h')                 ;; equalize frame heights
;           {
                ;; Compute maximum number of windows vertically in this frame.
;               int n = frame_minheight(topfr, NOWIN);
                ;; add one for the bottom window if it doesn't have a statusline
;               if (row + height == @cmdline_row && @p_ls == 0)
;                   extra_sep = 1;
;               else
;                   extra_sep = 0;
;               totwincount = (n + extra_sep) / ((int)@p_wmh + 1);
;               has_next_curwin = frame_has_win(topfr, next_curwin);

                ;; Compute height for "next_curwin" window and room available for other windows.
                ;; "m" is the minimal height when counting "p_wh" for "next_curwin".

;               int m = frame_minheight(topfr, next_curwin);
;               room = height - m;
;               if (room < 0)
;               {
                    ;; The room is less then 'winheight', use all space for the current window.
;                   next_curwin_size = (int)@p_wh + room;
;                   room = 0;
;               }
;               else
;               {
;                   next_curwin_size = -1;
;                   for (frame_C fr = topfr.fr_child; fr != null; fr = fr.fr_next)
;                   {
                        ;; If 'winfixheight' set keep the window height if possible.
                        ;; Watch out for this window being the next_curwin.
;                       if (frame_fixed_height(fr))
;                       {
;                           n = frame_minheight(fr, NOWIN);
;                           int new_size = fr.fr_height;
;                           if (frame_has_win(fr, next_curwin))
;                           {
;                               room += @p_wh - @p_wmh;
;                               next_curwin_size = 0;
;                               if (new_size < @p_wh)
;                                   new_size = (int)@p_wh;
;                           }
;                           else
                                ;; These windows don't use up room.
;                               totwincount -= (n + (fr.fr_next == null ? extra_sep : 0)) / (@p_wmh + 1);
;                           room -= new_size - n;
;                           if (room < 0)
;                           {
;                               new_size += room;
;                               room = 0;
;                           }
;                           fr.fr_newheight = new_size;
;                       }
;                   }
;                   if (next_curwin_size == -1)
;                   {
;                       if (!has_next_curwin)
;                           next_curwin_size = 0;
;                       else if (1 < totwincount && @p_wh < (room + (totwincount - 2)) / (totwincount - 1))
;                       {
                            ;; Can make all windows higher than 'winheight', spread the room equally.
;                           next_curwin_size = (room + (int)@p_wh
;                                            + (totwincount - 1) * (int)@p_wmh
;                                            + (totwincount - 1)) / totwincount;
;                           room -= next_curwin_size - @p_wh;
;                       }
;                       else
;                           next_curwin_size = (int)@p_wh;
;                   }
;               }

;               if (has_next_curwin)
;                   --totwincount;          ;; don't count curwin
;           }

;           for (frame_C fr = topfr.fr_child; fr != null; fr = fr.fr_next)
;           {
;               wincount = 1;
;               int new_size;
;               if (fr.fr_next == null)
                    ;; last frame gets all that remains (avoid roundoff error)
;                   new_size = height;
;               else if (dir == 'h')
;                   new_size = fr.fr_height;
;               else if (frame_fixed_height(fr))
;               {
;                   new_size = fr.fr_newheight;
;                   wincount = 0;       ;; doesn't count as a sizeable window
;               }
;               else
;               {
                    ;; Compute the maximum number of windows vert. in "fr".
;                   int n = frame_minheight(fr, NOWIN);
;                   wincount = (n + (fr.fr_next == null ? extra_sep : 0)) / ((int)@p_wmh + 1);
;                   int m = frame_minheight(fr, next_curwin);
;                   boolean hnc;
;                   if (has_next_curwin)
;                       hnc = frame_has_win(fr, next_curwin);
;                   else
;                       hnc = false;
;                   if (hnc)            ;; don't count next_curwin
;                       --wincount;
;                   if (totwincount == 0)
;                       new_size = room;
;                   else
;                       new_size = (wincount * room + (totwincount >>> 1)) / totwincount;
;                   if (hnc)            ;; add next_curwin size
;                   {
;                       next_curwin_size -= @p_wh - (m - n);
;                       new_size += next_curwin_size;
;                       room -= new_size - next_curwin_size;
;                   }
;                   else
;                       room -= new_size;
;                   new_size += n;
;               }
                ;; Skip frame that is full width when splitting or closing a window,
                ;; unless equalizing all frames.
;               if (!current || dir != 'h' || topfr.fr_parent != null
;                       || (new_size != fr.fr_height)
;                       || frame_has_win(fr, next_curwin))
;                   win_equal_rec(next_curwin, current, fr, dir, col, row, width, new_size);
;               row += new_size;
;               height -= new_size;
;               totwincount -= wincount;
;           }
;       }
    ))

;; close all windows for buffer 'buf'

(defn- #_void close_windows [#_buffer_C buf, #_boolean keep_curwin]
    ;; keep_curwin: don't close "curwin"
    (§
;       int h = tabline_height();

;       @redrawingDisabled++;

;       for (window_C wp = @firstwin; wp != null && @lastwin != @firstwin; )
;       {
;           if (wp.w_buffer == buf && (!keep_curwin || wp != @curwin) && !(wp.w_closing || wp.w_buffer.b_closing))
;           {
;               win_close(wp, false);

                ;; Start all over, autocommands may change the window layout.
;               wp = @firstwin;
;           }
;           else
;               wp = wp.w_next;
;       }

        ;; Also check windows in other tab pages.
;       for (tabpage_C tp = @first_tabpage, nexttp; tp != null; tp = nexttp)
;       {
;           nexttp = null;
;           if (tp != @curtab)
;               for (window_C wp = tp.tp_firstwin; wp != null; wp = wp.w_next)
;                   if (wp.w_buffer == buf && !(wp.w_closing || wp.w_buffer.b_closing))
;                   {
;                       win_close_othertab(wp, false, tp);

                        ;; Start all over, the tab page may be closed and
                        ;; autocommands may change the window layout.
;                       nexttp = @first_tabpage;
;                       break;
;                   }
;       }

;       --@redrawingDisabled;

;       @redraw_tabline = true;
;       if (h != tabline_height())
;           shell_new_rows();
    ))

;; Return true if the current window is the only window that exists (ignoring "aucmd_win").
;; Returns false if there is a window, possibly in another tab page.

(defn- #_boolean last_window []
    (§
;       return (one_window() && null == null);
    ))

;; Return true if there is only one window other than "aucmd_win" in the current tab page.

(defn- #_boolean one_window []
    (§
;       boolean seen_one = false;

;       for (window_C wp = @firstwin; wp != null; wp = wp.w_next)
;       {
;           if (wp != @aucmd_win)
;           {
;               if (seen_one)
;                   return false;
;               seen_one = true;
;           }
;       }

;       return true;
    ))

;; Close the possibly last window in a tab page.
;; Returns true when the window was closed already.

(defn- #_boolean close_last_window_tabpage [#_window_C win, #_boolean free_buf, #_tabpage_C prev_curtab]
    (§
;       if (@firstwin == @lastwin)
;       {
;           buffer_C old_curbuf = @curbuf;

            ;; Closing the last window in a tab page.  First go to another tab page and then
            ;; close the window and the tab page.  This avoids that curwin and curtab are
            ;; invalid while we are freeing memory, they may be used in GUI events.
            ;; Don't trigger autocommands yet, they may use wrong values, so do that below.

;           goto_tabpage_tp(alt_tabpage(), false, true);
;           @redraw_tabline = true;

            ;; Safety check:
            ;; autocommands may have closed the window when jumping to the other tab page.
;           if (valid_tabpage(prev_curtab) && prev_curtab.tp_firstwin == win)
;           {
;               int h = tabline_height();

;               win_close_othertab(win, free_buf, prev_curtab);
;               if (h != tabline_height())
;                   shell_new_rows();
;           }

;           return true;
;       }
;       return false;
    ))

;; Close window "win".  Only works for the current tab page.
;; If "free_buf" is true related buffer may be unloaded.
;;
;; Called by :quit, :close, :xit and :wq.
;; Returns false when the window was not closed.

(defn- #_boolean win_close [#_window_C win, #_boolean free_buf]
    (§
;       boolean other_buffer = false;
;       boolean close_curwin = false;

;       tabpage_C prev_curtab = @curtab;

;       if (last_window())
;       {
;           emsg(u8("E444: Cannot close last window"));
;           return false;
;       }

;       if (win.w_closing || (win.w_buffer != null && win.w_buffer.b_closing))
;           return false; ;; window is already being closed
;       if (win == @aucmd_win)
;       {
;           emsg(u8("E813: Cannot close autocmd window"));
;           return false;
;       }
;       if ((@firstwin == @aucmd_win || @lastwin == @aucmd_win) && one_window())
;       {
;           emsg(u8("E814: Cannot close window, only autocmd window would remain"));
;           return false;
;       }

        ;; When closing the last window in a tab page first go to another tab page
        ;; and then close the window and the tab page to avoid that curwin and
        ;; curtab are invalid while we are freeing memory.
;       if (close_last_window_tabpage(win, free_buf, prev_curtab))
;           return false;

;       if (win == @curwin)
;       {
            ;; Guess which window is going to be the new current window.
            ;; This may change because of the autocommands (sigh).

;           window_C wp = frame2win(win_altframe(win, null));

            ;; Be careful: If autocommands delete the window or cause this window
            ;; to be the last one left, return now.

;           if (wp.w_buffer != @curbuf)
;           {
;               other_buffer = true;
;               win.w_closing = true;
;               if (!win_valid(win))
;                   return false;
;               win.w_closing = false;
;               if (last_window())
;                   return false;
;           }
;           win.w_closing = true;
;           if (!win_valid(win))
;               return false;
;           win.w_closing = false;
;           if (last_window())
;               return false;
            ;; autocmds may abort script processing
;           if (aborting())
;               return false;
;       }

        ;; Close the link to the buffer.

;       if (win.w_buffer != null)
;       {
;           win.w_closing = true;
;           close_buffer(win, win.w_buffer, free_buf ? DOBUF_UNLOAD : 0, true);
;           if (win_valid(win))
;               win.w_closing = false;
;       }

;       if (only_one_window() && win_valid(win) && win.w_buffer == null
;               && (last_window() || @curtab != prev_curtab || close_last_window_tabpage(win, free_buf, prev_curtab)))
;       {
            ;; Autocommands have close all windows, quit now.
            ;; Restore curwin.w_buffer, otherwise writing viminfo may fail.
;           if (@curwin.w_buffer == null)
;               @curwin.w_buffer = @curbuf;
;           getout(0);
;       }

        ;; Autocommands may have closed the window already,
        ;; or closed the only other window or moved to another tab page.
;       else if (!win_valid(win) || last_window() || @curtab != prev_curtab || close_last_window_tabpage(win, free_buf, prev_curtab))
;           return false;

        ;; Free the memory used for the window and get the window that received the screen space.
;       int[] dir = new int[1];
;       window_C wp = win_free_mem(win, dir, null);

        ;; Make sure curwin isn't invalid.
        ;; It can cause severe trouble when printing an error message.
        ;; For win_equal() curbuf needs to be valid too.
;       if (win == @curwin)
;       {
;           @curwin = wp;
;           @curbuf = @curwin.w_buffer;
;           close_curwin = true;
;       }
;       if (@p_ea && (@p_ead.at(0) == (byte)'b' || @p_ead.at(0) == dir[0]))
;           win_equal(@curwin, true, dir[0]);
;       else
;           win_comp_pos();
;       if (close_curwin)
;       {
;           win_enter_ext(wp, false, true, true, true);
;       }

        ;; If last window has a status line now and we don't want one,
        ;; remove the status line.

;       last_status(false);

;       redraw_all_later(NOT_VALID);
;       return true;
    ))

;; Close window "win" in tab page "tp", which is not the current tab page.
;; This may be the last window in that tab page and result in closing the tab,
;; thus "tp" may become invalid!
;; Caller must check if buffer is hidden and whether the tabline needs to be updated.

(defn- #_void win_close_othertab [#_window_C win, #_boolean free_buf, #_tabpage_C tp]
    (§
;       if (win.w_closing || win.w_buffer.b_closing)
;           return; ;; window is already being closed

        ;; Close the link to the buffer.
;       close_buffer(win, win.w_buffer, free_buf ? DOBUF_UNLOAD : 0, false);

        ;; Careful: Autocommands may have closed the tab page or made it the current tab page.
;       tabpage_C ptp;
;       for (ptp = @first_tabpage; ptp != null && ptp != tp; ptp = null)
        ;
;       if (ptp == null || tp == @curtab)
;           return;

        ;; Autocommands may have closed the window already.
;       window_C wp;
;       for (wp = tp.tp_firstwin; wp != null && wp != win; wp = wp.w_next)
        ;
;       if (wp == null)
;           return;

        ;; When closing the last window in a tab page remove the tab page.
;       if (tp == null ? @firstwin == @lastwin : tp.tp_firstwin == tp.tp_lastwin)
;       {
;           if (tp == @first_tabpage)
;               @first_tabpage = null;
;           else
;           {
;               for (ptp = @first_tabpage; ptp != null && null != tp; ptp = null)
                ;
;               if (ptp == null)
;               {
;                   emsg2(e_intern2, u8("win_close_othertab()"));
;                   return;
;               }
;           }
;       }

        ;; Free the memory used for the window.
;       int[] dir = new int[1];
;       win_free_mem(win, dir, tp);
    ))

;; Free the memory used for a window.
;; Returns a pointer to the window that got the freed up space.

(defn- #_window_C win_free_mem [#_window_C win, #_int* dirp, #_tabpage_C tp]
    ;; dirp: set to 'v' or 'h' for direction if 'ea'
    ;; tp: tab page "win" is in, null for current
    (§
        ;; Remove the window and its frame from the tree of frames.
;       frame_C frp = win.w_frame;
;       window_C wp = winframe_remove(win, dirp, tp);
;       win_free(win, tp);

        ;; When deleting the current window of another tab page select a new current window.
;       if (tp != null && win == tp.tp_curwin)
;           tp.tp_curwin = wp;

;       return wp;
    ))

;; Remove a window and its frame from the tree of frames.
;; Returns a pointer to the window that got the freed up space.

(defn- #_window_C winframe_remove [#_window_C win, #_int* dirp, #_tabpage_C tp]
    ;; dirp: set to 'v' or 'h' for direction if 'ea'
    ;; tp: tab page "win" is in, null for current
    (§
;       frame_C frp_close = win.w_frame;

        ;; If there is only one window there is nothing to remove.

;       if (tp == null ? @firstwin == @lastwin : tp.tp_firstwin == tp.tp_lastwin)
;           return null;

        ;; Remove the window from its frame.

;       frame_C frp2 = win_altframe(win, tp);
;       window_C wp = frame2win(frp2);

        ;; Remove this frame from the list of frames.
;       frame_remove(frp_close);

;       if (frp_close.fr_parent.fr_layout == FR_COL)
;       {
            ;; When 'winfixheight' is set, try to find another frame in the column
            ;; (as close to the closed frame as possible) to distribute the height to.
;           if (frp2.fr_win != null && frp2.fr_win.w_onebuf_opt.@wo_wfh)
;           {
;               frame_C frp = frp_close.fr_prev;
;               frame_C frp3 = frp_close.fr_next;
;               while (frp != null || frp3 != null)
;               {
;                   if (frp != null)
;                   {
;                       if (frp.fr_win != null && !frp.fr_win.w_onebuf_opt.@wo_wfh)
;                       {
;                           frp2 = frp;
;                           wp = frp.fr_win;
;                           break;
;                       }
;                       frp = frp.fr_prev;
;                   }
;                   if (frp3 != null)
;                   {
;                       if (frp3.fr_win != null && !frp3.fr_win.w_onebuf_opt.@wo_wfh)
;                       {
;                           frp2 = frp3;
;                           wp = frp3.fr_win;
;                           break;
;                       }
;                       frp3 = frp3.fr_next;
;                   }
;               }
;           }
;           frame_new_height(frp2, frp2.fr_height + frp_close.fr_height,
;                               (frp2 == frp_close.fr_next) ? true : false, false);
;           dirp[0] = 'v';
;       }
;       else
;       {
            ;; When 'winfixwidth' is set, try to find another frame in the column
            ;; (as close to the closed frame as possible) to distribute the width to.
;           if (frp2.fr_win != null && frp2.fr_win.w_onebuf_opt.@wo_wfw)
;           {
;               frame_C frp = frp_close.fr_prev;
;               frame_C frp3 = frp_close.fr_next;
;               while (frp != null || frp3 != null)
;               {
;                   if (frp != null)
;                   {
;                       if (frp.fr_win != null && !frp.fr_win.w_onebuf_opt.@wo_wfw)
;                       {
;                           frp2 = frp;
;                           wp = frp.fr_win;
;                           break;
;                       }
;                       frp = frp.fr_prev;
;                   }
;                   if (frp3 != null)
;                   {
;                       if (frp3.fr_win != null && !frp3.fr_win.w_onebuf_opt.@wo_wfw)
;                       {
;                           frp2 = frp3;
;                           wp = frp3.fr_win;
;                           break;
;                       }
;                       frp3 = frp3.fr_next;
;                   }
;               }
;           }
;           frame_new_width(frp2, frp2.fr_width + frp_close.fr_width, (frp2 == frp_close.fr_next), false);
;           dirp[0] = 'h';
;       }

        ;; If rows/columns go to a window below/right its positions need to be updated.
        ;; Can only be done after the sizes have been updated.
;       if (frp2 == frp_close.fr_next)
;       {
;           int[] row = { win.w_winrow };
;           int[] col = { win.w_wincol };

;           frame_comp_pos(frp2, row, col);
;       }

;       if (frp2.fr_next == null && frp2.fr_prev == null)
;       {
            ;; There is no other frame in this list, move its info to the parent and remove it.
;           frp2.fr_parent.fr_layout = frp2.fr_layout;
;           frp2.fr_parent.fr_child = frp2.fr_child;
;           for (frame_C frp = frp2.fr_child; frp != null; frp = frp.fr_next)
;               frp.fr_parent = frp2.fr_parent;
;           frp2.fr_parent.fr_win = frp2.fr_win;
;           if (frp2.fr_win != null)
;               frp2.fr_win.w_frame = frp2.fr_parent;
;           frame_C frp = frp2.fr_parent;

;           frp2 = frp.fr_parent;
;           if (frp2 != null && frp2.fr_layout == frp.fr_layout)
;           {
                ;; The frame above the parent has the same layout,
                ;; have to merge the frames into this list.
;               if (frp2.fr_child == frp)
;                   frp2.fr_child = frp.fr_child;
;               frp.fr_child.fr_prev = frp.fr_prev;
;               if (frp.fr_prev != null)
;                   frp.fr_prev.fr_next = frp.fr_child;
;               for (frame_C frp3 = frp.fr_child; ; frp3 = frp3.fr_next)
;               {
;                   frp3.fr_parent = frp2;
;                   if (frp3.fr_next == null)
;                   {
;                       frp3.fr_next = frp.fr_next;
;                       if (frp.fr_next != null)
;                           frp.fr_next.fr_prev = frp3;
;                       break;
;                   }
;               }
;           }
;       }

;       return wp;
    ))

;; Find out which frame is going to get the freed up space when "win" is closed.
;; if 'splitbelow'/'splitleft' the space goes to the window above/left.
;; if 'nosplitbelow'/'nosplitleft' the space goes to the window below/right.
;; This makes opening a window and closing it immediately keep the same window layout.

(defn- #_frame_C win_altframe [#_window_C win, #_tabpage_C tp]
    ;; tp: tab page "win" is in, null for current
    (§
;       if (tp == null ? @firstwin == @lastwin : tp.tp_firstwin == tp.tp_lastwin)
            ;; Last window in this tab page, will go to next tab page.
;           return alt_tabpage().tp_curwin.w_frame;

;       frame_C frp = win.w_frame;
;       boolean b;
;       if (frp.fr_parent != null && frp.fr_parent.fr_layout == FR_ROW)
;           b = @p_spr;
;       else
;           b = @p_sb;
;       if ((!b && frp.fr_next != null) || frp.fr_prev == null)
;           return frp.fr_next;

;       return frp.fr_prev;
    ))

;; Return the tabpage that will be used if the current one is closed.

(defn- #_tabpage_C alt_tabpage []
    (§
        ;; Use the next tab page if possible.
;       if (null != null)
;           return null;

;       tabpage_C tp;
        ;; Find the last but one tab page.
;       for (tp = @first_tabpage; null != @curtab; tp = null)
        ;
;       return tp;
    ))

;; Find the left-upper window in frame "frp".

(defn- #_window_C frame2win [#_frame_C frp]
    (§
;       while (frp.fr_win == null)
;           frp = frp.fr_child;
;       return frp.fr_win;
    ))

;; Return true if frame "frp" contains window "wp".

(defn- #_boolean frame_has_win [#_frame_C frp, #_window_C wp]
    (§
;       if (frp.fr_layout == FR_LEAF)
;           return (frp.fr_win == wp);

;       for (frame_C p = frp.fr_child; p != null; p = p.fr_next)
;           if (frame_has_win(p, wp))
;               return true;

;       return false;
    ))

;; Set a new height for a frame.  Recursively sets the height for contained
;; frames and windows.  Caller must take care of positions.

(defn- #_void frame_new_height [#_frame_C topfrp, #_int height, #_boolean topfirst, #_boolean wfh]
    ;; topfirst: resize topmost contained frame first
    ;; wfh: obey 'winfixheight' when there is a choice; may cause the height not to be set
    (§
;       if (topfrp.fr_win != null)
;       {
            ;; Simple case: just one window.
;           win_new_height(topfrp.fr_win, height - topfrp.fr_win.w_status_height);
;       }
;       else if (topfrp.fr_layout == FR_ROW)
;       {
;           frame_C frp;
;           do
;           {
                ;; All frames in this row get the same new height.
;               for (frp = topfrp.fr_child; frp != null; frp = frp.fr_next)
;               {
;                   frame_new_height(frp, height, topfirst, wfh);
;                   if (height < frp.fr_height)
;                   {
                        ;; Could not fit the windows, make the whole row higher.
;                       height = frp.fr_height;
;                       break;
;                   }
;               }
;           } while (frp != null);
;       }
;       else    ;; fr_layout == FR_COL
;       {
            ;; Complicated case: resize a column of frames.
            ;; Resize the bottom frame first, frames above that when needed.

;           frame_C frp = topfrp.fr_child;
;           if (wfh)
                ;; Advance past frames with one window with 'wfh' set.
;               while (frame_fixed_height(frp))
;               {
;                   frp = frp.fr_next;
;                   if (frp == null)
;                       return;         ;; no frame without 'wfh', give up
;               }
;           if (!topfirst)
;           {
                ;; Find the bottom frame of this column.
;               while (frp.fr_next != null)
;                   frp = frp.fr_next;
;               if (wfh)
                    ;; Advance back for frames with one window with 'wfh' set.
;                   while (frame_fixed_height(frp))
;                       frp = frp.fr_prev;
;           }

;           int extra_lines = height - topfrp.fr_height;
;           if (extra_lines < 0)
;           {
                ;; reduce height of contained frames, bottom or top frame first
;               while (frp != null)
;               {
;                   int h = frame_minheight(frp, null);
;                   if (frp.fr_height + extra_lines < h)
;                   {
;                       extra_lines += frp.fr_height - h;
;                       frame_new_height(frp, h, topfirst, wfh);
;                   }
;                   else
;                   {
;                       frame_new_height(frp, frp.fr_height + extra_lines, topfirst, wfh);
;                       break;
;                   }
;                   if (topfirst)
;                   {
;                       do
;                       {
;                           frp = frp.fr_next;
;                       } while (wfh && frp != null && frame_fixed_height(frp));
;                   }
;                   else
;                   {
;                       do
;                       {
;                           frp = frp.fr_prev;
;                       } while (wfh && frp != null && frame_fixed_height(frp));
;                   }
                    ;; Increase "height" if we could not reduce enough frames.
;                   if (frp == null)
;                       height -= extra_lines;
;               }
;           }
;           else if (0 < extra_lines)
;           {
                ;; increase height of bottom or top frame
;               frame_new_height(frp, frp.fr_height + extra_lines, topfirst, wfh);
;           }
;       }
;       topfrp.fr_height = height;
    ))

;; Return true if height of frame "frp" should not be changed because of
;; the 'winfixheight' option.

(defn- #_boolean frame_fixed_height [#_frame_C frp]
    (§
        ;; frame with one window: fixed height if 'winfixheight' set.
;       if (frp.fr_win != null)
;           return frp.fr_win.w_onebuf_opt.@wo_wfh;

;       if (frp.fr_layout == FR_ROW)
;       {
            ;; The frame is fixed height if one of the frames in the row is fixed height.
;           for (frp = frp.fr_child; frp != null; frp = frp.fr_next)
;               if (frame_fixed_height(frp))
;                   return true;

;           return false;
;       }

        ;; frp.fr_layout == FR_COL: the frame is fixed height
        ;; if all of the frames in the row are fixed height.
;       for (frp = frp.fr_child; frp != null; frp = frp.fr_next)
;           if (!frame_fixed_height(frp))
;               return false;

;       return true;
    ))

;; Return true if width of frame "frp" should not be changed
;; because of the 'winfixwidth' option.

(defn- #_boolean frame_fixed_width [#_frame_C frp]
    (§
        ;; frame with one window: fixed width if 'winfixwidth' set.
;       if (frp.fr_win != null)
;           return frp.fr_win.w_onebuf_opt.@wo_wfw;

;       if (frp.fr_layout == FR_COL)
;       {
            ;; The frame is fixed width if one of the frames in the row is fixed width.
;           for (frp = frp.fr_child; frp != null; frp = frp.fr_next)
;               if (frame_fixed_width(frp))
;                   return true;

;           return false;
;       }

        ;; frp.fr_layout == FR_ROW: the frame is fixed width
        ;; if all of the frames in the row are fixed width.
;       for (frp = frp.fr_child; frp != null; frp = frp.fr_next)
;           if (!frame_fixed_width(frp))
;               return false;

;       return true;
    ))

;; Add a status line to windows at the bottom of "frp".
;; Note: Does not check if there is room!

(defn- #_void frame_add_statusline [#_frame_C frp]
    (§
;       if (frp.fr_layout == FR_LEAF)
;       {
;           window_C wp = frp.fr_win;
;           if (wp.w_status_height == 0)
;           {
;               if (0 < wp.w_height)    ;; don't make it negative
;                   --wp.w_height;
;               wp.w_status_height = STATUS_HEIGHT;
;           }
;       }
;       else if (frp.fr_layout == FR_ROW)
;       {
            ;; Handle all the frames in the row.
;           for (frp = frp.fr_child; frp != null; frp = frp.fr_next)
;               frame_add_statusline(frp);
;       }
;       else ;; frp.fr_layout == FR_COL
;       {
            ;; Only need to handle the last frame in the column.
;           for (frp = frp.fr_child; frp.fr_next != null; frp = frp.fr_next)
            ;
;           frame_add_statusline(frp);
;       }
    ))

;; Set width of a frame.  Handles recursively going through contained frames.
;; May remove separator line for windows at the right side (for win_close()).

(defn- #_void frame_new_width [#_frame_C topfrp, #_int width, #_boolean leftfirst, #_boolean wfw]
    ;; leftfirst: resize leftmost contained frame first
    ;; wfw: obey 'winfixwidth' when there is a choice; may cause the width not to be set
    (§
;       if (topfrp.fr_layout == FR_LEAF)
;       {
            ;; Simple case: just one window.
;           window_C wp = topfrp.fr_win;
            ;; Find out if there are any windows right of this one.
;           frame_C frp;
;           for (frp = topfrp; frp.fr_parent != null; frp = frp.fr_parent)
;               if (frp.fr_parent.fr_layout == FR_ROW && frp.fr_next != null)
;                   break;
;           if (frp.fr_parent == null)
;               wp.w_vsep_width = 0;
;           win_new_width(wp, width - wp.w_vsep_width);
;       }
;       else if (topfrp.fr_layout == FR_COL)
;       {
;           frame_C frp;
;           do
;           {
                ;; All frames in this column get the same new width.
;               for (frp = topfrp.fr_child; frp != null; frp = frp.fr_next)
;               {
;                   frame_new_width(frp, width, leftfirst, wfw);
;                   if (width < frp.fr_width)
;                   {
                        ;; Could not fit the windows, make whole column wider.
;                       width = frp.fr_width;
;                       break;
;                   }
;               }
;           } while (frp != null);
;       }
;       else    ;; fr_layout == FR_ROW
;       {
            ;; Complicated case: resize a row of frames.
            ;; Resize the rightmost frame first, frames left of it when needed.

;           frame_C frp = topfrp.fr_child;
;           if (wfw)
                ;; Advance past frames with one window with 'wfw' set.
;               while (frame_fixed_width(frp))
;               {
;                   frp = frp.fr_next;
;                   if (frp == null)
;                       return;         ;; no frame without 'wfw', give up
;               }
;           if (!leftfirst)
;           {
                ;; Find the rightmost frame of this row.
;               while (frp.fr_next != null)
;                   frp = frp.fr_next;
;               if (wfw)
                    ;; Advance back for frames with one window with 'wfw' set.
;                   while (frame_fixed_width(frp))
;                       frp = frp.fr_prev;
;           }

;           int extra_cols = width - topfrp.fr_width;
;           if (extra_cols < 0)
;           {
                ;; reduce frame width, rightmost frame first
;               while (frp != null)
;               {
;                   int w = frame_minwidth(frp, null);
;                   if (frp.fr_width + extra_cols < w)
;                   {
;                       extra_cols += frp.fr_width - w;
;                       frame_new_width(frp, w, leftfirst, wfw);
;                   }
;                   else
;                   {
;                       frame_new_width(frp, frp.fr_width + extra_cols, leftfirst, wfw);
;                       break;
;                   }
;                   if (leftfirst)
;                   {
;                       do
;                       {
;                           frp = frp.fr_next;
;                       } while (wfw && frp != null && frame_fixed_width(frp));
;                   }
;                   else
;                   {
;                       do
;                       {
;                           frp = frp.fr_prev;
;                       } while (wfw && frp != null && frame_fixed_width(frp));
;                   }
                    ;; Increase "width" if we could not reduce enough frames.
;                   if (frp == null)
;                       width -= extra_cols;
;               }
;           }
;           else if (0 < extra_cols)
;           {
                ;; increase width of rightmost frame
;               frame_new_width(frp, frp.fr_width + extra_cols, leftfirst, wfw);
;           }
;       }
;       topfrp.fr_width = width;
    ))

;; Add the vertical separator to windows at the right side of "frp".
;; Note: Does not check if there is room!

(defn- #_void frame_add_vsep [#_frame_C frp]
    (§
;       if (frp.fr_layout == FR_LEAF)
;       {
;           window_C wp = frp.fr_win;
;           if (wp.w_vsep_width == 0)
;           {
;               if (0 < wp.w_width)     ;; don't make it negative
;                   --wp.w_width;
;               wp.w_vsep_width = 1;
;           }
;       }
;       else if (frp.fr_layout == FR_COL)
;       {
            ;; Handle all the frames in the column.
;           for (frp = frp.fr_child; frp != null; frp = frp.fr_next)
;               frame_add_vsep(frp);
;       }
;       else ;; frp.fr_layout == FR_ROW
;       {
            ;; Only need to handle the last frame in the row.
;           frp = frp.fr_child;
;           while (frp.fr_next != null)
;               frp = frp.fr_next;
;           frame_add_vsep(frp);
;       }
    ))

;; Set frame width from the window it contains.

(defn- #_void frame_fix_width [#_window_C wp]
    (§
;       wp.w_frame.fr_width = wp.w_width + wp.w_vsep_width;
    ))

;; Set frame height from the window it contains.

(defn- #_void frame_fix_height [#_window_C wp]
    (§
;       wp.w_frame.fr_height = wp.w_height + wp.w_status_height;
    ))

;; Compute the minimal height for frame "topfrp".
;; Uses the 'winminheight' option.
;; When "next_curwin" isn't null, use "p_wh" for this window.
;; When "next_curwin" is NOWIN, don't use at least one line for the current window.

(defn- #_int frame_minheight [#_frame_C topfrp, #_window_C next_curwin]
    (§
;       int m;

;       if (topfrp.fr_win != null)
;       {
;           if (topfrp.fr_win == next_curwin)
;               m = (int)@p_wh + topfrp.fr_win.w_status_height;
;           else
;           {
                ;; window: minimal height of the window plus status line
;               m = (int)@p_wmh + topfrp.fr_win.w_status_height;
                ;; Current window is minimal one line high.
;               if (@p_wmh == 0 && topfrp.fr_win == @curwin && next_curwin == null)
;                   m++;
;           }
;       }
;       else if (topfrp.fr_layout == FR_ROW)
;       {
            ;; get the minimal height from each frame in this row
;           m = 0;
;           for (frame_C frp = topfrp.fr_child; frp != null; frp = frp.fr_next)
;           {
;               int n = frame_minheight(frp, next_curwin);
;               if (m < n)
;                   m = n;
;           }
;       }
;       else
;       {
            ;; Add up the minimal heights for all frames in this column.
;           m = 0;
;           for (frame_C frp = topfrp.fr_child; frp != null; frp = frp.fr_next)
;               m += frame_minheight(frp, next_curwin);
;       }

;       return m;
    ))

;; Compute the minimal width for frame "topfrp".
;; When "next_curwin" isn't null, use "p_wiw" for this window.
;; When "next_curwin" is NOWIN, don't use at least one column for the current window.

(defn- #_int frame_minwidth [#_frame_C topfrp, #_window_C next_curwin]
    ;; next_curwin: use "p_wh" and "p_wiw" for next_curwin
    (§
;       int m;

;       if (topfrp.fr_win != null)
;       {
;           if (topfrp.fr_win == next_curwin)
;               m = (int)@p_wiw + topfrp.fr_win.w_vsep_width;
;           else
;           {
                ;; window: minimal width of the window plus separator column
;               m = (int)@p_wmw + topfrp.fr_win.w_vsep_width;
                ;; Current window is minimal one column wide.
;               if (@p_wmw == 0 && topfrp.fr_win == @curwin && next_curwin == null)
;                   m++;
;           }
;       }
;       else if (topfrp.fr_layout == FR_COL)
;       {
            ;; get the minimal width from each frame in this column
;           m = 0;
;           for (frame_C frp = topfrp.fr_child; frp != null; frp = frp.fr_next)
;           {
;               int n = frame_minwidth(frp, next_curwin);
;               if (m < n)
;                   m = n;
;           }
;       }
;       else
;       {
            ;; Add up the minimal widths for all frames in this row.
;           m = 0;
;           for (frame_C frp = topfrp.fr_child; frp != null; frp = frp.fr_next)
;               m += frame_minwidth(frp, next_curwin);
;       }

;       return m;
    ))

;; Try to close all windows except current one.
;; Buffers in the other windows become hidden if 'hidden' is set, or '!' is
;; used and the buffer was modified.
;;
;; Used by ":bdel" and ":only".

(defn- #_void close_others [#_boolean message, #_boolean forceit]
    ;; forceit: always hide all other windows
    (§
;       if (one_window())
;       {
;           if (message)
;               msg(m_onlyone);
;           return;
;       }

        ;; Be very careful here: autocommands may change the window layout.
;       for (window_C wp = @firstwin, nextwp; win_valid(wp); wp = nextwp)
;       {
;           nextwp = wp.w_next;
;           if (wp != @curwin)               ;; don't close current window
;           {
                ;; Check if it's allowed to abandon this window.
;               boolean r = can_abandon(wp.w_buffer, forceit);
;               if (!win_valid(wp))         ;; autocommands messed wp up
;               {
;                   nextwp = @firstwin;
;                   continue;
;               }
;               if (!r)
;               {
;                   if (bufIsChanged(wp.w_buffer))
;                       continue;
;               }
;               win_close(wp, !@cmdmod.hide && !bufIsChanged(wp.w_buffer));
;           }
;       }

;       if (message && @lastwin != @firstwin)
;           emsg(u8("E445: Other window contains changes"));
    ))

;; Init the current window "curwin".
;; Called when a new file is being edited.

(defn- #_void curwin_init []
    (§
;       win_init_empty(@curwin);
    ))

(defn- #_void win_init_empty [#_window_C wp]
    (§
;       redraw_win_later(wp, NOT_VALID);

;       wp.w_lines_valid = 0;
;       wp.w_cursor.lnum = 1;
;       wp.w_curswant = wp.w_cursor.col = 0;
;       wp.w_cursor.coladd = 0;
;       wp.w_pcmark.lnum = 1;       ;; pcmark not cleared but set to line 1
;       wp.w_pcmark.col = 0;
;       wp.w_prev_pcmark.lnum = 0;
;       wp.w_prev_pcmark.col = 0;
;       wp.w_topline = 1;
;       wp.w_botline = 2;
    ))

;; Allocate the first window and put an empty buffer in it.
;; Called from main().

(defn- #_void win_alloc_first []
    (§
;       win_alloc_firstwin(null);

;       @first_tabpage = newTabpage();
;       @first_tabpage.tp_topframe = @topframe;
;       @curtab = @first_tabpage;
    ))

;; Allocate the first window.
;; When "oldwin" is null create an empty buffer for it.
;; When "oldwin" is not null copy info from it to the new window.

(defn- #_void win_alloc_firstwin [#_window_C oldwin]
    (§
;       @curwin = newWindow(null, false);

;       if (oldwin == null)
;       {
;           @curbuf = newBuffer(1L);

;           @curwin.w_buffer = @curbuf;
;           @curbuf.b_nwindows = 1;          ;; there is one window
;           curwin_init();                  ;; init current window
;       }
;       else
;       {
            ;; First window in new tab page, initialize it from "oldwin".
;           win_init(@curwin, oldwin, 0);

            ;; We don't want cursor- and scroll-binding in the first window.
;           @curwin.w_onebuf_opt.@wo_scb = false;
;           @curwin.w_onebuf_opt.@wo_crb = false;
;       }

;       @curwin.w_frame = newFrame(@curwin);

;       @topframe = @curwin.w_frame;
;       @topframe.fr_width = (int)@Columns;
;       @topframe.fr_height = (int)(@Rows - @p_ch);
;       @topframe.fr_win = @curwin;
    ))

;; Create a frame for window "wp".

(defn- #_frame_C newFrame [#_window_C wp]
    (§
;       frame_C frp = §_frame_C();

;       frp.fr_layout = FR_LEAF;
;       frp.fr_win = wp;

;       return frp;
    ))

;; Initialize the window and frame size to the maximum.

(defn- #_void win_init_size []
    (§
;       long rows_avail = @Rows - @p_ch - tabline_height();

;       @firstwin.w_height = (int)rows_avail;
;       @topframe.fr_height = (int)rows_avail;
;       @firstwin.w_width = (int)@Columns;
;       @topframe.fr_width = (int)@Columns;
    ))

;; Allocate a new tabpage_C and init the values.

(defn- #_tabpage_C newTabpage []
    (§
;       tabpage_C tp = §_tabpage_C();

;       tp.tp_ch_used = @p_ch;

;       return tp;
    ))

;; Return true when "tpc" points to a valid tab page.

(defn- #_boolean valid_tabpage [#_tabpage_C tpc]
    (§
;       tabpage_C tp;

;       for (tp = @first_tabpage; tp != null; tp = null)
;           if (tp == tpc)
;               return true;

;       return false;
    ))

;; Prepare for leaving the current tab page.
;; When autocommands change "curtab" we don't leave the tab page and return false.
;; Careful: When true is returned need to get a new tab page very very soon!

(defn- #_boolean leave_tabpage [#_buffer_C new_curbuf, #_boolean trigger_leave_autocmds]
    ;; new_curbuf: what is going to be the new curbuf, null if unknown
    (§
;       tabpage_C tp = @curtab;

;       reset_VIsual_and_resel();   ;; stop Visual mode

;       if (trigger_leave_autocmds)
;       {
;           if (@curtab != tp)
;               return false;
;       }

;       tp.tp_curwin = @curwin;
;       tp.tp_prevwin = @prevwin;
;       tp.tp_firstwin = @firstwin;
;       tp.tp_lastwin = @lastwin;
;       tp.tp_old_Rows = @Rows;
;       tp.tp_old_Columns = @Columns;

;       @firstwin = null;
;       @lastwin = null;

;       return true;
    ))

;; Start using tab page "tp".
;; Only to be used after leave_tabpage() or freeing the current tab page.
;; Only trigger *Enter autocommands when trigger_enter_autocmds is true.
;; Only trigger *Leave autocommands when trigger_leave_autocmds is true.

(defn- #_void enter_tabpage [#_tabpage_C tp, #_buffer_C old_curbuf, #_boolean trigger_enter_autocmds, #_boolean trigger_leave_autocmds]
    (§
;       int old_off = tp.tp_firstwin.w_winrow;
;       window_C next_prevwin = tp.tp_prevwin;

;       @curtab = tp;
;       @firstwin = tp.tp_firstwin;
;       @lastwin = tp.tp_lastwin;
;       @topframe = tp.tp_topframe;

        ;; We would like doing the TabEnter event first, but we don't have a
        ;; valid current window yet, which may break some commands.
        ;; This triggers autocommands, thus may make "tp" invalid.
;       win_enter_ext(tp.tp_curwin, false, true, trigger_enter_autocmds, trigger_leave_autocmds);
;       @prevwin = next_prevwin;

;       last_status(false);         ;; status line may appear or disappear
;       win_comp_pos();             ;; recompute w_winrow for all windows
;       @must_redraw = CLEAR;        ;; need to redraw everything

        ;; The tabpage line may have appeared or disappeared, may need to resize
        ;; the frames for that.  When the Vim window was resized need to update
        ;; frame sizes too.  Use the stored value of "p_ch", so that it can be
        ;; different for each tab page.
;       @p_ch = @curtab.tp_ch_used;
;       if (@curtab.tp_old_Rows != @Rows || (old_off != @firstwin.w_winrow))
;           shell_new_rows();
;       if (@curtab.tp_old_Columns != @Columns && @starting == 0)
;           shell_new_columns();    ;; update window widths

;       redraw_all_later(CLEAR);
    ))

;; Go to tabpage "tp".
;; Only trigger *Enter autocommands when trigger_enter_autocmds is true.
;; Only trigger *Leave autocommands when trigger_leave_autocmds is true.
;; Note: doesn't update the GUI tab.

(defn- #_void goto_tabpage_tp [#_tabpage_C tp, #_boolean trigger_enter_autocmds, #_boolean trigger_leave_autocmds]
    (§
        ;; Don't repeat a message in another tab page.
;       set_keep_msg(null, 0);

;       if (tp != @curtab && leave_tabpage(tp.tp_curwin.w_buffer, trigger_leave_autocmds) == true)
;       {
;           if (valid_tabpage(tp))
;               enter_tabpage(tp, @curbuf, trigger_enter_autocmds, trigger_leave_autocmds);
;           else
;               enter_tabpage(@curtab, @curbuf, trigger_enter_autocmds, trigger_leave_autocmds);
;       }
    ))

;; Enter window "wp" in tab page "tp".
;; Also updates the GUI tab.

(defn- #_void goto_tabpage_win [#_tabpage_C tp, #_window_C wp]
    (§
;       goto_tabpage_tp(tp, true, true);

;       if (@curtab == tp && win_valid(wp))
;           win_enter(wp, true);
    ))

;; Go to another window.
;; When jumping to another buffer, stop Visual mode.  Do this before
;; changing windows so we can yank the selection into the '*' register.
;; When jumping to another window on the same buffer, adjust its cursor
;; position to keep the same Visual area.

(defn- #_void win_goto [#_window_C wp]
    (§
;       window_C owp = @curwin;

;       if (text_locked())
;       {
;           beep_flush();
;           text_locked_msg();
;           return;
;       }
;       if (curbuf_locked())
;           return;

;       if (wp.w_buffer != @curbuf)
;           reset_VIsual_and_resel();
;       else if (@VIsual_active)
;           COPY_pos(wp.w_cursor, @curwin.w_cursor);

;       win_enter(wp, true);

        ;; Conceal cursor line in previous window, unconceal in current window.
;       if (win_valid(owp) && 0 < owp.w_onebuf_opt.@wo_cole && @msg_scrolled == 0)
;           update_single_line(owp, owp.w_cursor.lnum);
;       if (0 < @curwin.w_onebuf_opt.@wo_cole && @msg_scrolled == 0)
;           @need_cursor_line_redraw = true;
    ))

;; Move to window above or below "count" times.

(defn- #_void win_goto_ver [#_boolean up, #_long count]
    ;; up: true to go to win above
    (§
;       frame_C foundfr = @curwin.w_frame;

;       end:
;       while (0 < count--)
;       {
;           frame_C nfr;

            ;; First go upwards in the tree of frames until we find a upwards or downwards neighbor.

;           for (frame_C fr = foundfr; ; fr = fr.fr_parent)
;           {
;               if (fr == @topframe)
;                   break end;
;               if (up)
;                   nfr = fr.fr_prev;
;               else
;                   nfr = fr.fr_next;
;               if (fr.fr_parent.fr_layout == FR_COL && nfr != null)
;                   break;
;           }

            ;; Now go downwards to find the bottom or top frame in it.

;           for ( ; ; )
;           {
;               if (nfr.fr_layout == FR_LEAF)
;               {
;                   foundfr = nfr;
;                   break;
;               }
;               frame_C fr = nfr.fr_child;
;               if (nfr.fr_layout == FR_ROW)
;               {
                    ;; Find the frame at the cursor row.
;                   while (fr.fr_next != null
;                           && frame2win(fr).w_wincol + fr.fr_width <= @curwin.w_wincol + @curwin.w_wcol)
;                       fr = fr.fr_next;
;               }
;               if (nfr.fr_layout == FR_COL && up)
;                   while (fr.fr_next != null)
;                       fr = fr.fr_next;
;               nfr = fr;
;           }
;       }

;       if (foundfr != null)
;           win_goto(foundfr.fr_win);
    ))

;; Move to left or right window.

(defn- #_void win_goto_hor [#_boolean left, #_long count]
    ;; left: true to go to left win
    (§
;       frame_C foundfr = @curwin.w_frame;

;       end:
;       while (0 < count--)
;       {
;           frame_C nfr;

            ;; First go upwards in the tree of frames until we find a left or right neighbor.

;           for (frame_C fr = foundfr; ; fr = fr.fr_parent)
;           {
;               if (fr == @topframe)
;                   break end;
;               if (left)
;                   nfr = fr.fr_prev;
;               else
;                   nfr = fr.fr_next;
;               if (fr.fr_parent.fr_layout == FR_ROW && nfr != null)
;                   break;
;           }

            ;; Now go downwards to find the leftmost or rightmost frame in it.

;           for ( ; ; )
;           {
;               if (nfr.fr_layout == FR_LEAF)
;               {
;                   foundfr = nfr;
;                   break;
;               }
;               frame_C fr = nfr.fr_child;
;               if (nfr.fr_layout == FR_COL)
;               {
                    ;; Find the frame at the cursor row.
;                   while (fr.fr_next != null
;                           && frame2win(fr).w_winrow + fr.fr_height <= @curwin.w_winrow + @curwin.w_wrow)
;                       fr = fr.fr_next;
;               }
;               if (nfr.fr_layout == FR_ROW && left)
;                   while (fr.fr_next != null)
;                       fr = fr.fr_next;
;               nfr = fr;
;           }
;       }

;       if (foundfr != null)
;           win_goto(foundfr.fr_win);
    ))

;; Make window "wp" the current window.

(defn- #_void win_enter [#_window_C wp, #_boolean undo_sync]
    (§
;       win_enter_ext(wp, undo_sync, false, true, true);
    ))

;; Make window wp the current window.
;; Can be called with "curwin_invalid" true, which means that curwin has just
;; been closed and isn't valid.

(defn- #_void win_enter_ext [#_window_C wp, #_boolean undo_sync, #_boolean curwin_invalid, #_boolean trigger_enter_autocmds, #_boolean trigger_leave_autocmds]
    (§
;       boolean other_buffer = false;

;       if (wp == @curwin && !curwin_invalid)        ;; nothing to do
;           return;

;       if (!curwin_invalid && trigger_leave_autocmds)
;       {
            ;; Be careful: If autocommands delete the window, return now.

;           if (wp.w_buffer != @curbuf)
;           {
;               other_buffer = true;
;               if (!win_valid(wp))
;                   return;
;           }
;           if (!win_valid(wp))
;               return;
            ;; autocmds may abort script processing
;           if (aborting())
;               return;
;       }

        ;; sync undo before leaving the current buffer
;       if (undo_sync && @curbuf != wp.w_buffer)
;           u_sync(false);

        ;; Might need to scroll the old window before switching, e.g., when the cursor was moved.
;       update_topline();

        ;; may have to copy the buffer options when 'cpo' contains 'S'
;       if (wp.w_buffer != @curbuf)
;           buf_copy_options(wp.w_buffer, BCO_ENTER);
;       if (!curwin_invalid)
;       {
;           @prevwin = @curwin;       ;; remember for CTRL-W p
;           @curwin.w_redr_status = true;
;       }
;       @curwin = wp;
;       @curbuf = wp.w_buffer;
;       check_cursor();
;       if (!virtual_active())
;           @curwin.w_cursor.coladd = 0;
;       changed_line_abv_curs();    ;; assume cursor position needs updating

;       @curwin.w_redr_status = true;
;       @redraw_tabline = true;
;       if (@restart_edit != 0)
;           redraw_later(VALID);    ;; causes status line redraw

        ;; set window height to desired minimal value
;       if (@curwin.w_height < @p_wh && !@curwin.w_onebuf_opt.@wo_wfh)
;           win_setheight((int)@p_wh);
;       else if (@curwin.w_height == 0)
;           win_setheight(1);

        ;; set window width to desired minimal value
;       if (@curwin.w_width < @p_wiw && !@curwin.w_onebuf_opt.@wo_wfw)
;           win_setwidth((int)@p_wiw);

;       setmouse();                 ;; in case jumped to/from help buffer
    ))

;; Allocate a window structure and link it in the window list when "hidden" is false.

(defn- #_window_C newWindow [#_window_C after, #_boolean hidden]
    (§
        ;; allocate window structure and linesizes arrays
;       window_C new_wp = §_window_C();

;       win_alloc_lines(new_wp);

        ;; link the window in the window list
;       if (!hidden)
;           win_append(after, new_wp);
;       new_wp.w_wincol = 0;
;       new_wp.w_width = (int)@Columns;

        ;; position the display and the cursor at the top of the file
;       new_wp.w_topline = 1;
;       new_wp.w_botline = 2;
;       new_wp.w_cursor.lnum = 1;
;       new_wp.w_scbind_pos = 1;

        ;; We won't calculate w_fraction until resizing the window.
;       new_wp.w_fraction = 0;
;       new_wp.w_prev_fraction_row = -1;

;       new_wp.w_match_head = null;
;       new_wp.w_next_match_id = 4;

;       return new_wp;
    ))

;; Remove window 'wp' from the window list and free the structure.

(defn- #_void win_free [#_window_C wp, #_tabpage_C tp]
    ;; tp: tab page "win" is in, null for current
    (§
;       clear_winopt(wp.w_onebuf_opt);
;       clear_winopt(wp.w_allbuf_opt);

;       if (@prevwin == wp)
;           @prevwin = null;
;       win_free_lines(wp);

        ;; Remove the window from the b_wininfo lists,
        ;; it may happen that the freed memory is re-used for another window.
;       for (buffer_C buf = @firstbuf; buf != null; buf = buf.b_next)
;           for (wininfo_C wip = buf.b_wininfo; wip != null; wip = wip.wi_next)
;               if (wip.wi_win == wp)
;                   wip.wi_win = null;

;       clear_matches(wp);

;       free_jumplist(wp);

;       wp.w_p_cc_cols = null;

;       if (wp != @aucmd_win)
;           win_remove(wp, tp);
    ))

;; Append window "wp" in the window list after window "after".

(defn- #_void win_append [#_window_C after, #_window_C wp]
    (§
;       window_C before;
;       if (after == null)      ;; after null is in front of the first
;           before = @firstwin;
;       else
;           before = after.w_next;

;       wp.w_next = before;
;       wp.w_prev = after;
;       if (after == null)
;           @firstwin = wp;
;       else
;           after.w_next = wp;
;       if (before == null)
;           @lastwin = wp;
;       else
;           before.w_prev = wp;
    ))

;; Remove a window from the window list.

(defn- #_void win_remove [#_window_C wp, #_tabpage_C tp]
    ;; tp: tab page "win" is in, null for current
    (§
;       if (wp.w_prev != null)
;           wp.w_prev.w_next = wp.w_next;
;       else if (tp == null)
;           @firstwin = wp.w_next;
;       else
;           tp.tp_firstwin = wp.w_next;
;       if (wp.w_next != null)
;           wp.w_next.w_prev = wp.w_prev;
;       else if (tp == null)
;           @lastwin = wp.w_prev;
;       else
;           tp.tp_lastwin = wp.w_prev;
    ))

;; Append frame "frp" in a frame list after frame "after".

(defn- #_void frame_append [#_frame_C after, #_frame_C frp]
    (§
;       frp.fr_next = after.fr_next;
;       after.fr_next = frp;
;       if (frp.fr_next != null)
;           frp.fr_next.fr_prev = frp;
;       frp.fr_prev = after;
    ))

;; Insert frame "frp" in a frame list before frame "before".

(defn- #_void frame_insert [#_frame_C before, #_frame_C frp]
    (§
;       frp.fr_next = before;
;       frp.fr_prev = before.fr_prev;
;       before.fr_prev = frp;
;       if (frp.fr_prev != null)
;           frp.fr_prev.fr_next = frp;
;       else
;           frp.fr_parent.fr_child = frp;
    ))

;; Remove a frame from a frame list.

(defn- #_void frame_remove [#_frame_C frp]
    (§
;       if (frp.fr_prev != null)
;           frp.fr_prev.fr_next = frp.fr_next;
;       else
;           frp.fr_parent.fr_child = frp.fr_next;
;       if (frp.fr_next != null)
;           frp.fr_next.fr_prev = frp.fr_prev;
    ))

;; Allocate w_lines[] for window "wp".

(defn- #_void win_alloc_lines [#_window_C wp]
    (§
;       wp.w_lines_valid = 0;
;       wp.w_lines_len = (int)@Rows;
;       wp.w_lines = ARRAY_wline(wp.w_lines_len);
    ))

;; Free w_lines[] for window "wp".

(defn- #_void win_free_lines [#_window_C wp]
    (§
;       wp.w_lines_len = 0;
;       wp.w_lines = null;
    ))

;; Called from win_new_shellsize() after Rows changed.
;; This only does the current tab page, others must be done when made active.

(defn- #_void shell_new_rows []
    (§
;       long rows_avail = @Rows - @p_ch - tabline_height();

;       int h = (int)rows_avail;

;       if (@firstwin == null)           ;; not initialized yet
;           return;
;       if (h < frame_minheight(@topframe, null))
;           h = frame_minheight(@topframe, null);

        ;; First try setting the heights of windows with 'winfixheight'.
        ;; If that doesn't result in the right height, forget about that option.
;       frame_new_height(@topframe, h, false, true);
;       if (!frame_check_height(@topframe, h))
;           frame_new_height(@topframe, h, false, false);

;       win_comp_pos();                 ;; recompute w_winrow and w_wincol
;       compute_cmdrow();
;       @curtab.tp_ch_used = @p_ch;
    ))

;; Called from win_new_shellsize() after Columns changed.

(defn- #_void shell_new_columns []
    (§
;       if (@firstwin == null)           ;; not initialized yet
;           return;

        ;; First try setting the widths of windows with 'winfixwidth'.
        ;; If that doesn't result in the right width, forget about that option.
;       frame_new_width(@topframe, (int)@Columns, false, true);
;       if (!frame_check_width(@topframe, (int)@Columns))
;           frame_new_width(@topframe, (int)@Columns, false, false);

;       win_comp_pos();                 ;; recompute w_winrow and w_wincol
    ))

;; Save the size of all windows in "iap".

(defn- #_void win_size_save [#_iarray_C iap]
    (§
;       ia_grow(iap, win_count() * 2);

;       for (window_C wp = @firstwin; wp != null; wp = wp.w_next)
;       {
;           iap.ia_data[iap.ia_len++] = wp.w_width + wp.w_vsep_width;
;           iap.ia_data[iap.ia_len++] = wp.w_height;
;       }
    ))

;; Restore window sizes, but only if the number of windows is still the same.
;; Does not free the growarray.

(defn- #_void win_size_restore [#_iarray_C iap]
    (§
;       if (win_count() * 2 == iap.ia_len)
;       {
            ;; The order matters, because frames contain other frames, but it's
            ;; difficult to get right.  The easy way out is to do it twice.
;           for (int round = 0; round < 2; round++)
;           {
;               int i = 0;
;               for (window_C wp = @firstwin; wp != null; wp = wp.w_next)
;               {
;                   frame_setwidth(wp.w_frame, iap.ia_data[i++]);
;                   win_setheight_win(iap.ia_data[i++], wp);
;               }
;           }
            ;; recompute the window positions
;           win_comp_pos();
;       }
    ))

;; Update the position for all windows, using the width and height of the frames.
;; Returns the row just after the last window.

(defn- #_int win_comp_pos []
    (§
;       int[] row = { tabline_height() };
;       int[] col = { 0 };

;       frame_comp_pos(@topframe, row, col);
;       return row[0];
    ))

;; Update the position of the windows in frame "topfrp",
;; using the width and height of the frames.
;; "*row" and "*col" are the top-left position of the frame.
;; They are updated to the bottom-right position plus one.

(defn- #_void frame_comp_pos [#_frame_C topfrp, #_int* row, #_int* col]
    (§
;       window_C wp = topfrp.fr_win;
;       if (wp != null)
;       {
;           if (wp.w_winrow != row[0] || wp.w_wincol != col[0])
;           {
                ;; position changed, redraw
;               wp.w_winrow = row[0];
;               wp.w_wincol = col[0];
;               redraw_win_later(wp, NOT_VALID);
;               wp.w_redr_status = true;
;           }
;           row[0] += wp.w_height + wp.w_status_height;
;           col[0] += wp.w_width + wp.w_vsep_width;
;       }
;       else
;       {
;           int startrow = row[0];
;           int startcol = col[0];
;           for (frame_C frp = topfrp.fr_child; frp != null; frp = frp.fr_next)
;           {
;               if (topfrp.fr_layout == FR_ROW)
;                   row[0] = startrow;        ;; all frames are at the same row
;               else
;                   col[0] = startcol;        ;; all frames are at the same col
;               frame_comp_pos(frp, row, col);
;           }
;       }
    ))

;; Set current window height and take care of repositioning other windows to fit around it.

(defn- #_void win_setheight [#_int height]
    (§
;       win_setheight_win(height, @curwin);
    ))

;; Set the window height of window "win" and take care of repositioning other windows to fit around it.

(defn- #_void win_setheight_win [#_int height, #_window_C win]
    (§
;       if (win == @curwin)
;       {
            ;; Always keep current window at least one line high, even when 'winminheight' is zero.
;           if (height < @p_wmh)
;               height = (int)@p_wmh;
;           if (height == 0)
;               height = 1;
;       }

;       frame_setheight(win.w_frame, height + win.w_status_height);

        ;; recompute the window positions
;       int row = win_comp_pos();

        ;; If there is extra space created between the last window and the command line, clear it.

;       if (@full_screen && @msg_scrolled == 0 && row < @cmdline_row)
;           screen_fill(row, @cmdline_row, 0, (int)@Columns, ' ', ' ', 0);
;       @cmdline_row = row;
;       @msg_row = row;
;       @msg_col = 0;

;       redraw_all_later(NOT_VALID);
    ))

;; Set the height of a frame to "height" and take care that all frames and
;; windows inside it are resized.  Also resize frames on the left and right
;; if the are in the same FR_ROW frame.
;;
;; Strategy:
;; If the frame is part of a FR_COL frame, try fitting the frame in that frame.
;; If that doesn't work (the FR_COL frame is too small), recursively go to
;; containing frames to resize them and make room.
;; If the frame is part of a FR_ROW frame, all frames must be resized as well.
;; Check for the minimal height of the FR_ROW frame.
;; At the top level we can also use change the command line height.

(defn- #_void frame_setheight [#_frame_C curfrp, #_int height]
    (§
        ;; If the height already is the desired value, nothing to do.
;       if (curfrp.fr_height == height)
;           return;

;       if (curfrp.fr_parent == null)
;       {
;           long rows_avail = @Rows - @p_ch - tabline_height();

            ;; topframe: can only change the command line
;           if (rows_avail < height)
;               height = (int)rows_avail;
;           if (0 < height)
;               frame_new_height(curfrp, height, false, false);
;       }
;       else if (curfrp.fr_parent.fr_layout == FR_ROW)
;       {
            ;; Row of frames: also need to resize frames left and right of this one.
            ;; First check for the minimal height of these.
;           int h = frame_minheight(curfrp.fr_parent, null);
;           if (height < h)
;               height = h;
;           frame_setheight(curfrp.fr_parent, height);
;       }
;       else
;       {
;           // %% red. 3x
;           int room = 0;                       ;; total number of lines available
;           int room_reserved = 0;
;           int room_cmdline = 0;               ;; lines available from cmdline

            ;; Column of frames: try to change only frames in this column.
            ;; Do this twice:
            ;; 1: compute room available, if it's not enough try resizing the containing frame.
            ;; 2: compute the room available and adjust the height to it.
            ;; Try not to reduce the height of a window with 'winfixheight' set.

;           for (int run = 1; run <= 2; run++)
;           {
;               room = 0;                   ;; total number of lines available
;               room_reserved = 0;

;               for (frame_C frp = curfrp.fr_parent.fr_child; frp != null; frp = frp.fr_next)
;               {
;                   if (frp != curfrp && frp.fr_win != null && frp.fr_win.w_onebuf_opt.@wo_wfh)
;                       room_reserved += frp.fr_height;
;                   room += frp.fr_height;
;                   if (frp != curfrp)
;                       room -= frame_minheight(frp, null);
;               }
;               if (curfrp.fr_width != (int)@Columns)
;                   room_cmdline = 0;
;               else
;               {
;                   room_cmdline = (int)(@Rows - @p_ch) - (@lastwin.w_winrow + @lastwin.w_height + @lastwin.w_status_height);
;                   if (room_cmdline < 0)
;                       room_cmdline = 0;
;               }

;               if (height <= room + room_cmdline)
;                   break;
;               if (run == 2 || curfrp.fr_width == (int)@Columns)
;               {
;                   if (height > room + room_cmdline)
;                       height = room + room_cmdline;
;                   break;
;               }

;               frame_setheight(curfrp.fr_parent, height
;                   + frame_minheight(curfrp.fr_parent, NOWIN) - (int)@p_wmh - 1);
;           }

            ;; Compute the number of lines we will take from others frames (can be negative!).

;           int take = height - curfrp.fr_height;

            ;; If there is not enough room,
            ;; also reduce the height of a window with 'winfixheight' set.

;           if (room + room_cmdline - room_reserved < height)
;               room_reserved = room + room_cmdline - height;

            ;; If there is only a 'winfixheight' window and making the window smaller,
            ;; need to make the other window taller.

;           if (take < 0 && room - curfrp.fr_height < room_reserved)
;               room_reserved = 0;

;           if (0 < take && 0 < room_cmdline)
;           {
                ;; use lines from cmdline first
;               if (take < room_cmdline)
;                   room_cmdline = take;
;               take -= room_cmdline;
;               @topframe.fr_height += room_cmdline;
;           }

            ;; set the current frame to the new height

;           frame_new_height(curfrp, height, false, false);

            ;; First take lines from the frames after the current frame.
            ;; If that is not enough, takes lines from frames above the current frame.

;           for (int run = 0; run < 2; run++)
;           {
;               frame_C frp;
;               if (run == 0)
;                   frp = curfrp.fr_next;   ;; 1st run: start with next window
;               else
;                   frp = curfrp.fr_prev;   ;; 2nd run: start with prev window
;               while (frp != null && take != 0)
;               {
;                   int h = frame_minheight(frp, null);
;                   if (0 < room_reserved && frp.fr_win != null && frp.fr_win.w_onebuf_opt.@wo_wfh)
;                   {
;                       if (room_reserved >= frp.fr_height)
;                           room_reserved -= frp.fr_height;
;                       else
;                       {
;                           if (take < frp.fr_height - room_reserved)
;                               room_reserved = frp.fr_height - take;
;                           take -= frp.fr_height - room_reserved;
;                           frame_new_height(frp, room_reserved, false, false);
;                           room_reserved = 0;
;                       }
;                   }
;                   else
;                   {
;                       if (frp.fr_height - take < h)
;                       {
;                           take -= frp.fr_height - h;
;                           frame_new_height(frp, h, false, false);
;                       }
;                       else
;                       {
;                           frame_new_height(frp, frp.fr_height - take, false, false);
;                           take = 0;
;                       }
;                   }
;                   if (run == 0)
;                       frp = frp.fr_next;
;                   else
;                       frp = frp.fr_prev;
;               }
;           }
;       }
    ))

;; Set current window width and take care of repositioning other windows to fit around it.

(defn- #_void win_setwidth [#_int width]
    (§
;       win_setwidth_win(width, @curwin);
    ))

(defn- #_void win_setwidth_win [#_int width, #_window_C win]
    (§
        ;; Always keep current window at least one column wide, even when 'winminwidth' is zero.
;       if (win == @curwin)
;       {
;           if (width < @p_wmw)
;               width = (int)@p_wmw;
;           if (width == 0)
;               width = 1;
;       }

;       frame_setwidth(win.w_frame, width + win.w_vsep_width);

        ;; recompute the window positions
;       win_comp_pos();

;       redraw_all_later(NOT_VALID);
    ))

;; Set the width of a frame to "width"
;; and take care that all frames and windows inside it are resized.
;; Also resize frames above and below if the are in the same FR_ROW frame.
;;
;; Strategy is similar to frame_setheight().

(defn- #_void frame_setwidth [#_frame_C curfrp, #_int width]
    (§
        ;; If the width already is the desired value, nothing to do.
;       if (curfrp.fr_width == width)
;           return;

;       if (curfrp.fr_parent == null)
            ;; topframe: can't change width
;           return;

;       if (curfrp.fr_parent.fr_layout == FR_COL)
;       {
            ;; Column of frames: also need to resize frames above and below of this one.
            ;; First check for the minimal width of these.
;           int w = frame_minwidth(curfrp.fr_parent, null);
;           if (width < w)
;               width = w;
;           frame_setwidth(curfrp.fr_parent, width);
;       }
;       else
;       {
;           // %% red. 2x
;           int room = 0;                       ;; total number of lines available
;           int room_reserved = 0;

            ;; Row of frames: try to change only frames in this row.
            ;; Do this twice:
            ;; 1: compute room available, if it's not enough try resizing the containing frame.
            ;; 2: compute the room available and adjust the width to it.

;           for (int run = 1; run <= 2; run++)
;           {
;               room = 0;
;               room_reserved = 0;

;               for (frame_C frp = curfrp.fr_parent.fr_child; frp != null; frp = frp.fr_next)
;               {
;                   if (frp != curfrp && frp.fr_win != null && frp.fr_win.w_onebuf_opt.@wo_wfw)
;                       room_reserved += frp.fr_width;
;                   room += frp.fr_width;
;                   if (frp != curfrp)
;                       room -= frame_minwidth(frp, null);
;               }

;               if (width <= room)
;                   break;

;               long rows_avail = @Rows - @p_ch - tabline_height();

;               if (run == 2 || rows_avail <= curfrp.fr_height)
;               {
;                   if (room < width)
;                       width = room;
;                   break;
;               }

;               frame_setwidth(curfrp.fr_parent, width
;                    + frame_minwidth(curfrp.fr_parent, NOWIN) - (int)@p_wmw - 1);
;           }

            ;; Compute the number of lines we will take from others frames (can be negative!).

;           int take = width - curfrp.fr_width;

            ;; If there is not enough room,
            ;; also reduce the width of a window with 'winfixwidth' set.

;           if (room - room_reserved < width)
;               room_reserved = room - width;

            ;; If there is only a 'winfixwidth' window and making the window smaller,
            ;; need to make the other window narrower.

;           if (take < 0 && room - curfrp.fr_width < room_reserved)
;               room_reserved = 0;

            ;; set the current frame to the new width

;           frame_new_width(curfrp, width, false, false);

            ;; First take lines from the frames right of the current frame.
            ;; If that is not enough, takes lines from frames left of the current frame.

;           for (int run = 0; run < 2; run++)
;           {
;               frame_C frp;
;               if (run == 0)
;                   frp = curfrp.fr_next;   ;; 1st run: start with next window
;               else
;                   frp = curfrp.fr_prev;   ;; 2nd run: start with prev window
;               while (frp != null && take != 0)
;               {
;                   int w = frame_minwidth(frp, null);
;                   if (0 < room_reserved && frp.fr_win != null && frp.fr_win.w_onebuf_opt.@wo_wfw)
;                   {
;                       if (room_reserved >= frp.fr_width)
;                           room_reserved -= frp.fr_width;
;                       else
;                       {
;                           if (take < frp.fr_width - room_reserved)
;                               room_reserved = frp.fr_width - take;
;                           take -= frp.fr_width - room_reserved;
;                           frame_new_width(frp, room_reserved, false, false);
;                           room_reserved = 0;
;                       }
;                   }
;                   else
;                   {
;                       if (frp.fr_width - take < w)
;                       {
;                           take -= frp.fr_width - w;
;                           frame_new_width(frp, w, false, false);
;                       }
;                       else
;                       {
;                           frame_new_width(frp, frp.fr_width - take, false, false);
;                           take = 0;
;                       }
;                   }
;                   if (run == 0)
;                       frp = frp.fr_next;
;                   else
;                       frp = frp.fr_prev;
;               }
;           }
;       }
    ))

;; Check 'winminheight' for a valid value.

(defn- #_void win_setminheight []
    (§
;       boolean first = true;

        ;; loop until there is a 'winminheight' that is possible
;       while (0 < @p_wmh)
;       {
            ;; TODO: handle vertical splits
;           int room = (int)-@p_wh;
;           for (window_C wp = @firstwin; wp != null; wp = wp.w_next)
;               room += wp.w_height - @p_wmh;
;           if (0 <= room)
;               break;
;           --@p_wmh;
;           if (first)
;           {
;               emsg(e_noroom);
;               first = false;
;           }
;       }
    ))

;; Status line of dragwin is dragged "offset" lines down (negative is up).

(defn- #_void win_drag_status_line [#_window_C dragwin, #_int offset]
    (§
;       frame_C fr = dragwin.w_frame;
;       frame_C curfr = fr;
;       if (fr != @topframe)         ;; more than one window
;       {
;           fr = fr.fr_parent;
            ;; When the parent frame is not a column of frames, its parent should be.
;           if (fr.fr_layout != FR_COL)
;           {
;               curfr = fr;
;               if (fr != @topframe) ;; only a row of windows, may drag statusline
;                   fr = fr.fr_parent;
;           }
;       }

        ;; If this is the last frame in a column, may want to resize
        ;; the parent frame instead (go two up to skip a row of frames).
;       while (curfr != @topframe && curfr.fr_next == null)
;       {
;           if (fr != @topframe)
;               fr = fr.fr_parent;
;           curfr = fr;
;           if (fr != @topframe)
;               fr = fr.fr_parent;
;       }

;       boolean up;     ;; if true, drag status line up, otherwise down
;       int room;

;       if (offset < 0) ;; drag up
;       {
;           up = true;
;           offset = -offset;
            ;; sum up the room of the current frame and above it
;           if (fr == curfr)
;           {
                ;; only one window
;               room = fr.fr_height - frame_minheight(fr, null);
;           }
;           else
;           {
;               room = 0;
;               for (fr = fr.fr_child; ; fr = fr.fr_next)
;               {
;                   room += fr.fr_height - frame_minheight(fr, null);
;                   if (fr == curfr)
;                       break;
;               }
;           }
;           fr = curfr.fr_next;     ;; put fr at frame that grows
;       }
;       else            ;; drag down
;       {
;           up = false;

            ;; Only dragging the last status line can reduce "p_ch".

;           room = (int)@Rows - @cmdline_row;
;           if (curfr.fr_next == null)
;               room -= 1;
;           else
;               room -= @p_ch;
;           if (room < 0)
;               room = 0;
            ;; sum up the room of frames below of the current one
;           for (fr = curfr.fr_next; fr != null; fr = fr.fr_next)
;               room += fr.fr_height - frame_minheight(fr, null);
;           fr = curfr;                     ;; put fr at window that grows
;       }

;       if (room < offset)          ;; not enough room
;           offset = room;          ;; move as far as we can
;       if (offset <= 0)
;           return;

        ;; Grow frame fr by "offset" lines.
        ;; Doesn't happen when dragging the last status line up.

;       if (fr != null)
;           frame_new_height(fr, fr.fr_height + offset, up, false);

;       if (up)
;           fr = curfr;             ;; current frame gets smaller
;       else
;           fr = curfr.fr_next;     ;; next frame gets smaller

        ;; Now make the other frames smaller.

;       while (fr != null && 0 < offset)
;       {
;           int n = frame_minheight(fr, null);
;           if (fr.fr_height - offset <= n)
;           {
;               offset -= fr.fr_height - n;
;               frame_new_height(fr, n, !up, false);
;           }
;           else
;           {
;               frame_new_height(fr, fr.fr_height - offset, !up, false);
;               break;
;           }
;           if (up)
;               fr = fr.fr_prev;
;           else
;               fr = fr.fr_next;
;       }

;       int row = win_comp_pos();
;       screen_fill(row, @cmdline_row, 0, (int)@Columns, ' ', ' ', 0);
;       @cmdline_row = row;

;       @p_ch = @Rows - @cmdline_row;
;       if (@p_ch < 1)
;           @p_ch = 1;
;       @curtab.tp_ch_used = @p_ch;

;       redraw_all_later(SOME_VALID);
;       showmode();
    ))

;; Separator line of dragwin is dragged "offset" lines right (negative is left).

(defn- #_void win_drag_vsep_line [#_window_C dragwin, #_int offset]
    (§
;       frame_C fr = dragwin.w_frame;
;       if (fr == @topframe)         ;; only one window (cannot happen?)
;           return;

;       frame_C curfr = fr;
;       fr = fr.fr_parent;
        ;; When the parent frame is not a row of frames, its parent should be.
;       if (fr.fr_layout != FR_ROW)
;       {
;           if (fr == @topframe)     ;; only a column of windows (cannot happen?)
;               return;
;           curfr = fr;
;           fr = fr.fr_parent;
;       }

        ;; If this is the last frame in a row, may want to resize a parent frame instead.
;       while (curfr.fr_next == null)
;       {
;           if (fr == @topframe)
;               break;
;           curfr = fr;
;           fr = fr.fr_parent;
;           if (fr != @topframe)
;           {
;               curfr = fr;
;               fr = fr.fr_parent;
;           }
;       }

;       boolean left;   ;; if true, drag separator line left, otherwise right
;       int room;

;       if (offset < 0) ;; drag left
;       {
;           left = true;
;           offset = -offset;
            ;; sum up the room of the current frame and left of it
;           room = 0;
;           for (fr = fr.fr_child; ; fr = fr.fr_next)
;           {
;               room += fr.fr_width - frame_minwidth(fr, null);
;               if (fr == curfr)
;                   break;
;           }
;           fr = curfr.fr_next;     ;; put fr at frame that grows
;       }
;       else            ;; drag right
;       {
;           left = false;
            ;; sum up the room of frames right of the current one
;           room = 0;
;           for (fr = curfr.fr_next; fr != null; fr = fr.fr_next)
;               room += fr.fr_width - frame_minwidth(fr, null);
;           fr = curfr;             ;; put fr at window that grows
;       }

;       if (room < offset)          ;; not enough room
;           offset = room;          ;; move as far as we can
;       if (offset <= 0)            ;; No room at all, quit.
;           return;

        ;; grow frame fr by offset lines
;       frame_new_width(fr, fr.fr_width + offset, left, false);

        ;; shrink other frames: current and at the left or at the right
;       if (left)
;           fr = curfr;             ;; current frame gets smaller
;       else
;           fr = curfr.fr_next;     ;; next frame gets smaller

;       while (fr != null && 0 < offset)
;       {
;           int n = frame_minwidth(fr, null);
;           if (fr.fr_width - offset <= n)
;           {
;               offset -= fr.fr_width - n;
;               frame_new_width(fr, n, !left, false);
;           }
;           else
;           {
;               frame_new_width(fr, fr.fr_width - offset, !left, false);
;               break;
;           }
;           if (left)
;               fr = fr.fr_prev;
;           else
;               fr = fr.fr_next;
;       }

;       win_comp_pos();
;       redraw_all_later(NOT_VALID);
    ))

(final long FRACTION_MULT 16384#_L)

;; Set wp.w_fraction for the current w_wrow and w_height.

(defn- #_void set_fraction [#_window_C wp]
    (§
;       wp.w_fraction = (int)(((long)wp.w_wrow * FRACTION_MULT + (long)wp.w_height / 2) / (long)wp.w_height);
    ))

;; Set the height of a window.
;; This takes care of the things inside the window, not what happens to the
;; window position, the frame or to other windows.

(defn- #_void win_new_height [#_window_C wp, #_int height]
    (§
;       int prev_height = wp.w_height;

        ;; Don't want a negative height.  Happens when splitting a tiny window.
        ;; Will equalize heights soon to fix it.
;       if (height < 0)
;           height = 0;
;       if (wp.w_height == height)
;           return;                             ;; nothing to do

;       if (0 < wp.w_height)
;       {
;           if (wp == @curwin)
                ;; w_wrow needs to be valid.  When setting 'laststatus' this may
                ;; call win_new_height() recursively.
;               validate_cursor();

;           if (wp.w_height != prev_height)
;               return;                         ;; Recursive call already changed the size,
                                                ;; bail out here to avoid the following
                                                ;; to mess things up.

;           if (wp.w_wrow != wp.w_prev_fraction_row)
;               set_fraction(wp);
;       }

;       wp.w_height = height;
;       wp.w_skipcol = 0;

        ;; Don't change w_topline when height is zero.  Don't set w_topline
        ;; when 'scrollbind' is set and this isn't the current window.
;       if (0 < height && (!wp.w_onebuf_opt.@wo_scb || wp == @curwin))
;       {
            ;; Find a value for w_topline that shows the cursor at the same
            ;; relative position in the window as before (more or less).

;           long lnum = wp.w_cursor.lnum;
;           if (lnum < 1)           ;; can happen when starting up
;               lnum = 1;
;           wp.w_wrow = (int)(((long)wp.w_fraction * (long)height - 1L + FRACTION_MULT / 2) / FRACTION_MULT);
;           int line_size = plines_win_col(wp, lnum, (long)wp.w_cursor.col) - 1;
;           int sline = wp.w_wrow - line_size;

;           if (0 <= sline)
;           {
                ;; Make sure the whole cursor line is visible, if possible.
;               int rows = plines_win(wp, lnum, false);

;               if (sline > wp.w_height - rows)
;               {
;                   sline = wp.w_height - rows;
;                   wp.w_wrow -= rows - line_size;
;               }
;           }

;           if (sline < 0)
;           {
                ;; Cursor line would go off top of screen if w_wrow was this high.
                ;; Make cursor line the first line in the window.  If not enough
                ;; room use w_skipcol;

;               wp.w_wrow = line_size;
;               if (wp.w_height <= wp.w_wrow && 0 < wp.w_width - win_col_off(wp))
;               {
;                   wp.w_skipcol += wp.w_width - win_col_off(wp);
;                   --wp.w_wrow;
;                   while (wp.w_height <= wp.w_wrow)
;                   {
;                       wp.w_skipcol += wp.w_width - win_col_off(wp) + win_col_off2(wp);
;                       --wp.w_wrow;
;                   }
;               }
;               set_topline(wp, lnum);
;           }
;           else if (0 < sline)
;           {
;               while (0 < sline && 1 < lnum)
;               {
;                   --lnum;
;                       line_size = plines_win(wp, lnum, true);
;                   sline -= line_size;
;               }

;               if (sline < 0)
;               {
                    ;; Line we want at top would go off top of screen.  Use next line instead.

;                   lnum++;
;                   wp.w_wrow -= line_size + sline;
;               }
;               else if (0 < sline)
;               {
                    ;; First line of file reached, use that as topline.
;                   lnum = 1;
;                   wp.w_wrow -= sline;
;               }

;               set_topline(wp, lnum);
;           }
;       }

;       if (wp == @curwin)
;       {
;           if (@p_so != 0)
;               update_topline();
;           curs_columns(false);    ;; validate w_wrow
;       }
;       if (0 < prev_height)
;           wp.w_prev_fraction_row = wp.w_wrow;

;       win_comp_scroll(wp);
;       redraw_win_later(wp, SOME_VALID);
;       wp.w_redr_status = true;
;       invalidate_botline_win(wp);
    ))

;; Set the width of a window.

(defn- #_void win_new_width [#_window_C wp, #_int width]
    (§
;       wp.w_width = width;
;       wp.w_lines_valid = 0;
;       changed_line_abv_curs_win(wp);
;       invalidate_botline_win(wp);
;       if (wp == @curwin)
;       {
;           update_topline();
;           curs_columns(true);     ;; validate w_wrow
;       }
;       redraw_win_later(wp, NOT_VALID);
;       wp.w_redr_status = true;
    ))

(defn- #_void win_comp_scroll [#_window_C wp]
    (§
;       wp.w_onebuf_opt.@wo_scr = (wp.w_height >>> 1);
;       if (wp.w_onebuf_opt.@wo_scr == 0)
;           wp.w_onebuf_opt.@wo_scr = 1;
    ))

;; command_height: called whenever "p_ch" has been changed

(defn- #_void command_height []
    (§
;       long old_p_ch = @curtab.tp_ch_used;

        ;; Use the value of "p_ch" that we remembered.  This is needed for when the
        ;; GUI starts up, we can't be sure in what order things happen.  And when
        ;; "p_ch" was changed in another tab page.
;       @curtab.tp_ch_used = @p_ch;

        ;; Find bottom frame with width of screen.
;       frame_C frp = @lastwin.w_frame;
;       while (frp.fr_width != (int)@Columns && frp.fr_parent != null)
;           frp = frp.fr_parent;

        ;; Avoid changing the height of a window with 'winfixheight' set.
;       while (frp.fr_prev != null && frp.fr_layout == FR_LEAF && frp.fr_win.w_onebuf_opt.@wo_wfh)
;           frp = frp.fr_prev;

;       if (@starting != NO_SCREEN)
;       {
;           @cmdline_row = (int)(@Rows - @p_ch);

;           if (old_p_ch < @p_ch)                ;; "p_ch" got bigger
;           {
;               while (old_p_ch < @p_ch)
;               {
;                   if (frp == null)
;                   {
;                       emsg(e_noroom);
;                       @p_ch = old_p_ch;
;                       @curtab.tp_ch_used = @p_ch;
;                       @cmdline_row = (int)(@Rows - @p_ch);
;                       break;
;                   }
;                   int h = frp.fr_height - frame_minheight(frp, null);
;                   if (h > @p_ch - old_p_ch)
;                       h = (int)(@p_ch - old_p_ch);
;                   old_p_ch += h;
;                   frame_add_height(frp, -h);
;                   frp = frp.fr_prev;
;               }

                ;; Recompute window positions.
;               win_comp_pos();

                ;; clear the lines added to cmdline
;               if (@full_screen)
;                   screen_fill(@cmdline_row, (int)@Rows, 0, (int)@Columns, ' ', ' ', 0);
;               @msg_row = @cmdline_row;
;               @redraw_cmdline = true;
;               return;
;           }

;           if (@msg_row < @cmdline_row)
;               @msg_row = @cmdline_row;
;           @redraw_cmdline = true;
;       }
;       frame_add_height(frp, (int)(old_p_ch - @p_ch));

        ;; Recompute window positions.
;       if (frp != @lastwin.w_frame)
;           win_comp_pos();
    ))

;; Resize frame "frp" to be "n" lines higher (negative for less high).
;; Also resize the frames it is contained in.

(defn- #_void frame_add_height [#_frame_C frp, #_int n]
    (§
;       frame_new_height(frp, frp.fr_height + n, false, false);
;       for ( ; ; )
;       {
;           frp = frp.fr_parent;
;           if (frp == null)
;               break;
;           frp.fr_height += n;
;       }
    ))

;; Add or remove a status line for the bottom window(s), according to the
;; value of 'laststatus'.

(defn- #_void last_status [#_boolean morewin]
    ;; morewin: pretend there are two or more windows
    (§
        ;; Don't make a difference between horizontal or vertical split.
;       last_status_rec(@topframe, (@p_ls == 2 || (@p_ls == 1 && (morewin || @lastwin != @firstwin))));
    ))

(defn- #_void last_status_rec [#_frame_C fr, #_boolean statusline]
    (§
;       if (fr.fr_layout == FR_LEAF)
;       {
;           window_C wp = fr.fr_win;
;           if (wp.w_status_height != 0 && !statusline)
;           {
                ;; remove status line
;               win_new_height(wp, wp.w_height + 1);
;               wp.w_status_height = 0;
;               comp_col();
;           }
;           else if (wp.w_status_height == 0 && statusline)
;           {
                ;; Find a frame to take a line from.
;               frame_C fp = fr;
;               while (fp.fr_height <= frame_minheight(fp, null))
;               {
;                   if (fp == @topframe)
;                   {
;                       emsg(e_noroom);
;                       return;
;                   }
                    ;; In a column of frames: go to frame above.
                    ;; If already at the top or in a row of frames: go to parent.
;                   if (fp.fr_parent.fr_layout == FR_COL && fp.fr_prev != null)
;                       fp = fp.fr_prev;
;                   else
;                       fp = fp.fr_parent;
;               }
;               wp.w_status_height = 1;
;               if (fp != fr)
;               {
;                   frame_new_height(fp, fp.fr_height - 1, false, false);
;                   frame_fix_height(wp);
;                   win_comp_pos();
;               }
;               else
;                   win_new_height(wp, wp.w_height - 1);
;               comp_col();
;               redraw_all_later(SOME_VALID);
;           }
;       }
;       else if (fr.fr_layout == FR_ROW)
;       {
            ;; vertically split windows, set status line for each one
;           for (frame_C fp = fr.fr_child; fp != null; fp = fp.fr_next)
;               last_status_rec(fp, statusline);
;       }
;       else
;       {
            ;; horizontally split window, set status line for last one
;           frame_C fp;
;           for (fp = fr.fr_child; fp.fr_next != null; fp = fp.fr_next)
            ;
;           last_status_rec(fp, statusline);
;       }
    ))

;; Return the number of lines used by the tab page line.

(defn- #_int tabline_height []
    (§
;       return (null != null) ? 1 : 0;
    ))

;; Check if the "://" of a URL is at the pointer, return URL_SLASH.
;; Also check for ":\\", which MS Internet Explorer accepts, return URL_BACKSLASH.

(defn- #_int path_is_url [#_Bytes p]
    (§
;       if (STRNCMP(p, u8("://"), 3) == 0)
;           return URL_SLASH;
;       else if (STRNCMP(p, u8(":\\\\"), 3) == 0)
;           return URL_BACKSLASH;

;       return 0;
    ))

;; Check if "fname" starts with "name://".  Return URL_SLASH if it does.
;; Return URL_BACKSLASH for "name:\\".
;; Return zero otherwise.

(defn- #_int path_with_url [#_Bytes fname]
    (§
;       Bytes p;

;       for (p = fname; asc_isalpha(p.at(0)); p = p.plus(1))
        ;

;       return path_is_url(p);
    ))

;; Return true if "name" is a full (absolute) path name or URL.

(defn- #_boolean vim_isAbsName [#_Bytes name]
    (§
;       return (path_with_url(name) != 0 || mch_isFullName(name));
    ))

;; Get absolute file name into buffer "buf[len]".
;;
;; return false for failure, true otherwise

(defn- #_boolean vim_fullName [#_Bytes fname, #_Bytes buf, #_int len, #_boolean force]
    ;; force: force expansion even when already absolute
    (§
;       boolean retval = true;

;       buf.be(0, NUL);
;       if (fname == null)
;           return false;

;       int url = path_with_url(fname);
;       if (url == 0)
;           retval = mch_fullName(fname, buf, len, force);
;       if (url != 0 || retval == false)
;       {
            ;; something failed; use the file name (truncate when too long)
;           vim_strncpy(buf, fname, len - 1);
;       }

;       return retval;
    ))

;; Return the minimal number of rows that is needed on the screen to display
;; the current number of windows.

(defn- #_int min_rows []
    (§
;       if (@firstwin == null)       ;; not initialized yet
;           return MIN_LINES;

;       int total = 0;

;       for (tabpage_C tp = @first_tabpage; tp != null; tp = null)
;       {
;           int n = frame_minheight(tp.tp_topframe, null);
;           if (total < n)
;               total = n;
;       }
;       total += tabline_height();
;       total += 1;         ;; count the room for the command line

;       return total;
    ))

;; Return true if there is only one window (in the current tab page),
;; not counting a help or preview window, unless it is the current window.

(defn- #_boolean only_one_window []
    (§
;       int count = 0;

        ;; If there is another tab page there always is another window.
;       if (null != null)
;           return false;

;       for (window_C wp = @firstwin; wp != null; wp = wp.w_next)
;           if (wp.w_buffer != null && wp != @aucmd_win)
;               count++;

;       return (count <= 1);
    ))

;; Correct the cursor line number in other windows.  Used after changing the
;; current buffer, and before applying autocommands.
;; When "do_curwin" is true, also check current window.

(defn- #_void check_lnums [#_boolean do_curwin]
    (§
;       for (tabpage_C tp = @first_tabpage; tp != null; tp = null)
;           for (window_C wp = (tp == @curtab) ? @firstwin : tp.tp_firstwin; wp != null; wp = wp.w_next)
;               if ((do_curwin || wp != @curwin) && wp.w_buffer == @curbuf)
;               {
;                   if (wp.w_cursor.lnum > @curbuf.b_ml.ml_line_count)
;                       wp.w_cursor.lnum = @curbuf.b_ml.ml_line_count;
;                   if (wp.w_topline > @curbuf.b_ml.ml_line_count)
;                       wp.w_topline = @curbuf.b_ml.ml_line_count;
;               }
    ))

;; Delete all matches in the match list of window 'wp'.

(defn- #_void clear_matches [#_window_C wp]
    (§
;       while (wp.w_match_head != null)
;       {
;           matchitem_C mi = wp.w_match_head.next;
;           wp.w_match_head.mi_match.regprog = null;
;           wp.w_match_head = mi;
;       }

;       redraw_later(SOME_VALID);
    ))

;; Return true if "topfrp" and its children are at the right height.

(defn- #_boolean frame_check_height [#_frame_C topfrp, #_int height]
    (§
;       if (topfrp.fr_height != height)
;           return false;

;       if (topfrp.fr_layout == FR_ROW)
;           for (frame_C frp = topfrp.fr_child; frp != null; frp = frp.fr_next)
;               if (frp.fr_height != height)
;                   return false;

;       return true;
    ))

;; Return true if "topfrp" and its children are at the right width.

(defn- #_boolean frame_check_width [#_frame_C topfrp, #_int width]
    (§
;       if (topfrp.fr_width != width)
;           return false;

;       if (topfrp.fr_layout == FR_COL)
;           for (frame_C frp = topfrp.fr_child; frp != null; frp = frp.fr_next)
;               if (frp.fr_width != width)
;                   return false;

;       return true;
    ))

;; move.c: Functions for moving the cursor and scrolling text.
;;
;; There are two ways to move the cursor:
;; 1. Move the cursor directly, the text is scrolled to keep the cursor in the window.
;; 2. Scroll the text, the cursor is moved into the text visible in the window.
;; The 'scrolloff' option makes this a bit complicated.

(class! #_final lineoff_C
    [
        (field long     lnum)       ;; line number
        (field int      height)     ;; height of added line
    ])

(defn- #_void COPY_lineoff [#_lineoff_C lo1, #_lineoff_C lo0]
    (§
;       lo1.lnum = lo0.lnum;
;       lo1.height = lo0.height;
    ))

;; Compute wp.w_botline for the current wp.w_topline.
;; Can be called after wp.w_topline changed.

(defn- #_void comp_botline [#_window_C wp]
    (§
;       long lnum;
;       int done;

        ;; If w_cline_row is valid, start there.
        ;; Otherwise have to start at w_topline.

;       check_cursor_moved(wp);
;       if ((wp.w_valid & VALID_CROW) != 0)
;       {
;           lnum = wp.w_cursor.lnum;
;           done = wp.w_cline_row;
;       }
;       else
;       {
;           lnum = wp.w_topline;
;           done = 0;
;       }

;       for ( ; lnum <= wp.w_buffer.b_ml.ml_line_count; lnum++)
;       {
;           int n = plines_win(wp, lnum, true);
;           if (lnum == wp.w_cursor.lnum)
;           {
;               wp.w_cline_row = done;
;               wp.w_cline_height = n;
;               redraw_for_cursorline(wp);
;               wp.w_valid |= (VALID_CROW|VALID_CHEIGHT);
;           }
;           if (wp.w_height < done + n)
;               break;
;           done += n;
;       }

        ;; wp.w_botline is the line that is just below the window
;       wp.w_botline = lnum;
;       wp.w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;

;       set_empty_rows(wp, done);
    ))

;; Redraw when w_cline_row changes and 'relativenumber' or 'cursorline' is set.

(defn- #_void redraw_for_cursorline [#_window_C wp]
    (§
;       if ((wp.w_onebuf_opt.@wo_rnu || wp.w_onebuf_opt.@wo_cul) && (wp.w_valid & VALID_CROW) == 0)
;           redraw_win_later(wp, SOME_VALID);
    ))

;; Update curwin.w_topline and redraw if necessary.
;; Used to update the screen before printing a message.

(defn- #_void update_topline_redraw []
    (§
;       update_topline();
;       if (@must_redraw != 0)
;           update_screen(0);
    ))

;; Update curwin.w_topline to move the cursor onto the screen.

(defn- #_void update_topline []
    (§
;       boolean check_topline = false;
;       boolean check_botline = false;
;       long save_so = @p_so;

;       if (!screen_valid(true))
;           return;

        ;; If the window height is zero just use the cursor line.
;       if (@curwin.w_height == 0)
;       {
;           @curwin.w_topline = @curwin.w_cursor.lnum;
;           @curwin.w_botline = @curwin.w_topline;
;           @curwin.w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;
;           @curwin.w_scbind_pos = 1;
;           return;
;       }

;       check_cursor_moved(@curwin);
;       if ((@curwin.w_valid & VALID_TOPLINE) != 0)
;           return;

        ;; When dragging with the mouse, don't scroll that quickly.
;       if (0 < @mouse_dragging)
;           @p_so = @mouse_dragging - 1;

;       long old_topline = @curwin.w_topline;

        ;; If the buffer is empty, always set topline to 1.

;       if (bufempty())             ;; special case - file is empty
;       {
;           if (@curwin.w_topline != 1)
;               redraw_later(NOT_VALID);
;           @curwin.w_topline = 1;
;           @curwin.w_botline = 2;
;           @curwin.w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;
;           @curwin.w_scbind_pos = 1;
;       }

        ;; If the cursor is above or near the top of the window, scroll the window
        ;; to show the line the cursor is in, with 'scrolloff' context.

;       else
;       {
;           if (1 < @curwin.w_topline)
;           {
                ;; If the cursor is above topline, scrolling is always needed.
                ;; If the cursor is far below topline and there is no folding,
                ;; scrolling down is never needed.
;               if (@curwin.w_cursor.lnum < @curwin.w_topline)
;                   check_topline = true;
;               else if (check_top_offset())
;                   check_topline = true;
;           }

;           if (check_topline)
;           {
;               int halfheight = @curwin.w_height / 2 - 1;
;               if (halfheight < 2)
;                   halfheight = 2;

;               int n = (int)(@curwin.w_topline + @p_so - @curwin.w_cursor.lnum);

                ;; If we weren't very close to begin with, we scroll to put the
                ;; cursor in the middle of the window.  Otherwise put the cursor
                ;; near the top of the window.
;               if (halfheight <= n)
;                   scroll_cursor_halfway(false);
;               else
;               {
;                   scroll_cursor_top(scrolljump_value(), false);
;                   check_botline = true;
;               }
;           }

;           else
;           {
;               check_botline = true;
;           }
;       }

        ;; If the cursor is below the bottom of the window, scroll the window
        ;; to put the cursor on the window.
        ;; When w_botline is invalid, recompute it first, to avoid a redraw later.
        ;; If w_botline was approximated, we might need a redraw later in a few
        ;; cases, but we don't want to spend (a lot of) time recomputing w_botline
        ;; for every small change.

;       if (check_botline)
;       {
;           if ((@curwin.w_valid & VALID_BOTLINE_AP) == 0)
;               validate_botline();

;           if (@curwin.w_botline <= @curbuf.b_ml.ml_line_count)
;           {
;               if (@curwin.w_cursor.lnum < @curwin.w_botline)
;               {
;                   if (@curwin.w_botline - @p_so <= @curwin.w_cursor.lnum)
;                   {
                        ;; Cursor is (a few lines) above botline,
                        ;; check if there are 'scrolloff' window lines below the cursor.
                        ;; If not, need to scroll.
;                       int n = @curwin.w_empty_rows;
;                       lineoff_C loff = §_lineoff_C();
;                       loff.lnum = @curwin.w_cursor.lnum;
;                       loff.height = 0;
;                       while (loff.lnum < @curwin.w_botline)
;                       {
;                           n += loff.height;
;                           if (@p_so <= n)
;                               break;
;                           botline_forw(loff);
;                       }
;                       if (@p_so <= n)
                            ;; sufficient context, no need to scroll
;                           check_botline = false;
;                   }
;                   else
                        ;; sufficient context, no need to scroll
;                       check_botline = false;
;               }
;               if (check_botline)
;               {
;                   long line_count = @curwin.w_cursor.lnum - @curwin.w_botline + 1 + @p_so;
;                   if (line_count <= @curwin.w_height + 1)
;                       scroll_cursor_bot(scrolljump_value(), false);
;                   else
;                       scroll_cursor_halfway(false);
;               }
;           }
;       }
;       @curwin.w_valid |= VALID_TOPLINE;

        ;; Need to redraw when topline changed.

;       if (@curwin.w_topline != old_topline)
;       {
;           @dollar_vcol = -1;
;           if (@curwin.w_skipcol != 0)
;           {
;               @curwin.w_skipcol = 0;
;               redraw_later(NOT_VALID);
;           }
;           else
;               redraw_later(VALID);
            ;; May need to set w_skipcol when cursor in w_topline.
;           if (@curwin.w_cursor.lnum == @curwin.w_topline)
;               validate_cursor();
;       }

;       @p_so = save_so;
    ))

;; Return the scrolljump value to use for the current window.
;; When 'scrolljump' is positive use it as-is.
;; When 'scrolljump' is negative use it as a percentage of the window height.

(defn- #_int scrolljump_value []
    (§
;       if (0 <= @p_sj)
;           return (int)@p_sj;

;       return (@curwin.w_height * (int)-@p_sj) / 100;
    ))

;; Return true when there are not 'scrolloff' lines above the cursor for the current window.

(defn- #_boolean check_top_offset []
    (§
;       if (@curwin.w_cursor.lnum < @curwin.w_topline + @p_so)
;       {
;           lineoff_C loff = §_lineoff_C();
;           loff.lnum = @curwin.w_cursor.lnum;

;           int n = 0;
            ;; Count the visible screen lines above the cursor line.
;           for ( ; n < @p_so; n += loff.height)
;           {
;               topline_back(loff);
                ;; Stop when included a line above the window.
;               if (loff.lnum < @curwin.w_topline)
;                   break;
;           }

;           if (n < @p_so)
;               return true;
;       }

;       return false;
    ))

(defn- #_void update_curswant []
    (§
;       if (@curwin.w_set_curswant)
;       {
;           validate_virtcol();
;           @curwin.w_curswant = @curwin.w_virtcol;
;           @curwin.w_set_curswant = false;
;       }
    ))

;; Check if the cursor has moved.  Set the w_valid flag accordingly.

(defn- #_void check_cursor_moved [#_window_C wp]
    (§
;       if (wp.w_cursor.lnum != wp.w_valid_cursor.lnum)
;       {
;           wp.w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL|VALID_CHEIGHT|VALID_CROW|VALID_TOPLINE);
;           COPY_pos(wp.w_valid_cursor, wp.w_cursor);
;           wp.w_valid_leftcol = wp.w_leftcol;
;       }
;       else if (wp.w_cursor.col != wp.w_valid_cursor.col
;                 || wp.w_leftcol != wp.w_valid_leftcol
;          || wp.w_cursor.coladd != wp.w_valid_cursor.coladd)
;       {
;           wp.w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL);
;           wp.w_valid_cursor.col = wp.w_cursor.col;
;           wp.w_valid_leftcol = wp.w_leftcol;
;           wp.w_valid_cursor.coladd = wp.w_cursor.coladd;
;       }
    ))

;; Call this function when some window settings have changed, which require
;; the cursor position, botline and topline to be recomputed and the window
;; to be redrawn.  E.g, when changing the 'wrap' option or folding.

(defn- #_void changed_window_setting []
    (§
;       changed_window_setting_win(@curwin);
    ))

(defn- #_void changed_window_setting_win [#_window_C wp]
    (§
;       wp.w_lines_valid = 0;
;       changed_line_abv_curs_win(wp);
;       wp.w_valid &= ~(VALID_BOTLINE|VALID_BOTLINE_AP|VALID_TOPLINE);
;       redraw_win_later(wp, NOT_VALID);
    ))

;; Set wp.w_topline to a certain number.

(defn- #_void set_topline [#_window_C wp, #_long lnum]
    (§
        ;; Approximate the value of w_botline.
;       wp.w_botline += lnum - wp.w_topline;
;       wp.w_topline = lnum;
;       wp.w_topline_was_set = true;
;       wp.w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE|VALID_TOPLINE);
        ;; Don't set VALID_TOPLINE here, 'scrolloff' needs to be checked.
;       redraw_later(VALID);
    ))

;; Call this function when the length of the cursor line (in screen
;; characters) has changed, and the change is before the cursor.
;; Need to take care of w_botline separately!

(defn- #_void changed_cline_bef_curs []
    (§
;       @curwin.w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL|VALID_CHEIGHT|VALID_TOPLINE);
    ))

(defn- #_void changed_cline_bef_curs_win [#_window_C wp]
    (§
;       wp.w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL|VALID_CHEIGHT|VALID_TOPLINE);
    ))

;; Call this function when the length of a line (in screen characters) above
;; the cursor have changed.
;; Need to take care of w_botline separately!

(defn- #_void changed_line_abv_curs []
    (§
;       @curwin.w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL|VALID_CROW|VALID_CHEIGHT|VALID_TOPLINE);
    ))

(defn- #_void changed_line_abv_curs_win [#_window_C wp]
    (§
;       wp.w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL|VALID_CROW|VALID_CHEIGHT|VALID_TOPLINE);
    ))

;; Make sure the value of curwin.w_botline is valid.

(defn- #_void validate_botline []
    (§
;       if ((@curwin.w_valid & VALID_BOTLINE) == 0)
;           comp_botline(@curwin);
    ))

;; Mark curwin.w_botline as invalid (because of some change in the buffer).

(defn- #_void invalidate_botline []
    (§
;       @curwin.w_valid &= ~(VALID_BOTLINE|VALID_BOTLINE_AP);
    ))

(defn- #_void invalidate_botline_win [#_window_C wp]
    (§
;       wp.w_valid &= ~(VALID_BOTLINE|VALID_BOTLINE_AP);
    ))

(defn- #_void approximate_botline_win [#_window_C wp]
    (§
;       wp.w_valid &= ~VALID_BOTLINE;
    ))

;; Return true if curwin.w_wrow and curwin.w_wcol are valid.

(defn- #_boolean cursor_valid []
    (§
;       check_cursor_moved(@curwin);
;       return ((@curwin.w_valid & (VALID_WROW|VALID_WCOL)) == (VALID_WROW|VALID_WCOL));
    ))

;; Validate cursor position.  Makes sure w_wrow and w_wcol are valid.
;; w_topline must be valid, you may need to call update_topline() first!

(defn- #_void validate_cursor []
    (§
;       check_cursor_moved(@curwin);
;       if ((@curwin.w_valid & (VALID_WCOL|VALID_WROW)) != (VALID_WCOL|VALID_WROW))
;           curs_columns(true);
    ))

;; Compute wp.w_cline_row and wp.w_cline_height, based on the current value of wp.w_topline.

(defn- #_void curs_rows [#_window_C wp]
    (§
        ;; check if wp.w_lines[].wl_size is invalid
;       boolean all_invalid = (!redrawing()
;                           || wp.w_lines_valid == 0
;                           || wp.w_topline < wp.w_lines[0].wl_lnum);
;       int i = 0;
;       wp.w_cline_row = 0;
;       for (long lnum = wp.w_topline; lnum < wp.w_cursor.lnum; i++)
;       {
;           boolean valid = false;
;           if (!all_invalid && i < wp.w_lines_valid)
;           {
;               if (wp.w_lines[i].wl_lnum < lnum || !wp.w_lines[i].wl_valid)
;                   continue;               ;; skip changed or deleted lines
;               if (wp.w_lines[i].wl_lnum == lnum)
;               {
;                   valid = true;
;               }
;               else if (lnum < wp.w_lines[i].wl_lnum)
;                   --i;                    ;; hold at inserted lines
;           }
;           if (valid)
;           {
;               lnum++;
;               wp.w_cline_row += wp.w_lines[i].wl_size;
;           }
;           else
;           {
;               wp.w_cline_row += plines_win(wp, lnum++, true);
;           }
;       }

;       check_cursor_moved(wp);
;       if ((wp.w_valid & VALID_CHEIGHT) == 0)
;       {
;           if (all_invalid
;                   || i == wp.w_lines_valid
;                   || (i < wp.w_lines_valid
;                           && (!wp.w_lines[i].wl_valid || wp.w_lines[i].wl_lnum != wp.w_cursor.lnum)))
;           {
;               wp.w_cline_height = plines_win(wp, wp.w_cursor.lnum, true);
;           }
;           else if (wp.w_lines_valid < i)
;           {
                ;; a line that is too long to fit on the last screen line
;               wp.w_cline_height = 0;
;           }
;           else
;           {
;               wp.w_cline_height = wp.w_lines[i].wl_size;
;           }
;       }

;       redraw_for_cursorline(@curwin);
;       wp.w_valid |= VALID_CROW|VALID_CHEIGHT;
    ))

;; Validate curwin.w_virtcol only.

(defn- #_void validate_virtcol []
    (§
;       validate_virtcol_win(@curwin);
    ))

;; Validate wp.w_virtcol only.

(defn- #_void validate_virtcol_win [#_window_C wp]
    (§
;       check_cursor_moved(wp);
;       if ((wp.w_valid & VALID_VIRTCOL) == 0)
;       {
;           int[] vcol = { wp.w_virtcol };
;           getvvcol(wp, wp.w_cursor, null, vcol, null);
;           wp.w_virtcol = vcol[0];
;           wp.w_valid |= VALID_VIRTCOL;
;           if (wp.w_onebuf_opt.@wo_cuc)
;               redraw_win_later(wp, SOME_VALID);
;       }
    ))

;; Validate curwin.w_cline_height only.

(defn- #_void validate_cheight []
    (§
;       check_cursor_moved(@curwin);
;       if ((@curwin.w_valid & VALID_CHEIGHT) == 0)
;       {
;           @curwin.w_cline_height = plines(@curwin.w_cursor.lnum);
;           @curwin.w_valid |= VALID_CHEIGHT;
;       }
    ))

;; Validate w_wcol and w_virtcol only.

(defn- #_void validate_cursor_col []
    (§
;       validate_virtcol();
;       if ((@curwin.w_valid & VALID_WCOL) == 0)
;       {
;           int col = @curwin.w_virtcol;
;           int off = curwin_col_off();
;           col += off;
;           int width = @curwin.w_width - off + curwin_col_off2();

            ;; long line wrapping, adjust curwin.w_wrow
;           if (@curwin.w_onebuf_opt.@wo_wrap && @curwin.w_width <= col && 0 < width)
                ;; use same formula as what is used in curs_columns()
;               col -= ((col - @curwin.w_width) / width + 1) * width;
;           if (@curwin.w_leftcol < col)
;               col -= @curwin.w_leftcol;
;           else
;               col = 0;
;           @curwin.w_wcol = col;

;           @curwin.w_valid |= VALID_WCOL;
;       }
    ))

;; Compute offset of a window, occupied by absolute or relative line number,
;; fold column and sign column (these don't move when scrolling horizontally).

(defn- #_int win_col_off [#_window_C wp]
    (§
;       return (((wp.w_onebuf_opt.@wo_nu || wp.w_onebuf_opt.@wo_rnu) ? number_width(wp) + 1 : 0)
;             + ((@cmdwin_type == 0 || wp != @curwin) ? 0 : 1));
    ))

(defn- #_int curwin_col_off []
    (§
;       return win_col_off(@curwin);
    ))

;; Return the difference in column offset for the second screen line of a wrapped line.
;; It's 8 if 'number' or 'relativenumber' is on and 'n' is in 'cpoptions'.

(defn- #_int win_col_off2 [#_window_C wp]
    (§
;       if ((wp.w_onebuf_opt.@wo_nu || wp.w_onebuf_opt.@wo_rnu) && vim_strbyte(@p_cpo, CPO_NUMCOL) != null)
;           return number_width(wp) + 1;

;       return 0;
    ))

(defn- #_int curwin_col_off2 []
    (§
;       return win_col_off2(@curwin);
    ))

;; compute curwin.w_wcol and curwin.w_virtcol.
;; Also updates curwin.w_wrow and curwin.w_cline_row.
;; Also updates curwin.w_leftcol.

(defn- #_void curs_columns [#_boolean may_scroll]
    ;; may_scroll: when true, may scroll horizontally
    (§
        ;; First make sure that w_topline is valid (after moving the cursor).

;       update_topline();

        ;; Next make sure that w_cline_row is valid.

;       if ((@curwin.w_valid & VALID_CROW) == 0)
;           curs_rows(@curwin);

        ;; Compute the number of virtual columns.

;       int[] startcol = new int[1];
;       int[] vcol = { @curwin.w_virtcol };
;       int[] endcol = new int[1];
;       getvvcol(@curwin, @curwin.w_cursor, startcol, vcol, endcol);
;       @curwin.w_virtcol = vcol[0];

        ;; remove '$' from change command when cursor moves onto it
;       if (@dollar_vcol < startcol[0])
;           @dollar_vcol = -1;

        ;; offset for first screen line
;       int extra = curwin_col_off();
;       @curwin.w_wcol = @curwin.w_virtcol + extra;
;       endcol[0] += extra;

        ;; Now compute w_wrow, counting screen lines from w_cline_row.

;       @curwin.w_wrow = @curwin.w_cline_row;

;       int width = 0;

;       int textwidth = @curwin.w_width - extra;
;       if (textwidth <= 0)
;       {
            ;; No room for text, put cursor in last char of window.
;           @curwin.w_wcol = @curwin.w_width - 1;
;           @curwin.w_wrow = @curwin.w_height - 1;
;       }
;       else if (@curwin.w_onebuf_opt.@wo_wrap && @curwin.w_width != 0)
;       {
;           width = textwidth + curwin_col_off2();

            ;; long line wrapping, adjust curwin.w_wrow
;           if (@curwin.w_width <= @curwin.w_wcol)
;           {
                ;; this same formula is used in validate_cursor_col()
;               int n = (@curwin.w_wcol - @curwin.w_width) / width + 1;
;               @curwin.w_wcol -= n * width;
;               @curwin.w_wrow += n;

                ;; When cursor wraps to first char of next line in Insert mode,
                ;; the 'showbreak' string isn't shown, backup to first column.
;               if (@p_sbr.at(0) != NUL && ml_get_cursor().at(0) == NUL && @curwin.w_wcol == mb_string2cells(@p_sbr, -1))
;                   @curwin.w_wcol = 0;
;           }
;       }
        ;; No line wrapping: compute curwin.w_leftcol if scrolling is on and line is not folded.
        ;; If scrolling is off, curwin.w_leftcol is assumed to be 0.
;       else if (may_scroll)
;       {
            ;; If Cursor is left of the screen, scroll rightwards.
            ;; If Cursor is right of the screen, scroll leftwards.
            ;; If we get closer to the edge than 'sidescrolloff', scroll a little extra.

;           int off_left = startcol[0] - @curwin.w_leftcol - (int)@p_siso;
;           int off_right = endcol[0] - (@curwin.w_leftcol + @curwin.w_width - (int)@p_siso) + 1;
;           if (off_left < 0 || 0 < off_right)
;           {
;               int diff;
;               if (off_left < 0)
;                   diff = -off_left;
;               else
;                   diff = off_right;

                ;; When far off or not enough room on either side, put cursor in middle of window.
;               int new_leftcol;
;               if (@p_ss == 0 || textwidth / 2 <= diff || off_left <= off_right)
;                   new_leftcol = @curwin.w_wcol - extra - textwidth / 2;
;               else
;               {
;                   if (diff < @p_ss)
;                       diff = (int)@p_ss;
;                   if (off_left < 0)
;                       new_leftcol = @curwin.w_leftcol - diff;
;                   else
;                       new_leftcol = @curwin.w_leftcol + diff;
;               }
;               if (new_leftcol < 0)
;                   new_leftcol = 0;
;               if (new_leftcol != @curwin.w_leftcol)
;               {
;                   @curwin.w_leftcol = new_leftcol;
                    ;; screen has to be redrawn with new curwin.w_leftcol
;                   redraw_later(NOT_VALID);
;               }
;           }
;           @curwin.w_wcol -= @curwin.w_leftcol;
;       }
;       else if (@curwin.w_leftcol < @curwin.w_wcol)
;           @curwin.w_wcol -= @curwin.w_leftcol;
;       else
;           @curwin.w_wcol = 0;

;       int prev_skipcol = @curwin.w_skipcol;

;       int p_lines = 0;
;       if ((@curwin.w_height <= @curwin.w_wrow
;                   || ((0 < prev_skipcol || @curwin.w_height <= @curwin.w_wrow + @p_so)
;                       && @curwin.w_height <= (p_lines = plines_win(@curwin, @curwin.w_cursor.lnum, false)) - 1))
;               && @curwin.w_height != 0
;               && @curwin.w_cursor.lnum == @curwin.w_topline
;               && 0 < width
;               && @curwin.w_width != 0)
;       {
            ;; Cursor past end of screen.  Happens with a single line that does
            ;; not fit on screen.  Find a skipcol to show the text around the
            ;; cursor.  Avoid scrolling all the time. compute value of "extra":
            ;; 1: less than "p_so" lines above
            ;; 2: less than "p_so" lines below
            ;; 3: both of them
;           extra = 0;
;           if (@curwin.w_virtcol < @curwin.w_skipcol + @p_so * width)
;               extra = 1;
            ;; Compute last display line of the buffer line that we want at the bottom of the window.
;           if (p_lines == 0)
;               p_lines = plines_win(@curwin, @curwin.w_cursor.lnum, false);
;           --p_lines;
;           int n;
;           if (@curwin.w_wrow + @p_so < p_lines)
;               n = @curwin.w_wrow + (int)@p_so;
;           else
;               n = p_lines;
;           if (@curwin.w_height + @curwin.w_skipcol / width <= n)
;               extra += 2;

;           if (extra == 3 || p_lines < @p_so * 2)
;           {
                ;; not enough room for 'scrolloff', put cursor in the middle
;               n = @curwin.w_virtcol / width;
;               if (@curwin.w_height / 2 < n)
;                   n -= @curwin.w_height / 2;
;               else
;                   n = 0;
                ;; don't skip more than necessary
;               if (n > p_lines - @curwin.w_height + 1)
;                   n = p_lines - @curwin.w_height + 1;
;               @curwin.w_skipcol = n * width;
;           }
;           else if (extra == 1)
;           {
                ;; less then 'scrolloff' lines above, decrease skipcol
;               extra = (@curwin.w_skipcol + (int)@p_so * width - @curwin.w_virtcol + width - 1) / width;
;               if (0 < extra)
;               {
;                   if (@curwin.w_skipcol < extra * width)
;                       extra = @curwin.w_skipcol / width;
;                   @curwin.w_skipcol -= extra * width;
;               }
;           }
;           else if (extra == 2)
;           {
                ;; less then 'scrolloff' lines below, increase skipcol
;               endcol[0] = (n - @curwin.w_height + 1) * width;
;               while (@curwin.w_virtcol < endcol[0])
;                   endcol[0] -= width;
;               if (@curwin.w_skipcol < endcol[0])
;                   @curwin.w_skipcol = endcol[0];
;           }

;           @curwin.w_wrow -= @curwin.w_skipcol / width;
;           if (@curwin.w_height <= @curwin.w_wrow)
;           {
                ;; small window, make sure cursor is in it
;               extra = @curwin.w_wrow - @curwin.w_height + 1;
;               @curwin.w_skipcol += extra * width;
;               @curwin.w_wrow -= extra;
;           }

;           extra = (prev_skipcol - @curwin.w_skipcol) / width;
;           if (0 < extra)
;               win_ins_lines(@curwin, 0, extra, false, false);
;           else if (extra < 0)
;               win_del_lines(@curwin, 0, -extra, false, false);
;       }
;       else
;           @curwin.w_skipcol = 0;
;       if (prev_skipcol != @curwin.w_skipcol)
;           redraw_later(NOT_VALID);

        ;; Redraw when w_virtcol changes and 'cursorcolumn' is set.
;       if (@curwin.w_onebuf_opt.@wo_cuc && (@curwin.w_valid & VALID_VIRTCOL) == 0)
;           redraw_later(SOME_VALID);

;       @curwin.w_valid |= VALID_WCOL|VALID_WROW|VALID_VIRTCOL;
    ))

;; Scroll the current window down by "line_count" logical lines.  "CTRL-Y"

(defn- #_void scrolldown [#_long line_count]
    (§
;       long done = 0;              ;; total # of physical lines done
;       boolean moved = false;

;       validate_cursor();          ;; w_wrow needs to be valid
;       while (0 < line_count--)
;       {
;           if (@curwin.w_topline == 1)
;               break;
;           --@curwin.w_topline;
;           done += plines(@curwin.w_topline);

;           --@curwin.w_botline;         ;; approximate w_botline
;           invalidate_botline();
;       }
;       @curwin.w_wrow += done;          ;; keep w_wrow updated
;       @curwin.w_cline_row += done;     ;; keep w_cline_row updated

        ;; Compute the row number of the last row of the cursor line
        ;; and move the cursor onto the displayed part of the window.

;       int wrow = @curwin.w_wrow;
;       if (@curwin.w_onebuf_opt.@wo_wrap && @curwin.w_width != 0)
;       {
;           validate_virtcol();
;           validate_cheight();
;           wrow += @curwin.w_cline_height - 1 - @curwin.w_virtcol / @curwin.w_width;
;       }
;       while (@curwin.w_height <= wrow && 1 < @curwin.w_cursor.lnum)
;       {
;           wrow -= plines(@curwin.w_cursor.lnum--);
;           @curwin.w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_CHEIGHT|VALID_CROW|VALID_VIRTCOL);
;           moved = true;
;       }
;       if (moved)
;           coladvance(@curwin.w_curswant);
    ))

;; Scroll the current window up by "line_count" logical lines.  "CTRL-E"

(defn- #_void scrollup [#_long line_count]
    (§
;       @curwin.w_topline += line_count;
;       @curwin.w_botline += line_count;     ;; approximate w_botline

;       if (@curwin.w_topline > @curbuf.b_ml.ml_line_count)
;           @curwin.w_topline = @curbuf.b_ml.ml_line_count;
;       if (@curwin.w_botline > @curbuf.b_ml.ml_line_count + 1)
;           @curwin.w_botline = @curbuf.b_ml.ml_line_count + 1;

;       @curwin.w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);
;       if (@curwin.w_cursor.lnum < @curwin.w_topline)
;       {
;           @curwin.w_cursor.lnum = @curwin.w_topline;
;           @curwin.w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_CHEIGHT|VALID_CROW|VALID_VIRTCOL);
;           coladvance(@curwin.w_curswant);
;       }
    ))

;; Add one line above "lp.lnum".  This can be a filler line, a closed fold or
;; a (wrapped) text line.  Uses and sets "lp.fill".
;; Returns the height of the added line in "lp.height".
;; Lines above the first one are incredibly high: MAXCOL.

(defn- #_void topline_back [#_lineoff_C lp]
    (§
;       --lp.lnum;
;       if (lp.lnum < 1)
;           lp.height = MAXCOL;
;       else
;       {
;           lp.height = plines(lp.lnum);
;       }
    ))

;; Add one line below "lp.lnum".
;; This can be a filler line, a closed fold or a (wrapped) text line.
;; Uses and sets "lp.fill".
;; Returns the height of the added line in "lp.height".
;; Lines below the last one are incredibly high.

(defn- #_void botline_forw [#_lineoff_C lp]
    (§
;       lp.lnum++;
;       if (@curbuf.b_ml.ml_line_count < lp.lnum)
;           lp.height = MAXCOL;
;       else
;           lp.height = plines(lp.lnum);
    ))

;; Recompute topline to put the cursor at the top of the window.
;; Scroll at least "min_scroll" lines.
;; If "always" is true, always set topline (for "zt").

(defn- #_void scroll_cursor_top [#_int min_scroll, #_boolean always]
    (§
;       int scrolled = 0;
;       int extra = 0;
;       long old_topline = @curwin.w_topline;

;       int off = (int)@p_so;
;       if (0 < @mouse_dragging)
;           off = @mouse_dragging - 1;

        ;; Decrease topline until:
        ;; - it has become 1
        ;; - (part of) the cursor line is moved off the screen or
        ;; - moved at least 'scrolljump' lines and
        ;; - at least 'scrolloff' lines above and below the cursor

;       validate_cheight();
;       int used = @curwin.w_cline_height;
;       if (@curwin.w_cursor.lnum < @curwin.w_topline)
;           scrolled = used;

;       long top = @curwin.w_cursor.lnum - 1;    ;; just above displayed lines
;       long bot = @curwin.w_cursor.lnum + 1;    ;; just below displayed lines
;       long new_topline = top + 1;

        ;; Check if the lines from "top" to "bot" fit in the window.  If they do,
        ;; set new_topline and advance "top" and "bot" to include more lines.

;       while (0 < top)
;       {
;           int i = plines(top);
;           used += i;
;           if (extra + i <= off && bot < @curbuf.b_ml.ml_line_count)
;           {
;               used += plines(bot);
;           }
;           if (@curwin.w_height < used)
;               break;
;           if (top < @curwin.w_topline)
;               scrolled += i;

            ;; If scrolling is needed, scroll at least 'sj' lines.

;           if ((@curwin.w_topline <= new_topline || min_scroll < scrolled) && off <= extra)
;               break;

;           extra += i;
;           new_topline = top;
;           --top;
;           bot++;
;       }

        ;; If we don't have enough space, put cursor in the middle.
        ;; This makes sure we get the same position when using "k" and "j" in a small window.

;       if (@curwin.w_height < used)
;           scroll_cursor_halfway(false);
;       else
;       {
            ;; If "always" is false, only adjust topline to a lower value, higher
            ;; value may happen with wrapping lines

;           if (new_topline < @curwin.w_topline || always)
;               @curwin.w_topline = new_topline;
;           if (@curwin.w_topline > @curwin.w_cursor.lnum)
;               @curwin.w_topline = @curwin.w_cursor.lnum;
;           if (@curwin.w_topline != old_topline)
;               @curwin.w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE|VALID_BOTLINE_AP);
;           @curwin.w_valid |= VALID_TOPLINE;
;       }
    ))

;; Set w_empty_rows and w_filler_rows for window "wp", having used up "used"
;; screen lines for text lines.

(defn- #_void set_empty_rows [#_window_C wp, #_int used]
    (§
;       if (used == 0)
;           wp.w_empty_rows = 0;    ;; single line that doesn't fit
;       else
;           wp.w_empty_rows = wp.w_height - used;
    ))

;; Recompute topline to put the cursor at the bottom of the window.
;; Scroll at least "min_scroll" lines.
;; If "set_topbot" is true, set topline and botline first (for "zb").
;; This is messy stuff!!!

(defn- #_void scroll_cursor_bot [#_int min_scroll, #_boolean set_topbot]
    (§
;       int scrolled = 0;
;       int extra = 0;
;       long old_topline = @curwin.w_topline;
;       long old_botline = @curwin.w_botline;
;       int old_valid = @curwin.w_valid;
;       int old_empty_rows = @curwin.w_empty_rows;

;       lineoff_C loff = §_lineoff_C();
;       lineoff_C boff = §_lineoff_C();

;       long cln = @curwin.w_cursor.lnum;            ;; Cursor Line Number
;       if (set_topbot)
;       {
;           int used = 0;
;           @curwin.w_botline = cln + 1;
;           for (@curwin.w_topline = @curwin.w_botline; 1 < @curwin.w_topline; @curwin.w_topline = loff.lnum)
;           {
;               loff.lnum = @curwin.w_topline;
;               topline_back(loff);
;               if (loff.height == MAXCOL || @curwin.w_height < used + loff.height)
;                   break;
;               used += loff.height;
;           }
;           set_empty_rows(@curwin, used);
;           @curwin.w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;
;           if (@curwin.w_topline != old_topline)
;               @curwin.w_valid &= ~(VALID_WROW|VALID_CROW);
;       }
;       else
;           validate_botline();

        ;; The lines of the cursor line itself are always used.
;       validate_cheight();
;       int used = @curwin.w_cline_height;

        ;; If the cursor is below botline, we will at least scroll by the height of the cursor line.
        ;; Correct for empty lines, which are really part of botline.
;       if (@curwin.w_botline <= cln)
;       {
;           scrolled = used;
;           if (cln == @curwin.w_botline)
;               scrolled -= @curwin.w_empty_rows;
;       }

        ;; Stop counting lines to scroll when
        ;; - hitting start of the file
        ;; - scrolled nothing or at least 'sj' lines
        ;; - at least 'so' lines below the cursor
        ;; - lines between botline and cursor have been counted

;       loff.lnum = cln;
;       boff.lnum = cln;

;       while (1 < loff.lnum)
;       {
            ;; Stop when scrolled nothing or at least "min_scroll", found "extra"
            ;; context for 'scrolloff' and counted all lines below the window.
;           if ((((scrolled <= 0 || min_scroll <= scrolled)
;                           && (0 < @mouse_dragging ? @mouse_dragging - 1 : @p_so) <= extra)
;                       || @curbuf.b_ml.ml_line_count < boff.lnum + 1)
;                   && loff.lnum <= @curwin.w_botline)
;               break;

            ;; Add one line above.
;           topline_back(loff);
;           if (loff.height == MAXCOL)
;               used = MAXCOL;
;           else
;               used += loff.height;
;           if (@curwin.w_height < used)
;               break;
;           if (@curwin.w_botline <= loff.lnum)
;           {
                ;; Count screen lines that are below the window.
;               scrolled += loff.height;
;               if (loff.lnum == @curwin.w_botline)
;                   scrolled -= @curwin.w_empty_rows;
;           }

;           if (boff.lnum < @curbuf.b_ml.ml_line_count)
;           {
                ;; Add one line below.
;               botline_forw(boff);
;               used += boff.height;
;               if (@curwin.w_height < used)
;                   break;
;               if (extra < (0 < @mouse_dragging ? @mouse_dragging - 1 : @p_so) || scrolled < min_scroll)
;               {
;                   extra += boff.height;
;                   if (@curwin.w_botline <= boff.lnum)
;                   {
                        ;; Count screen lines that are below the window.
;                       scrolled += boff.height;
;                       if (boff.lnum == @curwin.w_botline)
;                           scrolled -= @curwin.w_empty_rows;
;                   }
;               }
;           }
;       }

;       long line_count;
        ;; curwin.w_empty_rows is larger, no need to scroll
;       if (scrolled <= 0)
;           line_count = 0;
        ;; more than a screenfull, don't scroll but redraw
;       else if (@curwin.w_height < used)
;           line_count = used;
        ;; scroll minimal number of lines
;       else
;       {
;           line_count = 0;
;           boff.lnum = @curwin.w_topline - 1;
;           int i;
;           for (i = 0; i < scrolled && boff.lnum < @curwin.w_botline; )
;           {
;               botline_forw(boff);
;               i += boff.height;
;               line_count++;
;           }
;           if (i < scrolled)       ;; below curwin.w_botline, don't scroll
;               line_count = 9999;
;       }

        ;; Scroll up if the cursor is off the bottom of the screen a bit.
        ;; Otherwise put it at 1/2 of the screen.

;       if (@curwin.w_height <= line_count && min_scroll < line_count)
;           scroll_cursor_halfway(false);
;       else
;           scrollup(line_count);

        ;; If topline didn't change we need to restore w_botline and w_empty_rows (we changed them).
        ;; If topline did change, update_screen() will set botline.

;       if (@curwin.w_topline == old_topline && set_topbot)
;       {
;           @curwin.w_botline = old_botline;
;           @curwin.w_empty_rows = old_empty_rows;
;           @curwin.w_valid = old_valid;
;       }
;       @curwin.w_valid |= VALID_TOPLINE;
    ))

;; Recompute topline to put the cursor halfway the window
;; If "atend" is true, also put it halfway at the end of the file.

(defn- #_void scroll_cursor_halfway [#_boolean atend]
    (§
;       lineoff_C loff = §_lineoff_C();
;       lineoff_C boff = §_lineoff_C();

;       loff.lnum = boff.lnum = @curwin.w_cursor.lnum;
;       int used = plines(loff.lnum);
;       long topline = loff.lnum;

;       for (int above = 0, below = 0; 1 < topline; )
;       {
;           if (below <= above)         ;; add a line below the cursor first
;           {
;               if (boff.lnum < @curbuf.b_ml.ml_line_count)
;               {
;                   botline_forw(boff);
;                   used += boff.height;
;                   if (@curwin.w_height < used)
;                       break;
;                   below += boff.height;
;               }
;               else
;               {
;                   below++;            ;; count a "~" line
;                   if (atend)
;                       used++;
;               }
;           }

;           if (above < below)          ;; add a line above the cursor
;           {
;               topline_back(loff);
;               if (loff.height == MAXCOL)
;                   used = MAXCOL;
;               else
;                   used += loff.height;
;               if (@curwin.w_height < used)
;                   break;
;               above += loff.height;
;               topline = loff.lnum;
;           }
;       }

;       @curwin.w_topline = topline;
;       @curwin.w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE|VALID_BOTLINE_AP);
;       @curwin.w_valid |= VALID_TOPLINE;
    ))

;; Correct the cursor position so that it is in a part of the screen at least
;; 'so' lines from the top and bottom, if possible.
;; If not possible, put it at the same position as scroll_cursor_halfway().
;; When called topline must be valid!

(defn- #_void cursor_correct []
    (§
        ;; How many lines we would like to have above/below the cursor depends on
        ;; whether the first/last line of the file is on screen.

;       int above_wanted = (int)@p_so;
;       int below_wanted = (int)@p_so;
;       if (0 < @mouse_dragging)
;       {
;           above_wanted = @mouse_dragging - 1;
;           below_wanted = @mouse_dragging - 1;
;       }
;       if (@curwin.w_topline == 1)
;       {
;           above_wanted = 0;
;           int max_off = @curwin.w_height / 2;
;           if (max_off < below_wanted)
;               below_wanted = max_off;
;       }
;       validate_botline();
;       if (@curwin.w_botline == @curbuf.b_ml.ml_line_count + 1 && @mouse_dragging == 0)
;       {
;           below_wanted = 0;
;           int max_off = (@curwin.w_height - 1) / 2;
;           if (max_off < above_wanted)
;               above_wanted = max_off;
;       }

        ;; If there are sufficient file-lines above and below the cursor, we can return now.

;       long cln = @curwin.w_cursor.lnum;    ;; Cursor Line Number
;       if (@curwin.w_topline + above_wanted <= cln && cln < @curwin.w_botline - below_wanted)
;           return;

;       int above = 0;          ;; screen lines above topline
;       int below = 0;          ;; screen lines below botline

        ;; Narrow down the area where the cursor can be put by taking lines from
        ;; the top and the bottom until:
        ;; - the desired context lines are found
        ;; - the lines from the top is past the lines from the bottom

;       long topline = @curwin.w_topline;
;       long botline = @curwin.w_botline - 1;
;       while ((above < above_wanted || below < below_wanted) && topline < botline)
;       {
;           if (below < below_wanted && (below <= above || above_wanted <= above))
;           {
;               below += plines(botline);
;               --botline;
;           }
;           if (above < above_wanted && (above < below || below_wanted <= below))
;           {
;               above += plines(topline);
;               topline++;
;           }
;       }
;       if (topline == botline || botline == 0)
;           @curwin.w_cursor.lnum = topline;
;       else if (botline < topline)
;           @curwin.w_cursor.lnum = botline;
;       else
;       {
;           if (cln < topline && 1 < @curwin.w_topline)
;           {
;               @curwin.w_cursor.lnum = topline;
;               @curwin.w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_CHEIGHT|VALID_CROW);
;           }
;           if (botline < cln && @curwin.w_botline <= @curbuf.b_ml.ml_line_count)
;           {
;               @curwin.w_cursor.lnum = botline;
;               @curwin.w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_CHEIGHT|VALID_CROW);
;           }
;       }
;       @curwin.w_valid |= VALID_TOPLINE;
    ))

;; move screen 'count' pages up or down and update screen
;;
;; return false for failure, true otherwise

(defn- #_boolean onepage [#_int dir, #_long count]
    (§
;       boolean retval = true;

;       long old_topline = @curwin.w_topline;

;       if (@curbuf.b_ml.ml_line_count == 1) ;; nothing to do
;       {
;           beep_flush();
;           return false;
;       }

;       lineoff_C loff = §_lineoff_C();

;       for ( ; 0 < count; --count)
;       {
;           validate_botline();

            ;; It's an error to move a page up when the first line is already on
            ;; the screen.  It's an error to move a page down when the last line
            ;; is on the screen and the topline is 'scrolloff' lines from the last line.

;           if (dir == FORWARD
;                   ? (@curbuf.b_ml.ml_line_count - @p_so <= @curwin.w_topline
;                       && @curbuf.b_ml.ml_line_count < @curwin.w_botline)
;                   : (@curwin.w_topline == 1))
;           {
;               beep_flush();
;               retval = false;
;               break;
;           }

;           if (dir == FORWARD)
;           {
;               if (@firstwin == @lastwin && 0 < @p_window && @p_window < @Rows - 1)
;               {
                    ;; Vi compatible scrolling.
;                   if (@p_window <= 2)
;                       @curwin.w_topline++;
;                   else
;                       @curwin.w_topline += @p_window - 2;
;                   if (@curwin.w_topline > @curbuf.b_ml.ml_line_count)
;                       @curwin.w_topline = @curbuf.b_ml.ml_line_count;
;                   @curwin.w_cursor.lnum = @curwin.w_topline;
;               }
;               else if (@curbuf.b_ml.ml_line_count < @curwin.w_botline)
;               {
                    ;; at end of file
;                   @curwin.w_topline = @curbuf.b_ml.ml_line_count;
;                   @curwin.w_valid &= ~(VALID_WROW|VALID_CROW);
;               }
;               else
;               {
                    ;; For the overlap, start with the line just below the window and go upwards.
;                   loff.lnum = @curwin.w_botline;
;                   get_scroll_overlap(loff, -1);
;                   @curwin.w_topline = loff.lnum;
;                   @curwin.w_cursor.lnum = @curwin.w_topline;
;                   @curwin.w_valid &= ~(VALID_WCOL|VALID_CHEIGHT|VALID_WROW|
;                                      VALID_CROW|VALID_BOTLINE|VALID_BOTLINE_AP);
;               }
;           }
;           else    ;; dir == BACKWARDS
;           {
;               if (@firstwin == @lastwin && 0 < @p_window && @p_window < @Rows - 1)
;               {
                    ;; Vi compatible scrolling (sort of).
;                   if (@p_window <= 2)
;                       --@curwin.w_topline;
;                   else
;                       @curwin.w_topline -= @p_window - 2;
;                   if (@curwin.w_topline < 1)
;                       @curwin.w_topline = 1;
;                   @curwin.w_cursor.lnum = @curwin.w_topline + @p_window - 1;
;                   if (@curwin.w_cursor.lnum > @curbuf.b_ml.ml_line_count)
;                       @curwin.w_cursor.lnum = @curbuf.b_ml.ml_line_count;
;                   continue;
;               }

                ;; Find the line at the top of the window that is going to be the
                ;; line at the bottom of the window.  Make sure this results in
                ;; the same line as before doing CTRL-F.
;               loff.lnum = @curwin.w_topline - 1;
;               get_scroll_overlap(loff, 1);

;               if (loff.lnum > @curbuf.b_ml.ml_line_count)
;                   loff.lnum = @curbuf.b_ml.ml_line_count;
;               @curwin.w_cursor.lnum = loff.lnum;

                ;; Find the line just above the new topline to get the right line
                ;; at the bottom of the window.
;               long n = 0;
;               while (n <= @curwin.w_height && 1 <= loff.lnum)
;               {
;                   topline_back(loff);
;                   if (loff.height == MAXCOL)
;                       n = MAXCOL;
;                   else
;                       n += loff.height;
;               }
;               if (loff.lnum < 1)      ;; at begin of file
;               {
;                   @curwin.w_topline = 1;
;                   @curwin.w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);
;               }
;               else
;               {
                    ;; Go two lines forward again.
;                   botline_forw(loff);
;                   botline_forw(loff);

                    ;; Always scroll at least one line.  Avoid getting stuck on very long lines.
;                   if (@curwin.w_topline <= loff.lnum)
;                   {
;                       --@curwin.w_topline;

;                       comp_botline(@curwin);
;                       @curwin.w_cursor.lnum = @curwin.w_botline - 1;
;                       @curwin.w_valid &= ~(VALID_WCOL|VALID_CHEIGHT|VALID_WROW|VALID_CROW);
;                   }
;                   else
;                   {
;                       @curwin.w_topline = loff.lnum;
;                       @curwin.w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);
;                   }
;               }
;           }
;       }

;       cursor_correct();
;       if (retval == true)
;           beginline(BL_SOL | BL_FIX);
;       @curwin.w_valid &= ~(VALID_WCOL|VALID_WROW|VALID_VIRTCOL);

        ;; Avoid the screen jumping up and down when 'scrolloff' is non-zero.
        ;; But make sure we scroll at least one line (happens with mix of long
        ;; wrapping lines and non-wrapping line).

;       if (retval == true && dir == FORWARD && check_top_offset())
;       {
;           scroll_cursor_top(1, false);
;           if (@curwin.w_topline <= old_topline && old_topline < @curbuf.b_ml.ml_line_count)
;           {
;               @curwin.w_topline = old_topline + 1;
;           }
;       }

;       redraw_later(VALID);
;       return retval;
    ))

;; Decide how much overlap to use for page-up or page-down scrolling.
;; This is symmetric, so that doing both keeps the same lines displayed.
;; Three lines are examined:
;;
;;  before CTRL-F           after CTRL-F / before CTRL-B
;;     etc.                     l1
;;  l1 last but one line        ------------
;;  l2 last text line           l2 top text line
;;  -------------               l3 second text line
;;  l3                             etc.

(defn- #_void get_scroll_overlap [#_lineoff_C lp, #_int dir]
    (§
;       int min_height = @curwin.w_height - 2;

;       lp.height = plines(lp.lnum);
;       int h1 = lp.height;
;       if (min_height < h1)
;           return;         ;; no overlap

;       lineoff_C loff0 = §_lineoff_C();
;       COPY_lineoff(loff0, lp);
;       if (0 < dir)
;           botline_forw(lp);
;       else
;           topline_back(lp);
;       int h2 = lp.height;
;       if (h2 == MAXCOL || min_height < h2 + h1)
;       {
;           COPY_lineoff(lp, loff0);    ;; no overlap
;           return;
;       }

;       lineoff_C loff1 = §_lineoff_C();
;       COPY_lineoff(loff1, lp);
;       if (0 < dir)
;           botline_forw(lp);
;       else
;           topline_back(lp);
;       int h3 = lp.height;
;       if (h3 == MAXCOL || min_height < h3 + h2)
;       {
;           COPY_lineoff(lp, loff0);    ;; no overlap
;           return;
;       }

;       lineoff_C loff2 = §_lineoff_C();
;       COPY_lineoff(loff2, lp);
;       if (0 < dir)
;           botline_forw(lp);
;       else
;           topline_back(lp);
;       int h4 = lp.height;
;       if (h4 == MAXCOL || min_height < h4 + h3 + h2 || min_height < h3 + h2 + h1)
;           COPY_lineoff(lp, loff1);    ;; 1 line overlap
;       else
;           COPY_lineoff(lp, loff2);    ;; 2 lines overlap
    ))

;; Scroll 'scroll' lines up or down.

(defn- #_void halfpage [#_boolean flag, #_long Prenum]
    (§
;       long scrolled = 0;

;       if (Prenum != 0)
;           @curwin.w_onebuf_opt.@wo_scr = (@curwin.w_height < Prenum) ? @curwin.w_height : Prenum;
;       int n = ((int)@curwin.w_onebuf_opt.@wo_scr <= @curwin.w_height) ? (int)@curwin.w_onebuf_opt.@wo_scr : @curwin.w_height;

;       validate_botline();
;       int room = @curwin.w_empty_rows;
;       if (flag)
;       {
            ;; scroll the text up

;           while (0 < n && @curwin.w_botline <= @curbuf.b_ml.ml_line_count)
;           {
;               int i = plines(@curwin.w_topline);
;               n -= i;
;               if (n < 0 && 0 < scrolled)
;                   break;
;               @curwin.w_topline++;

;               if (@curwin.w_cursor.lnum < @curbuf.b_ml.ml_line_count)
;               {
;                   @curwin.w_cursor.lnum++;
;                   @curwin.w_valid &= ~(VALID_VIRTCOL|VALID_CHEIGHT|VALID_WCOL);
;               }

;               @curwin.w_valid &= ~(VALID_CROW|VALID_WROW);
;               scrolled += i;

                ;; Correct w_botline for changed w_topline.
                ;; Won't work when there are filler lines.

;               room += i;
;               do
;               {
;                   i = plines(@curwin.w_botline);
;                   if (room < i)
;                       break;
;                   @curwin.w_botline++;
;                   room -= i;
;               } while (@curwin.w_botline <= @curbuf.b_ml.ml_line_count);
;           }

            ;; When hit bottom of the file: move cursor down.

;           if (0 < n)
;           {
;               @curwin.w_cursor.lnum += n;
;               check_cursor_lnum();
;           }
;       }
;       else
;       {
            ;; scroll the text down

;           while (0 < n && 1 < @curwin.w_topline)
;           {
;               int i = plines(@curwin.w_topline - 1);
;               n -= i;
;               if (n < 0 && 0 < scrolled)
;                   break;
;               --@curwin.w_topline;

;               @curwin.w_valid &= ~(VALID_CROW|VALID_WROW|VALID_BOTLINE|VALID_BOTLINE_AP);
;               scrolled += i;
;               if (1 < @curwin.w_cursor.lnum)
;               {
;                   --@curwin.w_cursor.lnum;
;                   @curwin.w_valid &= ~(VALID_VIRTCOL|VALID_CHEIGHT|VALID_WCOL);
;               }
;           }

            ;; When hit top of the file: move cursor up.

;           if (0 < n)
;           {
;               if (@curwin.w_cursor.lnum <= (long)n)
;                   @curwin.w_cursor.lnum = 1;
;               else
;                   @curwin.w_cursor.lnum -= n;
;           }
;       }
;       cursor_correct();
;       beginline(BL_SOL | BL_FIX);
;       redraw_later(VALID);
    ))

(defn- #_void do_check_cursorbind []
    (§
;       long line = @curwin.w_cursor.lnum;
;       int col = @curwin.w_cursor.col;
;       int coladd = @curwin.w_cursor.coladd;
;       int curswant = @curwin.w_curswant;
;       boolean set_curswant = @curwin.w_set_curswant;

;       window_C old_curwin = @curwin;
;       buffer_C old_curbuf = @curbuf;
;       boolean old_VIsual_select = @VIsual_select;
;       boolean old_VIsual_active = @VIsual_active;

        ;; loop through the cursorbound windows

;       @VIsual_select = @VIsual_active = false;
;       for (@curwin = @firstwin; @curwin != null; @curwin = @curwin.w_next)
;       {
;           @curbuf = @curwin.w_buffer;
            ;; skip original window  and windows with 'noscrollbind'
;           if (@curwin != old_curwin && @curwin.w_onebuf_opt.@wo_crb)
;           {
;               @curwin.w_cursor.lnum = line;
;               @curwin.w_cursor.col = col;
;               @curwin.w_cursor.coladd = coladd;
;               @curwin.w_curswant = curswant;
;               @curwin.w_set_curswant = set_curswant;

                ;; Make sure the cursor is in a valid position.  Temporarily set
                ;; "restart_edit" to allow the cursor to be beyond the EOL.
;               int restart_edit_save = @restart_edit;
;               @restart_edit = TRUE;
;               check_cursor();
;               @restart_edit = restart_edit_save;
                ;; Correct cursor for multi-byte character.
;               mb_adjust_pos(@curbuf, @curwin.w_cursor);
;               redraw_later(VALID);

                ;; Only scroll when 'scrollbind' hasn't done this.
;               if (!@curwin.w_onebuf_opt.@wo_scb)
;                   update_topline();
;               @curwin.w_redr_status = true;
;           }
;       }

        ;; reset current-window

;       @VIsual_select = old_VIsual_select;
;       @VIsual_active = old_VIsual_active;
;       @curwin = old_curwin;
;       @curbuf = old_curbuf;
    ))

;;; ============================================================================================== VimX

;; syntax.c: code for syntax highlighting ---------------------------------------------------------

;; Structure that stores information about a highlight group.
;; The ID of a highlight group is also called group ID.
;; It is the index in the highlight_ga array PLUS ONE.

(class! #_final hl_group_C
    [
        (field Bytes        sg_name)            ;; highlight group name
        (field Bytes        sg_name_u)          ;; uppercase of "sg_name"
;; for normal terminals
        (field int          sg_term)            ;; "term=" highlighting attributes
        (field Bytes        sg_start)           ;; terminal string for start highl
        (field Bytes        sg_stop)            ;; terminal string for stop highl
        (field int          sg_term_attr)       ;; Screen attr for term mode
;; for color terminals
        (field int          sg_cterm)           ;; "cterm=" highlighting attr
        (field boolean      sg_cterm_bold)      ;; bold attr was set for light color
        (field int          sg_cterm_fg)        ;; terminal fg color number + 1
        (field int          sg_cterm_bg)        ;; terminal bg color number + 1
        (field int          sg_cterm_attr)      ;; Screen attr for color term mode
;; Store the sp color name for the GUI or synIDattr().
        (field int          sg_gui)             ;; "gui=" highlighting attributes
        (field Bytes        sg_gui_fg_name)     ;; GUI foreground color name
        (field Bytes        sg_gui_bg_name)     ;; GUI background color name
        (field Bytes        sg_gui_sp_name)     ;; GUI special color name
        (field int          sg_link)            ;; link to this highlight group ID
        (field int          sg_set)             ;; combination of SG_* flags
    ])

(defn- #_void COPY_hl_group [#_hl_group_C sg1, #_hl_group_C sg0]
    (§
;       sg1.sg_name = sg0.sg_name;
;       sg1.sg_name_u = sg0.sg_name_u;
;       sg1.sg_term = sg0.sg_term;
;       sg1.sg_start = sg0.sg_start;
;       sg1.sg_stop = sg0.sg_stop;
;       sg1.sg_term_attr = sg0.sg_term_attr;
;       sg1.sg_cterm = sg0.sg_cterm;
;       sg1.sg_cterm_bold = sg0.sg_cterm_bold;
;       sg1.sg_cterm_fg = sg0.sg_cterm_fg;
;       sg1.sg_cterm_bg = sg0.sg_cterm_bg;
;       sg1.sg_cterm_attr = sg0.sg_cterm_attr;
;       sg1.sg_gui = sg0.sg_gui;
;       sg1.sg_gui_fg_name = sg0.sg_gui_fg_name;
;       sg1.sg_gui_bg_name = sg0.sg_gui_bg_name;
;       sg1.sg_gui_sp_name = sg0.sg_gui_sp_name;
;       sg1.sg_link = sg0.sg_link;
;       sg1.sg_set = sg0.sg_set;
    ))

;; highlight groups for 'highlight' option
(atom! hl_group_C*  highlight_ga    0)

(final int MAX_HL_ID       20000)       ;; maximum value for a highlight ID.

;; An attribute number is the index in attr_table plus ATTR_OFF.

(final int ATTR_OFF (inc HL_ALL))

;; The attributes of the syntax item that has been recognized.

(atom! int current_sub_char)

;; Return conceal substitution character

(defn- #_int syn_get_sub_char []
    (§
;       return @current_sub_char;
    ))

;; Highlighting stuff

(defn- #_void init_highlight [#_boolean both, #_boolean reset]
    ;; both: include groups where 'bg' doesn't matter
    ;; reset: clear group first
    (§
    ))

;; Reset the cterm colors to what they were before Vim was started,
;; if possible.  Otherwise reset them to zero.

(defn- #_void restore_cterm_colors []
    (§
;       @cterm_normal_fg_color = 0;
;       @cterm_normal_fg_bold = 0;
;       @cterm_normal_bg_color = 0;
    ))

;; Table with the specifications for an attribute number.
;; Note that this table is used by ALL buffers.
;; This is required because the GUI can redraw at any time for any buffer.

(atom! attrentry_C* term_attr_table     0)
(atom! attrentry_C* cterm_attr_table    0)

(atom! boolean _4_recursive)

;; Return the attr number for a set of colors and font.
;; Add a new entry to the term_attr_table, cterm_attr_table or gui_attr_table, if the combination is new.
;; Return 0 for error (no more room).

(defn- #_int get_attr_entry [#_attrentry_C* table, #_attrentry_C aep]
    (§
        ;; Try to find an entry with the same specifications.

;       for (int i = 0; i < table.ga_len; i++)
;       {
;           attrentry_C taep = table.ga_data[i];
;           if (aep.ae_attr == taep.ae_attr
;                   && ((table == @term_attr_table
;                           && (aep.ae_esc_start == null) == (taep.ae_esc_start == null)
;                           && (aep.ae_esc_start == null
;                               || STRCMP(aep.ae_esc_start, taep.ae_esc_start) == 0)
;                           && (aep.ae_esc_stop == null) == (taep.ae_esc_stop == null)
;                           && (aep.ae_esc_stop == null
;                               || STRCMP(aep.ae_esc_stop, taep.ae_esc_stop) == 0))
;                       || (table == @cterm_attr_table
;                               && aep.ae_fg_color == taep.ae_fg_color
;                               && aep.ae_bg_color == taep.ae_bg_color)
;                        ))

;           return i + ATTR_OFF;
;       }

;       final int MAX_TYPENR = 65535;

;       if (MAX_TYPENR < table.ga_len + ATTR_OFF)
;       {
            ;; Running out of attribute entries!
            ;; Remove all attributes, and compute new ones for all groups.
            ;; When called recursively, we are really out of numbers.

;           if (@_4_recursive)
;           {
;               emsg(u8("E424: Too many different highlighting attributes in use"));
;               return 0;
;           }
;           @_4_recursive = true;

;           clear_hl_tables();

;           @must_redraw = CLEAR;

;           for (int i = 0; i < @highlight_ga.ga_len; i++)
;               set_hl_attr(i);

;           @_4_recursive = false;
;       }

        ;; This is a new combination of colors and font, add an entry.

;       table.ga_grow(1);

;       attrentry_C taep = table.ga_data[table.ga_len++] = §_attrentry_C();

;       taep.ae_attr = aep.ae_attr;
;       if (table == @term_attr_table)
;       {
;           if (aep.ae_esc_start == null)
;               taep.ae_esc_start = null;
;           else
;               taep.ae_esc_start = STRDUP(aep.ae_esc_start);
;           if (aep.ae_esc_stop == null)
;               taep.ae_esc_stop = null;
;           else
;               taep.ae_esc_stop = STRDUP(aep.ae_esc_stop);
;       }
;       else if (table == @cterm_attr_table)
;       {
;           taep.ae_fg_color = aep.ae_fg_color;
;           taep.ae_bg_color = aep.ae_bg_color;
;       }

;       return table.ga_len - 1 + ATTR_OFF;
    ))

;; Clear all highlight tables.

(defn- #_void clear_hl_tables []
    (§
;       for (int i = 0; i < @term_attr_table.ga_len; i++)
;       {
;           attrentry_C taep = @term_attr_table.ga_data[i];
;           taep.ae_esc_start = null;
;           taep.ae_esc_stop = null;
;       }
;       @term_attr_table.ga_clear();
;       @cterm_attr_table.ga_clear();
    ))

;; Combine special attributes (e.g., for spelling)
;; with other attributes (e.g., for syntax highlighting).
;; "prim_attr" overrules "char_attr".
;; This creates a new group when required.
;; Since we expect there to be few spelling mistakes we don't cache the result.
;; Return the resulting attributes.

(defn- #_int hl_combine_attr [#_int char_attr, #_int prim_attr]
    (§
;       attrentry_C char_aep = null;
;       attrentry_C spell_aep;

;       if (char_attr == 0)
;           return prim_attr;
;       if (char_attr <= HL_ALL && prim_attr <= HL_ALL)
;           return char_attr | prim_attr;

;       attrentry_C new_en = §_attrentry_C();

;       if (1 < @t_colors)
;       {
;           if (HL_ALL < char_attr)
;               char_aep = syn_cterm_attr2entry(char_attr);
;           if (char_aep != null)
;               COPY_attrentry(new_en, char_aep);
;           else
;           {
;               ZER0_attrentry(new_en);
;               if (char_attr <= HL_ALL)
;                   new_en.ae_attr = char_attr;
;           }

;           if (prim_attr <= HL_ALL)
;               new_en.ae_attr |= prim_attr;
;           else
;           {
;               spell_aep = syn_cterm_attr2entry(prim_attr);
;               if (spell_aep != null)
;               {
;                   new_en.ae_attr |= spell_aep.ae_attr;
;                   if (0 < spell_aep.ae_fg_color)
;                       new_en.ae_fg_color = spell_aep.ae_fg_color;
;                   if (0 < spell_aep.ae_bg_color)
;                       new_en.ae_bg_color = spell_aep.ae_bg_color;
;               }
;           }

;           return get_attr_entry(@cterm_attr_table, new_en);
;       }

;       if (HL_ALL < char_attr)
;           char_aep = syn_term_attr2entry(char_attr);
;       if (char_aep != null)
;           COPY_attrentry(new_en, char_aep);
;       else
;       {
;           ZER0_attrentry(new_en);
;           if (char_attr <= HL_ALL)
;               new_en.ae_attr = char_attr;
;       }

;       if (prim_attr <= HL_ALL)
;           new_en.ae_attr |= prim_attr;
;       else
;       {
;           spell_aep = syn_term_attr2entry(prim_attr);
;           if (spell_aep != null)
;           {
;               new_en.ae_attr |= spell_aep.ae_attr;
;               if (spell_aep.ae_esc_start != null)
;               {
;                   new_en.ae_esc_start = spell_aep.ae_esc_start;
;                   new_en.ae_esc_stop = spell_aep.ae_esc_stop;
;               }
;           }
;       }

;       return get_attr_entry(@term_attr_table, new_en);
    ))

;; Get the highlight attributes (HL_BOLD etc.) from an attribute nr.
;; Only to be used when "attr" > HL_ALL.

(defn- #_int syn_attr2attr [#_int attr]
    (§
;       attrentry_C aep;

;       if (1 < @t_colors)
;           aep = syn_cterm_attr2entry(attr);
;       else
;           aep = syn_term_attr2entry(attr);

;       if (aep == null)        ;; highlighting not set
;           return 0;

;       return aep.ae_attr;
    ))

(defn- #_attrentry_C syn_term_attr2entry [#_int attr]
    (§
;       attr -= ATTR_OFF;
;       if (@term_attr_table.ga_len <= attr)     ;; did ":syntax clear"
;           return null;

;       return @term_attr_table.ga_data[attr];
    ))

(defn- #_attrentry_C syn_cterm_attr2entry [#_int attr]
    (§
;       attr -= ATTR_OFF;
;       if (@cterm_attr_table.ga_len <= attr)    ;; did ":syntax clear"
;           return null;

;       return @cterm_attr_table.ga_data[attr];
    ))

;; Set the attribute numbers for a highlight group.
;; Called after one of the attributes has changed.

(defn- #_void set_hl_attr [#_int idx]
    ;; idx: index in array
    (§
;       hl_group_C[] hlt = @highlight_ga.ga_data;
;       hl_group_C sgp = hlt[idx];

        ;; The "Normal" group doesn't need an attribute number.
;       if (sgp.sg_name_u != null && STRCMP(sgp.sg_name_u, u8("NORMAL")) == 0)
;           return;

        ;; For the term mode: If there are other than "normal" highlighting
        ;; attributes, need to allocate an attr number.

;       if (sgp.sg_start == null && sgp.sg_stop == null)
;           sgp.sg_term_attr = sgp.sg_term;
;       else
;       {
;           attrentry_C at_en = §_attrentry_C();
;           at_en.ae_attr = sgp.sg_term;
;           at_en.ae_esc_start = sgp.sg_start;
;           at_en.ae_esc_stop = sgp.sg_stop;
;           sgp.sg_term_attr = get_attr_entry(@term_attr_table, at_en);
;       }

        ;; For the color term mode: If there are other than "normal"
        ;; highlighting attributes, need to allocate an attr number.

;       if (sgp.sg_cterm_fg == 0 && sgp.sg_cterm_bg == 0)
;           sgp.sg_cterm_attr = sgp.sg_cterm;
;       else
;       {
;           attrentry_C at_en = §_attrentry_C();
;           at_en.ae_attr = sgp.sg_cterm;
;           at_en.ae_fg_color = sgp.sg_cterm_fg;
;           at_en.ae_bg_color = sgp.sg_cterm_bg;
;           sgp.sg_cterm_attr = get_attr_entry(@cterm_attr_table, at_en);
;       }
    ))

;; Like syn_name2id(), but take a pointer + length argument.

(defn- #_int syn_namen2id [#_Bytes linep, #_int len]
    (§
;       Bytes name = STRNDUP(linep, len);
;       return syn_name2id(name);
    ))

;; Lookup a highlight group name and return it's ID.
;; If it is not found, 0 is returned.

(defn- #_int syn_name2id [#_Bytes name]
    (§
;       Bytes name_u = vim_strsave_up(name);

;       hl_group_C[] hlt = @highlight_ga.ga_data;

;       int i;
;       for (i = @highlight_ga.ga_len; 0 <= --i; )
;           if (hlt[i].sg_name_u != null && STRCMP(name_u, hlt[i].sg_name_u) == 0)
;               break;
;       return i + 1;
    ))

;; Find highlight group name in the table and return it's ID.
;; The argument is a pointer to the name and the length of the name.
;; If it doesn't exist yet, a new entry is created.
;; Return 0 for failure.

(defn- #_int syn_check_group [#_Bytes pp, #_int len]
    (§
;       Bytes name = STRNDUP(pp, len);

;       int id = syn_name2id(name);
;       if (id == 0)                        ;; doesn't exist yet
;           id = syn_add_group(name);

;       return id;
    ))

;; Add new highlight group and return it's ID.
;; "name" must be an allocated string, it will be consumed.
;; Return 0 for failure.

(defn- #_int syn_add_group [#_Bytes name]
    (§
        ;; Check that the name is ASCII letters, digits and underscore.
;       for (Bytes p = name; p.at(0) != NUL; p = p.plus(1))
;       {
;           if (!vim_isprintc(p.at(0)))
;           {
;               emsg(u8("E669: Unprintable character in group name"));
;               return 0;
;           }
;           else if (!asc_isalnum(p.at(0)) && p.at(0) != (byte)'_')
;           {
                ;; This is an error, but since there previously was no check only give a warning.
;               msg(u8("W18: Invalid character in group name"));
;               break;
;           }
;       }

;       if (MAX_HL_ID <= @highlight_ga.ga_len)
;       {
;           emsg(u8("E849: Too many highlight and syntax groups"));
;           return 0;
;       }

        ;; Make room for at least one other syntax_highlight entry.

;       hl_group_C[] hlt = @highlight_ga.ga_grow(1);

;       hlt[@highlight_ga.ga_len] = §_hl_group_C();
;       hlt[@highlight_ga.ga_len].sg_name = name;
;       hlt[@highlight_ga.ga_len].sg_name_u = vim_strsave_up(name);

;       @highlight_ga.ga_len++;

;       return @highlight_ga.ga_len; ;; ID is index plus one
    ))

;; Translate a group ID to highlight attributes.

(defn- #_int syn_id2attr [#_int hl_id]
    (§
;       hl_id = syn_get_final_id(hl_id);

;       hl_group_C[] hlt = @highlight_ga.ga_data;
;       hl_group_C sgp = hlt[hl_id - 1];                        ;; index is ID minus one

;       return (1 < @t_colors) ? sgp.sg_cterm_attr : sgp.sg_term_attr;
    ))

;; Translate a group ID to the final group ID (following links).

(defn- #_int syn_get_final_id [#_int hl_id]
    (§
;       if (@highlight_ga.ga_len < hl_id || hl_id < 1)
;           return 0;                                           ;; Can be called from eval!!

;       hl_group_C[] hlt = @highlight_ga.ga_data;

        ;; Follow links until there is no more.
        ;; Look out for loops!  Break after 100 links.

;       for (int count = 100; 0 <= --count; )
;       {
;           hl_group_C sgp = hlt[hl_id - 1];                    ;; index is ID minus one
;           if (sgp.sg_link == 0 || @highlight_ga.ga_len < sgp.sg_link)
;               break;
;           hl_id = sgp.sg_link;
;       }

;       return hl_id;
    ))

;; The HL_FLAGS must be in the same order as the HLF_ enums!
;; When changing this also adjust the default for 'highlight'.

(final int* #_"[/*HLF_COUNT*/]" hl_flags
    [
        \8, \@, \d, \e, \h, \i, \l, \m,
        \M, \n, \N, \r, \s, \S, \c, \t,
        \v, \V, \w, \W, \f, \F, \A, \C,
        \D, \T, \-, \>, \B, \P, \R, \L,
        \+, \=, \x, \X, \*, \#, \_, \!,
        \., \o
    ])

;; Translate the 'highlight' option into attributes in highlight_attr[] and
;; set up the user highlights User1..9.  If FEAT_STL_OPT is in use, a set of
;; corresponding highlights to use on top of HLF_SNC is computed.
;; Called only when the 'highlight' option has been changed and upon first
;; screen redraw after any :highlight command.
;; Return false when an invalid flag is found in 'highlight'; true otherwise.

(defn- #_boolean highlight_changed []
    (§
;       int id_SNC = -1;
;       int id_S = -1;

;       @need_highlight_changed = false;

        ;; Clear all attributes.

;       for (int hlf = 0; hlf < HLF_COUNT; hlf++)
;           @highlight_attr[hlf] = 0;

        ;; First set all attributes to their default value.
        ;; Then use the attributes from the 'highlight' option.

;       for (int i = 0; i < 2; i++)
;       {
;           Bytes p;
;           if (i != 0)
;               p = @p_hl;
;           else
;               p = get_highlight_default();
;           if (p == null)      ;; just in case
;               continue;

;           while (p.at(0) != NUL)
;           {
;               int hlf;
;               for (hlf = 0; hlf < HLF_COUNT; hlf++)
;                   if (hl_flags[hlf] == p.at(0))
;                       break;
;               p = p.plus(1);
;               if (hlf == HLF_COUNT || p.at(0) == NUL)
;                   return false;

                ;; Allow several hl_flags to be combined, like "bu" for bold-underlined.

;               int attr = 0;
;               for ( ; p.at(0) != NUL && p.at(0) != (byte)','; p = p.plus(1))            ;; parse upto comma
;               {
;                   if (vim_iswhite(p.at(0)))           ;; ignore white space
;                       continue;

;                   if (HL_ALL < attr)  ;; Combination with ':' is not allowed.
;                       return false;

;                   switch (p.at(0))
;                   {
;                       case 'b':
;                           attr |= HL_BOLD;
;                           break;
;                       case 'i':
;                           attr |= HL_ITALIC;
;                           break;
;                       case '-':
;                       case 'n':                       ;; no highlighting
;                           break;
;                       case 'r':
;                           attr |= HL_INVERSE;
;                           break;
;                       case 's':
;                           attr |= HL_STANDOUT;
;                           break;
;                       case 'u':
;                           attr |= HL_UNDERLINE;
;                           break;
;                       case 'c':
;                           attr |= HL_UNDERCURL;
;                           break;
;                       case ':':
;                       {
;                           p = p.plus(1);                        ;; highlight group name
;                           if (attr != 0 || p.at(0) == NUL)      ;; no combinations
;                               return false;
;                           Bytes end = vim_strchr(p, ',');
;                           if (end == null)
;                               end = p.plus(STRLEN(p));
;                           int id = syn_check_group(p, BDIFF(end, p));
;                           if (id == 0)
;                               return false;
;                           attr = syn_id2attr(id);
;                           p = end.minus(1);
;                           if (hlf == HLF_SNC)
;                               id_SNC = syn_get_final_id(id);
;                           else if (hlf == HLF_S)
;                               id_S = syn_get_final_id(id);
;                           break;
;                       }
;                       default:
;                           return false;
;                   }
;               }
;               @highlight_attr[hlf] = attr;

;               p = skip_to_option_part(p);             ;; skip comma and spaces
;           }
;       }

        ;; Setup the user highlights
        ;;
        ;; Temporarily utilize 10 more hl entries.  Have to be in there
        ;; simultaneously in case of table overflows in get_attr_entry()

;       hl_group_C[] hlt = @highlight_ga.ga_grow(10);

;       int n = @highlight_ga.ga_len;
;       for (int i = 0; i < 10; i++)
;           hlt[n + i] = §_hl_group_C();

        ;; Make sure id_S is always valid to simplify code below.
;       if (id_S == 0)
;       {
;           hlt[n + 9].sg_term = @highlight_attr[HLF_S];
;           id_S = n + 10;
;       }

;       for (int i = 0; i < 9; i++)
;       {
;           Bytes userhl = new Bytes(10);
;           libC.sprintf(userhl, u8("User%d"), i + 1);

;           int id = syn_name2id(userhl);
;           if (id == 0)
;           {
;               @highlight_user[i] = 0;
;               @highlight_stlnc[i] = 0;
;           }
;           else
;           {
;               @highlight_user[i] = syn_id2attr(id);
;               if (id_SNC == 0)
;               {
;                   hlt[n + i].sg_term = @highlight_attr[HLF_SNC];
;                   hlt[n + i].sg_cterm = @highlight_attr[HLF_SNC];
;                   hlt[n + i].sg_gui = @highlight_attr[HLF_SNC];
;               }
;               else
;                   COPY_hl_group(hlt[n + i], hlt[id_SNC - 1]);
;               hlt[n + i].sg_link = 0;

                ;; Apply difference between UserX and HLF_S to HLF_SNC.
;               hlt[n + i].sg_term ^= (hlt[id - 1].sg_term ^ hlt[id_S - 1].sg_term);
;               if (BNE(hlt[id - 1].sg_start, hlt[id_S - 1].sg_start))
;                   hlt[n + i].sg_start = hlt[id - 1].sg_start;
;               if (BNE(hlt[id - 1].sg_stop, hlt[id_S - 1].sg_stop))
;                   hlt[n + i].sg_stop = hlt[id - 1].sg_stop;
;               hlt[n + i].sg_cterm ^= (hlt[id - 1].sg_cterm ^ hlt[id_S - 1].sg_cterm);
;               if (hlt[id - 1].sg_cterm_fg != hlt[id_S - 1].sg_cterm_fg)
;                   hlt[n + i].sg_cterm_fg = hlt[id - 1].sg_cterm_fg;
;               if (hlt[id - 1].sg_cterm_bg != hlt[id_S - 1].sg_cterm_bg)
;                   hlt[n + i].sg_cterm_bg = hlt[id - 1].sg_cterm_bg;
;               hlt[n + i].sg_gui ^= (hlt[id - 1].sg_gui ^ hlt[id_S - 1].sg_gui);
;               @highlight_ga.ga_len = n + i + 1;
;               set_hl_attr(n + i);         ;; at long last we can apply
;               @highlight_stlnc[i] = syn_id2attr(n + i + 1);
;           }
;       }

;       @highlight_ga.ga_len = n;
;       for (int i = 0; i < 10; i++)
;           hlt[n + i] = null;

;       return true;
    ))

;;; ============================================================================================== VimY

;; oops!

(final cmdname_C* cmdnames
    [
        (->cmdname_C (u8 "append"),        ex_append,        (| BANG RANGE ZEROR CMDWIN MODIFY),                           ADDR_LINES),
        (->cmdname_C (u8 "abbreviate"),    ex_abbreviate,    (| EXTRA NOTRLCOM USECTRLV CMDWIN),                           ADDR_LINES),
        (->cmdname_C (u8 "abclear"),       ex_abclear,       (| EXTRA CMDWIN),                                             ADDR_LINES),
        (->cmdname_C (u8 "aboveleft"),     ex_wrongmodifier, (| NEEDARG EXTRA NOTRLCOM),                                   ADDR_LINES),
        (->cmdname_C (u8 "ascii"),         ex_ascii,         (| SBOXOK CMDWIN),                                            ADDR_LINES),
        (->cmdname_C (u8 "buffer"),        ex_buffer,        (| BANG RANGE NOTADR BUFNAME BUFUNL COUNT EXTRA EDITCMD),     ADDR_BUFFERS),
        (->cmdname_C (u8 "bNext"),         ex_bprevious,     (| BANG RANGE NOTADR COUNT EDITCMD),                          ADDR_LINES),
        (->cmdname_C (u8 "ball"),          ex_buffer_all,    (| RANGE NOTADR COUNT),                                       ADDR_LINES),
        (->cmdname_C (u8 "bdelete"),       ex_bunload,       (| BANG RANGE NOTADR BUFNAME COUNT EXTRA),                    ADDR_BUFFERS),
        (->cmdname_C (u8 "belowright"),    ex_wrongmodifier, (| NEEDARG EXTRA NOTRLCOM),                                   ADDR_LINES),
        (->cmdname_C (u8 "bfirst"),        ex_brewind,       (| BANG RANGE NOTADR EDITCMD),                                ADDR_LINES),
        (->cmdname_C (u8 "blast"),         ex_blast,         (| BANG RANGE NOTADR EDITCMD),                                ADDR_LINES),
        (->cmdname_C (u8 "bmodified"),     ex_bmodified,     (| BANG RANGE NOTADR COUNT EDITCMD),                          ADDR_LINES),
        (->cmdname_C (u8 "bnext"),         ex_bnext,         (| BANG RANGE NOTADR COUNT EDITCMD),                          ADDR_LINES),
        (->cmdname_C (u8 "botright"),      ex_wrongmodifier, (| NEEDARG EXTRA NOTRLCOM),                                   ADDR_LINES),
        (->cmdname_C (u8 "bprevious"),     ex_bprevious,     (| BANG RANGE NOTADR COUNT EDITCMD),                          ADDR_LINES),
        (->cmdname_C (u8 "brewind"),       ex_brewind,       (| BANG RANGE NOTADR EDITCMD),                                ADDR_LINES),
        (->cmdname_C (u8 "buffers"),       ex_buflist,       (| BANG CMDWIN),                                              ADDR_LINES),
        (->cmdname_C (u8 "bunload"),       ex_bunload,       (| BANG RANGE NOTADR BUFNAME COUNT EXTRA),                    ADDR_LOADED_BUFFERS),
        (->cmdname_C (u8 "bwipeout"),      ex_bunload,       (| BANG RANGE NOTADR BUFNAME BUFUNL COUNT EXTRA),             ADDR_BUFFERS),
        (->cmdname_C (u8 "change"),        ex_change,        (| BANG RANGE COUNT CMDWIN MODIFY),                           ADDR_LINES),
        (->cmdname_C (u8 "cabbrev"),       ex_abbreviate,    (| EXTRA NOTRLCOM USECTRLV CMDWIN),                           ADDR_LINES),
        (->cmdname_C (u8 "cabclear"),      ex_abclear,       (| EXTRA CMDWIN),                                             ADDR_LINES),
        (->cmdname_C (u8 "center"),        ex_align,         (| RANGE EXTRA CMDWIN MODIFY),                                ADDR_LINES),
        (->cmdname_C (u8 "changes"),       ex_changes,          CMDWIN,                                                    ADDR_LINES),
        (->cmdname_C (u8 "close"),         ex_close,         (| BANG RANGE NOTADR COUNT CMDWIN),                           ADDR_WINDOWS),
        (->cmdname_C (u8 "cmap"),          ex_map,           (| EXTRA NOTRLCOM USECTRLV CMDWIN),                           ADDR_LINES),
        (->cmdname_C (u8 "cmapclear"),     ex_mapclear,      (| EXTRA CMDWIN),                                             ADDR_LINES),
        (->cmdname_C (u8 "cnoremap"),      ex_map,           (| EXTRA NOTRLCOM USECTRLV CMDWIN),                           ADDR_LINES),
        (->cmdname_C (u8 "cnoreabbrev"),   ex_abbreviate,    (| EXTRA NOTRLCOM USECTRLV CMDWIN),                           ADDR_LINES),
        (->cmdname_C (u8 "copy"),          ex_copymove,      (| RANGE EXTRA CMDWIN MODIFY),                                ADDR_LINES),
        (->cmdname_C (u8 "cunmap"),        ex_unmap,         (| EXTRA NOTRLCOM USECTRLV CMDWIN),                           ADDR_LINES),
        (->cmdname_C (u8 "cunabbrev"),     ex_abbreviate,    (| EXTRA NOTRLCOM USECTRLV CMDWIN),                           ADDR_LINES),
        (->cmdname_C (u8 "delete"),        ex_operators,     (| RANGE REGSTR COUNT CMDWIN MODIFY),                         ADDR_LINES),
        (->cmdname_C (u8 "delmarks"),      ex_delmarks,      (| BANG EXTRA CMDWIN),                                        ADDR_LINES),
        (->cmdname_C (u8 "display"),       ex_display,       (| EXTRA NOTRLCOM SBOXOK CMDWIN),                             ADDR_LINES),
        (->cmdname_C (u8 "digraphs"),      ex_digraphs,      (| EXTRA CMDWIN),                                             ADDR_LINES),
        (->cmdname_C (u8 "edit"),          ex_edit,          (| BANG FILE1 EDITCMD ARGOPT),                                ADDR_LINES),
        (->cmdname_C (u8 "earlier"),       ex_later,         (| EXTRA NOSPC CMDWIN),                                       ADDR_LINES),
        (->cmdname_C (u8 "enew"),          ex_edit,             BANG,                                                      ADDR_LINES),
        (->cmdname_C (u8 "ex"),            ex_edit,          (| BANG FILE1 EDITCMD ARGOPT),                                ADDR_LINES),
        (->cmdname_C (u8 "fixdel"),        ex_fixdel,           CMDWIN,                                                    ADDR_LINES),
        (->cmdname_C (u8 "global"),        ex_global,        (| RANGE BANG EXTRA DFLALL SBOXOK CMDWIN),                    ADDR_LINES),
        (->cmdname_C (u8 "goto"),          ex_goto,          (| RANGE NOTADR COUNT SBOXOK CMDWIN),                         ADDR_LINES),
        (->cmdname_C (u8 "hide"),          ex_hide,          (| BANG RANGE NOTADR COUNT EXTRA NOTRLCOM),                   ADDR_WINDOWS),
        (->cmdname_C (u8 "history"),       ex_history,       (| EXTRA CMDWIN),                                             ADDR_LINES),
        (->cmdname_C (u8 "insert"),        ex_append,        (| BANG RANGE CMDWIN MODIFY),                                 ADDR_LINES),
        (->cmdname_C (u8 "iabbrev"),       ex_abbreviate,    (| EXTRA NOTRLCOM USECTRLV CMDWIN),                           ADDR_LINES),
        (->cmdname_C (u8 "iabclear"),      ex_abclear,       (| EXTRA CMDWIN),                                             ADDR_LINES),
        (->cmdname_C (u8 "imap"),          ex_map,           (| EXTRA NOTRLCOM USECTRLV CMDWIN),                           ADDR_LINES),
        (->cmdname_C (u8 "imapclear"),     ex_mapclear,      (| EXTRA CMDWIN),                                             ADDR_LINES),
        (->cmdname_C (u8 "inoremap"),      ex_map,           (| EXTRA NOTRLCOM USECTRLV CMDWIN),                           ADDR_LINES),
        (->cmdname_C (u8 "inoreabbrev"),   ex_abbreviate,    (| EXTRA NOTRLCOM USECTRLV CMDWIN),                           ADDR_LINES),
        (->cmdname_C (u8 "iunmap"),        ex_unmap,         (| EXTRA NOTRLCOM USECTRLV CMDWIN),                           ADDR_LINES),
        (->cmdname_C (u8 "iunabbrev"),     ex_abbreviate,    (| EXTRA NOTRLCOM USECTRLV CMDWIN),                           ADDR_LINES),
        (->cmdname_C (u8 "join"),          ex_join,          (| BANG RANGE COUNT EXFLAGS CMDWIN MODIFY),                   ADDR_LINES),
        (->cmdname_C (u8 "jumps"),         ex_jumps,            CMDWIN,                                                    ADDR_LINES),
        (->cmdname_C (u8 "k"),             ex_mark,          (| RANGE WORD1 SBOXOK CMDWIN),                                ADDR_LINES),
        (->cmdname_C (u8 "keepmarks"),     ex_wrongmodifier, (| NEEDARG EXTRA NOTRLCOM),                                   ADDR_LINES),
        (->cmdname_C (u8 "keepjumps"),     ex_wrongmodifier, (| NEEDARG EXTRA NOTRLCOM),                                   ADDR_LINES),
        (->cmdname_C (u8 "keeppatterns"),  ex_wrongmodifier, (| NEEDARG EXTRA NOTRLCOM),                                   ADDR_LINES),
        (->cmdname_C (u8 "keepalt"),       ex_wrongmodifier, (| NEEDARG EXTRA NOTRLCOM),                                   ADDR_LINES),
        (->cmdname_C (u8 "list"),          ex_print,         (| RANGE COUNT EXFLAGS CMDWIN),                               ADDR_LINES),
        (->cmdname_C (u8 "later"),         ex_later,         (| EXTRA NOSPC CMDWIN),                                       ADDR_LINES),
        (->cmdname_C (u8 "left"),          ex_align,         (| RANGE EXTRA CMDWIN MODIFY),                                ADDR_LINES),
        (->cmdname_C (u8 "leftabove"),     ex_wrongmodifier, (| NEEDARG EXTRA NOTRLCOM),                                   ADDR_LINES),
        (->cmdname_C (u8 "lockmarks"),     ex_wrongmodifier, (| NEEDARG EXTRA NOTRLCOM),                                   ADDR_LINES),
        (->cmdname_C (u8 "move"),          ex_copymove,      (| RANGE EXTRA CMDWIN MODIFY),                                ADDR_LINES),
        (->cmdname_C (u8 "mark"),          ex_mark,          (| RANGE WORD1 SBOXOK CMDWIN),                                ADDR_LINES),
        (->cmdname_C (u8 "map"),           ex_map,           (| BANG EXTRA NOTRLCOM USECTRLV CMDWIN),                      ADDR_LINES),
        (->cmdname_C (u8 "mapclear"),      ex_mapclear,      (| EXTRA BANG CMDWIN),                                        ADDR_LINES),
        (->cmdname_C (u8 "marks"),         ex_marks,         (| EXTRA CMDWIN),                                             ADDR_LINES),
        (->cmdname_C (u8 "messages"),      ex_messages,         CMDWIN,                                                    ADDR_LINES),
        (->cmdname_C (u8 "mode"),          ex_mode,          (| WORD1 CMDWIN),                                             ADDR_LINES),
        (->cmdname_C (u8 "new"),           ex_splitview,     (| BANG FILE1 RANGE NOTADR EDITCMD ARGOPT),                   ADDR_LINES),
        (->cmdname_C (u8 "nmap"),          ex_map,           (| EXTRA NOTRLCOM USECTRLV CMDWIN),                           ADDR_LINES),
        (->cmdname_C (u8 "nmapclear"),     ex_mapclear,      (| EXTRA CMDWIN),                                             ADDR_LINES),
        (->cmdname_C (u8 "nnoremap"),      ex_map,           (| EXTRA NOTRLCOM USECTRLV CMDWIN),                           ADDR_LINES),
        (->cmdname_C (u8 "noremap"),       ex_map,           (| BANG EXTRA NOTRLCOM USECTRLV CMDWIN),                      ADDR_LINES),
        (->cmdname_C (u8 "nohlsearch"),    ex_nohlsearch,    (| SBOXOK CMDWIN),                                            ADDR_LINES),
        (->cmdname_C (u8 "noreabbrev"),    ex_abbreviate,    (| EXTRA NOTRLCOM USECTRLV CMDWIN),                           ADDR_LINES),
        (->cmdname_C (u8 "normal"),        ex_normal,        (| RANGE BANG EXTRA NEEDARG NOTRLCOM USECTRLV SBOXOK CMDWIN), ADDR_LINES),
        (->cmdname_C (u8 "number"),        ex_print,         (| RANGE COUNT EXFLAGS CMDWIN),                               ADDR_LINES),
        (->cmdname_C (u8 "nunmap"),        ex_unmap,         (| EXTRA NOTRLCOM USECTRLV CMDWIN),                           ADDR_LINES),
        (->cmdname_C (u8 "omap"),          ex_map,           (| EXTRA NOTRLCOM USECTRLV CMDWIN),                           ADDR_LINES),
        (->cmdname_C (u8 "omapclear"),     ex_mapclear,      (| EXTRA CMDWIN),                                             ADDR_LINES),
        (->cmdname_C (u8 "only"),          ex_only,          (| BANG NOTADR RANGE COUNT),                                  ADDR_WINDOWS),
        (->cmdname_C (u8 "onoremap"),      ex_map,           (| EXTRA NOTRLCOM USECTRLV CMDWIN),                           ADDR_LINES),
        (->cmdname_C (u8 "ounmap"),        ex_unmap,         (| EXTRA NOTRLCOM USECTRLV CMDWIN),                           ADDR_LINES),
        (->cmdname_C (u8 "print"),         ex_print,         (| RANGE COUNT EXFLAGS CMDWIN SBOXOK),                        ADDR_LINES),
        (->cmdname_C (u8 "put"),           ex_put,           (| RANGE BANG REGSTR ZEROR CMDWIN MODIFY),                    ADDR_LINES),
        (->cmdname_C (u8 "quit"),          ex_quit,          (| BANG RANGE COUNT NOTADR CMDWIN),                           ADDR_WINDOWS),
        (->cmdname_C (u8 "quitall"),       ex_quit_all,         BANG,                                                      ADDR_LINES),
        (->cmdname_C (u8 "qall"),          ex_quit_all,      (| BANG CMDWIN),                                              ADDR_LINES),
        (->cmdname_C (u8 "redo"),          ex_redo,             CMDWIN,                                                    ADDR_LINES),
        (->cmdname_C (u8 "redraw"),        ex_redraw,        (| BANG CMDWIN),                                              ADDR_LINES),
        (->cmdname_C (u8 "redrawstatus"),  ex_redrawstatus,  (| BANG CMDWIN),                                              ADDR_LINES),
        (->cmdname_C (u8 "registers"),     ex_display,       (| EXTRA NOTRLCOM CMDWIN),                                    ADDR_LINES),
        (->cmdname_C (u8 "resize"),        ex_resize,        (| RANGE NOTADR WORD1),                                       ADDR_LINES),
        (->cmdname_C (u8 "retab"),         ex_retab,         (| RANGE DFLALL BANG WORD1 CMDWIN MODIFY),                    ADDR_LINES),
        (->cmdname_C (u8 "right"),         ex_align,         (| RANGE EXTRA CMDWIN MODIFY),                                ADDR_LINES),
        (->cmdname_C (u8 "rightbelow"),    ex_wrongmodifier, (| NEEDARG EXTRA NOTRLCOM),                                   ADDR_LINES),
        (->cmdname_C (u8 "substitute"),    ex_sub,           (| RANGE EXTRA CMDWIN),                                       ADDR_LINES),
        (->cmdname_C (u8 "sandbox"),       ex_wrongmodifier, (| NEEDARG EXTRA NOTRLCOM),                                   ADDR_LINES),
        (->cmdname_C (u8 "sbuffer"),       ex_buffer,        (| BANG RANGE NOTADR BUFNAME BUFUNL COUNT EXTRA EDITCMD),     ADDR_BUFFERS),
        (->cmdname_C (u8 "sbNext"),        ex_bprevious,     (| RANGE NOTADR COUNT EDITCMD),                               ADDR_LINES),
        (->cmdname_C (u8 "sball"),         ex_buffer_all,    (| RANGE NOTADR COUNT EDITCMD),                               ADDR_LINES),
        (->cmdname_C (u8 "sbfirst"),       ex_brewind,          EDITCMD,                                                   ADDR_LINES),
        (->cmdname_C (u8 "sblast"),        ex_blast,            EDITCMD,                                                   ADDR_LINES),
        (->cmdname_C (u8 "sbmodified"),    ex_bmodified,     (| RANGE NOTADR COUNT EDITCMD),                               ADDR_LINES),
        (->cmdname_C (u8 "sbnext"),        ex_bnext,         (| RANGE NOTADR COUNT EDITCMD),                               ADDR_LINES),
        (->cmdname_C (u8 "sbprevious"),    ex_bprevious,     (| RANGE NOTADR COUNT EDITCMD),                               ADDR_LINES),
        (->cmdname_C (u8 "sbrewind"),      ex_brewind,          EDITCMD,                                                   ADDR_LINES),
        (->cmdname_C (u8 "set"),           ex_set,           (| EXTRA CMDWIN SBOXOK),                                      ADDR_LINES),
        (->cmdname_C (u8 "setglobal"),     ex_set,           (| EXTRA CMDWIN SBOXOK),                                      ADDR_LINES),
        (->cmdname_C (u8 "setlocal"),      ex_set,           (| EXTRA CMDWIN SBOXOK),                                      ADDR_LINES),
        (->cmdname_C (u8 "silent"),        ex_wrongmodifier, (| NEEDARG EXTRA BANG NOTRLCOM SBOXOK CMDWIN),                ADDR_LINES),
        (->cmdname_C (u8 "smagic"),        ex_submagic,      (| RANGE EXTRA CMDWIN),                                       ADDR_LINES),
        (->cmdname_C (u8 "smap"),          ex_map,           (| EXTRA NOTRLCOM USECTRLV CMDWIN),                           ADDR_LINES),
        (->cmdname_C (u8 "smapclear"),     ex_mapclear,      (| EXTRA CMDWIN),                                             ADDR_LINES),
        (->cmdname_C (u8 "snomagic"),      ex_submagic,      (| RANGE EXTRA CMDWIN),                                       ADDR_LINES),
        (->cmdname_C (u8 "snoremap"),      ex_map,           (| EXTRA NOTRLCOM USECTRLV CMDWIN),                           ADDR_LINES),
        (->cmdname_C (u8 "split"),         ex_splitview,     (| BANG FILE1 RANGE NOTADR EDITCMD ARGOPT),                   ADDR_LINES),
        (->cmdname_C (u8 "stop"),          ex_stop,          (| BANG CMDWIN),                                              ADDR_LINES),
        (->cmdname_C (u8 "startinsert"),   ex_startinsert,   (| BANG CMDWIN),                                              ADDR_LINES),
        (->cmdname_C (u8 "startgreplace"), ex_startinsert,   (| BANG CMDWIN),                                              ADDR_LINES),
        (->cmdname_C (u8 "startreplace"),  ex_startinsert,   (| BANG CMDWIN),                                              ADDR_LINES),
        (->cmdname_C (u8 "stopinsert"),    ex_stopinsert,    (| BANG CMDWIN),                                              ADDR_LINES),
        (->cmdname_C (u8 "sunhide"),       ex_buffer_all,    (| RANGE NOTADR COUNT),                                       ADDR_LINES),
        (->cmdname_C (u8 "sunmap"),        ex_unmap,         (| EXTRA NOTRLCOM USECTRLV CMDWIN),                           ADDR_LINES),
        (->cmdname_C (u8 "suspend"),       ex_stop,          (| BANG CMDWIN),                                              ADDR_LINES),
        (->cmdname_C (u8 "sview"),         ex_splitview,     (| BANG FILE1 RANGE NOTADR EDITCMD ARGOPT),                   ADDR_LINES),
        (->cmdname_C (u8 "syncbind"),      ex_syncbind,         0,                                                         ADDR_LINES),
        (->cmdname_C (u8 "t"),             ex_copymove,      (| RANGE EXTRA CMDWIN MODIFY),                                ADDR_LINES),
        (->cmdname_C (u8 "topleft"),       ex_wrongmodifier, (| NEEDARG EXTRA NOTRLCOM),                                   ADDR_LINES),
        (->cmdname_C (u8 "undo"),          ex_undo,          (| RANGE NOTADR COUNT ZEROR CMDWIN),                          ADDR_LINES),
        (->cmdname_C (u8 "undojoin"),      ex_undojoin,         CMDWIN,                                                    ADDR_LINES),
        (->cmdname_C (u8 "undolist"),      ex_undolist,         CMDWIN,                                                    ADDR_LINES),
        (->cmdname_C (u8 "unabbreviate"),  ex_abbreviate,    (| EXTRA NOTRLCOM USECTRLV CMDWIN),                           ADDR_LINES),
        (->cmdname_C (u8 "unhide"),        ex_buffer_all,    (| RANGE NOTADR COUNT),                                       ADDR_LINES),
        (->cmdname_C (u8 "unmap"),         ex_unmap,         (| BANG EXTRA NOTRLCOM USECTRLV CMDWIN),                      ADDR_LINES),
        (->cmdname_C (u8 "unsilent"),      ex_wrongmodifier, (| NEEDARG EXTRA NOTRLCOM SBOXOK CMDWIN),                     ADDR_LINES),
        (->cmdname_C (u8 "vglobal"),       ex_global,        (| RANGE EXTRA DFLALL CMDWIN),                                ADDR_LINES),
        (->cmdname_C (u8 "verbose"),       ex_wrongmodifier, (| NEEDARG RANGE NOTADR EXTRA NOTRLCOM SBOXOK CMDWIN),        ADDR_LINES),
        (->cmdname_C (u8 "vertical"),      ex_wrongmodifier, (| NEEDARG EXTRA NOTRLCOM),                                   ADDR_LINES),
        (->cmdname_C (u8 "visual"),        ex_edit,          (| BANG FILE1 EDITCMD ARGOPT),                                ADDR_LINES),
        (->cmdname_C (u8 "view"),          ex_edit,          (| BANG FILE1 EDITCMD ARGOPT),                                ADDR_LINES),
        (->cmdname_C (u8 "vmap"),          ex_map,           (| EXTRA NOTRLCOM USECTRLV CMDWIN),                           ADDR_LINES),
        (->cmdname_C (u8 "vmapclear"),     ex_mapclear,      (| EXTRA CMDWIN),                                             ADDR_LINES),
        (->cmdname_C (u8 "vnoremap"),      ex_map,           (| EXTRA NOTRLCOM USECTRLV CMDWIN),                           ADDR_LINES),
        (->cmdname_C (u8 "vnew"),          ex_splitview,     (| BANG FILE1 RANGE NOTADR EDITCMD ARGOPT),                   ADDR_LINES),
        (->cmdname_C (u8 "vsplit"),        ex_splitview,     (| BANG FILE1 RANGE NOTADR EDITCMD ARGOPT),                   ADDR_LINES),
        (->cmdname_C (u8 "vunmap"),        ex_unmap,         (| EXTRA NOTRLCOM USECTRLV CMDWIN),                           ADDR_LINES),
        (->cmdname_C (u8 "wincmd"),        ex_wincmd,        (| NEEDARG WORD1 RANGE NOTADR),                               ADDR_WINDOWS),
        (->cmdname_C (u8 "xmap"),          ex_map,           (| EXTRA NOTRLCOM USECTRLV CMDWIN),                           ADDR_LINES),
        (->cmdname_C (u8 "xmapclear"),     ex_mapclear,      (| EXTRA CMDWIN),                                             ADDR_LINES),
        (->cmdname_C (u8 "xnoremap"),      ex_map,           (| EXTRA NOTRLCOM USECTRLV CMDWIN),                           ADDR_LINES),
        (->cmdname_C (u8 "xunmap"),        ex_unmap,         (| EXTRA NOTRLCOM USECTRLV CMDWIN),                           ADDR_LINES),
        (->cmdname_C (u8 "yank"),          ex_operators,     (| RANGE REGSTR COUNT CMDWIN),                                ADDR_LINES),
        (->cmdname_C (u8 "z"),             ex_z,             (| RANGE EXTRA EXFLAGS CMDWIN),                               ADDR_LINES),

        ;; commands that don't start with a lowercase letter

        (->cmdname_C (u8 "#"),             ex_print,         (| RANGE COUNT EXFLAGS CMDWIN),                               ADDR_LINES),
        (->cmdname_C (u8 "&"),             ex_sub,           (| RANGE EXTRA CMDWIN MODIFY),                                ADDR_LINES),
        (->cmdname_C (u8 "<"),             ex_operators,     (| RANGE COUNT EXFLAGS CMDWIN MODIFY),                        ADDR_LINES),
        (->cmdname_C (u8 "="),             ex_equal,         (| RANGE DFLALL EXFLAGS CMDWIN),                              ADDR_LINES),
        (->cmdname_C (u8 ">"),             ex_operators,     (| RANGE COUNT EXFLAGS CMDWIN MODIFY),                        ADDR_LINES),
        (->cmdname_C (u8 "~"),             ex_sub,           (| RANGE EXTRA CMDWIN MODIFY),                                ADDR_LINES),
    ])

;;; ============================================================================================== VimZ

(defn #_void -main [& #_String* args]
    (§
;       try
;       {
;           Bytes[] argv = new Bytes[1 + args.length];

;           argv[0] = u8("vim");

;           for (int i = 0; i < args.length; i++)
;               argv[1 + i] = u8(args[i]);

;           _main(argv.length, argv);
;       }
;       finally
;       {
;           getout(3);
;       }
    ))
